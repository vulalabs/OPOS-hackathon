/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/@solana/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */\nfunction checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('b must be a Uint8Array');\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */\nfunction uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n    constructor(span, property) {\n        if (!Number.isInteger(span)) {\n            throw new TypeError('span must be an integer');\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */\n        this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */\n        this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */\n    makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n    getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError('indeterminate span');\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n    replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n    fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + '[' + lo.property + ']';\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\n// `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if ('function' !== typeof Class) {\n        throw new TypeError('Class must be constructor');\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\n        throw new Error('Class is already bound to a layout');\n    }\n    if (!(layout && (layout instanceof Layout))) {\n        throw new TypeError('layout must be a Layout');\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\n        throw new Error('layout is already bound to a constructor');\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = (() => new Class());\n    Object.defineProperty(Class.prototype, 'encode', {\n        value(b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true,\n    });\n    Object.defineProperty(Class, 'decode', {\n        value(b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true,\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    isCount() {\n        throw new Error('ExternalLayout is abstract');\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property) {\n        if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n            throw new TypeError('elementSpan must be a (positive) integer');\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */\n        this.elementSpan = elementSpan;\n    }\n    /** @override */\n    isCount() {\n        return true;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */\n    encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property) {\n        if (!(layout instanceof Layout)) {\n            throw new TypeError('layout must be a Layout');\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError('offset must be integer or undefined');\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */\n        this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */\n        this.offset = offset;\n    }\n    /** @override */\n    isCount() {\n        return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - (hi32 * V2E32);\n    return { hi32, lo32 };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n    constructor(property) {\n        super(4, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n    constructor(property) {\n        super(4, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n    constructor(elementLayout, count, property) {\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError('elementLayout must be a Layout');\n        }\n        if (!(((count instanceof ExternalLayout) && count.isCount())\n            || (Number.isInteger(count) && (0 <= count)))) {\n            throw new TypeError('count must be non-negative integer '\n                + 'or an unsigned integer ExternalLayout');\n        }\n        let span = -1;\n        if ((!(count instanceof ExternalLayout))\n            && (0 < elementLayout.span)) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */\n        this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */\n        this.count = count;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        }\n        else {\n            let idx = 0;\n            while (idx < count) {\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while (i < count) {\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v) => {\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n    constructor(fields, property, decodePrefixes) {\n        if (!(Array.isArray(fields)\n            && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n            throw new TypeError('fields must be array of Layout instances');\n        }\n        if (('boolean' === typeof property)\n            && (undefined === decodePrefixes)) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */\n        for (const fd of fields) {\n            if ((0 > fd.span)\n                && (undefined === fd.property)) {\n                throw new Error('fields cannot contain unnamed variable-length layout');\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n        }\n        catch (e) {\n            // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */\n        this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */\n        this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd) => {\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        }\n        catch (e) {\n            throw new RangeError('indeterminate span');\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes\n                && (b.length === offset)) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n    encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields) {\n            let span = fd.span;\n            lastWrote = (0 < span) ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */\n                        span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */\n        return (lastOffset + lastWrote) - firstOffset;\n    }\n    /** @override */\n    fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields) {\n            if ((undefined !== fd.property)\n                && (0 < values.length)) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n    layoutFor(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n    offsetOf(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        let offset = 0;\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            }\n            else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n    constructor(property) {\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */\n        this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */\n    decode(b, offset) {\n        throw new Error('UnionDiscriminator is abstract');\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n    encode(src, b, offset) {\n        throw new Error('UnionDiscriminator is abstract');\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property) {\n        if (!((layout instanceof ExternalLayout)\n            && layout.isCount())) {\n            throw new TypeError('layout must be an unsigned integer ExternalLayout');\n        }\n        super(property || layout.property || 'variant');\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */\n        this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n    constructor(discr, defaultLayout, property) {\n        let discriminator;\n        if ((discr instanceof UInt)\n            || (discr instanceof UIntBE)) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        }\n        else if ((discr instanceof ExternalLayout)\n            && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        }\n        else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError('discr must be a UnionDiscriminator '\n                + 'or an unsigned integer layout');\n        }\n        else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!((null === defaultLayout)\n            || (defaultLayout instanceof Layout))) {\n            throw new TypeError('defaultLayout must be null or a Layout');\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error('defaultLayout must have constant span');\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate('content');\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */\n        let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if ((0 <= span) && ((discr instanceof UInt)\n                || (discr instanceof UIntBE))) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */\n        this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */\n        this.usesPrefixDiscriminator = (discr instanceof UInt)\n            || (discr instanceof UIntBE);\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */\n        this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */\n        this.registry = {};\n        /* Private variable used when invoking getSourceVariant */\n        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */\n        this.getSourceVariant = function (src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n        this.configGetSourceVariant = function (gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */\n        const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error('unable to determine span for unrecognized variant');\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n    defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property\n                && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo\n                && ((!vlo.layout)\n                    || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {\n                return vlo;\n            }\n        }\n        else {\n            for (const tag in this.registry) {\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error('unable to infer src variant');\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n    decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        }\n        else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n    encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n    addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n    getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        }\n        else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n    constructor(union, variant, layout, property) {\n        if (!(union instanceof Union)) {\n            throw new TypeError('union must be a Union');\n        }\n        if ((!Number.isInteger(variant)) || (0 > variant)) {\n            throw new TypeError('variant must be a (non-negative) integer');\n        }\n        if (('string' === typeof layout)\n            && (undefined === property)) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError('layout must be a Layout');\n            }\n            if ((null !== union.defaultLayout)\n                && (0 <= layout.span)\n                && (layout.span > union.defaultLayout.span)) {\n                throw new Error('variant span exceeds span of containing union');\n            }\n            if ('string' !== typeof property) {\n                throw new TypeError('variant must have a String property');\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if ((0 <= span) && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */\n        this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */\n        this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */\n        this.layout = layout || null;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */\n            return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */\n        let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error('variant mismatch');\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        }\n        else if (this.property) {\n            dest[this.property] = true;\n        }\n        else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout\n            && (!Object.prototype.hasOwnProperty.call(src, this.property))) {\n            throw new TypeError('variant lacks property ' + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if ((0 <= this.union.span)\n                && (span > this.union.span)) {\n                throw new Error('encoded variant overruns containing union');\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n    fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n    constructor(word, msb, property) {\n        if (!((word instanceof UInt)\n            || (word instanceof UIntBE))) {\n            throw new TypeError('word must be a UInt or UIntBE layout');\n        }\n        if (('string' === typeof msb)\n            && (undefined === property)) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError('word cannot exceed 32 bits');\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */\n        this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */\n        this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/\n        this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */\n        let value = 0;\n        this._packedSetValue = function (v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function () {\n            return value;\n        };\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */\n    encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */\n    addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */\n    // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */\n    fieldFor(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n    constructor(container, bits, property) {\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError('container must be a BitStructure');\n        }\n        if ((!Number.isInteger(bits)) || (0 >= bits)) {\n            throw new TypeError('bits must be positive integer');\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n        if ((bits + usedBits) > totalBits) {\n            throw new Error('bits too long for span remainder ('\n                + (totalBits - usedBits) + ' of '\n                + totalBits + ' remain)');\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */\n        this.container = container;\n        /** The span of this value in bits. */\n        this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */\n        this.valueMask = (1 << bits) - 1;\n        if (32 === bits) { // shifted value out of range\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */\n        this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */\n        this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */\n        this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */\n    decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */\n    encode(value) {\n        if ('number' !== typeof value\n            || !Number.isInteger(value)\n            || (value !== fixBitwiseResult(value & this.valueMask))) {\n            throw new TypeError(nameWithProperty('BitField.encode', this)\n                + ' value must be integer not exceeding ' + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n            | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n    constructor(container, property) {\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */\n    decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */\n    encode(value) {\n        if ('boolean' === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n    constructor(length, property) {\n        if (!(((length instanceof ExternalLayout) && length.isCount())\n            || (Number.isInteger(length) && (0 <= length)))) {\n            throw new TypeError('length must be positive integer '\n                + 'or an unsigned integer ExternalLayout');\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */\n        this.length = length;\n    }\n    /** @override */\n    getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty('Blob.encode', this)\n                + ' requires (length ' + span + ') Uint8Array as src');\n        }\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Uint8Array');\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n    constructor(property) {\n        super(-1, property);\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while ((idx < b.length) && (0 !== b[idx])) {\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */\n        if ('string' !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, 'utf8');\n        const span = srcb.length;\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Buffer');\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n    constructor(maxSpan, property) {\n        if (('string' === typeof maxSpan) && (undefined === property)) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        }\n        else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError('maxSpan must be an integer');\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */\n        this.maxSpan = maxSpan;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if ((0 <= this.maxSpan)\n            && (this.maxSpan < span)) {\n            throw new RangeError('text length exceeds maxSpan');\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */\n        if ('string' !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, 'utf8');\n        const span = srcb.length;\n        if ((0 <= this.maxSpan)\n            && (this.maxSpan < span)) {\n            throw new RangeError('text length exceeds maxSpan');\n        }\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Buffer');\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n    constructor(value, property) {\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */\n        this.value = value;\n    }\n    /** @override */\n    decode(b, offset) {\n        return this.value;\n    }\n    /** @override */\n    encode(src, b, offset) {\n        /* Constants take no space */\n        return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = ((property) => new UInt(1, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = ((property) => new UInt(2, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = ((property) => new UInt(3, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = ((property) => new UInt(4, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = ((property) => new UInt(5, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = ((property) => new UInt(6, property));\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = ((property) => new NearUInt64(property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = ((property) => new UIntBE(2, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = ((property) => new UIntBE(3, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = ((property) => new UIntBE(4, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = ((property) => new UIntBE(5, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = ((property) => new UIntBE(6, property));\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = ((property) => new NearUInt64BE(property));\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = ((property) => new Int(1, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = ((property) => new Int(2, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = ((property) => new Int(3, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = ((property) => new Int(4, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = ((property) => new Int(5, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = ((property) => new Int(6, property));\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = ((property) => new NearInt64(property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = ((property) => new IntBE(2, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = ((property) => new IntBE(3, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = ((property) => new IntBE(4, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = ((property) => new IntBE(5, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = ((property) => new IntBE(6, property));\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = ((property) => new NearInt64BE(property));\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = ((property) => new Float(property));\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = ((property) => new FloatBE(property));\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = ((property) => new Double(property));\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = ((property) => new DoubleBE(property));\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n/** Factory for {@link CString} values. */\nexports.cstr = ((property) => new CString(property));\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n/** Factory for {@link Constant} values. */\nexports.constant = ((value, property) => new Constant(value, property));\n//# sourceMappingURL=Layout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS9idWZmZXItbGF5b3V0L2xpYi9MYXlvdXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksbUNBQW1DO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGFBQWEsTUFBTSw2QkFBNkIsR0FBRztBQUNuRCw4QkFBOEIsR0FBRywrQkFBK0I7QUFDaEUsTUFBTSwrQkFBK0IsR0FBRztBQUN4Qyw4QkFBOEIsT0FBTztBQUNyQztBQUNBLE1BQU07QUFDTixhQUFhLE1BQU0saUNBQWlDLEdBQUc7QUFDdkQsZ0NBQWdDLEdBQUcsaUNBQWlDO0FBQ3BFLE1BQU0saUNBQWlDLE9BQU87QUFDOUMsaUNBQWlDO0FBQ2pDLE1BQU07QUFDTixhQUFhLE1BQU0sNkJBQTZCLEdBQUc7QUFDbkQsOEJBQThCLEdBQUcsK0JBQStCO0FBQ2hFLE1BQU0sK0JBQStCLEdBQUc7QUFDeEMsOEJBQThCLE9BQU87QUFDckM7QUFDQSxNQUFNO0FBQ04sV0FBVyxpQ0FBaUMsR0FBRztBQUMvQyxnQ0FBZ0MsR0FBRyxpQ0FBaUM7QUFDcEUsTUFBTSxpQ0FBaUMsT0FBTztBQUM5QyxpQ0FBaUM7QUFDakM7QUFDQSxtREFBbUQ7QUFDbkQsK0NBQStDLEdBQUc7QUFDbEQsOENBQThDLEdBQUc7QUFDakQsNkNBQTZDLE9BQU87QUFDcEQsK0NBQStDO0FBQy9DLHdDQUF3QztBQUN4QyxzQ0FBc0MsS0FBSztBQUMzQyxxQ0FBcUM7QUFDckMsd0NBQXdDO0FBQ3hDLHNDQUFzQyxLQUFLO0FBQzNDLHFDQUFxQztBQUNyQyxNQUFNLHFDQUFxQztBQUMzQztBQUNBO0FBQ0E7QUFDQSxNQUFNLGlDQUFpQyxxQkFBcUI7QUFDNUQsaUNBQWlDO0FBQ2pDLDhDQUE4QztBQUM5QztBQUNBLE1BQU0scUNBQXFDO0FBQzNDLGdDQUFnQztBQUNoQztBQUNBLE1BQU0sZ0NBQWdDLHlCQUF5QjtBQUMvRCxrREFBa0Q7QUFDbEQ7QUFDQSw4REFBOEQ7QUFDOUQsNERBQTREO0FBQzVEO0FBQ0E7QUFDQSxNQUFNLHNDQUFzQztBQUM1QyxvQkFBb0I7QUFDcEIsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQSxNQUFNLG9DQUFvQztBQUMxQyxNQUFNLGdDQUFnQyx1QkFBdUI7QUFDN0QsdUNBQXVDO0FBQ3ZDO0FBQ0EsUUFBUSxtQ0FBbUM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELFdBQVcsR0FBRyxVQUFVLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsWUFBWSxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsVUFBVSxHQUFHLGNBQWMsR0FBRyxjQUFjLEdBQUcsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLGVBQWUsR0FBRyxZQUFZLEdBQUcsZUFBZSxHQUFHLGdCQUFnQixHQUFHLG9CQUFvQixHQUFHLHFCQUFxQixHQUFHLGFBQWEsR0FBRyxnQ0FBZ0MsR0FBRywwQkFBMEIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0IsR0FBRyxjQUFjLEdBQUcsZUFBZSxHQUFHLGFBQWEsR0FBRyxtQkFBbUIsR0FBRyxpQkFBaUIsR0FBRyxvQkFBb0IsR0FBRyxrQkFBa0IsR0FBRyxhQUFhLEdBQUcsV0FBVyxHQUFHLGNBQWMsR0FBRyxZQUFZLEdBQUcsb0JBQW9CLEdBQUcsbUJBQW1CLEdBQUcsc0JBQXNCLEdBQUcsNkJBQTZCLEdBQUcsd0JBQXdCLEdBQUcsY0FBYyxHQUFHLDBCQUEwQixHQUFHLHVCQUF1QjtBQUM5NkIsZ0JBQWdCLEdBQUcsWUFBWSxHQUFHLFlBQVksR0FBRyxZQUFZLEdBQUcsZ0NBQWdDLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRyxZQUFZLEdBQUcsY0FBYyxHQUFHLGFBQWEsR0FBRyxXQUFXLEdBQUcsYUFBYSxHQUFHLFdBQVcsR0FBRyxjQUFjLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxhQUFhLEdBQUcsYUFBYSxHQUFHLGFBQWEsR0FBRyxZQUFZLEdBQUcsV0FBVyxHQUFHLFdBQVcsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUNsWSxpQkFBaUIsbUJBQU8sQ0FBQyw4Q0FBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxpREFBaUQ7QUFDakQseUJBQXlCLElBQUksNEJBQTRCO0FBQ3pEO0FBQ0EsV0FBVyxRQUFRLHdCQUF3Qix1QkFBdUI7QUFDbEUsaUNBQWlDO0FBQ2pDLFlBQVksb0NBQW9DO0FBQ2hEO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWUsVUFBVTtBQUM5RCxvQkFBb0IsYUFBYSw0QkFBNEI7QUFDN0Q7QUFDQTtBQUNBLG1DQUFtQyw2QkFBNkI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNEJBQTRCO0FBQ25FO0FBQ0EsNkRBQTZEO0FBQzdELGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNEJBQTRCO0FBQy9EO0FBQ0EsVUFBVTtBQUNWLFVBQVU7QUFDVixVQUFVO0FBQ1YsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFlBQVk7QUFDM0I7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RDtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGNBQWM7QUFDdEQ7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCxpQ0FBaUM7QUFDakM7QUFDQSxlQUFlLFFBQVEsMEJBQTBCO0FBQ2pELGlDQUFpQztBQUNqQztBQUNBLGlCQUFpQixRQUFRLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxnQkFBZ0I7QUFDdkQsUUFBUSxxQ0FBcUM7QUFDN0MsaUJBQWlCLFlBQVk7QUFDN0IscUJBQXFCLG1DQUFtQztBQUN4RDtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLCtDQUErQztBQUMvQztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0NBQWtDO0FBQ3JEO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBLFdBQVcsUUFBUSxjQUFjLGNBQWM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksb0JBQW9CLCtCQUErQjtBQUN2RCxzQ0FBc0M7QUFDdEM7QUFDQSw0Q0FBNEM7QUFDNUMsNkNBQTZDO0FBQzdDLG1DQUFtQyxVQUFVLGNBQWM7QUFDM0Q7QUFDQSxXQUFXLFFBQVEsd0JBQXdCLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsc0NBQXNDLEdBQUcsK0JBQStCO0FBQ3hFLGNBQWM7QUFDZCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxPQUFPLHNCQUFzQixxQkFBcUI7QUFDbEQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXLFFBQVEsaUNBQWlDO0FBQ3BELHVDQUF1QztBQUN2QztBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBLE9BQU8sc0JBQXNCLDJCQUEyQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXLFFBQVEsMEJBQTBCO0FBQzdDLDhCQUE4QjtBQUM5QjtBQUNBLFdBQVcsUUFBUSx3QkFBd0I7QUFDM0MsOEJBQThCO0FBQzlCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLElBQUksaUNBQWlDLDJCQUEyQjtBQUNoRSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsMkJBQTJCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBCQUEwQixHQUFHO0FBQzVDLDBCQUEwQixHQUFHLDRCQUE0QixHQUFHO0FBQzVELDBCQUEwQixHQUFHLDRCQUE0QixHQUFHO0FBQzVEO0FBQ0E7QUFDQSxXQUFXLFFBQVEsd0JBQXdCLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCLEdBQUc7QUFDaEQsNkJBQTZCLEdBQUcsZ0NBQWdDO0FBQ2hFLElBQUksZ0NBQWdDLEdBQUc7QUFDdkMsNkJBQTZCLEdBQUc7QUFDaEM7QUFDQSxXQUFXLFFBQVEsd0JBQXdCLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEJBQTBCLEdBQUc7QUFDNUMsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUc7QUFDNUQsMEJBQTBCLEdBQUcsNEJBQTRCLEdBQUc7QUFDNUQ7QUFDQTtBQUNBLFdBQVcsUUFBUSx3QkFBd0IsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQSxXQUFXLFFBQVEsOEJBQThCO0FBQ2pELDRCQUE0QjtBQUM1QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEIsR0FBRztBQUNoRCw2QkFBNkIsR0FBRyxnQ0FBZ0M7QUFDaEUsSUFBSSxnQ0FBZ0MsR0FBRztBQUN2Qyw2QkFBNkIsR0FBRztBQUNoQztBQUNBLFdBQVcsUUFBUSx3QkFBd0IsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQSxXQUFXLFFBQVEsOEJBQThCO0FBQ2pELDRCQUE0QjtBQUM1QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxXQUFXLFFBQVEsOEJBQThCO0FBQ2pELDRCQUE0QjtBQUM1QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLFdBQVcsUUFBUSxpQ0FBaUM7QUFDcEQsd0NBQXdDO0FBQ3hDO0FBQ0EsV0FBVyx5QkFBeUIseUJBQXlCO0FBQzdELHdCQUF3QjtBQUN4Qiw4QkFBOEIscUJBQXFCO0FBQ25EO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHNCQUFzQixXQUFXO0FBQzdDLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEtBQUssZUFBZTtBQUNuRTtBQUNBLDBDQUEwQyw0QkFBNEI7QUFDdEU7QUFDQSxvQkFBb0IsNEJBQTRCO0FBQ2hEO0FBQ0E7QUFDQSxvQkFBb0IsMEJBQTBCLG1CQUFtQjtBQUNqRSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDLHFCQUFxQiwrQkFBK0I7QUFDcEQsZ0JBQWdCLDhCQUE4QjtBQUM5QztBQUNBO0FBQ0EsOEJBQThCLCtCQUErQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVSwwQkFBMEI7QUFDL0MsMkJBQTJCO0FBQzNCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxXQUFXLFNBQVMsb0NBQW9DO0FBQ3hELHFDQUFxQztBQUNyQztBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixjQUFjO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsVUFBVTtBQUM1QjtBQUNBLGlDQUFpQyw4QkFBOEI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QixLQUFLLGdCQUFnQjtBQUNwRTtBQUNBLG1FQUFtRTtBQUNuRSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxpQ0FBaUM7QUFDakMsc0NBQXNDLFNBQVMsWUFBWTtBQUMzRDtBQUNBLDRDQUE0QztBQUM1QyxpREFBaUQ7QUFDakQscUNBQXFDLElBQUk7QUFDekMscUNBQXFDO0FBQ3JDO0FBQ0EsV0FBVyxRQUFRLDBCQUEwQjtBQUM3Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixnQ0FBZ0M7QUFDakQscUVBQXFFO0FBQ3JFLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUNBQW1DO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQ0FBbUM7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxpQ0FBaUM7QUFDakMseUNBQXlDLEtBQUssYUFBYTtBQUMzRCxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0EsV0FBVyxnQkFBZ0Isc0JBQXNCO0FBQ2pELDBDQUEwQyxpQkFBaUI7QUFDM0Qsb0NBQW9DO0FBQ3BDO0FBQ0EsV0FBVyxRQUFRLDBCQUEwQjtBQUM3Qyx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsc0JBQXNCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw2Q0FBNkM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDZDQUE2QztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFLG9DQUFvQyx1QkFBdUI7QUFDM0QsdUNBQXVDO0FBQ3ZDLHNDQUFzQyxxQkFBcUI7QUFDM0QscURBQXFEO0FBQ3JELFdBQVcseUNBQXlDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLDBDQUEwQztBQUM5QyxJQUFJLGtDQUFrQztBQUN0Qyw0QkFBNEI7QUFDNUIsNkJBQTZCLGlDQUFpQztBQUM5RCx1Q0FBdUMsc0JBQXNCO0FBQzdELHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdELHVDQUF1QztBQUN2Qyx5Q0FBeUMscUJBQXFCO0FBQzlELHNDQUFzQyxnQkFBZ0I7QUFDdEQsZ0NBQWdDLDZCQUE2QjtBQUM3RCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLFVBQVUsOENBQThDO0FBQ3hEO0FBQ0EsV0FBVyw0Q0FBNEM7QUFDdkQ7QUFDQSxxQ0FBcUMseUJBQXlCO0FBQzlELElBQUksc0JBQXNCLGdCQUFnQjtBQUMxQyxvQ0FBb0MsTUFBTSxZQUFZLEtBQUs7QUFDM0QsVUFBVTtBQUNWO0FBQ0EsSUFBSSwwQkFBMEIseUJBQXlCO0FBQ3ZELHFDQUFxQztBQUNyQztBQUNBLFdBQVcsZUFBZSxpQ0FBaUM7QUFDM0QscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSwyQkFBMkIsY0FBYztBQUN6QyxpQkFBaUIsdUJBQXVCLHFCQUFxQjtBQUM3RCw2QkFBNkIsS0FBSztBQUNsQyxzQ0FBc0MsV0FBVztBQUNqRCw2QkFBNkI7QUFDN0I7QUFDQSxXQUFXLFFBQVEsOEJBQThCO0FBQ2pELDRCQUE0QjtBQUM1QjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwwQkFBMEI7QUFDN0M7QUFDQSx1QkFBdUI7QUFDdkIsa0VBQWtFO0FBQ2xFLDhEQUE4RDtBQUM5RCxtQkFBbUI7QUFDbkI7QUFDQSwyQkFBMkIseUNBQXlDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9ELGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSx3Q0FBd0M7QUFDcEQsaUNBQWlDLHFCQUFxQjtBQUN0RCw2QkFBNkIsa0NBQWtDO0FBQy9EO0FBQ0E7QUFDQSxZQUFZLDhCQUE4QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEIsa0VBQWtFO0FBQ2xFLGdDQUFnQztBQUNoQywrREFBK0Q7QUFDL0Q7QUFDQSxtQkFBbUIsUUFBUSxlQUFlO0FBQzFDLGlFQUFpRTtBQUNqRTtBQUNBLHFCQUFxQiwyQkFBMkI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixpRUFBaUU7QUFDakU7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxtQ0FBbUM7QUFDbkM7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QixZQUFZLDREQUE0RDtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBLGdCQUFnQiwyQkFBMkI7QUFDM0M7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw0QkFBNEIsS0FBSyxZQUFZO0FBQ2hFO0FBQ0EsMEJBQTBCLG1DQUFtQztBQUM3RDtBQUNBLHNDQUFzQztBQUN0QyxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEtBQUssWUFBWTtBQUNoRTtBQUNBO0FBQ0EsUUFBUSx5Q0FBeUM7QUFDakQsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLDJCQUEyQjtBQUNsRCxxQ0FBcUM7QUFDckM7QUFDQSxlQUFlLFFBQVEsMEJBQTBCO0FBQ2pELG1DQUFtQztBQUNuQztBQUNBLGVBQWUsUUFBUSw0QkFBNEI7QUFDbkQsZ0NBQWdDO0FBQ2hDO0FBQ0EsZ0JBQWdCLGVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsc0RBQXNELFdBQVc7QUFDakU7QUFDQSxnQkFBZ0IsRUFBRSxjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsd0JBQXdCO0FBQ3pDLG9CQUFvQix5Q0FBeUM7QUFDN0Q7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQSxjQUFjLG1DQUFtQztBQUNqRDtBQUNBLFdBQVcsT0FBTyx5QkFBeUI7QUFDM0MsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVyxRQUFRLDJCQUEyQjtBQUM5QyxpQ0FBaUM7QUFDakM7QUFDQSxXQUFXLFFBQVEsNEJBQTRCO0FBQy9DLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBO0FBQ0EsZ0JBQWdCLHlDQUF5QztBQUN6RDtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0IsMENBQTBDO0FBQzFDLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0MsSUFBSTtBQUN4RCxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQSxPQUFPLGVBQWU7QUFDdEI7QUFDQSxJQUFJLGVBQWUsc0JBQXNCO0FBQ3pDLG1DQUFtQyxLQUFLO0FBQ3hDLHVDQUF1Qzs7QUFFdkMsV0FBVyxRQUFRLHdCQUF3QjtBQUMzQywwQkFBMEI7QUFDMUIsSUFBSSxZQUFZLEtBQUssYUFBYTtBQUNsQztBQUNBLFdBQVcsTUFBTTtBQUNqQixnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELDJEQUEyRDtBQUMzRCxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0EsNkJBQTZCLGdCQUFnQjtBQUM3QztBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDRCQUE0QixLQUFLLG1CQUFtQjtBQUN2RTtBQUNBLG1FQUFtRTtBQUNuRSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUSx3QkFBd0IseUJBQXlCO0FBQ3hFO0FBQ0EsZUFBZSxRQUFRLDRCQUE0QjtBQUNuRCxnQ0FBZ0M7QUFDaEM7QUFDQSxnQkFBZ0IsVUFBVTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLHNDQUFzQztBQUN2RDtBQUNBO0FBQ0EsZUFBZSxRQUFRLDRCQUE0QjtBQUNuRCxnQ0FBZ0M7QUFDaEM7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLDBDQUEwQyxtQkFBbUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0NBQXNDO0FBQzVEO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQsVUFBVSx3QkFBd0I7QUFDbEM7QUFDQSxXQUFXLGNBQWMsNkJBQTZCO0FBQ3RELGdDQUFnQztBQUNoQztBQUNBLFdBQVcsUUFBUSx3QkFBd0IseUJBQXlCO0FBQ3BFO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsb0JBQW9CO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QiwwQkFBMEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRCxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxvQ0FBb0Msb0JBQW9CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwwQ0FBMEM7QUFDaEU7QUFDQTtBQUNBLFdBQVcsY0FBYyw2QkFBNkI7QUFDdEQsZ0NBQWdDO0FBQ2hDO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDhCQUE4QixLQUFLLHNCQUFzQjtBQUMzRTtBQUNBLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0EsV0FBVyx5QkFBeUIsc0JBQXNCO0FBQzFELHNCQUFzQjtBQUN0QjtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRTtBQUNsRSwyQkFBMkIsZ0JBQWdCO0FBQzNDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEtBQUssV0FBVztBQUMvRDtBQUNBLG9CQUFvQiwwQkFBMEIsbUJBQW1CO0FBQ2pFLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUSw4QkFBOEI7QUFDakQsNEJBQTRCO0FBQzVCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25ELDRCQUE0Qix3Q0FBd0M7QUFDcEU7QUFDQSxXQUFXLHNCQUFzQix5QkFBeUI7QUFDMUQsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRLDhCQUE4QjtBQUNqRCw0QkFBNEI7QUFDNUI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEUsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQixrQkFBa0I7QUFDbkMsY0FBYztBQUNkLGlCQUFpQixtQkFBbUI7QUFDcEMsY0FBYztBQUNkLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQSxVQUFVO0FBQ1YsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVztBQUNYLGlCQUFpQjtBQUNqQjtBQUNBLFdBQVc7QUFDWCxpQkFBaUI7QUFDakI7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVztBQUNYLGlCQUFpQjtBQUNqQjtBQUNBLFdBQVc7QUFDWCxpQkFBaUI7QUFDakIsWUFBWTtBQUNaLFlBQVk7QUFDWixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQixZQUFZO0FBQ1osY0FBYztBQUNkLGlCQUFpQiw4QkFBOEI7QUFDL0M7QUFDQSxVQUFVO0FBQ1YsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVztBQUNYLGlCQUFpQjtBQUNqQjtBQUNBLFdBQVc7QUFDWCxpQkFBaUI7QUFDakI7QUFDQSxXQUFXO0FBQ1gsaUJBQWlCO0FBQ2pCO0FBQ0EsV0FBVztBQUNYLGlCQUFpQjtBQUNqQjtBQUNBLFdBQVc7QUFDWCxpQkFBaUI7QUFDakI7QUFDQSxZQUFZO0FBQ1osaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQSxhQUFhO0FBQ2IsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLGlCQUFpQjtBQUNqQjtBQUNBLGFBQWE7QUFDYixpQkFBaUI7QUFDakI7QUFDQSxjQUFjO0FBQ2QsaUJBQWlCLGlEQUFpRDtBQUNsRSxXQUFXO0FBQ1gsaUJBQWlCLGdEQUFnRDtBQUNqRSxhQUFhO0FBQ2IsaUJBQWlCLGtEQUFrRDtBQUNuRSxXQUFXO0FBQ1gsaUJBQWlCLGlEQUFpRDtBQUNsRSxhQUFhO0FBQ2IsaUJBQWlCLGlCQUFpQjtBQUNsQyxjQUFjO0FBQ2QsaUJBQWlCLG9CQUFvQjtBQUNyQyxZQUFZO0FBQ1osaUJBQWlCLGdCQUFnQjtBQUNqQyxXQUFXO0FBQ1gsaUJBQWlCLGFBQWE7QUFDOUIsYUFBYTtBQUNiLGlCQUFpQixnQ0FBZ0M7QUFDakQsZ0NBQWdDO0FBQ2hDLGlCQUFpQixZQUFZO0FBQzdCLFlBQVk7QUFDWixpQkFBaUIsZUFBZTtBQUNoQyxZQUFZO0FBQ1osaUJBQWlCLFlBQVk7QUFDN0IsWUFBWTtBQUNaLGlCQUFpQixnQkFBZ0I7QUFDakMsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcz82N2RmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAyMDE1LTIwMTggUGV0ZXIgQS4gQmlnb3RcbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG4vKipcbiAqIFN1cHBvcnQgZm9yIHRyYW5zbGF0aW5nIGJldHdlZW4gVWludDhBcnJheSBpbnN0YW5jZXMgYW5kIEphdmFTY3JpcHRcbiAqIG5hdGl2ZSB0eXBlcy5cbiAqXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSBpcyB0aGUgYmFzaXMgb2YgYSBjbGFzc1xuICogaGllcmFyY2h5IHRoYXQgYXNzb2NpYXRlcyBwcm9wZXJ0eSBuYW1lcyB3aXRoIHNlcXVlbmNlcyBvZiBlbmNvZGVkXG4gKiBieXRlcy5cbiAqXG4gKiBMYXlvdXRzIGFyZSBzdXBwb3J0ZWQgZm9yIHRoZXNlIHNjYWxhciAobnVtZXJpYykgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0flVJbnR8VW5zaWduZWQgaW50ZWdlcnMgaW4gbGl0dGxlLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8OC1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51MTZ8MTYtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fDI0LWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMnwzMi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDB8NDAtYml0fSwgYW5kIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0OHw0OC1iaXR9XG4gKiAgIHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludEJFfFVuc2lnbmVkIGludGVnZXJzIGluIGJpZy1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnUxNmJlfDE2LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUyNGJlfDI0LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfDMyLWJpdH0sXG4gKiAgIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MGJlfDQwLWJpdH0sIGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51NDhiZXw0OC1iaXR9IHJlcHJlc2VudGF0aW9uIHJhbmdlcztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+SW50fFNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zOHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnMxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnRCRXxTaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhbiBmb3JtYXR9XG4gKiAgIHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQuczE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnM0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiA2NC1iaXQgaW50ZWdyYWwgdmFsdWVzIHRoYXQgZGVjb2RlIHRvIGFuIGV4YWN0IChpZiBtYWduaXR1ZGUgaXNcbiAqICAgbGVzcyB0aGFuIDJeNTMpIG9yIG5lYXJieSBpbnRlZ3JhbCBOdW1iZXIgaW4ge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NHx1bnNpZ25lZCBsaXR0bGUtZW5kaWFufSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnU2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5uczY0fHNpZ25lZCBsaXR0bGUtZW5kaWFufSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjRiZXx1bnNpZ25lZCBiaWctZW5kaWFufSBlbmNvZGluZ3M7XG4gKiAqIDMyLWJpdCBmbG9hdGluZyBwb2ludCB2YWx1ZXMgd2l0aCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mMzJ8bGl0dGxlLWVuZGlhbn0gYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMmJlfGJpZy1lbmRpYW59IHJlcHJlc2VudGF0aW9ucztcbiAqICogNjQtYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmY2NHxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0YmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5jb25zdHxDb25zdGFudHN9IHRoYXQgdGFrZSBubyBzcGFjZSBpbiB0aGVcbiAqICAgZW5jb2RlZCBleHByZXNzaW9uLlxuICpcbiAqIGFuZCBmb3IgdGhlc2UgYWdncmVnYXRlIHR5cGVzOlxuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8U2VxdWVuY2V9cyBvZiBpbnN0YW5jZXMgb2YgYSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5MYXlvdXR8TGF5b3V0fSwgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzXG4gKiAgIGFuIEFycmF5IGFuZCBjb25zdGFudCBvciBkYXRhLWRlcGVuZGVudCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5TZXF1ZW5jZSNjb3VudHxsZW5ndGh9O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zdHJ1Y3R8U3RydWN0dXJlfXMgdGhhdCBhZ2dyZWdhdGUgYVxuICogICBoZXRlcm9nZW5lb3VzIHNlcXVlbmNlIG9mIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9XG4gKiAgIGluc3RhbmNlcywgd2l0aCBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIGFzIGFuIE9iamVjdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258VW5pb259cyB0aGF0IHN1cHBvcnQgbXVsdGlwbGUge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+VmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IG92ZXIgYSBmaXhlZFxuICogICAocGFkZGVkKSBvciB2YXJpYWJsZSAobm90IHBhZGRlZCkgc3BhbiBvZiBieXRlcywgdXNpbmcgYW5cbiAqICAgdW5zaWduZWQgaW50ZWdlciBhdCB0aGUgc3RhcnQgb2YgdGhlIGRhdGEgb3IgYSBzZXBhcmF0ZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC51bmlvbkxheW91dERpc2NyaW1pbmF0b3J8bGF5b3V0IGVsZW1lbnR9IHRvXG4gKiAgIGRldGVybWluZSB3aGljaCBsYXlvdXQgdG8gdXNlIHdoZW4gaW50ZXJwcmV0aW5nIHRoZSBidWZmZXJcbiAqICAgY29udGVudHM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmJpdHN8Qml0U3RydWN0dXJlfXMgdGhhdCBjb250YWluIGEgc2VxdWVuY2VcbiAqICAgb2YgaW5kaXZpZHVhbCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5CaXRTdHJ1Y3R1cmUjYWRkRmllbGR8Qml0RmllbGR9cyBwYWNrZWQgaW50byBhbiA4LFxuICogICAxNiwgMjQsIG9yIDMyLWJpdCB1bnNpZ25lZCBpbnRlZ2VyIHN0YXJ0aW5nIGF0IHRoZSBsZWFzdC0gb3JcbiAqICAgbW9zdC1zaWduaWZpY2FudCBiaXQ7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNzdHJ8QyBzdHJpbmdzfSBvZiB2YXJ5aW5nIGxlbmd0aDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYmxvYnxCbG9ic30gb2YgZml4ZWQtIG9yIHZhcmlhYmxlLXtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJsb2IjbGVuZ3RofGxlbmd0aH0gcmF3IGRhdGEuXG4gKlxuICogQWxsIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGluc3RhbmNlcyBhcmUgaW1tdXRhYmxlXG4gKiBhZnRlciBjb25zdHJ1Y3Rpb24sIHRvIHByZXZlbnQgaW50ZXJuYWwgc3RhdGUgZnJvbSBiZWNvbWluZ1xuICogaW5jb25zaXN0ZW50LlxuICpcbiAqIEBsb2NhbCBMYXlvdXRcbiAqIEBsb2NhbCBFeHRlcm5hbExheW91dFxuICogQGxvY2FsIEdyZWVkeUNvdW50XG4gKiBAbG9jYWwgT2Zmc2V0TGF5b3V0XG4gKiBAbG9jYWwgVUludFxuICogQGxvY2FsIFVJbnRCRVxuICogQGxvY2FsIEludFxuICogQGxvY2FsIEludEJFXG4gKiBAbG9jYWwgTmVhclVJbnQ2NFxuICogQGxvY2FsIE5lYXJVSW50NjRCRVxuICogQGxvY2FsIE5lYXJJbnQ2NFxuICogQGxvY2FsIE5lYXJJbnQ2NEJFXG4gKiBAbG9jYWwgRmxvYXRcbiAqIEBsb2NhbCBGbG9hdEJFXG4gKiBAbG9jYWwgRG91YmxlXG4gKiBAbG9jYWwgRG91YmxlQkVcbiAqIEBsb2NhbCBTZXF1ZW5jZVxuICogQGxvY2FsIFN0cnVjdHVyZVxuICogQGxvY2FsIFVuaW9uRGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvclxuICogQGxvY2FsIFVuaW9uXG4gKiBAbG9jYWwgVmFyaWFudExheW91dFxuICogQGxvY2FsIEJpdFN0cnVjdHVyZVxuICogQGxvY2FsIEJpdEZpZWxkXG4gKiBAbG9jYWwgQm9vbGVhblxuICogQGxvY2FsIEJsb2JcbiAqIEBsb2NhbCBDU3RyaW5nXG4gKiBAbG9jYWwgQ29uc3RhbnRcbiAqIEBsb2NhbCBiaW5kQ29uc3RydWN0b3JMYXlvdXRcbiAqIEBtb2R1bGUgTGF5b3V0XG4gKiBAbGljZW5zZSBNSVRcbiAqIEBhdXRob3IgUGV0ZXIgQS4gQmlnb3RcbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZ2l0aHViLmNvbS9wYWJpZ290L2J1ZmZlci1sYXlvdXR8YnVmZmVyLWxheW91dCBvbiBHaXRIdWJ9XG4gKi9cbid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuczE2ID0gZXhwb3J0cy5zOCA9IGV4cG9ydHMubnU2NGJlID0gZXhwb3J0cy51NDhiZSA9IGV4cG9ydHMudTQwYmUgPSBleHBvcnRzLnUzMmJlID0gZXhwb3J0cy51MjRiZSA9IGV4cG9ydHMudTE2YmUgPSBleHBvcnRzLm51NjQgPSBleHBvcnRzLnU0OCA9IGV4cG9ydHMudTQwID0gZXhwb3J0cy51MzIgPSBleHBvcnRzLnUyNCA9IGV4cG9ydHMudTE2ID0gZXhwb3J0cy51OCA9IGV4cG9ydHMub2Zmc2V0ID0gZXhwb3J0cy5ncmVlZHkgPSBleHBvcnRzLkNvbnN0YW50ID0gZXhwb3J0cy5VVEY4ID0gZXhwb3J0cy5DU3RyaW5nID0gZXhwb3J0cy5CbG9iID0gZXhwb3J0cy5Cb29sZWFuID0gZXhwb3J0cy5CaXRGaWVsZCA9IGV4cG9ydHMuQml0U3RydWN0dXJlID0gZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gZXhwb3J0cy5VbmlvbiA9IGV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBleHBvcnRzLlN0cnVjdHVyZSA9IGV4cG9ydHMuU2VxdWVuY2UgPSBleHBvcnRzLkRvdWJsZUJFID0gZXhwb3J0cy5Eb3VibGUgPSBleHBvcnRzLkZsb2F0QkUgPSBleHBvcnRzLkZsb2F0ID0gZXhwb3J0cy5OZWFySW50NjRCRSA9IGV4cG9ydHMuTmVhckludDY0ID0gZXhwb3J0cy5OZWFyVUludDY0QkUgPSBleHBvcnRzLk5lYXJVSW50NjQgPSBleHBvcnRzLkludEJFID0gZXhwb3J0cy5JbnQgPSBleHBvcnRzLlVJbnRCRSA9IGV4cG9ydHMuVUludCA9IGV4cG9ydHMuT2Zmc2V0TGF5b3V0ID0gZXhwb3J0cy5HcmVlZHlDb3VudCA9IGV4cG9ydHMuRXh0ZXJuYWxMYXlvdXQgPSBleHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGV4cG9ydHMubmFtZVdpdGhQcm9wZXJ0eSA9IGV4cG9ydHMuTGF5b3V0ID0gZXhwb3J0cy51aW50OEFycmF5VG9CdWZmZXIgPSBleHBvcnRzLmNoZWNrVWludDhBcnJheSA9IHZvaWQgMDtcbmV4cG9ydHMuY29uc3RhbnQgPSBleHBvcnRzLnV0ZjggPSBleHBvcnRzLmNzdHIgPSBleHBvcnRzLmJsb2IgPSBleHBvcnRzLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9IGV4cG9ydHMudW5pb24gPSBleHBvcnRzLnNlcSA9IGV4cG9ydHMuYml0cyA9IGV4cG9ydHMuc3RydWN0ID0gZXhwb3J0cy5mNjRiZSA9IGV4cG9ydHMuZjY0ID0gZXhwb3J0cy5mMzJiZSA9IGV4cG9ydHMuZjMyID0gZXhwb3J0cy5uczY0YmUgPSBleHBvcnRzLnM0OGJlID0gZXhwb3J0cy5zNDBiZSA9IGV4cG9ydHMuczMyYmUgPSBleHBvcnRzLnMyNGJlID0gZXhwb3J0cy5zMTZiZSA9IGV4cG9ydHMubnM2NCA9IGV4cG9ydHMuczQ4ID0gZXhwb3J0cy5zNDAgPSBleHBvcnRzLnMzMiA9IGV4cG9ydHMuczI0ID0gdm9pZCAwO1xuY29uc3QgYnVmZmVyXzEgPSByZXF1aXJlKFwiYnVmZmVyXCIpO1xuLyogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gY2hlY2tVaW50OEFycmF5KGIpIHtcbiAgICBpZiAoIShiIGluc3RhbmNlb2YgVWludDhBcnJheSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYiBtdXN0IGJlIGEgVWludDhBcnJheScpO1xuICAgIH1cbn1cbmV4cG9ydHMuY2hlY2tVaW50OEFycmF5ID0gY2hlY2tVaW50OEFycmF5O1xuLyogQ3JlYXRlIGEgQnVmZmVyIGluc3RhbmNlIGZyb20gYSBVaW50OEFycmF5LlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKSB7XG4gICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgIHJldHVybiBidWZmZXJfMS5CdWZmZXIuZnJvbShiLmJ1ZmZlciwgYi5ieXRlT2Zmc2V0LCBiLmxlbmd0aCk7XG59XG5leHBvcnRzLnVpbnQ4QXJyYXlUb0J1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcjtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5b3V0IG9iamVjdHMuXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQgdGhlIHtAbGlua1xuICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG9yIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW50ZWdlcjsgYSBuZWdhdGl2ZSB2YWx1ZSBzaWduaWZpZXMgdGhhdCB0aGVcbiAqIHNwYW4gaXMge0BsaW5rIExheW91dCNnZXRTcGFufHZhbHVlLXNwZWNpZmljfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIEluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUgc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogWmVybyB3aWxsIG9ubHkgYXBwZWFyIGluIHtAbGluayBDb25zdGFudH1zIGFuZCBpbiB7QGxpbmtcbiAgICAgICAgICogU2VxdWVuY2V9cyB3aGVyZSB0aGUge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSBpcyB6ZXJvLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZSBzcGFuIGlzIHZhbHVlLXNwZWNpZmljLCBhbmRcbiAgICAgICAgICogbXVzdCBiZSBvYnRhaW5lZCB1c2luZyB7QGxpbmsgTGF5b3V0I2dldFNwYW58Z2V0U3Bhbn0uICovXG4gICAgICAgIHRoaXMuc3BhbiA9IHNwYW47XG4gICAgICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBsYXlvdXQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgICAgICogT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAgICAgKiBpbnN0YW5jZXMuICBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgc3BhbiBvZiB0aGUgdW5uYW1lZCBsYXlvdXQgd2lsbFxuICAgICAgICAgKiBiZSB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIEZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBPYmplY3QgaW50byB3aGljaCBkZWNvZGVkIHByb3BlcnRpZXMgd2lsbFxuICAgICAqIGJlIHdyaXR0ZW4uXG4gICAgICpcbiAgICAgKiBVc2VkIG9ubHkgZm9yIGxheW91dHMgdGhhdCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IHRvIE9iamVjdFxuICAgICAqIGluc3RhbmNlcywgd2hpY2ggbWVhbnM6XG4gICAgICogKiB7QGxpbmsgU3RydWN0dXJlfVxuICAgICAqICoge0BsaW5rIFVuaW9ufVxuICAgICAqICoge0BsaW5rIFZhcmlhbnRMYXlvdXR9XG4gICAgICogKiB7QGxpbmsgQml0U3RydWN0dXJlfVxuICAgICAqXG4gICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gb2YgdGhlc2UgbGF5b3V0c1xuICAgICAqIHdpbGwgYmUgT2JqZWN0IGluc3RhbmNlcy5cbiAgICAgKlxuICAgICAqIFNlZSB7QGxpbmsgYmluZENvbnN0cnVjdG9yTGF5b3V0fS5cbiAgICAgKi9cbiAgICBtYWtlRGVzdGluYXRpb25PYmplY3QoKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsY3VsYXRlIHRoZSBzcGFuIG9mIGEgc3BlY2lmaWMgaW5zdGFuY2Ugb2YgYSBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1VpbnQ4QXJyYXl9IGIgLSB0aGUgYnVmZmVyIHRoYXQgY29udGFpbnMgYW4gZW5jb2RlZCBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBbb2Zmc2V0XSAtIHRoZSBvZmZzZXQgYXQgd2hpY2ggdGhlIGVuY29kZWQgaW5zdGFuY2VcbiAgICAgKiBzdGFydHMuICBJZiBhYnNlbnQgYSB6ZXJvIG9mZnNldCBpcyBpbmZlcnJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgbnVtYmVyIG9mIGJ5dGVzIGNvdmVyZWQgYnkgdGhlIGxheW91dFxuICAgICAqIGluc3RhbmNlLiAgSWYgdGhpcyBtZXRob2QgaXMgbm90IG92ZXJyaWRkZW4gaW4gYSBzdWJjbGFzcyB0aGVcbiAgICAgKiBkZWZpbml0aW9uLXRpbWUgY29uc3RhbnQge0BsaW5rIExheW91dCNzcGFufHNwYW59IHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IC0gaWYgdGhlIGxlbmd0aCBvZiB0aGUgdmFsdWUgY2Fubm90IGJlXG4gICAgICogZGV0ZXJtaW5lZC5cbiAgICAgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCkge1xuICAgICAgICBpZiAoMCA+IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlcGxpY2F0ZSB0aGUgbGF5b3V0IHVzaW5nIGEgbmV3IHByb3BlcnR5LlxuICAgICAqXG4gICAgICogVGhpcyBmdW5jdGlvbiBtdXN0IGJlIHVzZWQgdG8gZ2V0IGEgc3RydWN0dXJhbGx5LWVxdWl2YWxlbnQgbGF5b3V0XG4gICAgICogd2l0aCBhIGRpZmZlcmVudCBuYW1lIHNpbmNlIGFsbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZXMgYXJlXG4gICAgICogaW1tdXRhYmxlLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBhIHNoYWxsb3cgY29weS4gIEFsbCBmaWVsZHMgZXhjZXB0IHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gYXJlIHN0cmljdGx5IGVxdWFsIHRvIHRoZSBvcmlnaW4gbGF5b3V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHZhbHVlIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IGluIHRoZSByZXBsaWNhLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0xheW91dH0gLSB0aGUgY29weSB3aXRoIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gICAgICogc2V0IHRvIGBwcm9wZXJ0eWAuXG4gICAgICovXG4gICAgcmVwbGljYXRlKHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24ocnYsIHRoaXMpO1xuICAgICAgICBydi5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBvYmplY3QgZnJvbSBsYXlvdXQgcHJvcGVydGllcyBhbmQgYW4gYXJyYXkgb2YgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBmdW5jdGlvbiByZXR1cm5zIGB1bmRlZmluZWRgIGlmIGludm9rZWQgb24gYSBsYXlvdXRcbiAgICAgKiB0aGF0IGRvZXMgbm90IHJldHVybiBpdHMgdmFsdWUgYXMgYW4gT2JqZWN0LiAgT2JqZWN0cyBhcmVcbiAgICAgKiByZXR1cm5lZCBmb3IgdGhpbmdzIHRoYXQgYXJlIGEge0BsaW5rIFN0cnVjdHVyZX0sIHdoaWNoIGluY2x1ZGVzXG4gICAgICoge0BsaW5rIFZhcmlhbnRMYXlvdXR8dmFyaWFudCBsYXlvdXRzfSBpZiB0aGV5IGFyZSBzdHJ1Y3R1cmVzLCBhbmRcbiAgICAgKiBleGNsdWRlcyB7QGxpbmsgVW5pb259cy4gIElmIHlvdSB3YW50IHRoaXMgZmVhdHVyZSBmb3IgYSB1bmlvblxuICAgICAqIHlvdSBtdXN0IHVzZSB7QGxpbmsgVW5pb24uZ2V0VmFyaWFudHxnZXRWYXJpYW50fSB0byBzZWxlY3QgdGhlXG4gICAgICogZGVzaXJlZCBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgLSBhbiBhcnJheSBvZiB2YWx1ZXMgdGhhdCBjb3JyZXNwb25kIHRvIHRoZVxuICAgICAqIGRlZmF1bHQgb3JkZXIgZm9yIHByb3BlcnRpZXMuICBBcyB3aXRoIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX1cbiAgICAgKiBsYXlvdXQgZWxlbWVudHMgdGhhdCBoYXZlIG5vIHByb3BlcnR5IG5hbWUgYXJlIHNraXBwZWQgd2hlblxuICAgICAqIGl0ZXJhdGluZyBvdmVyIHRoZSBhcnJheSB2YWx1ZXMuICBPbmx5IHRoZSB0b3AtbGV2ZWwgcHJvcGVydGllcyBhcmVcbiAgICAgKiBhc3NpZ25lZDsgYXJndW1lbnRzIGFyZSBub3QgYXNzaWduZWQgdG8gcHJvcGVydGllcyBvZiBjb250YWluZWRcbiAgICAgKiBsYXlvdXRzLiAgQW55IHVudXNlZCB2YWx1ZXMgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHsoT2JqZWN0fHVuZGVmaW5lZCl9XG4gICAgICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydHMuTGF5b3V0ID0gTGF5b3V0O1xuLyogUHJvdmlkZSB0ZXh0IHRoYXQgY2FycmllcyBhIG5hbWUgKHN1Y2ggYXMgZm9yIGEgZnVuY3Rpb24gdGhhdCB3aWxsXG4gKiBiZSB0aHJvd2luZyBhbiBlcnJvcikgYW5ub3RhdGVkIHdpdGggdGhlIHByb3BlcnR5IG9mIGEgZ2l2ZW4gbGF5b3V0XG4gKiAoc3VjaCBhcyBvbmUgZm9yIHdoaWNoIHRoZSB2YWx1ZSB3YXMgdW5hY2NlcHRhYmxlKS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBuYW1lV2l0aFByb3BlcnR5KG5hbWUsIGxvKSB7XG4gICAgaWYgKGxvLnByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBuYW1lICsgJ1snICsgbG8ucHJvcGVydHkgKyAnXSc7XG4gICAgfVxuICAgIHJldHVybiBuYW1lO1xufVxuZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gbmFtZVdpdGhQcm9wZXJ0eTtcbi8qKlxuICogQXVnbWVudCBhIGNsYXNzIHNvIHRoYXQgaW5zdGFuY2VzIGNhbiBiZSBlbmNvZGVkL2RlY29kZWQgdXNpbmcgYVxuICogZ2l2ZW4gbGF5b3V0LlxuICpcbiAqIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBjb3VwbGVzIGBDbGFzc2Agd2l0aCBgbGF5b3V0YCBpbiBzZXZlcmFsIHdheXM6XG4gKlxuICogKiBgQ2xhc3MubGF5b3V0X2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWwgdG8gYGxheW91dGA7XG4gKiAqIGBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl9gIGJlY29tZXMgYSBzdGF0aWMgbWVtYmVyIHByb3BlcnR5IGVxdWFsXG4gKiAgICB0byBgQ2xhc3NgO1xuICogKiBUaGUge0BsaW5rIExheW91dCNtYWtlRGVzdGluYXRpb25PYmplY3R8bWFrZURlc3RpbmF0aW9uT2JqZWN0KCl9XG4gKiAgIHByb3BlcnR5IG9mIGBsYXlvdXRgIGlzIHNldCB0byBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIGBuZXdcbiAqICAgQ2xhc3MoKWA7XG4gKiAqIGBDbGFzcy5kZWNvZGUoYiwgb2Zmc2V0KWAgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgZnVuY3Rpb24gdGhhdFxuICogICBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNkZWNvZGV8bGF5b3V0LmRlY29kZX0uICBUaGVcbiAqICAgc3ludGhlc2l6ZWQgZnVuY3Rpb24gbWF5IGJlIGNhcHR1cmVkIGFuZCBleHRlbmRlZC5cbiAqICogYENsYXNzLnByb3RvdHlwZS5lbmNvZGUoYiwgb2Zmc2V0KWAgcHJvdmlkZXMgYW4gaW5zdGFuY2UgbWVtYmVyXG4gKiAgIGZ1bmN0aW9uIHRoYXQgZGVsZWdhdGVzIHRvIHtAbGluayBMYXlvdXQjZW5jb2RlfGxheW91dC5lbmNvZGV9XG4gKiAgIHdpdGggYHNyY2Agc2V0IHRvIGB0aGlzYC4gIFRoZSBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmVcbiAqICAgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLCBidXQgd2hlbiB0aGUgZXh0ZW5zaW9uIGlzIGludm9rZWQgYHRoaXNgXG4gKiAgIG11c3QgYmUgZXhwbGljaXRseSBib3VuZCB0byB0aGUgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtjbGFzc30gQ2xhc3MgLSBhIEphdmFTY3JpcHQgY2xhc3Mgd2l0aCBhIG51bGxhcnlcbiAqIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSB0aGUge0BsaW5rIExheW91dH0gaW5zdGFuY2UgdXNlZCB0byBlbmNvZGVcbiAqIGluc3RhbmNlcyBvZiBgQ2xhc3NgLlxuICovXG4vLyBgQ2xhc3NgIG11c3QgYmUgYSBjb25zdHJ1Y3RvciBGdW5jdGlvbiwgYnV0IHRoZSBhc3NpZ25tZW50IG9mIGEgYGxheW91dF9gIHByb3BlcnR5IHRvIGl0IG1ha2VzIGl0IGRpZmZpY3VsdCB0byB0eXBlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2V4cGxpY2l0LW1vZHVsZS1ib3VuZGFyeS10eXBlc1xuZnVuY3Rpb24gYmluZENvbnN0cnVjdG9yTGF5b3V0KENsYXNzLCBsYXlvdXQpIHtcbiAgICBpZiAoJ2Z1bmN0aW9uJyAhPT0gdHlwZW9mIENsYXNzKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0NsYXNzIG11c3QgYmUgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChDbGFzcywgJ2xheW91dF8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NsYXNzIGlzIGFscmVhZHkgYm91bmQgdG8gYSBsYXlvdXQnKTtcbiAgICB9XG4gICAgaWYgKCEobGF5b3V0ICYmIChsYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGxheW91dCwgJ2JvdW5kQ29uc3RydWN0b3JfJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdsYXlvdXQgaXMgYWxyZWFkeSBib3VuZCB0byBhIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIENsYXNzLmxheW91dF8gPSBsYXlvdXQ7XG4gICAgbGF5b3V0LmJvdW5kQ29uc3RydWN0b3JfID0gQ2xhc3M7XG4gICAgbGF5b3V0Lm1ha2VEZXN0aW5hdGlvbk9iamVjdCA9ICgoKSA9PiBuZXcgQ2xhc3MoKSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENsYXNzLnByb3RvdHlwZSwgJ2VuY29kZScsIHtcbiAgICAgICAgdmFsdWUoYiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0LmVuY29kZSh0aGlzLCBiLCBvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MsICdkZWNvZGUnLCB7XG4gICAgICAgIHZhbHVlKGIsIG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgfSk7XG59XG5leHBvcnRzLmJpbmRDb25zdHJ1Y3RvckxheW91dCA9IGJpbmRDb25zdHJ1Y3RvckxheW91dDtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgYmVoYXZlcyBsaWtlIGEgbGF5b3V0IGJ1dCBkb2VzIG5vdCBjb25zdW1lIHNwYWNlXG4gKiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgbGF5b3V0LlxuICpcbiAqIFRoaXMgaXMgcHJpbWFyaWx5IHVzZWQgdG8gb2J0YWluIG1ldGFkYXRhIGFib3V0IGEgbWVtYmVyLCBzdWNoIGFzIGFcbiAqIHtAbGluayBPZmZzZXRMYXlvdXR9IHRoYXQgY2FuIHByb3ZpZGUgZGF0YSBhYm91dCBhIHtAbGlua1xuICogTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWMgc3Bhbn0uXG4gKlxuICogKipOT1RFKiogVGhpcyBpcyBhbiBhYnN0cmFjdCBiYXNlIGNsYXNzOyB5b3UgY2FuIGNyZWF0ZSBpbnN0YW5jZXNcbiAqIGlmIGl0IGFtdXNlcyB5b3UsIGJ1dCB0aGV5IHdvbid0IHN1cHBvcnQge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnR9IG9yIG90aGVyIHtAbGluayBMYXlvdXR9IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBFeHRlcm5hbExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGB0cnVlYCBpZmYgdGhlIGV4dGVybmFsIGxheW91dCBkZWNvZGVzIHRvIGFuIHVuc2lnbmVkXG4gICAgICogaW50ZWdlciBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBJbiB0aGF0IGNhc2UgaXQgY2FuIGJlIHVzZWQgYXMgdGhlIHNvdXJjZSBvZiB7QGxpbmtcbiAgICAgKiBTZXF1ZW5jZSNjb3VudHxTZXF1ZW5jZSBjb3VudHN9LCB7QGxpbmsgQmxvYiNsZW5ndGh8QmxvYiBsZW5ndGhzfSxcbiAgICAgKiBvciBhcyB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxleHRlcm5hbCB1bmlvblxuICAgICAqIGRpc2NyaW1pbmF0b3JzfS5cbiAgICAgKlxuICAgICAqIEBhYnN0cmFjdFxuICAgICAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZXJuYWxMYXlvdXQgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG59XG5leHBvcnRzLkV4dGVybmFsTGF5b3V0ID0gRXh0ZXJuYWxMYXlvdXQ7XG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBkZXRlcm1pbmVzIGl0cyB7QGxpbmtcbiAqIExheW91dCNkZWNvZGV8dmFsdWV9IGJhc2VkIG9uIG9mZnNldCBpbnRvIGFuZCBsZW5ndGggb2YgdGhlIGJ1ZmZlclxuICogb24gd2hpY2ggaXQgaXMgaW52b2tlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmdyZWVkeXxncmVlZHl9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtlbGVtZW50U3Bhbl0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBHcmVlZHlDb3VudCNlbGVtZW50U3BhbnxlbGVtZW50U3Bhbn0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7RXh0ZXJuYWxMYXlvdXR9XG4gKi9cbmNsYXNzIEdyZWVkeUNvdW50IGV4dGVuZHMgRXh0ZXJuYWxMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRTcGFuID0gMSwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCghTnVtYmVyLmlzSW50ZWdlcihlbGVtZW50U3BhbikpIHx8ICgwID49IGVsZW1lbnRTcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudFNwYW4gbXVzdCBiZSBhIChwb3NpdGl2ZSkgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gIFRoZSB2YWx1ZVxuICAgICAgICAgKiBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlci4gIElmIG5vdCBwcm92aWRlZCwgdGhlIHZhbHVlIHdpbGwgYmVcbiAgICAgICAgICogMS4gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50U3BhbiA9IGVsZW1lbnRTcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGNvbnN0IHJlbSA9IGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgICAgICByZXR1cm4gTWF0aC5mbG9vcihyZW0gLyB0aGlzLmVsZW1lbnRTcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLkdyZWVkeUNvdW50ID0gR3JlZWR5Q291bnQ7XG4vKipcbiAqIEFuIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzdXBwb3J0cyBhY2Nlc3NpbmcgYSB7QGxpbmsgTGF5b3V0fVxuICogYXQgYSBmaXhlZCBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgYW5vdGhlciBMYXlvdXQuICBUaGUgb2Zmc2V0IG1heVxuICogYmUgYmVmb3JlLCB3aXRoaW4sIG9yIGFmdGVyIHRoZSBiYXNlIGxheW91dC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm9mZnNldHxvZmZzZXR9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIE9mZnNldExheW91dCNsYXlvdXR8bGF5b3V0fSwgbW9kdWxvIGBwcm9wZXJ0eWAuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gSW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjb2Zmc2V0fG9mZnNldH0uICBEZWZhdWx0cyB0byB6ZXJvLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gT3B0aW9uYWwgbmV3IHByb3BlcnR5IG5hbWUgZm9yIGFcbiAqIHtAbGluayBMYXlvdXQjcmVwbGljYXRlfCByZXBsaWNhfSBvZiBgbGF5b3V0YCB0byBiZSB1c2VkIGFzIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgbm90IHByb3ZpZGVkIHRoZSBgbGF5b3V0YCBpcyB1c2VkXG4gKiB1bmNoYW5nZWQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE9mZnNldExheW91dCBleHRlbmRzIEV4dGVybmFsTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIG9mZnNldCA9IDAsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG9mZnNldCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29mZnNldCBtdXN0IGJlIGludGVnZXIgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobGF5b3V0LnNwYW4sIHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgc3Vib3JkaW5hdGVkIGxheW91dC4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgICAgIC8qKiBUaGUgbG9jYXRpb24gb2Yge0BsaW5rIE9mZnNldExheW91dCNsYXlvdXR9IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBzdGFydCBvZiBhbm90aGVyIGxheW91dC5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhlIHZhbHVlIG1heSBiZSBwb3NpdGl2ZSBvciBuZWdhdGl2ZSwgYnV0IGFuIGVycm9yIHdpbGwgdGhyb3duXG4gICAgICAgICAqIGlmIGF0IHRoZSBwb2ludCBvZiB1c2UgaXQgZ29lcyBvdXRzaWRlIHRoZSBzcGFuIG9mIHRoZSBVaW50OEFycmF5XG4gICAgICAgICAqIGJlaW5nIGFjY2Vzc2VkLiAgKi9cbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gKCh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAodGhpcy5sYXlvdXQgaW5zdGFuY2VvZiBVSW50QkUpKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZW5jb2RlKHNyYywgYiwgb2Zmc2V0ICsgdGhpcy5vZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuT2Zmc2V0TGF5b3V0ID0gT2Zmc2V0TGF5b3V0O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4fHU4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MTZ8dTE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0fHUyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTMyfHUzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnU0MHx1NDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnU0OHx1NDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgaWYgKDYgPCB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdzcGFuIG11c3Qgbm90IGV4Y2VlZCA2IGJ5dGVzJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZFVJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZVVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVJbnQgPSBVSW50O1xuLyoqXG4gKiBSZXByZXNlbnQgYW4gdW5zaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnU4YmV8dThiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC51MTZiZXx1MTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnUyNGJlfHUyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnUzMmJlfHUzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnU0MGJlfHU0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4YmV8dTQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVJbnRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkVUludEJFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlVUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludEJFID0gVUludEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fHM4fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMTZ8czE2fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczI0fHMyNH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczMyfHMzMn0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0MHxzNDB9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnM0OHxzNDh9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkSW50TEUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVJbnRMRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkludCA9IEludDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zOGJlfHM4YmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQuczE2YmV8czE2YmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjRiZXxzMjRiZX0sXG4gKiB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXxzMzJiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zNDBiZXxzNDBiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnM0OGJlfHM0OGJlfVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBJbnRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVJbnRCRShzcmMsIG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLkludEJFID0gSW50QkU7XG5jb25zdCBWMkUzMiA9IE1hdGgucG93KDIsIDMyKTtcbi8qIFRydWUgbW9kdWx1cyBoaWdoIGFuZCBsb3cgMzItYml0IHdvcmRzLCB3aGVyZSBsb3cgd29yZCBpcyBhbHdheXNcbiAqIG5vbi1uZWdhdGl2ZS4gKi9cbmZ1bmN0aW9uIGRpdm1vZEludDY0KHNyYykge1xuICAgIGNvbnN0IGhpMzIgPSBNYXRoLmZsb29yKHNyYyAvIFYyRTMyKTtcbiAgICBjb25zdCBsbzMyID0gc3JjIC0gKGhpMzIgKiBWMkUzMik7XG4gICAgcmV0dXJuIHsgaGkzMiwgbG8zMiB9O1xufVxuLyogUmVjb25zdHJ1Y3QgTnVtYmVyIGZyb20gcXVvdGllbnQgYW5kIG5vbi1uZWdhdGl2ZSByZW1haW5kZXIgKi9cbmZ1bmN0aW9uIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKSB7XG4gICAgcmV0dXJuIGhpMzIgKiBWMkUzMiArIGxvMzI7XG59XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NHxudTY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQubG8zMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhclVJbnQ2NCA9IE5lYXJVSW50NjQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnU2NGJlfG51NjRiZX1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhclVJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQuaGkzMiwgb2Zmc2V0KTtcbiAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUoc3BsaXQubG8zMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhclVJbnQ2NEJFID0gTmVhclVJbnQ2NEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjR8bnM2NH1cbiAqXG4gKiAqKk5PVEUqKiBWYWx1ZXMgd2l0aCBtYWduaXR1ZGUgZ3JlYXRlciB0aGFuIDJeNTIgbWF5IG5vdCBkZWNvZGUgdG9cbiAqIHRoZSBleGFjdCB2YWx1ZSBvZiB0aGUgZW5jb2RlZCByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgTmVhckludDY0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkxFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZEludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5sbzMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkxFKHNwbGl0LmhpMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJJbnQ2NCA9IE5lYXJJbnQ2NDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5uczY0YmV8bnM2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBjb25zdCBoaTMyID0gYnVmZmVyLnJlYWRJbnQzMkJFKG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGxvMzIgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGxpdCA9IGRpdm1vZEludDY0KHNyYyk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFySW50NjRCRSA9IE5lYXJJbnQ2NEJFO1xuLyoqXG4gKiBSZXByZXNlbnQgYSAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjMyfGYzMn1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig0LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRGbG9hdExFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUZsb2F0TEUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gNDtcbiAgICB9XG59XG5leHBvcnRzLkZsb2F0ID0gRmxvYXQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJiZXxmMzJiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEZsb2F0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEZsb2F0QkUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRmxvYXRCRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXRCRSA9IEZsb2F0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjR8ZjY0fVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRG91YmxlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWREb3VibGVMRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVEb3VibGVMRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuRG91YmxlID0gRG91YmxlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZjY0YmV8ZjY0YmV9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGVCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoOCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRG91YmxlQkUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRG91YmxlQkUoc3JjLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLkRvdWJsZUJFID0gRG91YmxlQkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYSBzcGVjaWZpYyBsYXlvdXQgYXMgYW4gQXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5zZXF8c2VxfVxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBlbGVtZW50TGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjZWxlbWVudExheW91dHxlbGVtZW50TGF5b3V0fS5cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBjb3VudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFNlcXVlbmNlI2NvdW50fGNvdW50fS4gIFRoZSBwYXJhbWV0ZXIgbXVzdCBiZSBlaXRoZXIgYSBwb3NpdGl2ZVxuICogaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU2VxdWVuY2UgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRMYXlvdXQsIGNvdW50LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShlbGVtZW50TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZWxlbWVudExheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoKChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBjb3VudC5pc0NvdW50KCkpXG4gICAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihjb3VudCkgJiYgKDAgPD0gY291bnQpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvdW50IG11c3QgYmUgbm9uLW5lZ2F0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoKCEoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpXG4gICAgICAgICAgICAmJiAoMCA8IGVsZW1lbnRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgICAgIHNwYW4gPSBjb3VudCAqIGVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBpbmRpdmlkdWFsIGVsZW1lbnRzIG9mIHRoZSBzZXF1ZW5jZS4gKi9cbiAgICAgICAgdGhpcy5lbGVtZW50TGF5b3V0ID0gZWxlbWVudExheW91dDtcbiAgICAgICAgLyoqIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIHNlcXVlbmNlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgZWl0aGVyIGEgbm9uLW5lZ2F0aXZlIGludGVnZXIgb3IgYW4gaW5zdGFuY2Ugb2ZcbiAgICAgICAgICoge0BsaW5rIEV4dGVybmFsTGF5b3V0fSBmb3Igd2hpY2gge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudCgpfSBpcyBgdHJ1ZWAuICovXG4gICAgICAgIHRoaXMuY291bnQgPSBjb3VudDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoMCA8IHRoaXMuZWxlbWVudExheW91dC5zcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gY291bnQgKiB0aGlzLmVsZW1lbnRMYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBpZHggPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGlkeCA8IGNvdW50KSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSB0aGlzLmVsZW1lbnRMYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgICAgICAgICArK2lkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gW107XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5jb3VudDtcbiAgICAgICAgaWYgKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIGNvdW50ID0gY291bnQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGkgPCBjb3VudCkge1xuICAgICAgICAgICAgcnYucHVzaCh0aGlzLmVsZW1lbnRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCkpO1xuICAgICAgICAgICAgb2Zmc2V0ICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBTZXF1ZW5jZX0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiBgc3JjYCBpcyBzaG9ydGVyIHRoYW4ge0BsaW5rIFNlcXVlbmNlI2NvdW50fGNvdW50fSB0aGVuXG4gICAgICogdGhlIHVudXNlZCBzcGFjZSBpbiB0aGUgYnVmZmVyIGlzIGxlZnQgdW5jaGFuZ2VkLiAgSWYgYHNyY2AgaXNcbiAgICAgKiBsb25nZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZSB1bm5lZWRlZCBlbGVtZW50cyBhcmVcbiAgICAgKiBpZ25vcmVkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGVsbyA9IHRoaXMuZWxlbWVudExheW91dDtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyYy5yZWR1Y2UoKHNwYW4sIHYpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBzcGFuICsgZWxvLmVuY29kZSh2LCBiLCBvZmZzZXQgKyBzcGFuKTtcbiAgICAgICAgfSwgMCk7XG4gICAgICAgIGlmICh0aGlzLmNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMuY291bnQuZW5jb2RlKHNyYy5sZW5ndGgsIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5TZXF1ZW5jZSA9IFNlcXVlbmNlO1xuLyoqXG4gKiBSZXByZXNlbnQgYSBjb250aWd1b3VzIHNlcXVlbmNlIG9mIGFyYml0cmFyeSBsYXlvdXQgZWxlbWVudHMgYXMgYW5cbiAqIE9iamVjdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxzdHJ1Y3R9XG4gKlxuICogKipOT1RFKiogVGhlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBvZiB0aGUgc3RydWN0dXJlIGlzIHZhcmlhYmxlXG4gKiBpZiBhbnkgbGF5b3V0IGluIHtAbGluayBTdHJ1Y3R1cmUjZmllbGRzfGZpZWxkc30gaGFzIGEgdmFyaWFibGVcbiAqIHNwYW4uICBXaGVuIHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kaW5nfSB3ZSBtdXN0IGhhdmUgYSB2YWx1ZSBmb3JcbiAqIGFsbCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBvciB3ZSB3b3VsZG4ndCBiZSBhYmxlIHRvIGZpZ3VyZSBvdXRcbiAqIGhvdyBtdWNoIHNwYWNlIHRvIHVzZSBmb3Igc3RvcmFnZS4gIFdlIGNhbiBvbmx5IGlkZW50aWZ5IHRoZSB2YWx1ZVxuICogZm9yIGEgZmllbGQgd2hlbiBpdCBoYXMgYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS4gIEFzXG4gKiBzdWNoLCBhbHRob3VnaCBhIHN0cnVjdHVyZSBtYXkgY29udGFpbiBib3RoIHVubmFtZWQgZmllbGRzIGFuZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkcywgaXQgY2Fubm90IGNvbnRhaW4gYW4gdW5uYW1lZFxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0W119IGZpZWxkcyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfS4gIEFuIGVycm9yIGlzIHJhaXNlZCBpZiB0aGlzIGNvbnRhaW5zIGFcbiAqIHZhcmlhYmxlLWxlbmd0aCBmaWVsZCBmb3Igd2hpY2ggYSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fVxuICogaXMgbm90IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW2RlY29kZVByZWZpeGVzXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFN0cnVjdHVyZSNkZWNvZGVQcmVmaXhlc3xwcm9wZXJ0eX0uXG4gKlxuICogQHRocm93cyB7RXJyb3J9IC0gaWYgYGZpZWxkc2AgY29udGFpbnMgYW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGhcbiAqIGxheW91dC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgU3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykge1xuICAgICAgICBpZiAoIShBcnJheS5pc0FycmF5KGZpZWxkcylcbiAgICAgICAgICAgICYmIGZpZWxkcy5yZWR1Y2UoKGFjYywgdikgPT4gYWNjICYmICh2IGluc3RhbmNlb2YgTGF5b3V0KSwgdHJ1ZSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWVsZHMgbXVzdCBiZSBhcnJheSBvZiBMYXlvdXQgaW5zdGFuY2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnYm9vbGVhbicgPT09IHR5cGVvZiBwcm9wZXJ0eSlcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IGRlY29kZVByZWZpeGVzKSkge1xuICAgICAgICAgICAgZGVjb2RlUHJlZml4ZXMgPSBwcm9wZXJ0eTtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIFZlcmlmeSBhYnNlbmNlIG9mIHVubmFtZWQgdmFyaWFibGUtbGVuZ3RoIGZpZWxkcy4gKi9cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiBmaWVsZHMpIHtcbiAgICAgICAgICAgIGlmICgoMCA+IGZkLnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZmQucHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaWVsZHMgY2Fubm90IGNvbnRhaW4gdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggbGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4gPSBmaWVsZHMucmVkdWNlKChzcGFuLCBmZCkgPT4gc3BhbiArIGZkLmdldFNwYW4oKSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIGlnbm9yZSBlcnJvclxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgTGF5b3V0fSB2YWx1ZXMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgICAgICogc3RydWN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgaW5kaXZpZHVhbCBlbGVtZW50cyBuZWVkIG5vdCBiZSB0aGUgc2FtZSB0eXBlLCBhbmQgbWF5IGJlXG4gICAgICAgICAqIGVpdGhlciBzY2FsYXIgb3IgYWdncmVnYXRlIGxheW91dHMuICBJZiBhIG1lbWJlciBsYXlvdXQgbGVhdmVzXG4gICAgICAgICAqIGl0cyB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB1bmRlZmluZWQgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gICAgICAgICAqIHdpbGwgbm90IGJlIG11dGF0ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEB0eXBlIHtMYXlvdXRbXX0gKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgICAgIC8qKiBDb250cm9sIGJlaGF2aW9yIG9mIHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZSgpfSBnaXZlbiBzaG9ydFxuICAgICAgICAgKiBidWZmZXJzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbiBzb21lIHNpdHVhdGlvbnMgYSBzdHJ1Y3R1cmUgbWFueSBiZSBleHRlbmRlZCB3aXRoIGFkZGl0aW9uYWxcbiAgICAgICAgICogZmllbGRzIG92ZXIgdGltZSwgd2l0aCBvbGRlciBpbnN0YWxsYXRpb25zIHByb3ZpZGluZyBvbmx5IGFcbiAgICAgICAgICogcHJlZml4IG9mIHRoZSBmdWxsIHN0cnVjdHVyZS4gIElmIHRoaXMgcHJvcGVydHkgaXMgYHRydWVgXG4gICAgICAgICAqIGRlY29kaW5nIHdpbGwgYWNjZXB0IHRob3NlIGJ1ZmZlcnMgYW5kIGxlYXZlIHN1YnNlcXVlbnQgZmllbGRzXG4gICAgICAgICAqIHVuZGVmaW5lZCwgYXMgbG9uZyBhcyB0aGUgYnVmZmVyIGVuZHMgYXQgYSBmaWVsZCBib3VuZGFyeS5cbiAgICAgICAgICogRGVmYXVsdHMgdG8gYGZhbHNlYC4gKi9cbiAgICAgICAgdGhpcy5kZWNvZGVQcmVmaXhlcyA9ICEhZGVjb2RlUHJlZml4ZXM7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgaWYgKDAgPD0gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnNwID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmc3A7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNwYW4gKyBmc3A7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2luZGV0ZXJtaW5hdGUgc3BhbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ICs9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlY29kZVByZWZpeGVzXG4gICAgICAgICAgICAgICAgJiYgKGIubGVuZ3RoID09PSBvZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0uXG4gICAgICpcbiAgICAgKiBJZiBgc3JjYCBpcyBtaXNzaW5nIGEgcHJvcGVydHkgZm9yIGEgbWVtYmVyIHdpdGggYSBkZWZpbmVkIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaW9uIG9mIHRoZSBidWZmZXIgaXNcbiAgICAgKiBsZWZ0IHVubW9kaWZpZWQuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBmaXJzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgbGV0IGxhc3RPZmZzZXQgPSAwO1xuICAgICAgICBsZXQgbGFzdFdyb3RlID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgbGV0IHNwYW4gPSBmZC5zcGFuO1xuICAgICAgICAgICAgbGFzdFdyb3RlID0gKDAgPCBzcGFuKSA/IHNwYW4gOiAwO1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFzdFdyb3RlID0gZmQuZW5jb2RlKGZ2LCBiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFJlYWQgdGhlIGFzLWVuY29kZWQgc3Bhbiwgd2hpY2ggaXMgbm90IG5lY2Vzc2FyaWx5IHRoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2FtZSBhcyB3aGF0IHdlIHdyb3RlLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BhbiA9IGZkLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgICBvZmZzZXQgKz0gc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBVc2UgKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIGluc3RlYWQgb2Ygb2Zmc2V0IGJlY2F1c2UgdGhlIGxhc3RcbiAgICAgICAgICogaXRlbSBtYXkgaGF2ZSBoYWQgYSBkeW5hbWljIGxlbmd0aCBhbmQgd2UgZG9uJ3Qgd2FudCB0byBpbmNsdWRlXG4gICAgICAgICAqIHRoZSBwYWRkaW5nIGJldHdlZW4gaXQgYW5kIHRoZSBlbmQgb2YgdGhlIHNwYWNlIHJlc2VydmVkIGZvclxuICAgICAgICAgKiBpdC4gKi9cbiAgICAgICAgcmV0dXJuIChsYXN0T2Zmc2V0ICsgbGFzdFdyb3RlKSAtIGZpcnN0T2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZnJvbUFycmF5KHZhbHVlcykge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KVxuICAgICAgICAgICAgICAgICYmICgwIDwgdmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IHZhbHVlcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBsYXlvdXQgb2YgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIHRoZSBzdHJ1Y3R1cmUgbWVtYmVyIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7TGF5b3V0fSAtIHRoZSBsYXlvdXQgYXNzb2NpYXRlZCB3aXRoIGBwcm9wZXJ0eWAsIG9yXG4gICAgICogdW5kZWZpbmVkIGlmIHRoZXJlIGlzIG5vIHN1Y2ggcHJvcGVydHkuXG4gICAgICovXG4gICAgbGF5b3V0Rm9yKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBvZmZzZXQgb2YgYSBzdHJ1Y3R1cmUgbWVtYmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gdGhlIG9mZnNldCBpbiBieXRlcyB0byB0aGUgc3RhcnQgb2YgYHByb3BlcnR5YFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLCBvciB1bmRlZmluZWQgaWYgYHByb3BlcnR5YCBpcyBub3QgYSBmaWVsZFxuICAgICAqIHdpdGhpbiB0aGUgc3RydWN0dXJlLiAgSWYgdGhlIHByb3BlcnR5IGlzIGEgbWVtYmVyIGJ1dCBmb2xsb3dzIGFcbiAgICAgKiB2YXJpYWJsZS1sZW5ndGggc3RydWN0dXJlIG1lbWJlciBhIG5lZ2F0aXZlIG51bWJlciB3aWxsIGJlXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgb2Zmc2V0T2YocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKDAgPiBmZC5zcGFuKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgwIDw9IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIG9mZnNldCArPSBmZC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJ1Y3R1cmUgPSBTdHJ1Y3R1cmU7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IEFQSSBmb3Ige0BsaW5rIFVuaW9ufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjZGVjb2RlfGRlY29kZX0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICovXG5jbGFzcyBVbmlvbkRpc2NyaW1pbmF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdG8gYmUgdXNlZCB3aGVuIHRoZVxuICAgICAgICAgKiBkaXNjcmltaW5hdG9yIGlzIHJlZmVyZW5jZWQgaW4gaXNvbGF0aW9uIChnZW5lcmFsbHkgd2hlbiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVjb2RlfFVuaW9uIGRlY29kZX0gY2Fubm90IGRlbGVnYXRlIHRvIGEgc3BlY2lmaWNcbiAgICAgICAgICogdmFyaWFudCkuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZGVjb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3QgcmVmZXJlbmNlIHRoZSBidWZmZXIgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZSB0aHJvdWdoIG90aGVyIG1lYW5zLiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG4gICAgLyoqIEFuYWxvZyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxMYXlvdXQgZW5jb2RlfSBmb3IgdW5pb24gZGlzY3JpbWluYXRvcnMuXG4gICAgICpcbiAgICAgKiBUaGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBtZXRob2QgbmVlZCBub3Qgc3RvcmUgdGhlIHZhbHVlIGlmXG4gICAgICogdmFyaWFudCBpbmZvcm1hdGlvbiBpcyBtYWludGFpbmVkIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5pb25EaXNjcmltaW5hdG9yIGlzIGFic3RyYWN0Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbkRpc2NyaW1pbmF0b3IgPSBVbmlvbkRpc2NyaW1pbmF0b3I7XG4vKipcbiAqIEFuIG9iamVjdCB0aGF0IGNhbiBwcm92aWRlIGEge0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvciBBUEl9IGZvciB7QGxpbmsgVW5pb259IHVzaW5nIGFuXG4gKiB1bnNpZ25lZCBpbnRlZ3JhbCB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSBsb2NhdGVkIGVpdGhlciBpbnNpZGUgb3JcbiAqIG91dHNpZGUgdGhlIHVuaW9uLlxuICpcbiAqIEBwYXJhbSB7RXh0ZXJuYWxMYXlvdXR9IGxheW91dCAtIGluaXRpYWxpemVzIHtAbGlua1xuICogVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAgTXVzdCBzYXRpc2Z5IHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gRGVmYXVsdCBmb3Ige0BsaW5rXG4gKiBVbmlvbkRpc2NyaW1pbmF0b3IjcHJvcGVydHl8cHJvcGVydHl9LCBzdXBlcnNlZGluZyB0aGUgcHJvcGVydHlcbiAqIGZyb20gYGxheW91dGAsIGJ1dCBkZWZhdWx0aW5nIHRvIGB2YXJpYW50YCBpZiBuZWl0aGVyIGBwcm9wZXJ0eWBcbiAqIG5vciBsYXlvdXQgcHJvdmlkZSBhIHByb3BlcnR5IG5hbWUuXG4gKlxuICogQGF1Z21lbnRzIHtVbmlvbkRpc2NyaW1pbmF0b3J9XG4gKi9cbmNsYXNzIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciBleHRlbmRzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gICAgY29uc3RydWN0b3IobGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgobGF5b3V0IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgICAmJiBsYXlvdXQuaXNDb3VudCgpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHByb3BlcnR5IHx8IGxheW91dC5wcm9wZXJ0eSB8fCAndmFyaWFudCcpO1xuICAgICAgICAvKiogVGhlIHtAbGluayBFeHRlcm5hbExheW91dH0gdXNlZCB0byBhY2Nlc3MgdGhlIGRpc2NyaW1pbmF0b3JcbiAgICAgICAgICogdmFsdWUuICovXG4gICAgICAgIHRoaXMubGF5b3V0ID0gbGF5b3V0O1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUgZGVjb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIGVuY29kaW5nIHRvIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQpO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gVW5pb25MYXlvdXREaXNjcmltaW5hdG9yO1xuLyoqXG4gKiBSZXByZXNlbnQgYW55IG51bWJlciBvZiBzcGFuLWNvbXBhdGlibGUgbGF5b3V0cy5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnVuaW9ufHVuaW9ufVxuICpcbiAqIElmIHRoZSB1bmlvbiBoYXMgYSB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gdGhhdFxuICogbGF5b3V0IG11c3QgaGF2ZSBhIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uICBUaGUgc3BhblxuICogb2YgYSBmaXhlZC1zcGFuIHVuaW9uIGluY2x1ZGVzIGl0cyB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaWYgdGhlIHZhcmlhbnQgaXMgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBvZiB0aGUgdW5pb259LCBwbHVzIHRoZSBzcGFuXG4gKiBvZiBpdHMge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LlxuICpcbiAqIElmIHRoZSB1bmlvbiBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBsYXlvdXQgdGhlbiB0aGUgZW5jb2RlZCBzcGFuXG4gKiBvZiB0aGUgdW5pb24gZGVwZW5kcyBvbiB0aGUgZW5jb2RlZCBzcGFuIG9mIGl0cyB2YXJpYW50ICh3aGljaCBtYXlcbiAqIGJlIGZpeGVkIG9yIHZhcmlhYmxlKS5cbiAqXG4gKiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8VmFyaWFudCBsYXlvdXR9cyBhcmUgYWRkZWQgdGhyb3VnaFxuICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uICBJZiB0aGUgdW5pb24gaGFzIGEgZGVmYXVsdFxuICogbGF5b3V0LCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dFxuICogY29udGFpbmVkIGJ5IHRoZSB2YXJpYW50fSBtdXN0IG5vdCBleGNlZWQgdGhlIHNwYW4gb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0gKG1pbnVzIHRoZSBzcGFuIG9mIGEge0BsaW5rXG4gKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnxwcmVmaXggZGlzcmltaW5hdG9yfSwgaWYgdXNlZCkuICBUaGVcbiAqIHNwYW4gb2YgdGhlIHZhcmlhbnQgd2lsbCBlcXVhbCB0aGUgc3BhbiBvZiB0aGUgdW5pb24gaXRzZWxmLlxuICpcbiAqIFRoZSB2YXJpYW50IGZvciBhIGJ1ZmZlciBjYW4gb25seSBiZSBpZGVudGlmaWVkIGZyb20gdGhlIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0gKGluIHRoZSBjYXNlIG9mIHRoZSB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9KSwgb3IgYnkgdXNpbmcge0BsaW5rXG4gKiBVbmlvbiNnZXRWYXJpYW50fGdldFZhcmlhbnR9IGFuZCBleGFtaW5pbmcgdGhlIHJlc3VsdGluZyB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXR9IGluc3RhbmNlLlxuICpcbiAqIEEgdmFyaWFudCBjb21wYXRpYmxlIHdpdGggYSBKYXZhU2NyaXB0IG9iamVjdCBjYW4gYmUgaWRlbnRpZmllZFxuICogdXNpbmcge0BsaW5rIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gKlxuICogQHBhcmFtIHsoVW5pb25EaXNjcmltaW5hdG9yfEV4dGVybmFsTGF5b3V0fExheW91dCl9IGRpc2NyIC0gSG93IHRvXG4gKiBpZGVudGlmeSB0aGUgbGF5b3V0IHVzZWQgdG8gaW50ZXJwcmV0IHRoZSB1bmlvbiBjb250ZW50cy4gIFRoZVxuICogcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0sIGFuXG4gKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LCBvciB7QGxpbmsgVUludH0gKG9yIHtAbGlua1xuICogVUludEJFfSkuICBXaGVuIGEgbm9uLWV4dGVybmFsIGxheW91dCBlbGVtZW50IGlzIHBhc3NlZCB0aGUgbGF5b3V0XG4gKiBhcHBlYXJzIGF0IHRoZSBzdGFydCBvZiB0aGUgdW5pb24uICBJbiBhbGwgY2FzZXMgdGhlIChzeW50aGVzaXplZClcbiAqIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGluc3RhbmNlIGlzIHJlY29yZGVkIGFzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS5cbiAqXG4gKiBAcGFyYW0geyhMYXlvdXR8bnVsbCl9IGRlZmF1bHRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9LiAgSWYgYWJzZW50IGRlZmF1bHRzIHRvIGBudWxsYC5cbiAqIElmIGBudWxsYCB0aGVyZSBpcyBubyBkZWZhdWx0IGxheW91dDogdGhlIHVuaW9uIGhhcyBkYXRhLWRlcGVuZGVudFxuICogbGVuZ3RoIGFuZCBhdHRlbXB0cyB0byBkZWNvZGUgb3IgZW5jb2RlIHVucmVjb2duaXplZCB2YXJpYW50cyB3aWxsXG4gKiB0aHJvdyBhbiBleGNlcHRpb24uICBBIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIG11c3QgaGF2ZSBhXG4gKiBub24tbmVnYXRpdmUge0BsaW5rIExheW91dCNzcGFufHNwYW59LCBhbmQgaWYgaXQgbGFja3MgYSB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0TGF5b3V0fSB3aWxsIGJlIGEge0BsaW5rXG4gKiBMYXlvdXQjcmVwbGljYXRlfHJlcGxpY2F9IHdpdGggcHJvcGVydHkgYGNvbnRlbnRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVW5pb24gZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkge1xuICAgICAgICBsZXQgZGlzY3JpbWluYXRvcjtcbiAgICAgICAgaWYgKChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAoZGlzY3IgaW5zdGFuY2VvZiBVSW50QkUpKSB7XG4gICAgICAgICAgICBkaXNjcmltaW5hdG9yID0gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihuZXcgT2Zmc2V0TGF5b3V0KGRpc2NyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGRpc2NyIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpXG4gICAgICAgICAgICAmJiBkaXNjci5pc0NvdW50KCkpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGRpc2NyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGRpc2NyIGluc3RhbmNlb2YgVW5pb25EaXNjcmltaW5hdG9yKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGlzY3IgbXVzdCBiZSBhIFVuaW9uRGlzY3JpbWluYXRvciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBkaXNjcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBkZWZhdWx0TGF5b3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgobnVsbCA9PT0gZGVmYXVsdExheW91dClcbiAgICAgICAgICAgIHx8IChkZWZhdWx0TGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBiZSBudWxsIG9yIGEgTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG51bGwgIT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICgwID4gZGVmYXVsdExheW91dC5zcGFuKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkZWZhdWx0TGF5b3V0IG11c3QgaGF2ZSBjb25zdGFudCBzcGFuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkID09PSBkZWZhdWx0TGF5b3V0LnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQucmVwbGljYXRlKCdjb250ZW50Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogVGhlIHVuaW9uIHNwYW4gY2FuIGJlIGVzdGltYXRlZCBvbmx5IGlmIHRoZXJlJ3MgYSBkZWZhdWx0XG4gICAgICAgICAqIGxheW91dC4gIFRoZSB1bmlvbiBzcGFucyBpdHMgZGVmYXVsdCBsYXlvdXQsIHBsdXMgYW55IHByZWZpeFxuICAgICAgICAgKiB2YXJpYW50IGxheW91dC4gIEJ5IGNvbnN0cnVjdGlvbiBib3RoIGxheW91dHMsIGlmIHByZXNlbnQsIGhhdmVcbiAgICAgICAgICogbm9uLW5lZ2F0aXZlIHNwYW4uICovXG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmIChkZWZhdWx0TGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gZGVmYXVsdExheW91dC5zcGFuO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHNwYW4pICYmICgoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSBkaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBpbnRlcmZhY2UgZm9yIHRoZSBkaXNjcmltaW5hdG9yIHZhbHVlIGluIGlzb2xhdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBhIHtAbGluayBVbmlvbkRpc2NyaW1pbmF0b3J9IGVpdGhlciBwYXNzZWQgdG8gdGhlXG4gICAgICAgICAqIGNvbnN0cnVjdG9yIG9yIHN5bnRoZXNpemVkIGZyb20gdGhlIGBkaXNjcmAgY29uc3RydWN0b3JcbiAgICAgICAgICogYXJndW1lbnQuICB7QGxpbmtcbiAgICAgICAgICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8dXNlc1ByZWZpeERpc2NyaW1pbmF0b3J9IHdpbGwgYmVcbiAgICAgICAgICogYHRydWVgIGlmZiB0aGUgYGRpc2NyYCBwYXJhbWV0ZXIgd2FzIGEgbm9uLW9mZnNldCB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0fSBpbnN0YW5jZS4gKi9cbiAgICAgICAgdGhpcy5kaXNjcmltaW5hdG9yID0gZGlzY3JpbWluYXRvcjtcbiAgICAgICAgLyoqIGB0cnVlYCBpZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gaXMgdGhlXG4gICAgICAgICAqIGZpcnN0IGZpZWxkIGluIHRoZSB1bmlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYGZhbHNlYCB0aGUgZGlzY3JpbWluYXRvciBpcyBvYnRhaW5lZCBmcm9tIHNvbWV3aGVyZVxuICAgICAgICAgKiBlbHNlLiAqL1xuICAgICAgICB0aGlzLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yID0gKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSk7XG4gICAgICAgIC8qKiBUaGUgbGF5b3V0IGZvciBub24tZGlzY3JpbWluYXRvciBjb250ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZVxuICAgICAgICAgKiBkaXNjcmltaW5hdG9yIGlzIG5vdCByZWNvZ25pemVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGlzIHRoZSB2YWx1ZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLiAgSXQgaXNcbiAgICAgICAgICogc3RydWN0dXJhbGx5IGVxdWl2YWxlbnQgdG8gdGhlIHNlY29uZCBjb21wb25lbnQgb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2xheW91dHxsYXlvdXR9IGJ1dCBtYXkgaGF2ZSBhIGRpZmZlcmVudCBwcm9wZXJ0eVxuICAgICAgICAgKiBuYW1lLiAqL1xuICAgICAgICB0aGlzLmRlZmF1bHRMYXlvdXQgPSBkZWZhdWx0TGF5b3V0O1xuICAgICAgICAvKiogQSByZWdpc3RyeSBvZiBhbGxvd2VkIHZhcmlhbnRzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUga2V5cyBhcmUgdW5zaWduZWQgaW50ZWdlcnMgd2hpY2ggc2hvdWxkIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAgICAgKiB7QGxpbmsgVW5pb24uZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfS4gIFRoZSBwcm9wZXJ0eSB2YWx1ZVxuICAgICAgICAgKiBpcyB0aGUgY29ycmVzcG9uZGluZyB7QGxpbmsgVmFyaWFudExheW91dH0gaW5zdGFuY2VzIGFzc2lnbmVkXG4gICAgICAgICAqIHRvIHRoaXMgdW5pb24gYnkge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSByZWdpc3RyeSByZW1haW5zIG11dGFibGUgc28gdGhhdCB2YXJpYW50cyBjYW4gYmVcbiAgICAgICAgICoge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkZWR9IGF0IGFueSB0aW1lLiAgVXNlcnMgc2hvdWxkIG5vdFxuICAgICAgICAgKiBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuICovXG4gICAgICAgIHRoaXMucmVnaXN0cnkgPSB7fTtcbiAgICAgICAgLyogUHJpdmF0ZSB2YXJpYWJsZSB1c2VkIHdoZW4gaW52b2tpbmcgZ2V0U291cmNlVmFyaWFudCAqL1xuICAgICAgICBsZXQgYm91bmRHZXRTb3VyY2VWYXJpYW50ID0gdGhpcy5kZWZhdWx0R2V0U291cmNlVmFyaWFudC5iaW5kKHRoaXMpO1xuICAgICAgICAvKiogRnVuY3Rpb24gdG8gaW5mZXIgdGhlIHZhcmlhbnQgc2VsZWN0ZWQgYnkgYSBzb3VyY2Ugb2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBEZWZhdWx0cyB0byB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9IGJ1dCBtYXlcbiAgICAgICAgICogYmUgb3ZlcnJpZGRlbiB1c2luZyB7QGxpbmtcbiAgICAgICAgICogVW5pb24jY29uZmlnR2V0U291cmNlVmFyaWFudHxjb25maWdHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHNyYyAtIGFzIHdpdGgge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2RlZmF1bHRHZXRTb3VyY2VWYXJpYW50fGRlZmF1bHRHZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHJldHVybnMgeyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IFRoZSBkZWZhdWx0IHZhcmlhbnRcbiAgICAgICAgICogKGB1bmRlZmluZWRgKSBvciBmaXJzdCByZWdpc3RlcmVkIHZhcmlhbnQgdGhhdCB1c2VzIGEgcHJvcGVydHlcbiAgICAgICAgICogYXZhaWxhYmxlIGluIGBzcmNgLiAqL1xuICAgICAgICB0aGlzLmdldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICByZXR1cm4gYm91bmRHZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBvdmVycmlkZSB0aGUgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI2dldFNvdXJjZVZhcmlhbnR8Z2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZSB0aGlzIGlmIHRoZSBkZXNpcmVkIHZhcmlhbnQgY2Fubm90IGJlIGlkZW50aWZpZWQgdXNpbmcgdGhlXG4gICAgICAgICAqIGFsZ29yaXRobSBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgcHJvdmlkZWQgZnVuY3Rpb24gd2lsbCBiZSBpbnZva2VkIGJvdW5kIHRvIHRoaXNcbiAgICAgICAgICogVW5pb24gaW5zdGFuY2UsIHByb3ZpZGluZyBsb2NhbCBhY2Nlc3MgdG8ge0BsaW5rXG4gICAgICAgICAqIFVuaW9uI3JlZ2lzdHJ5fHJlZ2lzdHJ5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ3N2IC0gYSBmdW5jdGlvbiB0aGF0IGZvbGxvd3MgdGhlIEFQSSBvZlxuICAgICAgICAgKiB7QGxpbmsgVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LiAqL1xuICAgICAgICB0aGlzLmNvbmZpZ0dldFNvdXJjZVZhcmlhbnQgPSBmdW5jdGlvbiAoZ3N2KSB7XG4gICAgICAgICAgICBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSBnc3YuYmluZCh0aGlzKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogRGVmYXVsdCBsYXlvdXRzIGFsd2F5cyBoYXZlIG5vbi1uZWdhdGl2ZSBzcGFuLCBzbyB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAqIG9uZSBhbmQgd2UgaGF2ZSB0byByZWNvZ25pemUgdGhlIHZhcmlhbnQgd2hpY2ggd2lsbCBpbiB0dXJuXG4gICAgICAgICAqIGRldGVybWluZSB0aGUgc3Bhbi4gKi9cbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5nZXRWYXJpYW50KGIsIG9mZnNldCk7XG4gICAgICAgIGlmICghdmxvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlcm1pbmUgc3BhbiBmb3IgdW5yZWNvZ25pemVkIHZhcmlhbnQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmxvLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGluZmVyIGEgcmVnaXN0ZXJlZCBVbmlvbiB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBgc3JjYC5cbiAgICAgKlxuICAgICAqIFRoZSBmaXJzdCBzYXRpc2ZpZWQgcnVsZSBpbiB0aGUgZm9sbG93aW5nIHNlcXVlbmNlIGRlZmluZXMgdGhlXG4gICAgICogcmV0dXJuIHZhbHVlOlxuICAgICAqICogSWYgYHNyY2AgaGFzIHByb3BlcnRpZXMgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IgYW5kXG4gICAgICogICB0aGUgZGVmYXVsdCBsYXlvdXQsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkIHJlZ2FyZGxlc3Mgb2YgdGhlXG4gICAgICogICB2YWx1ZSBvZiB0aGUgZGlzY3JpbWluYXRvciBwcm9wZXJ0eSAodGhpcyBlbnN1cmVzIHRoZSBkZWZhdWx0XG4gICAgICogICBsYXlvdXQgd2lsbCBiZSB1c2VkKTtcbiAgICAgKiAqIElmIGBzcmNgIGhhcyBhIHByb3BlcnR5IG1hdGNoaW5nIHRoZSBVbmlvbiBkaXNjcmltaW5hdG9yLCB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIGlkZW50aWZpZXMgYSByZWdpc3RlcmVkIHZhcmlhbnQsIGFuZFxuICAgICAqICAgZWl0aGVyIChhKSB0aGUgdmFyaWFudCBoYXMgbm8gbGF5b3V0LCBvciAoYikgYHNyY2AgaGFzIHRoZVxuICAgICAqICAgdmFyaWFudCdzIHByb3BlcnR5LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZVxuICAgICAqICAgc291cmNlIHNhdGlzZmllcyB0aGUgY29uc3RyYWludHMgb2YgdGhlIHZhcmlhbnQgaXQgaWRlbnRpZmllcyk7XG4gICAgICogKiBJZiBgc3JjYCBkb2VzIG5vdCBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uXG4gICAgICogICBkaXNjcmltaW5hdG9yLCBidXQgZG9lcyBoYXZlIGEgcHJvcGVydHkgbWF0Y2hpbmcgYSByZWdpc3RlcmVkXG4gICAgICogICB2YXJpYW50LCB0aGVuIHRoZSB2YXJpYW50IGlzIHJldHVybmVkIChiZWNhdXNlIHRoZSBzb3VyY2VcbiAgICAgKiAgIG1hdGNoZXMgYSB2YXJpYW50IHdpdGhvdXQgYW4gZXhwbGljaXQgY29uZmxpY3QpO1xuICAgICAqICogQW4gZXJyb3IgaXMgdGhyb3duIChiZWNhdXNlIHdlIGVpdGhlciBjYW4ndCBpZGVudGlmeSBhIHZhcmlhbnQsXG4gICAgICogICBvciB3ZSB3ZXJlIGV4cGxpY2l0bHkgdG9sZCB0aGUgdmFyaWFudCBidXQgY2FuJ3Qgc2F0aXNmeSBpdCkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYW4gb2JqZWN0IHByZXN1bWVkIHRvIGJlIGNvbXBhdGlibGUgd2l0aFxuICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSBVbmlvbi5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh1bmRlZmluZWR8VmFyaWFudExheW91dCl9IC0gYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7RXJyb3J9IC0gaWYgYHNyY2AgY2Fubm90IGJlIGFzc29jaWF0ZWQgd2l0aCBhIGRlZmF1bHQgb3JcbiAgICAgKiByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICovXG4gICAgZGVmYXVsdEdldFNvdXJjZVZhcmlhbnQoc3JjKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHkpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kZWZhdWx0TGF5b3V0ICYmIHRoaXMuZGVmYXVsdExheW91dC5wcm9wZXJ0eVxuICAgICAgICAgICAgICAgICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMuZGVmYXVsdExheW91dC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVtzcmNbdGhpcy5kaXNjcmltaW5hdG9yLnByb3BlcnR5XV07XG4gICAgICAgICAgICBpZiAodmxvXG4gICAgICAgICAgICAgICAgJiYgKCghdmxvLmxheW91dClcbiAgICAgICAgICAgICAgICAgICAgfHwgKHZsby5wcm9wZXJ0eSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB2bG8ucHJvcGVydHkpKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5yZWdpc3RyeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZsbyA9IHRoaXMucmVnaXN0cnlbdGFnXTtcbiAgICAgICAgICAgICAgICBpZiAodmxvLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHZsby5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZsbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd1bmFibGUgdG8gaW5mZXIgc3JjIHZhcmlhbnQnKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgVW5pb259LlxuICAgICAqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgaXMge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8cmVnaXN0ZXJlZH0gdGhlIHJldHVyblxuICAgICAqIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIHRoYXQgdmFyaWFudCwgd2l0aCBubyBleHBsaWNpdFxuICAgICAqIGRpc2NyaW1pbmF0b3IuICBPdGhlcndpc2UgdGhlIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRcbiAgICAgKiBsYXlvdXR9IGlzIHVzZWQgdG8gZGVjb2RlIHRoZSBjb250ZW50LiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBkZXN0O1xuICAgICAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgIGNvbnN0IGRpc2NyID0gZGxvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICBjb25zdCBjbG8gPSB0aGlzLnJlZ2lzdHJ5W2Rpc2NyXTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gY2xvKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0TGF5b3V0ID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gZGxvLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgICAgICBkZXN0W2Rsby5wcm9wZXJ0eV0gPSBkaXNjcjtcbiAgICAgICAgICAgIC8vIGRlZmF1bHRMYXlvdXQucHJvcGVydHkgY2FuIGJlIHVuZGVmaW5lZCwgYnV0IHRoaXMgaXMgYWxsb3dlZCBieSBidWZmZXItbGF5b3V0XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgZGVzdFtkZWZhdWx0TGF5b3V0LnByb3BlcnR5XSA9IGRlZmF1bHRMYXlvdXQuZGVjb2RlKGIsIG9mZnNldCArIGNvbnRlbnRPZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVzdCA9IGNsby5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgVW5pb259LlxuICAgICAqXG4gICAgICogVGhpcyBBUEkgYXNzdW1lcyB0aGUgYHNyY2Agb2JqZWN0IGlzIGNvbnNpc3RlbnQgd2l0aCB0aGUgdW5pb24nc1xuICAgICAqIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fS4gIFRvIGVuY29kZSB2YXJpYW50c1xuICAgICAqIHVzZSB0aGUgYXBwcm9wcmlhdGUgdmFyaWFudC1zcGVjaWZpYyB7QGxpbmsgVmFyaWFudExheW91dCNlbmNvZGV9XG4gICAgICogbWV0aG9kLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgdmxvID0gdGhpcy5nZXRTb3VyY2VWYXJpYW50KHNyYyk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHZsbykge1xuICAgICAgICAgICAgY29uc3QgZGxvID0gdGhpcy5kaXNjcmltaW5hdG9yO1xuICAgICAgICAgICAgLy8gdGhpcy5kZWZhdWx0TGF5b3V0IGlzIG5vdCB1bmRlZmluZWQgd2hlbiB2bG8gaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgY29uc3QgY2xvID0gdGhpcy5kZWZhdWx0TGF5b3V0O1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICAgICAgaWYgKHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gZGxvLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGxvLmVuY29kZShzcmNbZGxvLnByb3BlcnR5XSwgYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8vIGNsby5wcm9wZXJ0eSBpcyBub3QgdW5kZWZpbmVkIHdoZW4gdmxvIGlzIHVuZGVmaW5lZFxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIHJldHVybiBjb250ZW50T2Zmc2V0ICsgY2xvLmVuY29kZShzcmNbY2xvLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZsby5lbmNvZGUoc3JjLCBiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogUmVnaXN0ZXIgYSBuZXcgdmFyaWFudCBzdHJ1Y3R1cmUgd2l0aGluIGEgdW5pb24uICBUaGUgbmV3bHlcbiAgICAgKiBjcmVhdGVkIHZhcmlhbnQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I3ZhcmlhbnR8dmFyaWFudH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1ZhcmlhbnRMYXlvdXR9ICovXG4gICAgYWRkVmFyaWFudCh2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IHJ2ID0gbmV3IFZhcmlhbnRMYXlvdXQodGhpcywgdmFyaWFudCwgbGF5b3V0LCBwcm9wZXJ0eSk7XG4gICAgICAgIHRoaXMucmVnaXN0cnlbdmFyaWFudF0gPSBydjtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYSByZWdpc3RlcmVkIHZhcmlhbnQuXG4gICAgICpcbiAgICAgKiBJZiBgdmJgIGRvZXMgbm90IHByb2R1Y2UgYSByZWdpc3RlcmVkIHZhcmlhbnQgdGhlIGZ1bmN0aW9uIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7KE51bWJlcnxVaW50OEFycmF5KX0gdmIgLSBlaXRoZXIgdGhlIHZhcmlhbnQgbnVtYmVyLCBvciBhXG4gICAgICogYnVmZmVyIGZyb20gd2hpY2ggdGhlIGRpc2NyaW1pbmF0b3IgaXMgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgLSBvZmZzZXQgaW50byBgdmJgIGZvciB0aGUgc3RhcnQgb2YgdGhlXG4gICAgICogdW5pb24uICBVc2VkIG9ubHkgd2hlbiBgdmJgIGlzIGFuIGluc3RhbmNlIG9mIHtVaW50OEFycmF5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyh7VmFyaWFudExheW91dH18dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KHZiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCB2YXJpYW50O1xuICAgICAgICBpZiAodmIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgICAgICB2YXJpYW50ID0gdGhpcy5kaXNjcmltaW5hdG9yLmRlY29kZSh2Yiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSB2YjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZWdpc3RyeVt2YXJpYW50XTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uID0gVW5pb247XG4vKipcbiAqIFJlcHJlc2VudCBhIHNwZWNpZmljIHZhcmlhbnQgd2l0aGluIGEgY29udGFpbmluZyB1bmlvbi5cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSB2YXJpYW50IG1heSBpbmNsdWRlXG4gKiB0aGUgc3BhbiBvZiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gdXNlZCB0b1xuICogaWRlbnRpZnkgaXQsIGJ1dCB2YWx1ZXMgcmVhZCBhbmQgd3JpdHRlbiB1c2luZyB0aGUgdmFyaWFudCBzdHJpY3RseVxuICogY29uZm9ybSB0byB0aGUgY29udGVudCBvZiB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAqXG4gKiAqKk5PVEUqKiBVc2VyIGNvZGUgc2hvdWxkIG5vdCBpbnZva2UgdGhpcyBjb25zdHJ1Y3RvciBkaXJlY3RseS4gIFVzZVxuICogdGhlIHVuaW9uIHtAbGluayBVbmlvbiNhZGRWYXJpYW50fGFkZFZhcmlhbnR9IGhlbHBlciBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtVbmlvbn0gdW5pb24gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I3VuaW9ufHVuaW9ufS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdmFyaWFudCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gW2xheW91dF0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAgSWYgYWJzZW50IHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAqIGRhdGEuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgVW5saWtlIG1hbnkgb3RoZXIgbGF5b3V0cywgdmFyaWFudFxuICogbGF5b3V0cyBub3JtYWxseSBpbmNsdWRlIGEgcHJvcGVydHkgbmFtZSBzbyB0aGV5IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB3aXRoaW4gdGhlaXIgY29udGFpbmluZyB7QGxpbmsgVW5pb259LiAgVGhlIHByb3BlcnR5IGlkZW50aWZpZXIgbWF5XG4gKiBiZSBhYnNlbnQgb25seSBpZiBgbGF5b3V0YCBpcyBpcyBhYnNlbnQuXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFZhcmlhbnRMYXlvdXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHVuaW9uLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKHVuaW9uIGluc3RhbmNlb2YgVW5pb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd1bmlvbiBtdXN0IGJlIGEgVW5pb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKHZhcmlhbnQpKSB8fCAoMCA+IHZhcmlhbnQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgYmUgYSAobm9uLW5lZ2F0aXZlKSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgnc3RyaW5nJyA9PT0gdHlwZW9mIGxheW91dClcbiAgICAgICAgICAgICYmICh1bmRlZmluZWQgPT09IHByb3BlcnR5KSkge1xuICAgICAgICAgICAgcHJvcGVydHkgPSBsYXlvdXQ7XG4gICAgICAgICAgICBsYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXlvdXQpIHtcbiAgICAgICAgICAgIGlmICghKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhIExheW91dCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChudWxsICE9PSB1bmlvbi5kZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICAgICAgICYmICgwIDw9IGxheW91dC5zcGFuKVxuICAgICAgICAgICAgICAgICYmIChsYXlvdXQuc3BhbiA+IHVuaW9uLmRlZmF1bHRMYXlvdXQuc3BhbikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgc3BhbiBleGNlZWRzIHNwYW4gb2YgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YXJpYW50IG11c3QgaGF2ZSBhIFN0cmluZyBwcm9wZXJ0eScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gdW5pb24uc3BhbjtcbiAgICAgICAgaWYgKDAgPiB1bmlvbi5zcGFuKSB7XG4gICAgICAgICAgICBzcGFuID0gbGF5b3V0ID8gbGF5b3V0LnNwYW4gOiAwO1xuICAgICAgICAgICAgaWYgKCgwIDw9IHNwYW4pICYmIHVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICAgICAgc3BhbiArPSB1bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgVW5pb259IHRvIHdoaWNoIHRoaXMgdmFyaWFudCBiZWxvbmdzLiAqL1xuICAgICAgICB0aGlzLnVuaW9uID0gdW5pb247XG4gICAgICAgIC8qKiBUaGUgdW5zaWduZWQgaW50ZWdyYWwgdmFsdWUgaWRlbnRpZnlpbmcgdGhpcyB2YXJpYW50IHdpdGhpblxuICAgICAgICAgKiB0aGUge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgICAgICogdW5pb24uICovXG4gICAgICAgIHRoaXMudmFyaWFudCA9IHZhcmlhbnQ7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIExheW91dH0gdG8gYmUgdXNlZCB3aGVuIHJlYWRpbmcvd3JpdGluZyB0aGVcbiAgICAgICAgICogbm9uLWRpc2NyaW1pbmF0b3IgcGFydCBvZiB0aGUge0BsaW5rXG4gICAgICAgICAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LiAgSWYgYG51bGxgIHRoZSB2YXJpYW50IGNhcnJpZXMgbm9cbiAgICAgICAgICogZGF0YS4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQgfHwgbnVsbDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIC8qIFdpbGwgYmUgZXF1YWwgdG8gdGhlIGNvbnRhaW5pbmcgdW5pb24gc3BhbiBpZiB0aGF0IGlzIG5vdFxuICAgICAgICAgICAgICogdmFyaWFibGUuICovXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgLyogU3BhbiBpcyBkZWZpbmVkIHNvbGVseSBieSB0aGUgdmFyaWFudCAoYW5kIHByZWZpeCBkaXNjcmltaW5hdG9yKSAqL1xuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMubWFrZURlc3RpbmF0aW9uT2JqZWN0KCk7XG4gICAgICAgIGlmICh0aGlzICE9PSB0aGlzLnVuaW9uLmdldFZhcmlhbnQoYiwgb2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd2YXJpYW50IG1pc21hdGNoJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYXlvdXQpIHtcbiAgICAgICAgICAgIGRlc3RbdGhpcy5wcm9wZXJ0eV0gPSB0aGlzLmxheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IucHJvcGVydHldID0gdGhpcy52YXJpYW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dFxuICAgICAgICAgICAgJiYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCB0aGlzLnByb3BlcnR5KSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbGFja3MgcHJvcGVydHkgJyArIHRoaXMucHJvcGVydHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5lbmNvZGUodGhpcy52YXJpYW50LCBiLCBvZmZzZXQpO1xuICAgICAgICBsZXQgc3BhbiA9IGNvbnRlbnRPZmZzZXQ7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgdGhpcy5sYXlvdXQuZW5jb2RlKHNyY1t0aGlzLnByb3BlcnR5XSwgYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgICAgICBzcGFuICs9IHRoaXMubGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoKDAgPD0gdGhpcy51bmlvbi5zcGFuKVxuICAgICAgICAgICAgICAgICYmIChzcGFuID4gdGhpcy51bmlvbi5zcGFuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZW5jb2RlZCB2YXJpYW50IG92ZXJydW5zIGNvbnRhaW5pbmcgdW5pb24nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIERlbGVnYXRlIHtAbGluayBMYXlvdXQjZnJvbUFycmF5fGZyb21BcnJheX0gdG8ge0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmZyb21BcnJheSh2YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5WYXJpYW50TGF5b3V0ID0gVmFyaWFudExheW91dDtcbi8qKiBKYXZhU2NyaXB0IGNob3NlIHRvIGRlZmluZSBiaXR3aXNlIG9wZXJhdGlvbnMgYXMgb3BlcmF0aW5nIG9uXG4gKiBzaWduZWQgMzItYml0IHZhbHVlcyBpbiAyJ3MgY29tcGxlbWVudCBmb3JtLCBtZWFuaW5nIGFueSBpbnRlZ2VyXG4gKiB3aXRoIGJpdCAzMSBzZXQgaXMgZ29pbmcgdG8gbG9vayBuZWdhdGl2ZS4gIEZvciByaWdodCBzaGlmdHMgdGhhdCdzXG4gKiBub3QgYSBwcm9ibGVtLCBiZWNhdXNlIGA+Pj5gIGlzIGEgbG9naWNhbCBzaGlmdCwgYnV0IGZvciBldmVyeVxuICogb3RoZXIgYml0d2lzZSBvcGVyYXRvciB3ZSBoYXZlIHRvIGNvbXBlbnNhdGUgZm9yIHBvc3NpYmxlIG5lZ2F0aXZlXG4gKiByZXN1bHRzLiAqL1xuZnVuY3Rpb24gZml4Qml0d2lzZVJlc3VsdCh2KSB7XG4gICAgaWYgKDAgPiB2KSB7XG4gICAgICAgIHYgKz0gMHgxMDAwMDAwMDA7XG4gICAgfVxuICAgIHJldHVybiB2O1xufVxuLyoqXG4gKiBDb250YWluIGEgc2VxdWVuY2Ugb2YgYml0IGZpZWxkcyBhcyBhbiB1bnNpZ25lZCBpbnRlZ2VyLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xiaXRzfVxuICpcbiAqIFRoaXMgaXMgYSBjb250YWluZXIgZWxlbWVudDsgd2l0aGluIGl0IHRoZXJlIGFyZSB7QGxpbmsgQml0RmllbGR9XG4gKiBpbnN0YW5jZXMgdGhhdCBwcm92aWRlIHRoZSBleHRyYWN0ZWQgcHJvcGVydGllcy4gIFRoZSBjb250YWluZXJcbiAqIHNpbXBseSBkZWZpbmVzIHRoZSBhZ2dyZWdhdGUgcmVwcmVzZW50YXRpb24gYW5kIGl0cyBiaXQgb3JkZXJpbmcuXG4gKiBUaGUgcmVwcmVzZW50YXRpb24gaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgcHJvcGVydGllcyB3aXRoIG51bWVyaWNcbiAqIG9yIHtAbGluayBCb29sZWFufSB2YWx1ZXMuXG4gKlxuICoge0BsaW5rIEJpdEZpZWxkfXMgYXJlIGFkZGVkIHdpdGggdGhlIHtAbGlua1xuICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBhbmQge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkQm9vbGVhbnxhZGRCb29sZWFufSBtZXRob2RzLlxuXG4gKiBAcGFyYW0ge0xheW91dH0gd29yZCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSN3b3JkfHdvcmR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGFuIGluc3RhbmNlIG9mXG4gKiB7QGxpbmsgVUludH0gKG9yIHtAbGluayBVSW50QkV9KSB0aGF0IGlzIG5vIG1vcmUgdGhhbiA0IGJ5dGVzIHdpZGUuXG4gKlxuICogQHBhcmFtIHtib29sfSBbbXNiXSAtIGB0cnVlYCBpZiB0aGUgYml0IG51bWJlcmluZyBzdGFydHMgYXQgdGhlXG4gKiBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkOyBgZmFsc2VgIChkZWZhdWx0KSBpZlxuICogaXQgc3RhcnRzIGF0IHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGNvbnRhaW5pbmcgd29yZC4gIElmXG4gKiB0aGUgcGFyYW1ldGVyIGF0IHRoaXMgcG9zaXRpb24gaXMgYSBzdHJpbmcgYW5kIGBwcm9wZXJ0eWAgaXNcbiAqIGB1bmRlZmluZWRgIHRoZSB2YWx1ZSBvZiB0aGlzIGFyZ3VtZW50IHdpbGwgaW5zdGVhZCBiZSB1c2VkIGFzIHRoZVxuICogdmFsdWUgb2YgYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEJpdFN0cnVjdHVyZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Iod29yZCwgbXNiLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgod29yZCBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICB8fCAod29yZCBpbnN0YW5jZW9mIFVJbnRCRSkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCd3b3JkIG11c3QgYmUgYSBVSW50IG9yIFVJbnRCRSBsYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbXNiKVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG1zYjtcbiAgICAgICAgICAgIG1zYiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICg0IDwgd29yZC5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd29yZCBjYW5ub3QgZXhjZWVkIDMyIGJpdHMnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih3b3JkLnNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgdXNlZCBmb3IgdGhlIHBhY2tlZCB2YWx1ZS4gIHtAbGluayBCaXRGaWVsZH1cbiAgICAgICAgICogaW5zdGFuY2VzIGFyZSBwYWNrZWQgc2VxdWVudGlhbGx5IGRlcGVuZGluZyBvbiB7QGxpbmtcbiAgICAgICAgICogQml0U3RydWN0dXJlI21zYnxtc2J9LiAqL1xuICAgICAgICB0aGlzLndvcmQgPSB3b3JkO1xuICAgICAgICAvKiogV2hldGhlciB0aGUgYml0IHNlcXVlbmNlcyBhcmUgcGFja2VkIHN0YXJ0aW5nIGF0IHRoZSBtb3N0XG4gICAgICAgICAqIHNpZ25pZmljYW50IGJpdCBncm93aW5nIGRvd24gKGB0cnVlYCksIG9yIHRoZSBsZWFzdCBzaWduaWZpY2FudFxuICAgICAgICAgKiBiaXQgZ3Jvd2luZyB1cCAoYGZhbHNlYCkuXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFJlZ2FyZGxlc3Mgb2YgdGhpcyB2YWx1ZSwgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZlxuICAgICAgICAgKiBhbnkge0BsaW5rIEJpdEZpZWxkfSB2YWx1ZSBpcyB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZVxuICAgICAgICAgKiBjb3JyZXNwb25kaW5nIHNlY3Rpb24gb2YgdGhlIHBhY2tlZCB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5tc2IgPSAhIW1zYjtcbiAgICAgICAgLyoqIFRoZSBzZXF1ZW5jZSBvZiB7QGxpbmsgQml0RmllbGR9IGxheW91dHMgdGhhdCBjb21wcmlzZSB0aGVcbiAgICAgICAgICogcGFja2VkIHN0cnVjdHVyZS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIGFycmF5IHJlbWFpbnMgbXV0YWJsZSB0byBhbGxvdyBmaWVsZHMgdG8gYmUge0BsaW5rXG4gICAgICAgICAqIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRlZH0gYWZ0ZXIgY29uc3RydWN0aW9uLiAgVXNlcnMgc2hvdWxkXG4gICAgICAgICAqIG5vdCBtYW5pcHVsYXRlIHRoZSBjb250ZW50IG9mIHRoaXMgcHJvcGVydHkuKi9cbiAgICAgICAgdGhpcy5maWVsZHMgPSBbXTtcbiAgICAgICAgLyogU3RvcmFnZSBmb3IgdGhlIHZhbHVlLiAgQ2FwdHVyZSBhIHZhcmlhYmxlIGluc3RlYWQgb2YgdXNpbmcgYW5cbiAgICAgICAgICogaW5zdGFuY2UgcHJvcGVydHkgYmVjYXVzZSB3ZSBkb24ndCB3YW50IGFueXRoaW5nIHRvIGNoYW5nZSB0aGVcbiAgICAgICAgICogdmFsdWUgd2l0aG91dCBnb2luZyB0aHJvdWdoIHRoZSBtdXRhdG9yLiAqL1xuICAgICAgICBsZXQgdmFsdWUgPSAwO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSA9IGZ1bmN0aW9uICh2KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGFja2VkR2V0VmFsdWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZXN0W2ZkLnByb3BlcnR5XSA9IGZkLmRlY29kZShiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIHBhY2tlZFxuICAgICAqIHZhbHVlIGlzIGxlZnQgdW5tb2RpZmllZC4gIFVudXNlZCBiaXRzIGFyZSBhbHNvIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy53b3JkLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB0aGlzLl9wYWNrZWRTZXRWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZkLnByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZnYgPSBzcmNbZmQucHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmICh1bmRlZmluZWQgIT09IGZ2KSB7XG4gICAgICAgICAgICAgICAgICAgIGZkLmVuY29kZShmdik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLndvcmQuZW5jb2RlKHRoaXMuX3BhY2tlZEdldFZhbHVlKCksIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyBiaXRmaWVsZCB3aXRoIGEgY29udGFpbmluZyBiaXQgc3RydWN0dXJlLiAgVGhlXG4gICAgICogcmVzdWx0aW5nIGJpdGZpZWxkIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAqL1xuICAgIGFkZEZpZWxkKGJpdHMsIHByb3BlcnR5KSB7XG4gICAgICAgIGNvbnN0IGJmID0gbmV3IEJpdEZpZWxkKHRoaXMsIGJpdHMsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgLyoqIEFzIHdpdGgge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gZm9yIHNpbmdsZS1iaXRcbiAgICAgKiBmaWVsZHMgd2l0aCBgYm9vbGVhbmAgdmFsdWUgcmVwcmVzZW50YXRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59ICovXG4gICAgLy8gYEJvb2xlYW5gIGNvbmZsaWN0cyB3aXRoIHRoZSBuYXRpdmUgcHJpbWl0aXZlIHR5cGVcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10eXBlc1xuICAgIGFkZEJvb2xlYW4ocHJvcGVydHkpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBteSBCb29sZWFuLCBub3QgdGhlIEphdmFzY3JpcHQgb25lLlxuICAgICAgICBjb25zdCBiZiA9IG5ldyBCb29sZWFuKHRoaXMsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5maWVsZHMucHVzaChiZik7XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFjY2VzcyB0byB0aGUgYml0IGZpZWxkIGZvciBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIGJpdCBmaWVsZCBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0JpdEZpZWxkfSAtIHRoZSBmaWVsZCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmaWVsZEZvcihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoZmQucHJvcGVydHkgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5CaXRTdHJ1Y3R1cmUgPSBCaXRTdHJ1Y3R1cmU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNlcXVlbmNlIG9mIGJpdHMgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0uXG4gKlxuICogQWxsIGJpdCBmaWVsZCB2YWx1ZXMgYXJlIHJlcHJlc2VudGVkIGFzIHVuc2lnbmVkIGludGVnZXJzLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRGaWVsZHxhZGRGaWVsZH0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogKipOT1RFKiogQml0RmllbGQgaW5zdGFuY2VzIGFyZSBub3QgaW5zdGFuY2VzIG9mIHtAbGluayBMYXlvdXR9XG4gKiBzaW5jZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gbWVhc3VyZXMgOC1iaXQgdW5pdHMuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBiaXRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBCaXRGaWVsZCNiaXRzfGJpdHN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqL1xuY2xhc3MgQml0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgYml0cywgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEoY29udGFpbmVyIGluc3RhbmNlb2YgQml0U3RydWN0dXJlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29udGFpbmVyIG11c3QgYmUgYSBCaXRTdHJ1Y3R1cmUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGJpdHMpKSB8fCAoMCA+PSBiaXRzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYml0cyBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3RhbEJpdHMgPSA4ICogY29udGFpbmVyLnNwYW47XG4gICAgICAgIGNvbnN0IHVzZWRCaXRzID0gY29udGFpbmVyLmZpZWxkcy5yZWR1Y2UoKHN1bSwgZmQpID0+IHN1bSArIGZkLmJpdHMsIDApO1xuICAgICAgICBpZiAoKGJpdHMgKyB1c2VkQml0cykgPiB0b3RhbEJpdHMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYml0cyB0b28gbG9uZyBmb3Igc3BhbiByZW1haW5kZXIgKCdcbiAgICAgICAgICAgICAgICArICh0b3RhbEJpdHMgLSB1c2VkQml0cykgKyAnIG9mICdcbiAgICAgICAgICAgICAgICArIHRvdGFsQml0cyArICcgcmVtYWluKScpO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIEJpdFN0cnVjdHVyZX0gaW5zdGFuY2UgdG8gd2hpY2ggdGhpcyBiaXQgZmllbGRcbiAgICAgICAgICogYmVsb25ncy4gKi9cbiAgICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIC8qKiBUaGUgc3BhbiBvZiB0aGlzIHZhbHVlIGluIGJpdHMuICovXG4gICAgICAgIHRoaXMuYml0cyA9IGJpdHM7XG4gICAgICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gYml0cyBpc29sYXRpbmcgdmFsdWUgYml0c1xuICAgICAgICAgKiB0aGF0IGZpdCB3aXRoaW4gdGhlIGZpZWxkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGF0IGlzLCBpdCBtYXNrcyBhIHZhbHVlIHRoYXQgaGFzIG5vdCB5ZXQgYmVlbiBzaGlmdGVkIGludG9cbiAgICAgICAgICogcG9zaXRpb24gd2l0aGluIGl0cyBjb250YWluaW5nIHBhY2tlZCBpbnRlZ2VyLiAqL1xuICAgICAgICB0aGlzLnZhbHVlTWFzayA9ICgxIDw8IGJpdHMpIC0gMTtcbiAgICAgICAgaWYgKDMyID09PSBiaXRzKSB7IC8vIHNoaWZ0ZWQgdmFsdWUgb3V0IG9mIHJhbmdlXG4gICAgICAgICAgICB0aGlzLnZhbHVlTWFzayA9IDB4RkZGRkZGRkY7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSBvZmZzZXQgb2YgdGhlIHZhbHVlIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWRcbiAgICAgICAgICogaW50ZWdlci4gIFRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIHBhY2tlZCB2YWx1ZSBpcyBhdFxuICAgICAgICAgKiBvZmZzZXQgemVybywgcmVnYXJkbGVzcyBvZiBiaXQgb3JkZXJpbmcgdXNlZC4gKi9cbiAgICAgICAgdGhpcy5zdGFydCA9IHVzZWRCaXRzO1xuICAgICAgICBpZiAodGhpcy5jb250YWluZXIubXNiKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0ID0gdG90YWxCaXRzIC0gdXNlZEJpdHMgLSBiaXRzO1xuICAgICAgICB9XG4gICAgICAgIC8qKiBBIG1hc2sgb2Yge0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30gaXNvbGF0aW5nIHRoZSBmaWVsZCB2YWx1ZVxuICAgICAgICAgKiB3aXRoaW4gdGhlIGNvbnRhaW5pbmcgcGFja2VkIHVuc2lnbmVkIGludGVnZXIuICovXG4gICAgICAgIHRoaXMud29yZE1hc2sgPSBmaXhCaXR3aXNlUmVzdWx0KHRoaXMudmFsdWVNYXNrIDw8IHRoaXMuc3RhcnQpO1xuICAgICAgICAvKiogVGhlIHByb3BlcnR5IG5hbWUgdXNlZCB3aGVuIHRoaXMgYml0ZmllbGQgaXMgcmVwcmVzZW50ZWQgaW4gYW5cbiAgICAgICAgICogT2JqZWN0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJbnRlbmRlZCB0byBiZSBmdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I3Byb3BlcnR5fS5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgbGVmdCB1bmRlZmluZWQgdGhlIGNvcnJlc3BvbmRpbmcgc3BhbiBvZiBiaXRzIHdpbGwgYmVcbiAgICAgICAgICogdHJlYXRlZCBhcyBwYWRkaW5nOiBpdCB3aWxsIG5vdCBiZSBtdXRhdGVkIGJ5IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gbm9yIHJlcHJlc2VudGVkIGFzIGEgcHJvcGVydHkgaW4gdGhlXG4gICAgICAgICAqIGRlY29kZWQgT2JqZWN0LiAqL1xuICAgICAgICB0aGlzLnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIHRoaXMud29yZE1hc2spO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHdvcmRWYWx1ZSA+Pj4gdGhpcy5zdGFydDtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKiogU3RvcmUgYSB2YWx1ZSBpbnRvIHRoZSBjb3JyZXNwb25kaW5nIHN1YnNlcXVlbmNlIG9mIHRoZSBjb250YWluaW5nXG4gICAgICogYml0IGZpZWxkLlxuICAgICAqXG4gICAgICogKipOT1RFKiogVGhpcyBpcyBub3QgYSBzcGVjaWFsaXphdGlvbiBvZiB7QGxpbmtcbiAgICAgKiBMYXlvdXQjZW5jb2RlfExheW91dC5lbmNvZGV9IGFuZCB0aGVyZSBpcyBubyByZXR1cm4gdmFsdWUuICovXG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICgnbnVtYmVyJyAhPT0gdHlwZW9mIHZhbHVlXG4gICAgICAgICAgICB8fCAhTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSlcbiAgICAgICAgICAgIHx8ICh2YWx1ZSAhPT0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSAmIHRoaXMudmFsdWVNYXNrKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQml0RmllbGQuZW5jb2RlJywgdGhpcylcbiAgICAgICAgICAgICAgICArICcgdmFsdWUgbXVzdCBiZSBpbnRlZ2VyIG5vdCBleGNlZWRpbmcgJyArIHRoaXMudmFsdWVNYXNrKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB3b3JkID0gdGhpcy5jb250YWluZXIuX3BhY2tlZEdldFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHdvcmRWYWx1ZSA9IGZpeEJpdHdpc2VSZXN1bHQodmFsdWUgPDwgdGhpcy5zdGFydCk7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLl9wYWNrZWRTZXRWYWx1ZShmaXhCaXR3aXNlUmVzdWx0KHdvcmQgJiB+dGhpcy53b3JkTWFzaylcbiAgICAgICAgICAgIHwgd29yZFZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkJpdEZpZWxkID0gQml0RmllbGQ7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpbmdsZSBiaXQgd2l0aGluIGEge0BsaW5rIEJpdFN0cnVjdHVyZX0gYXMgYVxuICogSmF2YVNjcmlwdCBib29sZWFuLlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LlxuICogVXNlIHRoZSBjb250YWluZXIge0BsaW5rIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IGhlbHBlclxuICogbWV0aG9kLlxuICpcbiAqIEBwYXJhbSB7Qml0U3RydWN0dXJlfSBjb250YWluZXIgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBCaXRGaWVsZCNjb250YWluZXJ8Y29udGFpbmVyfS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtCaXRGaWVsZH1cbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tZXh0ZW5kLW5hdGl2ZSAqL1xuY2xhc3MgQm9vbGVhbiBleHRlbmRzIEJpdEZpZWxkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKGNvbnRhaW5lciwgMSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogT3ZlcnJpZGUge0BsaW5rIEJpdEZpZWxkI2RlY29kZXxkZWNvZGV9IGZvciB7QGxpbmsgQm9vbGVhbnxCb29sZWFufS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuICEhc3VwZXIuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCdib29sZWFuJyA9PT0gdHlwZW9mIHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBCaXRGaWVsZCByZXF1aXJlcyBpbnRlZ2VyIHZhbHVlc1xuICAgICAgICAgICAgdmFsdWUgPSArdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZW5jb2RlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkJvb2xlYW4gPSBCb29sZWFuO1xuLyogZXNsaW50LWVuYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG4vKipcbiAqIENvbnRhaW4gYSBmaXhlZC1sZW5ndGggYmxvY2sgb2YgYXJiaXRyYXJ5IGRhdGEsIHJlcHJlc2VudGVkIGFzIGFcbiAqIFVpbnQ4QXJyYXkuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifGJsb2J9XG4gKlxuICogQHBhcmFtIHsoTnVtYmVyfEV4dGVybmFsTGF5b3V0KX0gbGVuZ3RoIC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBCbG9iI2xlbmd0aHxsZW5ndGh9LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQmxvYiBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IobGVuZ3RoLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoISgoKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSAmJiBsZW5ndGguaXNDb3VudCgpKVxuICAgICAgICAgICAgfHwgKE51bWJlci5pc0ludGVnZXIobGVuZ3RoKSAmJiAoMCA8PSBsZW5ndGgpKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xlbmd0aCBtdXN0IGJlIHBvc2l0aXZlIGludGVnZXIgJ1xuICAgICAgICAgICAgICAgICsgJ29yIGFuIHVuc2lnbmVkIGludGVnZXIgRXh0ZXJuYWxMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICBpZiAoIShsZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkpIHtcbiAgICAgICAgICAgIHNwYW4gPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBieXRlcyBpbiB0aGUgYmxvYi5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBtYXkgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlciwgb3IgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICAgICAqIEV4dGVybmFsTGF5b3V0fSB0aGF0IHNhdGlzZmllcyB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9LiAqL1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBzcGFuID0gdGhpcy5zcGFuO1xuICAgICAgICBpZiAoMCA+IHNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSB0aGlzLmxlbmd0aC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3Bhbik7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIEJsb2J9LlxuICAgICAqXG4gICAgICogKipOT1RFKiogSWYge0BsaW5rIExheW91dCNjb3VudHxjb3VudH0gaXMgYW4gaW5zdGFuY2Ugb2Yge0BsaW5rXG4gICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoZW4gdGhlIGxlbmd0aCBvZiBgc3JjYCB3aWxsIGJlIGVuY29kZWQgYXMgdGhlXG4gICAgICogY291bnQgYWZ0ZXIgYHNyY2AgaXMgZW5jb2RlZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBzcmMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKHNyYyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgc3BhbiA9PT0gc3JjLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobmFtZVdpdGhQcm9wZXJ0eSgnQmxvYi5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICsgJyByZXF1aXJlcyAobGVuZ3RoICcgKyBzcGFuICsgJykgVWludDhBcnJheSBhcyBzcmMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBVaW50OEFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjQnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKHNyYyk7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZShzcmNCdWZmZXIudG9TdHJpbmcoJ2hleCcpLCBvZmZzZXQsIHNwYW4sICdoZXgnKTtcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGVuZ3RoLmVuY29kZShzcGFuLCBiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuQmxvYiA9IEJsb2I7XG4vKipcbiAqIENvbnRhaW4gYSBgTlVMYC10ZXJtaW5hdGVkIFVURjggc3RyaW5nLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxjc3RyfVxuICpcbiAqICoqTk9URSoqIEFueSBVVEY4IHN0cmluZyB0aGF0IGluY29ycG9yYXRlcyBhIHplcm8tdmFsdWVkIGJ5dGUgd2lsbFxuICogbm90IGJlIGNvcnJlY3RseSBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ1N0cmluZyBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGxldCBpZHggPSBvZmZzZXQ7XG4gICAgICAgIHdoaWxlICgoaWR4IDwgYi5sZW5ndGgpICYmICgwICE9PSBiW2lkeF0pKSB7XG4gICAgICAgICAgICBpZHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSArIGlkeCAtIG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwYW4gPSB0aGlzLmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4gLSAxKS50b1N0cmluZygndXRmLTgnKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgLyogTXVzdCBmb3JjZSB0aGlzIHRvIGEgc3RyaW5nLCBsZXN0IGl0IGJlIGEgbnVtYmVyIGFuZCB0aGVcbiAgICAgICAgICogXCJ1dGY4LWVuY29kaW5nXCIgYmVsb3cgYWN0dWFsbHkgYWxsb2NhdGUgYSBidWZmZXIgb2YgbGVuZ3RoXG4gICAgICAgICAqIHNyYyAqL1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBzcmMpIHtcbiAgICAgICAgICAgIHNyYyA9IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNyY2IgPSBidWZmZXJfMS5CdWZmZXIuZnJvbShzcmMsICd1dGY4Jyk7XG4gICAgICAgIGNvbnN0IHNwYW4gPSBzcmNiLmxlbmd0aDtcbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBzcmNiLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXJbb2Zmc2V0ICsgc3Bhbl0gPSAwO1xuICAgICAgICByZXR1cm4gc3BhbiArIDE7XG4gICAgfVxufVxuZXhwb3J0cy5DU3RyaW5nID0gQ1N0cmluZztcbi8qKlxuICogQ29udGFpbiBhIFVURjggc3RyaW5nIHdpdGggaW1wbGljaXQgbGVuZ3RoLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudXRmOHx1dGY4fVxuICpcbiAqICoqTk9URSoqIEJlY2F1c2UgdGhlIGxlbmd0aCBpcyBpbXBsaWNpdCBpbiB0aGUgc2l6ZSBvZiB0aGUgYnVmZmVyXG4gKiB0aGlzIGxheW91dCBzaG91bGQgYmUgdXNlZCBvbmx5IGluIGlzb2xhdGlvbiwgb3IgaW4gYSBzaXR1YXRpb25cbiAqIHdoZXJlIHRoZSBsZW5ndGggY2FuIGJlIGV4cHJlc3NlZCBieSBvcGVyYXRpbmcgb24gYSBzbGljZSBvZiB0aGVcbiAqIGNvbnRhaW5pbmcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4U3Bhbl0gLSB0aGUgbWF4aW11bSBsZW5ndGggYWxsb3dlZCBmb3IgZW5jb2RlZFxuICogc3RyaW5nIGNvbnRlbnQuICBJZiBub3QgcHJvdmlkZWQgdGhlcmUgaXMgbm8gYm91bmQgb24gdGhlIGFsbG93ZWRcbiAqIGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVVEY4IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihtYXhTcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbWF4U3BhbikgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IG1heFNwYW47XG4gICAgICAgICAgICBtYXhTcGFuID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IG1heFNwYW4pIHtcbiAgICAgICAgICAgIG1heFNwYW4gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhTcGFuKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4U3BhbiBtdXN0IGJlIGFuIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIG1heGltdW0gc3BhbiBvZiB0aGUgbGF5b3V0IGluIGJ5dGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBQb3NpdGl2ZSB2YWx1ZXMgYXJlIGdlbmVyYWxseSBleHBlY3RlZC4gIFplcm8gaXMgYWJub3JtYWwuXG4gICAgICAgICAqIEF0dGVtcHRzIHRvIGVuY29kZSBvciBkZWNvZGUgYSB2YWx1ZSB0aGF0IGV4Y2VlZHMgdGhpcyBsZW5ndGhcbiAgICAgICAgICogd2lsbCB0aHJvdyBhIGBSYW5nZUVycm9yYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQSBuZWdhdGl2ZSB2YWx1ZSBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgbGVuZ3RoXG4gICAgICAgICAqIG9mIHRoZSBjb250ZW50LiAqL1xuICAgICAgICB0aGlzLm1heFNwYW4gPSBtYXhTcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgcmV0dXJuIGIubGVuZ3RoIC0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5zbGljZShvZmZzZXQsIG9mZnNldCArIHNwYW4pLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgICAgICogc3JjICovXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgICAgc3JjID0gU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgICAgICBpZiAoKDAgPD0gdGhpcy5tYXhTcGFuKVxuICAgICAgICAgICAgJiYgKHRoaXMubWF4U3BhbiA8IHNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGV4dCBsZW5ndGggZXhjZWVkcyBtYXhTcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvZmZzZXQgKyBzcGFuKSA+IGIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignZW5jb2Rpbmcgb3ZlcnJ1bnMgQnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3JjYi5jb3B5KHVpbnQ4QXJyYXlUb0J1ZmZlcihiKSwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VVEY4ID0gVVRGODtcbi8qKlxuICogQ29udGFpbiBhIGNvbnN0YW50IHZhbHVlLlxuICpcbiAqIFRoaXMgbGF5b3V0IG1heSBiZSB1c2VkIGluIGNhc2VzIHdoZXJlIGEgSmF2YVNjcmlwdCB2YWx1ZSBjYW4gYmVcbiAqIGluZmVycmVkIHdpdGhvdXQgYW4gZXhwcmVzc2lvbiBpbiB0aGUgYmluYXJ5IGVuY29kaW5nLiAgQW4gZXhhbXBsZVxuICogd291bGQgYmUgYSB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dH0gd2hlcmUgdGhlIGNvbnRlbnRcbiAqIGlzIGltcGxpZWQgYnkgdGhlIHVuaW9uIHtAbGluayBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fE51bWJlcnxTdHJpbmd9IHZhbHVlIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQ29uc3RhbnQjdmFsdWV8dmFsdWV9LiAgSWYgdGhlIHZhbHVlIGlzIGFuIG9iamVjdCAob3IgYXJyYXkpIGFuZFxuICogdGhlIGFwcGxpY2F0aW9uIGludGVuZHMgdGhlIG9iamVjdCB0byByZW1haW4gdW5jaGFuZ2VkIHJlZ2FyZGxlc3NcbiAqIG9mIHdoYXQgaXMgZG9uZSB0byB2YWx1ZXMgZGVjb2RlZCBieSB0aGlzIGxheW91dCwgdGhlIHZhbHVlIHNob3VsZFxuICogYmUgZnJvemVuIHByaW9yIHBhc3NpbmcgaXQgdG8gdGhpcyBjb25zdHJ1Y3Rvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIENvbnN0YW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoMCwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHZhbHVlIHByb2R1Y2VkIGJ5IHRoaXMgY29uc3RhbnQgd2hlbiB0aGUgbGF5b3V0IGlzIHtAbGlua1xuICAgICAgICAgKiBDb25zdGFudCNkZWNvZGV8ZGVjb2RlZH0uXG4gICAgICAgICAqXG4gICAgICAgICAqIEFueSBKYXZhU2NyaXB0IHZhbHVlIGluY2x1ZGluZyBgbnVsbGAgYW5kIGB1bmRlZmluZWRgIGlzXG4gICAgICAgICAqIHBlcm1pdHRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipXQVJOSU5HKiogSWYgYHZhbHVlYCBwYXNzZWQgaW4gdGhlIGNvbnN0cnVjdG9yIHdhcyBub3RcbiAgICAgICAgICogZnJvemVuLCBpdCBpcyBwb3NzaWJsZSBmb3IgdXNlcnMgb2YgZGVjb2RlZCB2YWx1ZXMgdG8gY2hhbmdlXG4gICAgICAgICAqIHRoZSBjb250ZW50IG9mIHRoZSB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICAvKiBDb25zdGFudHMgdGFrZSBubyBzcGFjZSAqL1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5leHBvcnRzLkNvbnN0YW50ID0gQ29uc3RhbnQ7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEdyZWVkeUNvdW50fS4gKi9cbmV4cG9ydHMuZ3JlZWR5ID0gKChlbGVtZW50U3BhbiwgcHJvcGVydHkpID0+IG5ldyBHcmVlZHlDb3VudChlbGVtZW50U3BhbiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgT2Zmc2V0TGF5b3V0fS4gKi9cbmV4cG9ydHMub2Zmc2V0ID0gKChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpID0+IG5ldyBPZmZzZXRMYXlvdXQobGF5b3V0LCBvZmZzZXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8dW5zaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMudTggPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgxLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNiA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy51MzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDAgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludCg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGxpdHRsZS1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJVSW50NjR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhclVJbnQ2NChwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0d28gYnl0ZXMuICovXG5leHBvcnRzLnUxNmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMudTI0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmaXZlIGJ5dGVzLiAqL1xuZXhwb3J0cy51NDBiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy51NDhiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NEJFfGJpZy1lbmRpYW4gdW5zaWduZWQgaW50XG4gKiBsYXlvdXRzfSBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5udTY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhclVJbnQ2NEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxzaWduZWQgaW50IGxheW91dHN9IHNwYW5uaW5nIG9uZVxuICogYnl0ZS4gKi9cbmV4cG9ydHMuczggPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDEsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCgzLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBmb3VyIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDggPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDYsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIE5lYXJJbnQ2NHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhckludDY0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMuczE2YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnMyNGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMmJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnM0MGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludEJFKDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMuczQ4YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0QkV8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBpbnRlcnByZXRlZCBhcyBOdW1iZXJzLiAqL1xuZXhwb3J0cy5uczY0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgTmVhckludDY0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXR8bGl0dGxlLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyID0gKChwcm9wZXJ0eSkgPT4gbmV3IEZsb2F0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEZsb2F0QkV8YmlnLWVuZGlhbiAzMi1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgRmxvYXRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGV8bGl0dGxlLWVuZGlhbiA2NC1iaXQgZmxvYXRpbmcgcG9pbnR9IHZhbHVlcy4gKi9cbmV4cG9ydHMuZjY0ID0gKChwcm9wZXJ0eSkgPT4gbmV3IERvdWJsZShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBEb3VibGVCRXxiaWctZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBEb3VibGVCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc3RydWN0ID0gKChmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykgPT4gbmV3IFN0cnVjdHVyZShmaWVsZHMsIHByb3BlcnR5LCBkZWNvZGVQcmVmaXhlcykpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYml0cyA9ICgod29yZCwgbXNiLCBwcm9wZXJ0eSkgPT4gbmV3IEJpdFN0cnVjdHVyZSh3b3JkLCBtc2IsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFNlcXVlbmNlfSB2YWx1ZXMuICovXG5leHBvcnRzLnNlcSA9ICgoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSA9PiBuZXcgU2VxdWVuY2UoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVuaW9ufSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uID0gKChkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpID0+IG5ldyBVbmlvbihkaXNjciwgZGVmYXVsdExheW91dCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yfSB2YWx1ZXMuICovXG5leHBvcnRzLnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciA9ICgobGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcihsYXlvdXQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJsb2J9IHZhbHVlcy4gKi9cbmV4cG9ydHMuYmxvYiA9ICgobGVuZ3RoLCBwcm9wZXJ0eSkgPT4gbmV3IEJsb2IobGVuZ3RoLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDU3RyaW5nfSB2YWx1ZXMuICovXG5leHBvcnRzLmNzdHIgPSAoKHByb3BlcnR5KSA9PiBuZXcgQ1N0cmluZyhwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVVEY4fSB2YWx1ZXMuICovXG5leHBvcnRzLnV0ZjggPSAoKG1heFNwYW4sIHByb3BlcnR5KSA9PiBuZXcgVVRGOChtYXhTcGFuLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBDb25zdGFudH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5jb25zdGFudCA9ICgodmFsdWUsIHByb3BlcnR5KSA9PiBuZXcgQ29uc3RhbnQodmFsdWUsIHByb3BlcnR5KSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXlvdXQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@solana/buffer-layout/lib/Layout.js\n"));

/***/ }),

/***/ "./node_modules/@solana/web3.js/lib/index.browser.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.browser.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: function() { return /* binding */ Account; },\n/* harmony export */   AddressLookupTableAccount: function() { return /* binding */ AddressLookupTableAccount; },\n/* harmony export */   AddressLookupTableInstruction: function() { return /* binding */ AddressLookupTableInstruction; },\n/* harmony export */   AddressLookupTableProgram: function() { return /* binding */ AddressLookupTableProgram; },\n/* harmony export */   Authorized: function() { return /* binding */ Authorized; },\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: function() { return /* binding */ BLOCKHASH_CACHE_TIMEOUT_MS; },\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: function() { return /* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID; },\n/* harmony export */   BPF_LOADER_PROGRAM_ID: function() { return /* binding */ BPF_LOADER_PROGRAM_ID; },\n/* harmony export */   BpfLoader: function() { return /* binding */ BpfLoader; },\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: function() { return /* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS; },\n/* harmony export */   ComputeBudgetInstruction: function() { return /* binding */ ComputeBudgetInstruction; },\n/* harmony export */   ComputeBudgetProgram: function() { return /* binding */ ComputeBudgetProgram; },\n/* harmony export */   Connection: function() { return /* binding */ Connection; },\n/* harmony export */   Ed25519Program: function() { return /* binding */ Ed25519Program; },\n/* harmony export */   Enum: function() { return /* binding */ Enum; },\n/* harmony export */   EpochSchedule: function() { return /* binding */ EpochSchedule; },\n/* harmony export */   FeeCalculatorLayout: function() { return /* binding */ FeeCalculatorLayout; },\n/* harmony export */   Keypair: function() { return /* binding */ Keypair; },\n/* harmony export */   LAMPORTS_PER_SOL: function() { return /* binding */ LAMPORTS_PER_SOL; },\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: function() { return /* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS; },\n/* harmony export */   Loader: function() { return /* binding */ Loader; },\n/* harmony export */   Lockup: function() { return /* binding */ Lockup; },\n/* harmony export */   MAX_SEED_LENGTH: function() { return /* binding */ MAX_SEED_LENGTH; },\n/* harmony export */   Message: function() { return /* binding */ Message; },\n/* harmony export */   MessageAccountKeys: function() { return /* binding */ MessageAccountKeys; },\n/* harmony export */   MessageV0: function() { return /* binding */ MessageV0; },\n/* harmony export */   NONCE_ACCOUNT_LENGTH: function() { return /* binding */ NONCE_ACCOUNT_LENGTH; },\n/* harmony export */   NonceAccount: function() { return /* binding */ NonceAccount; },\n/* harmony export */   PACKET_DATA_SIZE: function() { return /* binding */ PACKET_DATA_SIZE; },\n/* harmony export */   PUBLIC_KEY_LENGTH: function() { return /* binding */ PUBLIC_KEY_LENGTH; },\n/* harmony export */   PublicKey: function() { return /* binding */ PublicKey; },\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: function() { return /* binding */ SIGNATURE_LENGTH_IN_BYTES; },\n/* harmony export */   SOLANA_SCHEMA: function() { return /* binding */ SOLANA_SCHEMA; },\n/* harmony export */   STAKE_CONFIG_ID: function() { return /* binding */ STAKE_CONFIG_ID; },\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: function() { return /* binding */ STAKE_INSTRUCTION_LAYOUTS; },\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: function() { return /* binding */ SYSTEM_INSTRUCTION_LAYOUTS; },\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: function() { return /* binding */ SYSVAR_CLOCK_PUBKEY; },\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: function() { return /* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY; },\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: function() { return /* binding */ SYSVAR_INSTRUCTIONS_PUBKEY; },\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: function() { return /* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY; },\n/* harmony export */   SYSVAR_RENT_PUBKEY: function() { return /* binding */ SYSVAR_RENT_PUBKEY; },\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: function() { return /* binding */ SYSVAR_REWARDS_PUBKEY; },\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: function() { return /* binding */ SYSVAR_SLOT_HASHES_PUBKEY; },\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: function() { return /* binding */ SYSVAR_SLOT_HISTORY_PUBKEY; },\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: function() { return /* binding */ SYSVAR_STAKE_HISTORY_PUBKEY; },\n/* harmony export */   Secp256k1Program: function() { return /* binding */ Secp256k1Program; },\n/* harmony export */   SendTransactionError: function() { return /* binding */ SendTransactionError; },\n/* harmony export */   SolanaJSONRPCError: function() { return /* binding */ SolanaJSONRPCError; },\n/* harmony export */   SolanaJSONRPCErrorCode: function() { return /* binding */ SolanaJSONRPCErrorCode; },\n/* harmony export */   StakeAuthorizationLayout: function() { return /* binding */ StakeAuthorizationLayout; },\n/* harmony export */   StakeInstruction: function() { return /* binding */ StakeInstruction; },\n/* harmony export */   StakeProgram: function() { return /* binding */ StakeProgram; },\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   SystemInstruction: function() { return /* binding */ SystemInstruction; },\n/* harmony export */   SystemProgram: function() { return /* binding */ SystemProgram; },\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; },\n/* harmony export */   TransactionExpiredBlockheightExceededError: function() { return /* binding */ TransactionExpiredBlockheightExceededError; },\n/* harmony export */   TransactionExpiredNonceInvalidError: function() { return /* binding */ TransactionExpiredNonceInvalidError; },\n/* harmony export */   TransactionExpiredTimeoutError: function() { return /* binding */ TransactionExpiredTimeoutError; },\n/* harmony export */   TransactionInstruction: function() { return /* binding */ TransactionInstruction; },\n/* harmony export */   TransactionMessage: function() { return /* binding */ TransactionMessage; },\n/* harmony export */   TransactionStatus: function() { return /* binding */ TransactionStatus; },\n/* harmony export */   VALIDATOR_INFO_KEY: function() { return /* binding */ VALIDATOR_INFO_KEY; },\n/* harmony export */   VERSION_PREFIX_MASK: function() { return /* binding */ VERSION_PREFIX_MASK; },\n/* harmony export */   VOTE_PROGRAM_ID: function() { return /* binding */ VOTE_PROGRAM_ID; },\n/* harmony export */   ValidatorInfo: function() { return /* binding */ ValidatorInfo; },\n/* harmony export */   VersionedMessage: function() { return /* binding */ VersionedMessage; },\n/* harmony export */   VersionedTransaction: function() { return /* binding */ VersionedTransaction; },\n/* harmony export */   VoteAccount: function() { return /* binding */ VoteAccount; },\n/* harmony export */   VoteAuthorizationLayout: function() { return /* binding */ VoteAuthorizationLayout; },\n/* harmony export */   VoteInit: function() { return /* binding */ VoteInit; },\n/* harmony export */   VoteInstruction: function() { return /* binding */ VoteInstruction; },\n/* harmony export */   VoteProgram: function() { return /* binding */ VoteProgram; },\n/* harmony export */   clusterApiUrl: function() { return /* binding */ clusterApiUrl; },\n/* harmony export */   sendAndConfirmRawTransaction: function() { return /* binding */ sendAndConfirmRawTransaction; },\n/* harmony export */   sendAndConfirmTransaction: function() { return /* binding */ sendAndConfirmTransaction; }\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\");\n/* harmony import */ var _babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/esm/createClass.js\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"./node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\");\n/* harmony import */ var _babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/esm/inherits.js\");\n/* harmony import */ var _babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\");\n/* harmony import */ var _babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_9___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_9__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! bs58 */ \"./node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! borsh */ \"./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_12___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_12__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/buffer-layout */ \"./node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var _babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @babel/runtime/helpers/slicedToArray */ \"./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\");\n/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! bigint-buffer */ \"./node_modules/bigint-buffer/dist/browser.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"./node_modules/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @babel/runtime/helpers/toConsumableArray */ \"./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\");\n/* harmony import */ var _babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @babel/runtime/helpers/objectWithoutProperties */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\");\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! superstruct */ \"./node_modules/superstruct/lib/index.es.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! jayson/lib/client/browser */ \"./node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_19___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_19__);\n/* harmony import */ var _babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @babel/runtime/helpers/wrapNativeSuper */ \"./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\");\n/* harmony import */ var _babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! @babel/runtime/helpers/get */ \"./node_modules/@babel/runtime/helpers/esm/get.js\");\n/* harmony import */ var rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! rpc-websockets/dist/lib/client */ \"./node_modules/rpc-websockets/dist/lib/client.js\");\n/* harmony import */ var rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! rpc-websockets/dist/lib/client/websocket.browser */ \"./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"./node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"./node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */\n\n/**\n * Ed25519 Keypair\n */\n\nvar generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__.ed25519.utils.randomPrivateKey;\nvar generateKeypair = function generateKeypair() {\n  var privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__.ed25519.utils.randomPrivateKey();\n  var publicKey = getPublicKey(privateScalar);\n  var secretKey = new Uint8Array(64);\n  secretKey.set(privateScalar);\n  secretKey.set(publicKey, 32);\n  return {\n    publicKey: publicKey,\n    secretKey: secretKey\n  };\n};\nvar getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n  try {\n    _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__.ed25519.ExtendedPoint.fromHex(publicKey);\n    return true;\n  } catch (_unused) {\n    return false;\n  }\n}\nvar sign = function sign(message, secretKey) {\n  return _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__.ed25519.sign(message, secretKey.slice(0, 32));\n};\nvar verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_3__.ed25519.verify;\n\nvar toBuffer = function toBuffer(arr) {\n  if (buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(arr);\n  }\n};\n\nfunction _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct$4() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n// Class wrapping a plain object\nvar Struct = /*#__PURE__*/function () {\n  function Struct(properties) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Struct);\n    Object.assign(this, properties);\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Struct, [{\n    key: \"encode\",\n    value: function encode() {\n      return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_12__.serialize)(SOLANA_SCHEMA, this));\n    }\n  }], [{\n    key: \"decode\",\n    value: function decode(data) {\n      return (0,borsh__WEBPACK_IMPORTED_MODULE_12__.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n  }, {\n    key: \"decodeUnchecked\",\n    value: function decodeUnchecked(data) {\n      return (0,borsh__WEBPACK_IMPORTED_MODULE_12__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n  }]);\n  return Struct;\n}();\n\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nvar Enum = /*#__PURE__*/function (_Struct) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(Enum, _Struct);\n  var _super = _createSuper$4(Enum);\n  function Enum(properties) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Enum);\n    _this = _super.call(this, properties);\n    _this[\"enum\"] = '';\n    if (Object.keys(properties).length !== 1) {\n      throw new Error('Enum can only take single value');\n    }\n    Object.keys(properties).map(function (key) {\n      _this[\"enum\"] = key;\n    });\n    return _this;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Enum);\n}(Struct);\nvar SOLANA_SCHEMA = new Map();\n\nvar _Symbol$toStringTag;\nfunction _regeneratorRuntime$5() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$5 = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct$3() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\n/**\n * Maximum length of derived pubkey seed\n */\nvar MAX_SEED_LENGTH = 32;\n\n/**\n * Size of public key in bytes\n */\nvar PUBLIC_KEY_LENGTH = 32;\n\n/**\n * Value to be converted into public key\n */\n\n/**\n * JSON object representation of PublicKey class\n */\n\nfunction isPublicKeyData(value) {\n  return value._bn !== undefined;\n}\n\n// local counter used by PublicKey.unique()\nvar uniquePublicKeyCounter = 1;\n\n/**\n * A public key\n */\n_Symbol$toStringTag = Symbol.toStringTag;\nvar PublicKey = /*#__PURE__*/function (_Struct) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(PublicKey, _Struct);\n  var _super = _createSuper$3(PublicKey);\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  function PublicKey(value) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, PublicKey);\n    _this = _super.call(this, {});\n    /** @internal */\n    _this._bn = void 0;\n    if (isPublicKeyData(value)) {\n      _this._bn = value._bn;\n    } else {\n      if (typeof value === 'string') {\n        // assume base 58 encoding by default\n        var decoded = bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(value);\n        if (decoded.length != PUBLIC_KEY_LENGTH) {\n          throw new Error(\"Invalid public key input\");\n        }\n        _this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_9___default())(decoded);\n      } else {\n        _this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_9___default())(value);\n      }\n      if (_this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n        throw new Error(\"Invalid public key input\");\n      }\n    }\n    return _this;\n  }\n\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(PublicKey, [{\n    key: \"equals\",\n    value:\n    /**\n     * Checks if two publicKeys are equal\n     */\n    function equals(publicKey) {\n      return this._bn.eq(publicKey._bn);\n    }\n\n    /**\n     * Return the base-58 representation of the public key\n     */\n  }, {\n    key: \"toBase58\",\n    value: function toBase58() {\n      return bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(this.toBytes());\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.toBase58();\n    }\n\n    /**\n     * Return the byte array representation of the public key in big endian\n     */\n  }, {\n    key: \"toBytes\",\n    value: function toBytes() {\n      var buf = this.toBuffer();\n      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n\n    /**\n     * Return the Buffer representation of the public key in big endian\n     */\n  }, {\n    key: \"toBuffer\",\n    value: function toBuffer() {\n      var b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer);\n      if (b.length === PUBLIC_KEY_LENGTH) {\n        return b;\n      }\n      var zeroPad = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(32);\n      b.copy(zeroPad, 32 - b.length);\n      return zeroPad;\n    }\n  }, {\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return \"PublicKey(\".concat(this.toString(), \")\");\n    }\n\n    /**\n     * Return the base-58 representation of the public key\n     */\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.toBase58();\n    }\n\n    /**\n     * Derive a public key from another key, a seed, and a program ID.\n     * The program ID will also serve as the owner of the public key, giving\n     * it permission to write data to the account.\n     */\n    /* eslint-disable require-await */\n  }], [{\n    key: \"unique\",\n    value: function unique() {\n      var key = new PublicKey(uniquePublicKeyCounter);\n      uniquePublicKeyCounter += 1;\n      return new PublicKey(key.toBuffer());\n    }\n\n    /**\n     * Default public key value. The base58-encoded string representation is all ones (as seen below)\n     * The underlying BN number is 32 bytes that are all zeros\n     */\n  }, {\n    key: \"createWithSeed\",\n    value: function () {\n      var _createWithSeed = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$5().mark(function _callee(fromPublicKey, seed, programId) {\n        var buffer, publicKeyBytes;\n        return _regeneratorRuntime$5().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              buffer = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat([fromPublicKey.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(seed), programId.toBuffer()]);\n              publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_11__.sha256)(buffer);\n              return _context.abrupt(\"return\", new PublicKey(publicKeyBytes));\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      function createWithSeed(_x, _x2, _x3) {\n        return _createWithSeed.apply(this, arguments);\n      }\n      return createWithSeed;\n    }()\n    /**\n     * Derive a program address from seeds and a program ID.\n     */\n    /* eslint-disable require-await */\n  }, {\n    key: \"createProgramAddressSync\",\n    value: function createProgramAddressSync(seeds, programId) {\n      var buffer = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);\n      seeds.forEach(function (seed) {\n        if (seed.length > MAX_SEED_LENGTH) {\n          throw new TypeError(\"Max seed length exceeded\");\n        }\n        buffer = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat([buffer, toBuffer(seed)]);\n      });\n      buffer = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat([buffer, programId.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from('ProgramDerivedAddress')]);\n      var publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_11__.sha256)(buffer);\n      if (isOnCurve(publicKeyBytes)) {\n        throw new Error(\"Invalid seeds, address must fall off the curve\");\n      }\n      return new PublicKey(publicKeyBytes);\n    }\n\n    /**\n     * Async version of createProgramAddressSync\n     * For backwards compatibility\n     *\n     * @deprecated Use {@link createProgramAddressSync} instead\n     */\n    /* eslint-disable require-await */\n  }, {\n    key: \"createProgramAddress\",\n    value: function () {\n      var _createProgramAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$5().mark(function _callee2(seeds, programId) {\n        return _regeneratorRuntime$5().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              return _context2.abrupt(\"return\", this.createProgramAddressSync(seeds, programId));\n            case 1:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function createProgramAddress(_x4, _x5) {\n        return _createProgramAddress.apply(this, arguments);\n      }\n      return createProgramAddress;\n    }()\n    /**\n     * Find a valid program address\n     *\n     * Valid program addresses must fall off the ed25519 curve.  This function\n     * iterates a nonce until it finds one that when combined with the seeds\n     * results in a valid program address.\n     */\n  }, {\n    key: \"findProgramAddressSync\",\n    value: function findProgramAddressSync(seeds, programId) {\n      var nonce = 255;\n      var address;\n      while (nonce != 0) {\n        try {\n          var seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from([nonce]));\n          address = this.createProgramAddressSync(seedsWithNonce, programId);\n        } catch (err) {\n          if (err instanceof TypeError) {\n            throw err;\n          }\n          nonce--;\n          continue;\n        }\n        return [address, nonce];\n      }\n      throw new Error(\"Unable to find a viable program address nonce\");\n    }\n\n    /**\n     * Async version of findProgramAddressSync\n     * For backwards compatibility\n     *\n     * @deprecated Use {@link findProgramAddressSync} instead\n     */\n  }, {\n    key: \"findProgramAddress\",\n    value: function () {\n      var _findProgramAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$5().mark(function _callee3(seeds, programId) {\n        return _regeneratorRuntime$5().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              return _context3.abrupt(\"return\", this.findProgramAddressSync(seeds, programId));\n            case 1:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function findProgramAddress(_x6, _x7) {\n        return _findProgramAddress.apply(this, arguments);\n      }\n      return findProgramAddress;\n    }()\n    /**\n     * Check that a pubkey is on the ed25519 curve.\n     */\n  }, {\n    key: \"isOnCurve\",\n    value: function isOnCurve$1(pubkeyData) {\n      var pubkey = new PublicKey(pubkeyData);\n      return isOnCurve(pubkey.toBytes());\n    }\n  }]);\n  return PublicKey;\n}(Struct);\nPublicKey[\"default\"] = new PublicKey('11111111111111111111111111111111');\nSOLANA_SCHEMA.set(PublicKey, {\n  kind: 'struct',\n  fields: [['_bn', 'u256']]\n});\n\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */\nvar Account = /*#__PURE__*/function () {\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  function Account(secretKey) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Account);\n    /** @internal */\n    this._publicKey = void 0;\n    /** @internal */\n    this._secretKey = void 0;\n    if (secretKey) {\n      var secretKeyBuffer = toBuffer(secretKey);\n      if (secretKey.length !== 64) {\n        throw new Error('bad secret key size');\n      }\n      this._publicKey = secretKeyBuffer.slice(32, 64);\n      this._secretKey = secretKeyBuffer.slice(0, 32);\n    } else {\n      this._secretKey = toBuffer(generatePrivateKey());\n      this._publicKey = toBuffer(getPublicKey(this._secretKey));\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Account, [{\n    key: \"publicKey\",\n    get: function get() {\n      return new PublicKey(this._publicKey);\n    }\n\n    /**\n     * The **unencrypted** secret key for this account. The first 32 bytes\n     * is the private scalar and the last 32 bytes is the public key.\n     * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n     */\n  }, {\n    key: \"secretKey\",\n    get: function get() {\n      return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.concat([this._secretKey, this._publicKey], 64);\n    }\n  }]);\n  return Account;\n}();\n\nvar BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nvar PACKET_DATA_SIZE = 1280 - 40 - 8;\nvar VERSION_PREFIX_MASK = 0x7f;\nvar SIGNATURE_LENGTH_IN_BYTES = 64;\n\nfunction _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct$2() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar TransactionExpiredBlockheightExceededError = /*#__PURE__*/function (_Error) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(TransactionExpiredBlockheightExceededError, _Error);\n  var _super = _createSuper$2(TransactionExpiredBlockheightExceededError);\n  function TransactionExpiredBlockheightExceededError(signature) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, TransactionExpiredBlockheightExceededError);\n    _this = _super.call(this, \"Signature \".concat(signature, \" has expired: block height exceeded.\"));\n    _this.signature = void 0;\n    _this.signature = signature;\n    return _this;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(TransactionExpiredBlockheightExceededError);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(Error));\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {\n  value: 'TransactionExpiredBlockheightExceededError'\n});\nvar TransactionExpiredTimeoutError = /*#__PURE__*/function (_Error2) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(TransactionExpiredTimeoutError, _Error2);\n  var _super2 = _createSuper$2(TransactionExpiredTimeoutError);\n  function TransactionExpiredTimeoutError(signature, timeoutSeconds) {\n    var _this2;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, TransactionExpiredTimeoutError);\n    _this2 = _super2.call(this, \"Transaction was not confirmed in \".concat(timeoutSeconds.toFixed(2), \" seconds. It is \") + 'unknown if it succeeded or failed. Check signature ' + \"\".concat(signature, \" using the Solana Explorer or CLI tools.\"));\n    _this2.signature = void 0;\n    _this2.signature = signature;\n    return _this2;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(TransactionExpiredTimeoutError);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(Error));\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {\n  value: 'TransactionExpiredTimeoutError'\n});\nvar TransactionExpiredNonceInvalidError = /*#__PURE__*/function (_Error3) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(TransactionExpiredNonceInvalidError, _Error3);\n  var _super3 = _createSuper$2(TransactionExpiredNonceInvalidError);\n  function TransactionExpiredNonceInvalidError(signature) {\n    var _this3;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, TransactionExpiredNonceInvalidError);\n    _this3 = _super3.call(this, \"Signature \".concat(signature, \" has expired: the nonce is no longer valid.\"));\n    _this3.signature = void 0;\n    _this3.signature = signature;\n    return _this3;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(TransactionExpiredNonceInvalidError);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(Error));\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {\n  value: 'TransactionExpiredNonceInvalidError'\n});\n\nfunction _createForOfIteratorHelper$5(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }\nfunction _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar MessageAccountKeys = /*#__PURE__*/function () {\n  function MessageAccountKeys(staticAccountKeys, accountKeysFromLookups) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, MessageAccountKeys);\n    this.staticAccountKeys = void 0;\n    this.accountKeysFromLookups = void 0;\n    this.staticAccountKeys = staticAccountKeys;\n    this.accountKeysFromLookups = accountKeysFromLookups;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(MessageAccountKeys, [{\n    key: \"keySegments\",\n    value: function keySegments() {\n      var keySegments = [this.staticAccountKeys];\n      if (this.accountKeysFromLookups) {\n        keySegments.push(this.accountKeysFromLookups.writable);\n        keySegments.push(this.accountKeysFromLookups.readonly);\n      }\n      return keySegments;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      var _iterator = _createForOfIteratorHelper$5(this.keySegments()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var keySegment = _step.value;\n          if (index < keySegment.length) {\n            return keySegment[index];\n          } else {\n            index -= keySegment.length;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return;\n    }\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this.keySegments().flat().length;\n    }\n  }, {\n    key: \"compileInstructions\",\n    value: function compileInstructions(instructions) {\n      // Bail early if any account indexes would overflow a u8\n      var U8_MAX = 255;\n      if (this.length > U8_MAX + 1) {\n        throw new Error('Account index overflow encountered during compilation');\n      }\n      var keyIndexMap = new Map();\n      this.keySegments().flat().forEach(function (key, index) {\n        keyIndexMap.set(key.toBase58(), index);\n      });\n      var findKeyIndex = function findKeyIndex(key) {\n        var keyIndex = keyIndexMap.get(key.toBase58());\n        if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');\n        return keyIndex;\n      };\n      return instructions.map(function (instruction) {\n        return {\n          programIdIndex: findKeyIndex(instruction.programId),\n          accountKeyIndexes: instruction.keys.map(function (meta) {\n            return findKeyIndex(meta.pubkey);\n          }),\n          data: instruction.data\n        };\n      });\n    }\n  }]);\n  return MessageAccountKeys;\n}();\n\n/**\n * Layout for a public key\n */\nvar publicKey = function publicKey() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'publicKey';\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(32, property);\n};\n\n/**\n * Layout for a signature\n */\nvar signature = function signature() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'signature';\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */\nvar rustString = function rustString() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'string';\n  var rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('length'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('lengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32(), -8), 'chars')], property);\n  var _decode = rsl.decode.bind(rsl);\n  var _encode = rsl.encode.bind(rsl);\n  var rslShim = rsl;\n  rslShim.decode = function (b, offset) {\n    var data = _decode(b, offset);\n    return data['chars'].toString();\n  };\n  rslShim.encode = function (str, b, offset) {\n    var data = {\n      chars: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(str, 'utf8')\n    };\n    return _encode(data, b, offset);\n  };\n  rslShim.alloc = function (str) {\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(str, 'utf8').length;\n  };\n  return rslShim;\n};\n\n/**\n * Layout for an Authorized object\n */\nvar authorized = function authorized() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'authorized';\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([publicKey('staker'), publicKey('withdrawer')], property);\n};\n\n/**\n * Layout for a Lockup object\n */\nvar lockup = function lockup() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'lockup';\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('unixTimestamp'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('epoch'), publicKey('custodian')], property);\n};\n\n/**\n *  Layout for a VoteInit object\n */\nvar voteInit = function voteInit() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteInit';\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('commission')], property);\n};\n\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */\nvar voteAuthorizeWithSeedArgs = function voteAuthorizeWithSeedArgs() {\n  var property = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'voteAuthorizeWithSeedArgs';\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);\n};\nfunction getAlloc(type, fields) {\n  var getItemAlloc = function getItemAlloc(item) {\n    if (item.span >= 0) {\n      return item.span;\n    } else if (typeof item.alloc === 'function') {\n      return item.alloc(fields[item.property]);\n    } else if ('count' in item && 'elementLayout' in item) {\n      var field = fields[item.property];\n      if (Array.isArray(field)) {\n        return field.length * getItemAlloc(item.elementLayout);\n      }\n    } else if ('fields' in item) {\n      // This is a `Structure` whose size needs to be recursively measured.\n      return getAlloc({\n        layout: item\n      }, fields[item.property]);\n    }\n    // Couldn't determine allocated size of layout\n    return 0;\n  };\n  var alloc = 0;\n  type.layout.fields.forEach(function (item) {\n    alloc += getItemAlloc(item);\n  });\n  return alloc;\n}\n\nfunction decodeLength(bytes) {\n  var len = 0;\n  var size = 0;\n  for (;;) {\n    var elem = bytes.shift();\n    len |= (elem & 0x7f) << size * 7;\n    size += 1;\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n  return len;\n}\nfunction encodeLength(bytes, len) {\n  var rem_len = len;\n  for (;;) {\n    var elem = rem_len & 0x7f;\n    rem_len >>= 7;\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\nfunction _createForOfIteratorHelper$4(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }\nfunction _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar CompiledKeys = /*#__PURE__*/function () {\n  function CompiledKeys(payer, keyMetaMap) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, CompiledKeys);\n    this.payer = void 0;\n    this.keyMetaMap = void 0;\n    this.payer = payer;\n    this.keyMetaMap = keyMetaMap;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(CompiledKeys, [{\n    key: \"getMessageComponents\",\n    value: function getMessageComponents() {\n      var mapEntries = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(this.keyMetaMap.entries());\n      assert(mapEntries.length <= 256, 'Max static account keys length exceeded');\n      var writableSigners = mapEntries.filter(function (_ref) {\n        var _ref2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref, 2),\n          meta = _ref2[1];\n        return meta.isSigner && meta.isWritable;\n      });\n      var readonlySigners = mapEntries.filter(function (_ref3) {\n        var _ref4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref3, 2),\n          meta = _ref4[1];\n        return meta.isSigner && !meta.isWritable;\n      });\n      var writableNonSigners = mapEntries.filter(function (_ref5) {\n        var _ref6 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref5, 2),\n          meta = _ref6[1];\n        return !meta.isSigner && meta.isWritable;\n      });\n      var readonlyNonSigners = mapEntries.filter(function (_ref7) {\n        var _ref8 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref7, 2),\n          meta = _ref8[1];\n        return !meta.isSigner && !meta.isWritable;\n      });\n      var header = {\n        numRequiredSignatures: writableSigners.length + readonlySigners.length,\n        numReadonlySignedAccounts: readonlySigners.length,\n        numReadonlyUnsignedAccounts: readonlyNonSigners.length\n      };\n\n      // sanity checks\n      {\n        assert(writableSigners.length > 0, 'Expected at least one writable signer key');\n        var _writableSigners$ = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(writableSigners[0], 1),\n          payerAddress = _writableSigners$[0];\n        assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');\n      }\n      var staticAccountKeys = [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(writableSigners.map(function (_ref9) {\n        var _ref10 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref9, 1),\n          address = _ref10[0];\n        return new PublicKey(address);\n      })), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(readonlySigners.map(function (_ref11) {\n        var _ref12 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref11, 1),\n          address = _ref12[0];\n        return new PublicKey(address);\n      })), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(writableNonSigners.map(function (_ref13) {\n        var _ref14 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref13, 1),\n          address = _ref14[0];\n        return new PublicKey(address);\n      })), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(readonlyNonSigners.map(function (_ref15) {\n        var _ref16 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref15, 1),\n          address = _ref16[0];\n        return new PublicKey(address);\n      })));\n      return [header, staticAccountKeys];\n    }\n  }, {\n    key: \"extractTableLookup\",\n    value: function extractTableLookup(lookupTable) {\n      var _this$drainKeysFoundI = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {\n          return !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable;\n        }),\n        _this$drainKeysFoundI2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_this$drainKeysFoundI, 2),\n        writableIndexes = _this$drainKeysFoundI2[0],\n        drainedWritableKeys = _this$drainKeysFoundI2[1];\n      var _this$drainKeysFoundI3 = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, function (keyMeta) {\n          return !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable;\n        }),\n        _this$drainKeysFoundI4 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_this$drainKeysFoundI3, 2),\n        readonlyIndexes = _this$drainKeysFoundI4[0],\n        drainedReadonlyKeys = _this$drainKeysFoundI4[1];\n\n      // Don't extract lookup if no keys were found\n      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n        return;\n      }\n      return [{\n        accountKey: lookupTable.key,\n        writableIndexes: writableIndexes,\n        readonlyIndexes: readonlyIndexes\n      }, {\n        writable: drainedWritableKeys,\n        readonly: drainedReadonlyKeys\n      }];\n    }\n\n    /** @internal */\n  }, {\n    key: \"drainKeysFoundInLookupTable\",\n    value: function drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n      var _this = this;\n      var lookupTableIndexes = new Array();\n      var drainedKeys = new Array();\n      var _iterator = _createForOfIteratorHelper$4(this.keyMetaMap.entries()),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var _step$value = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_step.value, 2),\n            address = _step$value[0],\n            keyMeta = _step$value[1];\n          if (keyMetaFilter(keyMeta)) {\n            var key = new PublicKey(address);\n            var lookupTableIndex = lookupTableEntries.findIndex(function (entry) {\n              return entry.equals(key);\n            });\n            if (lookupTableIndex >= 0) {\n              assert(lookupTableIndex < 256, 'Max lookup table index exceeded');\n              lookupTableIndexes.push(lookupTableIndex);\n              drainedKeys.push(key);\n              _this.keyMetaMap[\"delete\"](address);\n            }\n          }\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return [lookupTableIndexes, drainedKeys];\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(instructions, payer) {\n      var keyMetaMap = new Map();\n      var getOrInsertDefault = function getOrInsertDefault(pubkey) {\n        var address = pubkey.toBase58();\n        var keyMeta = keyMetaMap.get(address);\n        if (keyMeta === undefined) {\n          keyMeta = {\n            isSigner: false,\n            isWritable: false,\n            isInvoked: false\n          };\n          keyMetaMap.set(address, keyMeta);\n        }\n        return keyMeta;\n      };\n      var payerKeyMeta = getOrInsertDefault(payer);\n      payerKeyMeta.isSigner = true;\n      payerKeyMeta.isWritable = true;\n      var _iterator2 = _createForOfIteratorHelper$4(instructions),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var ix = _step2.value;\n          getOrInsertDefault(ix.programId).isInvoked = true;\n          var _iterator3 = _createForOfIteratorHelper$4(ix.keys),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var accountMeta = _step3.value;\n              var _keyMeta = getOrInsertDefault(accountMeta.pubkey);\n              _keyMeta.isSigner || (_keyMeta.isSigner = accountMeta.isSigner);\n              _keyMeta.isWritable || (_keyMeta.isWritable = accountMeta.isWritable);\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return new CompiledKeys(payer, keyMetaMap);\n    }\n  }]);\n  return CompiledKeys;\n}();\n\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */\n\n/**\n * Message constructor arguments\n */\n\n/**\n * List of instructions to be processed atomically\n */\nvar Message = /*#__PURE__*/function () {\n  function Message(args) {\n    var _this = this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Message);\n    this.header = void 0;\n    this.accountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.instructions = void 0;\n    this.indexToProgramIds = new Map();\n    this.header = args.header;\n    this.accountKeys = args.accountKeys.map(function (account) {\n      return new PublicKey(account);\n    });\n    this.recentBlockhash = args.recentBlockhash;\n    this.instructions = args.instructions;\n    this.instructions.forEach(function (ix) {\n      return _this.indexToProgramIds.set(ix.programIdIndex, _this.accountKeys[ix.programIdIndex]);\n    });\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Message, [{\n    key: \"version\",\n    get: function get() {\n      return 'legacy';\n    }\n  }, {\n    key: \"staticAccountKeys\",\n    get: function get() {\n      return this.accountKeys;\n    }\n  }, {\n    key: \"compiledInstructions\",\n    get: function get() {\n      return this.instructions.map(function (ix) {\n        return {\n          programIdIndex: ix.programIdIndex,\n          accountKeyIndexes: ix.accounts,\n          data: bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(ix.data)\n        };\n      });\n    }\n  }, {\n    key: \"addressTableLookups\",\n    get: function get() {\n      return [];\n    }\n  }, {\n    key: \"getAccountKeys\",\n    value: function getAccountKeys() {\n      return new MessageAccountKeys(this.staticAccountKeys);\n    }\n  }, {\n    key: \"isAccountSigner\",\n    value: function isAccountSigner(index) {\n      return index < this.header.numRequiredSignatures;\n    }\n  }, {\n    key: \"isAccountWritable\",\n    value: function isAccountWritable(index) {\n      var numSignedAccounts = this.header.numRequiredSignatures;\n      if (index >= this.header.numRequiredSignatures) {\n        var unsignedAccountIndex = index - numSignedAccounts;\n        var numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n        return unsignedAccountIndex < numWritableUnsignedAccounts;\n      } else {\n        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n        return index < numWritableSignedAccounts;\n      }\n    }\n  }, {\n    key: \"isProgramId\",\n    value: function isProgramId(index) {\n      return this.indexToProgramIds.has(index);\n    }\n  }, {\n    key: \"programIds\",\n    value: function programIds() {\n      return (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(this.indexToProgramIds.values());\n    }\n  }, {\n    key: \"nonProgramIds\",\n    value: function nonProgramIds() {\n      var _this2 = this;\n      return this.accountKeys.filter(function (_, index) {\n        return !_this2.isProgramId(index);\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var numKeys = this.accountKeys.length;\n      var keyCount = [];\n      encodeLength(keyCount, numKeys);\n      var instructions = this.instructions.map(function (instruction) {\n        var accounts = instruction.accounts,\n          programIdIndex = instruction.programIdIndex;\n        var data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(instruction.data));\n        var keyIndicesCount = [];\n        encodeLength(keyIndicesCount, accounts.length);\n        var dataCount = [];\n        encodeLength(dataCount, data.length);\n        return {\n          programIdIndex: programIdIndex,\n          keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(keyIndicesCount),\n          keyIndices: accounts,\n          dataLength: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(dataCount),\n          data: data\n        };\n      });\n      var instructionCount = [];\n      encodeLength(instructionCount, instructions.length);\n      var instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(PACKET_DATA_SIZE);\n      buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(instructionCount).copy(instructionBuffer);\n      var instructionBufferLength = instructionCount.length;\n      instructions.forEach(function (instruction) {\n        var instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(instruction.dataLength.length, 'dataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('userdatum'), instruction.data.length, 'data')]);\n        var length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n        instructionBufferLength += length;\n      });\n      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n      var signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(1, 'numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(1, 'numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(1, 'numReadonlyUnsignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(keyCount.length, 'keyCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);\n      var transaction = {\n        numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from([this.header.numRequiredSignatures]),\n        numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from([this.header.numReadonlySignedAccounts]),\n        numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n        keyCount: buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(keyCount),\n        keys: this.accountKeys.map(function (key) {\n          return toBuffer(key.toBytes());\n        }),\n        recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(this.recentBlockhash)\n      };\n      var signData = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(2048);\n      var length = signDataLayout.encode(transaction, signData);\n      instructionBuffer.copy(signData, length);\n      return signData.slice(0, length + instructionBuffer.length);\n    }\n\n    /**\n     * Decode a compiled message into a Message object.\n     */\n  }], [{\n    key: \"compile\",\n    value: function compile(args) {\n      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),\n        _compiledKeys$getMess2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_compiledKeys$getMess, 2),\n        header = _compiledKeys$getMess2[0],\n        staticAccountKeys = _compiledKeys$getMess2[1];\n      var accountKeys = new MessageAccountKeys(staticAccountKeys);\n      var instructions = accountKeys.compileInstructions(args.instructions).map(function (ix) {\n        return {\n          programIdIndex: ix.programIdIndex,\n          accounts: ix.accountKeyIndexes,\n          data: bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(ix.data)\n        };\n      });\n      return new Message({\n        header: header,\n        accountKeys: staticAccountKeys,\n        recentBlockhash: args.recentBlockhash,\n        instructions: instructions\n      });\n    }\n  }, {\n    key: \"from\",\n    value: function from(buffer) {\n      // Slice up wire data\n      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(buffer);\n      var numRequiredSignatures = byteArray.shift();\n      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n        throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');\n      }\n      var numReadonlySignedAccounts = byteArray.shift();\n      var numReadonlyUnsignedAccounts = byteArray.shift();\n      var accountCount = decodeLength(byteArray);\n      var accountKeys = [];\n      for (var i = 0; i < accountCount; i++) {\n        var account = byteArray.slice(0, PUBLIC_KEY_LENGTH);\n        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);\n        accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(account)));\n      }\n      var recentBlockhash = byteArray.slice(0, PUBLIC_KEY_LENGTH);\n      byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);\n      var instructionCount = decodeLength(byteArray);\n      var instructions = [];\n      for (var _i = 0; _i < instructionCount; _i++) {\n        var programIdIndex = byteArray.shift();\n        var _accountCount = decodeLength(byteArray);\n        var accounts = byteArray.slice(0, _accountCount);\n        byteArray = byteArray.slice(_accountCount);\n        var dataLength = decodeLength(byteArray);\n        var dataSlice = byteArray.slice(0, dataLength);\n        var data = bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(dataSlice));\n        byteArray = byteArray.slice(dataLength);\n        instructions.push({\n          programIdIndex: programIdIndex,\n          accounts: accounts,\n          data: data\n        });\n      }\n      var messageArgs = {\n        header: {\n          numRequiredSignatures: numRequiredSignatures,\n          numReadonlySignedAccounts: numReadonlySignedAccounts,\n          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts\n        },\n        recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(recentBlockhash)),\n        accountKeys: accountKeys,\n        instructions: instructions\n      };\n      return new Message(messageArgs);\n    }\n  }]);\n  return Message;\n}();\n\nfunction _createForOfIteratorHelper$3(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }\nfunction _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n\n/**\n * Message constructor arguments\n */\n\nvar MessageV0 = /*#__PURE__*/function () {\n  function MessageV0(args) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, MessageV0);\n    this.header = void 0;\n    this.staticAccountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.compiledInstructions = void 0;\n    this.addressTableLookups = void 0;\n    this.header = args.header;\n    this.staticAccountKeys = args.staticAccountKeys;\n    this.recentBlockhash = args.recentBlockhash;\n    this.compiledInstructions = args.compiledInstructions;\n    this.addressTableLookups = args.addressTableLookups;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(MessageV0, [{\n    key: \"version\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"numAccountKeysFromLookups\",\n    get: function get() {\n      var count = 0;\n      var _iterator = _createForOfIteratorHelper$3(this.addressTableLookups),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var lookup = _step.value;\n          count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return count;\n    }\n  }, {\n    key: \"getAccountKeys\",\n    value: function getAccountKeys(args) {\n      var accountKeysFromLookups;\n      if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {\n        if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n          throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');\n        }\n        accountKeysFromLookups = args.accountKeysFromLookups;\n      } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {\n        accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n      } else if (this.addressTableLookups.length > 0) {\n        throw new Error('Failed to get account keys because address table lookups were not resolved');\n      }\n      return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n    }\n  }, {\n    key: \"isAccountSigner\",\n    value: function isAccountSigner(index) {\n      return index < this.header.numRequiredSignatures;\n    }\n  }, {\n    key: \"isAccountWritable\",\n    value: function isAccountWritable(index) {\n      var numSignedAccounts = this.header.numRequiredSignatures;\n      var numStaticAccountKeys = this.staticAccountKeys.length;\n      if (index >= numStaticAccountKeys) {\n        var lookupAccountKeysIndex = index - numStaticAccountKeys;\n        var numWritableLookupAccountKeys = this.addressTableLookups.reduce(function (count, lookup) {\n          return count + lookup.writableIndexes.length;\n        }, 0);\n        return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n      } else if (index >= this.header.numRequiredSignatures) {\n        var unsignedAccountIndex = index - numSignedAccounts;\n        var numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n        var numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n        return unsignedAccountIndex < numWritableUnsignedAccounts;\n      } else {\n        var numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n        return index < numWritableSignedAccounts;\n      }\n    }\n  }, {\n    key: \"resolveAddressTableLookups\",\n    value: function resolveAddressTableLookups(addressLookupTableAccounts) {\n      var accountKeysFromLookups = {\n        writable: [],\n        readonly: []\n      };\n      var _iterator2 = _createForOfIteratorHelper$3(this.addressTableLookups),\n        _step2;\n      try {\n        var _loop = function _loop() {\n          var tableLookup = _step2.value;\n          var tableAccount = addressLookupTableAccounts.find(function (account) {\n            return account.key.equals(tableLookup.accountKey);\n          });\n          if (!tableAccount) {\n            throw new Error(\"Failed to find address lookup table account for table key \".concat(tableLookup.accountKey.toBase58()));\n          }\n          var _iterator3 = _createForOfIteratorHelper$3(tableLookup.writableIndexes),\n            _step3;\n          try {\n            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n              var index = _step3.value;\n              if (index < tableAccount.state.addresses.length) {\n                accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n              } else {\n                throw new Error(\"Failed to find address for index \".concat(index, \" in address lookup table \").concat(tableLookup.accountKey.toBase58()));\n              }\n            }\n          } catch (err) {\n            _iterator3.e(err);\n          } finally {\n            _iterator3.f();\n          }\n          var _iterator4 = _createForOfIteratorHelper$3(tableLookup.readonlyIndexes),\n            _step4;\n          try {\n            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n              var _index = _step4.value;\n              if (_index < tableAccount.state.addresses.length) {\n                accountKeysFromLookups.readonly.push(tableAccount.state.addresses[_index]);\n              } else {\n                throw new Error(\"Failed to find address for index \".concat(_index, \" in address lookup table \").concat(tableLookup.accountKey.toBase58()));\n              }\n            }\n          } catch (err) {\n            _iterator4.e(err);\n          } finally {\n            _iterator4.f();\n          }\n        };\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return accountKeysFromLookups;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var encodedStaticAccountKeysLength = Array();\n      encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n      var serializedInstructions = this.serializeInstructions();\n      var encodedInstructionsLength = Array();\n      encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n      var serializedAddressTableLookups = this.serializeAddressTableLookups();\n      var encodedAddressTableLookupsLength = Array();\n      encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n      var messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('prefix'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('numReadonlyUnsignedAccounts')], 'header'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedInstructionsLength.length, 'instructionsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(serializedInstructions.length, 'serializedInstructions'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);\n      var serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n      var MESSAGE_VERSION_0_PREFIX = 1 << 7;\n      var serializedMessageLength = messageLayout.encode({\n        prefix: MESSAGE_VERSION_0_PREFIX,\n        header: this.header,\n        staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n        staticAccountKeys: this.staticAccountKeys.map(function (key) {\n          return key.toBytes();\n        }),\n        recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(this.recentBlockhash),\n        instructionsLength: new Uint8Array(encodedInstructionsLength),\n        serializedInstructions: serializedInstructions,\n        addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n        serializedAddressTableLookups: serializedAddressTableLookups\n      }, serializedMessage);\n      return serializedMessage.slice(0, serializedMessageLength);\n    }\n  }, {\n    key: \"serializeInstructions\",\n    value: function serializeInstructions() {\n      var serializedLength = 0;\n      var serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n      var _iterator5 = _createForOfIteratorHelper$3(this.compiledInstructions),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var instruction = _step5.value;\n          var encodedAccountKeyIndexesLength = Array();\n          encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n          var encodedDataLength = Array();\n          encodeLength(encodedDataLength, instruction.data.length);\n          var instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedDataLength.length, 'encodedDataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(instruction.data.length, 'data')]);\n          serializedLength += instructionLayout.encode({\n            programIdIndex: instruction.programIdIndex,\n            encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n            accountKeyIndexes: instruction.accountKeyIndexes,\n            encodedDataLength: new Uint8Array(encodedDataLength),\n            data: instruction.data\n          }, serializedInstructions, serializedLength);\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return serializedInstructions.slice(0, serializedLength);\n    }\n  }, {\n    key: \"serializeAddressTableLookups\",\n    value: function serializeAddressTableLookups() {\n      var serializedLength = 0;\n      var serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n      var _iterator6 = _createForOfIteratorHelper$3(this.addressTableLookups),\n        _step6;\n      try {\n        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n          var lookup = _step6.value;\n          var encodedWritableIndexesLength = Array();\n          encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n          var encodedReadonlyIndexesLength = Array();\n          encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n          var addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([publicKey('accountKey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8(), lookup.writableIndexes.length, 'writableIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);\n          serializedLength += addressTableLookupLayout.encode({\n            accountKey: lookup.accountKey.toBytes(),\n            encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n            writableIndexes: lookup.writableIndexes,\n            encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n            readonlyIndexes: lookup.readonlyIndexes\n          }, serializedAddressTableLookups, serializedLength);\n        }\n      } catch (err) {\n        _iterator6.e(err);\n      } finally {\n        _iterator6.f();\n      }\n      return serializedAddressTableLookups.slice(0, serializedLength);\n    }\n  }], [{\n    key: \"compile\",\n    value: function compile(args) {\n      var compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n      var addressTableLookups = new Array();\n      var accountKeysFromLookups = {\n        writable: new Array(),\n        readonly: new Array()\n      };\n      var lookupTableAccounts = args.addressLookupTableAccounts || [];\n      var _iterator7 = _createForOfIteratorHelper$3(lookupTableAccounts),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var lookupTable = _step7.value;\n          var extractResult = compiledKeys.extractTableLookup(lookupTable);\n          if (extractResult !== undefined) {\n            var _accountKeysFromLooku, _accountKeysFromLooku2;\n            var _extractResult = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(extractResult, 2),\n              addressTableLookup = _extractResult[0],\n              _extractResult$ = _extractResult[1],\n              writable = _extractResult$.writable,\n              readonly = _extractResult$.readonly;\n            addressTableLookups.push(addressTableLookup);\n            (_accountKeysFromLooku = accountKeysFromLookups.writable).push.apply(_accountKeysFromLooku, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(writable));\n            (_accountKeysFromLooku2 = accountKeysFromLookups.readonly).push.apply(_accountKeysFromLooku2, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(readonly));\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      var _compiledKeys$getMess = compiledKeys.getMessageComponents(),\n        _compiledKeys$getMess2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_compiledKeys$getMess, 2),\n        header = _compiledKeys$getMess2[0],\n        staticAccountKeys = _compiledKeys$getMess2[1];\n      var accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n      var compiledInstructions = accountKeys.compileInstructions(args.instructions);\n      return new MessageV0({\n        header: header,\n        staticAccountKeys: staticAccountKeys,\n        recentBlockhash: args.recentBlockhash,\n        compiledInstructions: compiledInstructions,\n        addressTableLookups: addressTableLookups\n      });\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(serializedMessage) {\n      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(serializedMessage);\n      var prefix = byteArray.shift();\n      var maskedPrefix = prefix & VERSION_PREFIX_MASK;\n      assert(prefix !== maskedPrefix, \"Expected versioned message but received legacy message\");\n      var version = maskedPrefix;\n      assert(version === 0, \"Expected versioned message with version 0 but found version \".concat(version));\n      var header = {\n        numRequiredSignatures: byteArray.shift(),\n        numReadonlySignedAccounts: byteArray.shift(),\n        numReadonlyUnsignedAccounts: byteArray.shift()\n      };\n      var staticAccountKeys = [];\n      var staticAccountKeysLength = decodeLength(byteArray);\n      for (var i = 0; i < staticAccountKeysLength; i++) {\n        staticAccountKeys.push(new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH)));\n      }\n      var recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(byteArray.splice(0, PUBLIC_KEY_LENGTH));\n      var instructionCount = decodeLength(byteArray);\n      var compiledInstructions = [];\n      for (var _i = 0; _i < instructionCount; _i++) {\n        var programIdIndex = byteArray.shift();\n        var accountKeyIndexesLength = decodeLength(byteArray);\n        var accountKeyIndexes = byteArray.splice(0, accountKeyIndexesLength);\n        var dataLength = decodeLength(byteArray);\n        var data = new Uint8Array(byteArray.splice(0, dataLength));\n        compiledInstructions.push({\n          programIdIndex: programIdIndex,\n          accountKeyIndexes: accountKeyIndexes,\n          data: data\n        });\n      }\n      var addressTableLookupsCount = decodeLength(byteArray);\n      var addressTableLookups = [];\n      for (var _i2 = 0; _i2 < addressTableLookupsCount; _i2++) {\n        var accountKey = new PublicKey(byteArray.splice(0, PUBLIC_KEY_LENGTH));\n        var writableIndexesLength = decodeLength(byteArray);\n        var writableIndexes = byteArray.splice(0, writableIndexesLength);\n        var readonlyIndexesLength = decodeLength(byteArray);\n        var readonlyIndexes = byteArray.splice(0, readonlyIndexesLength);\n        addressTableLookups.push({\n          accountKey: accountKey,\n          writableIndexes: writableIndexes,\n          readonlyIndexes: readonlyIndexes\n        });\n      }\n      return new MessageV0({\n        header: header,\n        staticAccountKeys: staticAccountKeys,\n        recentBlockhash: recentBlockhash,\n        compiledInstructions: compiledInstructions,\n        addressTableLookups: addressTableLookups\n      });\n    }\n  }]);\n  return MessageV0;\n}();\n\n// eslint-disable-next-line no-redeclare\nvar VersionedMessage = {\n  deserializeMessageVersion: function deserializeMessageVersion(serializedMessage) {\n    var prefix = serializedMessage[0];\n    var maskedPrefix = prefix & VERSION_PREFIX_MASK;\n\n    // if the highest bit of the prefix is not set, the message is not versioned\n    if (maskedPrefix === prefix) {\n      return 'legacy';\n    }\n\n    // the lower 7 bits of the prefix indicate the message version\n    return maskedPrefix;\n  },\n  deserialize: function deserialize(serializedMessage) {\n    var version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n    if (version === 'legacy') {\n      return Message.from(serializedMessage);\n    }\n    if (version === 0) {\n      return MessageV0.deserialize(serializedMessage);\n    } else {\n      throw new Error(\"Transaction message version \".concat(version, \" deserialization is not supported\"));\n    }\n  }\n};\n\nfunction _regeneratorRuntime$4() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$4 = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction _createForOfIteratorHelper$2(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }\nfunction _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\n/**\n * Transaction signature as base-58 encoded string\n */\n\nvar TransactionStatus = /*#__PURE__*/function (TransactionStatus) {\n  TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n  TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n  TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n  return TransactionStatus;\n}({});\n\n/**\n * Default (empty) signature\n */\nvar DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n\n/**\n * Account metadata used to define instructions\n */\n\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n */\n\n/**\n * Configuration object for Transaction.serialize()\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction Instruction class\n */\nvar TransactionInstruction = /*#__PURE__*/function () {\n  function TransactionInstruction(opts) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, TransactionInstruction);\n    /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */\n    this.keys = void 0;\n    /**\n     * Program Id to execute\n     */\n    this.programId = void 0;\n    /**\n     * Program input\n     */\n    this.data = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(0);\n    this.programId = opts.programId;\n    this.keys = opts.keys;\n    if (opts.data) {\n      this.data = opts.data;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(TransactionInstruction, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        keys: this.keys.map(function (_ref) {\n          var pubkey = _ref.pubkey,\n            isSigner = _ref.isSigner,\n            isWritable = _ref.isWritable;\n          return {\n            pubkey: pubkey.toJSON(),\n            isSigner: isSigner,\n            isWritable: isWritable\n          };\n        }),\n        programId: this.programId.toJSON(),\n        data: (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(this.data)\n      };\n    }\n  }]);\n  return TransactionInstruction;\n}();\n\n/**\n * Pair of signature and corresponding public key\n */\n\n/**\n * List of Transaction object fields that may be initialized at construction\n */\n\n// For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */\n/**\n * Use these options to construct a durable nonce transaction.\n */\n/**\n * Nonce information to be used to build an offline Transaction.\n */\n/**\n * @internal\n */\n/**\n * Transaction class\n */\nvar Transaction = /*#__PURE__*/function () {\n  /**\n   * Construct an empty Transaction\n   */\n  function Transaction(opts) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Transaction);\n    /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */\n    this.signatures = [];\n    /**\n     * The transaction fee payer\n     */\n    this.feePayer = void 0;\n    /**\n     * The instructions to atomically execute\n     */\n    this.instructions = [];\n    /**\n     * A recent transaction id. Must be populated by the caller\n     */\n    this.recentBlockhash = void 0;\n    /**\n     * the last block chain can advance to before tx is declared expired\n     * */\n    this.lastValidBlockHeight = void 0;\n    /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */\n    this.nonceInfo = void 0;\n    /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */\n    this.minNonceContextSlot = void 0;\n    /**\n     * @internal\n     */\n    this._message = void 0;\n    /**\n     * @internal\n     */\n    this._json = void 0;\n    if (!opts) {\n      return;\n    }\n    if (opts.feePayer) {\n      this.feePayer = opts.feePayer;\n    }\n    if (opts.signatures) {\n      this.signatures = opts.signatures;\n    }\n    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {\n      var _ref2 = opts,\n        minContextSlot = _ref2.minContextSlot,\n        nonceInfo = _ref2.nonceInfo;\n      this.minNonceContextSlot = minContextSlot;\n      this.nonceInfo = nonceInfo;\n    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {\n      var _ref3 = opts,\n        blockhash = _ref3.blockhash,\n        lastValidBlockHeight = _ref3.lastValidBlockHeight;\n      this.recentBlockhash = blockhash;\n      this.lastValidBlockHeight = lastValidBlockHeight;\n    } else {\n      var _ref4 = opts,\n        recentBlockhash = _ref4.recentBlockhash,\n        _nonceInfo = _ref4.nonceInfo;\n      if (_nonceInfo) {\n        this.nonceInfo = _nonceInfo;\n      }\n      this.recentBlockhash = recentBlockhash;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Transaction, [{\n    key: \"signature\",\n    get:\n    /**\n     * The first (payer) Transaction signature\n     *\n     * @returns {Buffer | null} Buffer of payer's signature\n     */\n    function get() {\n      if (this.signatures.length > 0) {\n        return this.signatures[0].signature;\n      }\n      return null;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        recentBlockhash: this.recentBlockhash || null,\n        feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n        nonceInfo: this.nonceInfo ? {\n          nonce: this.nonceInfo.nonce,\n          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n        } : null,\n        instructions: this.instructions.map(function (instruction) {\n          return instruction.toJSON();\n        }),\n        signers: this.signatures.map(function (_ref5) {\n          var publicKey = _ref5.publicKey;\n          return publicKey.toJSON();\n        })\n      };\n    }\n\n    /**\n     * Add one or more instructions to this Transaction\n     *\n     * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n     */\n  }, {\n    key: \"add\",\n    value: function add() {\n      var _this = this;\n      for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n        items[_key] = arguments[_key];\n      }\n      if (items.length === 0) {\n        throw new Error('No instructions');\n      }\n      items.forEach(function (item) {\n        if ('instructions' in item) {\n          _this.instructions = _this.instructions.concat(item.instructions);\n        } else if ('data' in item && 'programId' in item && 'keys' in item) {\n          _this.instructions.push(item);\n        } else {\n          _this.instructions.push(new TransactionInstruction(item));\n        }\n      });\n      return this;\n    }\n\n    /**\n     * Compile transaction data\n     */\n  }, {\n    key: \"compileMessage\",\n    value: function compileMessage() {\n      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n        return this._message;\n      }\n      var recentBlockhash;\n      var instructions;\n      if (this.nonceInfo) {\n        recentBlockhash = this.nonceInfo.nonce;\n        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n          instructions = [this.nonceInfo.nonceInstruction].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(this.instructions));\n        } else {\n          instructions = this.instructions;\n        }\n      } else {\n        recentBlockhash = this.recentBlockhash;\n        instructions = this.instructions;\n      }\n      if (!recentBlockhash) {\n        throw new Error('Transaction recentBlockhash required');\n      }\n      if (instructions.length < 1) {\n        console.warn('No instructions provided');\n      }\n      var feePayer;\n      if (this.feePayer) {\n        feePayer = this.feePayer;\n      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n        // Use implicit fee payer\n        feePayer = this.signatures[0].publicKey;\n      } else {\n        throw new Error('Transaction fee payer required');\n      }\n      for (var i = 0; i < instructions.length; i++) {\n        if (instructions[i].programId === undefined) {\n          throw new Error(\"Transaction instruction index \".concat(i, \" has undefined program id\"));\n        }\n      }\n      var programIds = [];\n      var accountMetas = [];\n      instructions.forEach(function (instruction) {\n        instruction.keys.forEach(function (accountMeta) {\n          accountMetas.push(_objectSpread$2({}, accountMeta));\n        });\n        var programId = instruction.programId.toString();\n        if (!programIds.includes(programId)) {\n          programIds.push(programId);\n        }\n      });\n\n      // Append programID account metas\n      programIds.forEach(function (programId) {\n        accountMetas.push({\n          pubkey: new PublicKey(programId),\n          isSigner: false,\n          isWritable: false\n        });\n      });\n\n      // Cull duplicate account metas\n      var uniqueMetas = [];\n      accountMetas.forEach(function (accountMeta) {\n        var pubkeyString = accountMeta.pubkey.toString();\n        var uniqueIndex = uniqueMetas.findIndex(function (x) {\n          return x.pubkey.toString() === pubkeyString;\n        });\n        if (uniqueIndex > -1) {\n          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n        } else {\n          uniqueMetas.push(accountMeta);\n        }\n      });\n\n      // Sort. Prioritizing first by signer, then by writable\n      uniqueMetas.sort(function (x, y) {\n        if (x.isSigner !== y.isSigner) {\n          // Signers always come before non-signers\n          return x.isSigner ? -1 : 1;\n        }\n        if (x.isWritable !== y.isWritable) {\n          // Writable accounts always come before read-only accounts\n          return x.isWritable ? -1 : 1;\n        }\n        // Otherwise, sort by pubkey, stringwise.\n        var options = {\n          localeMatcher: 'best fit',\n          usage: 'sort',\n          sensitivity: 'variant',\n          ignorePunctuation: false,\n          numeric: false,\n          caseFirst: 'lower'\n        };\n        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);\n      });\n\n      // Move fee payer to the front\n      var feePayerIndex = uniqueMetas.findIndex(function (x) {\n        return x.pubkey.equals(feePayer);\n      });\n      if (feePayerIndex > -1) {\n        var _uniqueMetas$splice = uniqueMetas.splice(feePayerIndex, 1),\n          _uniqueMetas$splice2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_uniqueMetas$splice, 1),\n          payerMeta = _uniqueMetas$splice2[0];\n        payerMeta.isSigner = true;\n        payerMeta.isWritable = true;\n        uniqueMetas.unshift(payerMeta);\n      } else {\n        uniqueMetas.unshift({\n          pubkey: feePayer,\n          isSigner: true,\n          isWritable: true\n        });\n      }\n\n      // Disallow unknown signers\n      var _iterator = _createForOfIteratorHelper$2(this.signatures),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var signature = _step.value;\n          var uniqueIndex = uniqueMetas.findIndex(function (x) {\n            return x.pubkey.equals(signature.publicKey);\n          });\n          if (uniqueIndex > -1) {\n            if (!uniqueMetas[uniqueIndex].isSigner) {\n              uniqueMetas[uniqueIndex].isSigner = true;\n              console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');\n            }\n          } else {\n            throw new Error(\"unknown signer: \".concat(signature.publicKey.toString()));\n          }\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      var numRequiredSignatures = 0;\n      var numReadonlySignedAccounts = 0;\n      var numReadonlyUnsignedAccounts = 0;\n\n      // Split out signing from non-signing keys and count header values\n      var signedKeys = [];\n      var unsignedKeys = [];\n      uniqueMetas.forEach(function (_ref6) {\n        var pubkey = _ref6.pubkey,\n          isSigner = _ref6.isSigner,\n          isWritable = _ref6.isWritable;\n        if (isSigner) {\n          signedKeys.push(pubkey.toString());\n          numRequiredSignatures += 1;\n          if (!isWritable) {\n            numReadonlySignedAccounts += 1;\n          }\n        } else {\n          unsignedKeys.push(pubkey.toString());\n          if (!isWritable) {\n            numReadonlyUnsignedAccounts += 1;\n          }\n        }\n      });\n      var accountKeys = signedKeys.concat(unsignedKeys);\n      var compiledInstructions = instructions.map(function (instruction) {\n        var data = instruction.data,\n          programId = instruction.programId;\n        return {\n          programIdIndex: accountKeys.indexOf(programId.toString()),\n          accounts: instruction.keys.map(function (meta) {\n            return accountKeys.indexOf(meta.pubkey.toString());\n          }),\n          data: bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(data)\n        };\n      });\n      compiledInstructions.forEach(function (instruction) {\n        assert(instruction.programIdIndex >= 0);\n        instruction.accounts.forEach(function (keyIndex) {\n          return assert(keyIndex >= 0);\n        });\n      });\n      return new Message({\n        header: {\n          numRequiredSignatures: numRequiredSignatures,\n          numReadonlySignedAccounts: numReadonlySignedAccounts,\n          numReadonlyUnsignedAccounts: numReadonlyUnsignedAccounts\n        },\n        accountKeys: accountKeys,\n        recentBlockhash: recentBlockhash,\n        instructions: compiledInstructions\n      });\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_compile\",\n    value: function _compile() {\n      var message = this.compileMessage();\n      var signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n      if (this.signatures.length === signedKeys.length) {\n        var valid = this.signatures.every(function (pair, index) {\n          return signedKeys[index].equals(pair.publicKey);\n        });\n        if (valid) return message;\n      }\n      this.signatures = signedKeys.map(function (publicKey) {\n        return {\n          signature: null,\n          publicKey: publicKey\n        };\n      });\n      return message;\n    }\n\n    /**\n     * Get a buffer of the Transaction data that need to be covered by signatures\n     */\n  }, {\n    key: \"serializeMessage\",\n    value: function serializeMessage() {\n      return this._compile().serialize();\n    }\n\n    /**\n     * Get the estimated fee associated with a transaction\n     *\n     * @param {Connection} connection Connection to RPC Endpoint.\n     *\n     * @returns {Promise<number | null>} The estimated fee for the transaction\n     */\n  }, {\n    key: \"getEstimatedFee\",\n    value: function () {\n      var _getEstimatedFee = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$4().mark(function _callee(connection) {\n        return _regeneratorRuntime$4().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return connection.getFeeForMessage(this.compileMessage());\n            case 2:\n              return _context.abrupt(\"return\", _context.sent.value);\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n      function getEstimatedFee(_x) {\n        return _getEstimatedFee.apply(this, arguments);\n      }\n      return getEstimatedFee;\n    }()\n    /**\n     * Specify the public keys which will be used to sign the Transaction.\n     * The first signer will be used as the transaction fee payer account.\n     *\n     * Signatures can be added with either `partialSign` or `addSignature`\n     *\n     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n     * specified and it can be set in the Transaction constructor or with the\n     * `feePayer` property.\n     */\n  }, {\n    key: \"setSigners\",\n    value: function setSigners() {\n      for (var _len2 = arguments.length, signers = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        signers[_key2] = arguments[_key2];\n      }\n      if (signers.length === 0) {\n        throw new Error('No signers');\n      }\n      var seen = new Set();\n      this.signatures = signers.filter(function (publicKey) {\n        var key = publicKey.toString();\n        if (seen.has(key)) {\n          return false;\n        } else {\n          seen.add(key);\n          return true;\n        }\n      }).map(function (publicKey) {\n        return {\n          signature: null,\n          publicKey: publicKey\n        };\n      });\n    }\n\n    /**\n     * Sign the Transaction with the specified signers. Multiple signatures may\n     * be applied to a Transaction. The first signature is considered \"primary\"\n     * and is used identify and confirm transactions.\n     *\n     * If the Transaction `feePayer` is not set, the first signer will be used\n     * as the transaction fee payer account.\n     *\n     * Transaction fields should not be modified after the first call to `sign`,\n     * as doing so may invalidate the signature and cause the Transaction to be\n     * rejected.\n     *\n     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n     *\n     * @param {Array<Signer>} signers Array of signers that will sign the transaction\n     */\n  }, {\n    key: \"sign\",\n    value: function sign() {\n      for (var _len3 = arguments.length, signers = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        signers[_key3] = arguments[_key3];\n      }\n      if (signers.length === 0) {\n        throw new Error('No signers');\n      }\n\n      // Dedupe signers\n      var seen = new Set();\n      var uniqueSigners = [];\n      for (var _i = 0, _signers = signers; _i < _signers.length; _i++) {\n        var signer = _signers[_i];\n        var key = signer.publicKey.toString();\n        if (seen.has(key)) {\n          continue;\n        } else {\n          seen.add(key);\n          uniqueSigners.push(signer);\n        }\n      }\n      this.signatures = uniqueSigners.map(function (signer) {\n        return {\n          signature: null,\n          publicKey: signer.publicKey\n        };\n      });\n      var message = this._compile();\n      this._partialSign.apply(this, [message].concat(uniqueSigners));\n    }\n\n    /**\n     * Partially sign a transaction with the specified accounts. All accounts must\n     * correspond to either the fee payer or a signer account in the transaction\n     * instructions.\n     *\n     * All the caveats from the `sign` method apply to `partialSign`\n     *\n     * @param {Array<Signer>} signers Array of signers that will sign the transaction\n     */\n  }, {\n    key: \"partialSign\",\n    value: function partialSign() {\n      for (var _len4 = arguments.length, signers = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        signers[_key4] = arguments[_key4];\n      }\n      if (signers.length === 0) {\n        throw new Error('No signers');\n      }\n\n      // Dedupe signers\n      var seen = new Set();\n      var uniqueSigners = [];\n      for (var _i2 = 0, _signers2 = signers; _i2 < _signers2.length; _i2++) {\n        var signer = _signers2[_i2];\n        var key = signer.publicKey.toString();\n        if (seen.has(key)) {\n          continue;\n        } else {\n          seen.add(key);\n          uniqueSigners.push(signer);\n        }\n      }\n      var message = this._compile();\n      this._partialSign.apply(this, [message].concat(uniqueSigners));\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_partialSign\",\n    value: function _partialSign(message) {\n      var _this2 = this;\n      var signData = message.serialize();\n      for (var _len5 = arguments.length, signers = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        signers[_key5 - 1] = arguments[_key5];\n      }\n      signers.forEach(function (signer) {\n        var signature = sign(signData, signer.secretKey);\n        _this2._addSignature(signer.publicKey, toBuffer(signature));\n      });\n    }\n\n    /**\n     * Add an externally created signature to a transaction. The public key\n     * must correspond to either the fee payer or a signer account in the transaction\n     * instructions.\n     *\n     * @param {PublicKey} pubkey Public key that will be added to the transaction.\n     * @param {Buffer} signature An externally created signature to add to the transaction.\n     */\n  }, {\n    key: \"addSignature\",\n    value: function addSignature(pubkey, signature) {\n      this._compile(); // Ensure signatures array is populated\n      this._addSignature(pubkey, signature);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_addSignature\",\n    value: function _addSignature(pubkey, signature) {\n      assert(signature.length === 64);\n      var index = this.signatures.findIndex(function (sigpair) {\n        return pubkey.equals(sigpair.publicKey);\n      });\n      if (index < 0) {\n        throw new Error(\"unknown signer: \".concat(pubkey.toString()));\n      }\n      this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(signature);\n    }\n\n    /**\n     * Verify signatures of a Transaction\n     * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n     * If no boolean is provided, we expect a fully signed Transaction by default.\n     *\n     * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n     */\n  }, {\n    key: \"verifySignatures\",\n    value: function verifySignatures(requireAllSignatures) {\n      return this._verifySignatures(this.serializeMessage(), requireAllSignatures === undefined ? true : requireAllSignatures);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_verifySignatures\",\n    value: function _verifySignatures(signData, requireAllSignatures) {\n      var _iterator2 = _createForOfIteratorHelper$2(this.signatures),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var _step2$value = _step2.value,\n            signature = _step2$value.signature,\n            publicKey = _step2$value.publicKey;\n          if (signature === null) {\n            if (requireAllSignatures) {\n              return false;\n            }\n          } else {\n            if (!verify(signature, signData, publicKey.toBytes())) {\n              return false;\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return true;\n    }\n\n    /**\n     * Serialize the Transaction in the wire format.\n     *\n     * @param {Buffer} [config] Config of transaction.\n     *\n     * @returns {Buffer} Signature of transaction in wire format.\n     */\n  }, {\n    key: \"serialize\",\n    value: function serialize(config) {\n      var _Object$assign = Object.assign({\n          requireAllSignatures: true,\n          verifySignatures: true\n        }, config),\n        requireAllSignatures = _Object$assign.requireAllSignatures,\n        verifySignatures = _Object$assign.verifySignatures;\n      var signData = this.serializeMessage();\n      if (verifySignatures && !this._verifySignatures(signData, requireAllSignatures)) {\n        throw new Error('Signature verification failed');\n      }\n      return this._serialize(signData);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_serialize\",\n    value: function _serialize(signData) {\n      var signatures = this.signatures;\n      var signatureCount = [];\n      encodeLength(signatureCount, signatures.length);\n      var transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n      var wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(transactionLength);\n      assert(signatures.length < 256);\n      buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n      signatures.forEach(function (_ref7, index) {\n        var signature = _ref7.signature;\n        if (signature !== null) {\n          assert(signature.length === 64, \"signature has invalid length\");\n          buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n        }\n      });\n      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n      assert(wireTransaction.length <= PACKET_DATA_SIZE, \"Transaction too large: \".concat(wireTransaction.length, \" > \").concat(PACKET_DATA_SIZE));\n      return wireTransaction;\n    }\n\n    /**\n     * Deprecated method\n     * @internal\n     */\n  }, {\n    key: \"keys\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].keys.map(function (keyObj) {\n        return keyObj.pubkey;\n      });\n    }\n\n    /**\n     * Deprecated method\n     * @internal\n     */\n  }, {\n    key: \"programId\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].programId;\n    }\n\n    /**\n     * Deprecated method\n     * @internal\n     */\n  }, {\n    key: \"data\",\n    get: function get() {\n      assert(this.instructions.length === 1);\n      return this.instructions[0].data;\n    }\n\n    /**\n     * Parse a wire transaction into a Transaction object.\n     *\n     * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n     *\n     * @returns {Transaction} Transaction associated with the signature\n     */\n  }], [{\n    key: \"from\",\n    value: function from(buffer) {\n      // Slice up wire data\n      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(buffer);\n      var signatureCount = decodeLength(byteArray);\n      var signatures = [];\n      for (var i = 0; i < signatureCount; i++) {\n        var signature = byteArray.slice(0, SIGNATURE_LENGTH_IN_BYTES);\n        byteArray = byteArray.slice(SIGNATURE_LENGTH_IN_BYTES);\n        signatures.push(bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(signature)));\n      }\n      return Transaction.populate(Message.from(byteArray), signatures);\n    }\n\n    /**\n     * Populate Transaction object from message and signatures\n     *\n     * @param {Message} message Message of transaction\n     * @param {Array<string>} signatures List of signatures to assign to the transaction\n     *\n     * @returns {Transaction} The populated Transaction\n     */\n  }, {\n    key: \"populate\",\n    value: function populate(message) {\n      var signatures = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var transaction = new Transaction();\n      transaction.recentBlockhash = message.recentBlockhash;\n      if (message.header.numRequiredSignatures > 0) {\n        transaction.feePayer = message.accountKeys[0];\n      }\n      signatures.forEach(function (signature, index) {\n        var sigPubkeyPair = {\n          signature: signature == bs58__WEBPACK_IMPORTED_MODULE_10___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(signature),\n          publicKey: message.accountKeys[index]\n        };\n        transaction.signatures.push(sigPubkeyPair);\n      });\n      message.instructions.forEach(function (instruction) {\n        var keys = instruction.accounts.map(function (account) {\n          var pubkey = message.accountKeys[account];\n          return {\n            pubkey: pubkey,\n            isSigner: transaction.signatures.some(function (keyObj) {\n              return keyObj.publicKey.toString() === pubkey.toString();\n            }) || message.isAccountSigner(account),\n            isWritable: message.isAccountWritable(account)\n          };\n        });\n        transaction.instructions.push(new TransactionInstruction({\n          keys: keys,\n          programId: message.accountKeys[instruction.programIdIndex],\n          data: bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(instruction.data)\n        }));\n      });\n      transaction._message = message;\n      transaction._json = transaction.toJSON();\n      return transaction;\n    }\n  }]);\n  return Transaction;\n}();\n\nfunction _createForOfIteratorHelper$1(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }\nfunction _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar TransactionMessage = /*#__PURE__*/function () {\n  function TransactionMessage(args) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, TransactionMessage);\n    this.payerKey = void 0;\n    this.instructions = void 0;\n    this.recentBlockhash = void 0;\n    this.payerKey = args.payerKey;\n    this.instructions = args.instructions;\n    this.recentBlockhash = args.recentBlockhash;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(TransactionMessage, [{\n    key: \"compileToLegacyMessage\",\n    value: function compileToLegacyMessage() {\n      return Message.compile({\n        payerKey: this.payerKey,\n        recentBlockhash: this.recentBlockhash,\n        instructions: this.instructions\n      });\n    }\n  }, {\n    key: \"compileToV0Message\",\n    value: function compileToV0Message(addressLookupTableAccounts) {\n      return MessageV0.compile({\n        payerKey: this.payerKey,\n        recentBlockhash: this.recentBlockhash,\n        instructions: this.instructions,\n        addressLookupTableAccounts: addressLookupTableAccounts\n      });\n    }\n  }], [{\n    key: \"decompile\",\n    value: function decompile(message, args) {\n      var header = message.header,\n        compiledInstructions = message.compiledInstructions,\n        recentBlockhash = message.recentBlockhash;\n      var numRequiredSignatures = header.numRequiredSignatures,\n        numReadonlySignedAccounts = header.numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts = header.numReadonlyUnsignedAccounts;\n      var numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n      assert(numWritableSignedAccounts > 0, 'Message header is invalid');\n      var numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n      assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');\n      var accountKeys = message.getAccountKeys(args);\n      var payerKey = accountKeys.get(0);\n      if (payerKey === undefined) {\n        throw new Error('Failed to decompile message because no account keys were found');\n      }\n      var instructions = [];\n      var _iterator = _createForOfIteratorHelper$1(compiledInstructions),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var compiledIx = _step.value;\n          var keys = [];\n          var _iterator2 = _createForOfIteratorHelper$1(compiledIx.accountKeyIndexes),\n            _step2;\n          try {\n            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n              var keyIndex = _step2.value;\n              var pubkey = accountKeys.get(keyIndex);\n              if (pubkey === undefined) {\n                throw new Error(\"Failed to find key for account key index \".concat(keyIndex));\n              }\n              var isSigner = keyIndex < numRequiredSignatures;\n              var isWritable = void 0;\n              if (isSigner) {\n                isWritable = keyIndex < numWritableSignedAccounts;\n              } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n                isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n              } else {\n                isWritable = keyIndex - accountKeys.staticAccountKeys.length <\n                // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n                accountKeys.accountKeysFromLookups.writable.length;\n              }\n              keys.push({\n                pubkey: pubkey,\n                isSigner: keyIndex < header.numRequiredSignatures,\n                isWritable: isWritable\n              });\n            }\n          } catch (err) {\n            _iterator2.e(err);\n          } finally {\n            _iterator2.f();\n          }\n          var programId = accountKeys.get(compiledIx.programIdIndex);\n          if (programId === undefined) {\n            throw new Error(\"Failed to find program id for program id index \".concat(compiledIx.programIdIndex));\n          }\n          instructions.push(new TransactionInstruction({\n            programId: programId,\n            data: toBuffer(compiledIx.data),\n            keys: keys\n          }));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return new TransactionMessage({\n        payerKey: payerKey,\n        instructions: instructions,\n        recentBlockhash: recentBlockhash\n      });\n    }\n  }]);\n  return TransactionMessage;\n}();\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\n/**\n * Versioned transaction class\n */\nvar VersionedTransaction = /*#__PURE__*/function () {\n  function VersionedTransaction(message, signatures) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, VersionedTransaction);\n    this.signatures = void 0;\n    this.message = void 0;\n    if (signatures !== undefined) {\n      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');\n      this.signatures = signatures;\n    } else {\n      var defaultSignatures = [];\n      for (var i = 0; i < message.header.numRequiredSignatures; i++) {\n        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n      }\n      this.signatures = defaultSignatures;\n    }\n    this.message = message;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(VersionedTransaction, [{\n    key: \"version\",\n    get: function get() {\n      return this.message.version;\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var serializedMessage = this.message.serialize();\n      var encodedSignaturesLength = Array();\n      encodeLength(encodedSignaturesLength, this.signatures.length);\n      var transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(signature(), this.signatures.length, 'signatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(serializedMessage.length, 'serializedMessage')]);\n      var serializedTransaction = new Uint8Array(2048);\n      var serializedTransactionLength = transactionLayout.encode({\n        encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n        signatures: this.signatures,\n        serializedMessage: serializedMessage\n      }, serializedTransaction);\n      return serializedTransaction.slice(0, serializedTransactionLength);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign$1(signers) {\n      var _this = this;\n      var messageData = this.message.serialize();\n      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n      var _iterator = _createForOfIteratorHelper(signers),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var signer = _step.value;\n          var signerIndex = signerPubkeys.findIndex(function (pubkey) {\n            return pubkey.equals(signer.publicKey);\n          });\n          assert(signerIndex >= 0, \"Cannot sign with non signer key \".concat(signer.publicKey.toBase58()));\n          _this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"addSignature\",\n    value: function addSignature(publicKey, signature) {\n      assert(signature.byteLength === 64, 'Signature must be 64 bytes long');\n      var signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n      var signerIndex = signerPubkeys.findIndex(function (pubkey) {\n        return pubkey.equals(publicKey);\n      });\n      assert(signerIndex >= 0, \"Can not add signature; `\".concat(publicKey.toBase58(), \"` is not required to sign this transaction\"));\n      this.signatures[signerIndex] = signature;\n    }\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(serializedTransaction) {\n      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(serializedTransaction);\n      var signatures = [];\n      var signaturesLength = decodeLength(byteArray);\n      for (var i = 0; i < signaturesLength; i++) {\n        signatures.push(new Uint8Array(byteArray.splice(0, SIGNATURE_LENGTH_IN_BYTES)));\n      }\n      var message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n      return new VersionedTransaction(message, signatures);\n    }\n  }]);\n  return VersionedTransaction;\n}();\n\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @internal\n */\nvar NUM_TICKS_PER_SECOND = 160;\n\n/**\n * @internal\n */\nvar DEFAULT_TICKS_PER_SLOT = 64;\n\n/**\n * @internal\n */\nvar NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n\n/**\n * @internal\n */\nvar MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\n\nvar SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\nvar SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');\nvar SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nvar SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');\nvar SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');\nvar SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');\nvar SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');\nvar SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');\nvar SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');\n\nfunction _regeneratorRuntime$3() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$3 = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\nfunction sendAndConfirmTransaction(_x, _x2, _x3, _x4) {\n  return _sendAndConfirmTransaction.apply(this, arguments);\n}\nfunction _sendAndConfirmTransaction() {\n  _sendAndConfirmTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$3().mark(function _callee(connection, transaction, signers, options) {\n    var sendOptions, signature, status, nonceInstruction, nonceAccountPubkey;\n    return _regeneratorRuntime$3().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          sendOptions = options && {\n            skipPreflight: options.skipPreflight,\n            preflightCommitment: options.preflightCommitment || options.commitment,\n            maxRetries: options.maxRetries,\n            minContextSlot: options.minContextSlot\n          };\n          _context.next = 3;\n          return connection.sendTransaction(transaction, signers, sendOptions);\n        case 3:\n          signature = _context.sent;\n          if (!(transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null)) {\n            _context.next = 10;\n            break;\n          }\n          _context.next = 7;\n          return connection.confirmTransaction({\n            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n            signature: signature,\n            blockhash: transaction.recentBlockhash,\n            lastValidBlockHeight: transaction.lastValidBlockHeight\n          }, options && options.commitment);\n        case 7:\n          status = _context.sent.value;\n          _context.next = 22;\n          break;\n        case 10:\n          if (!(transaction.minNonceContextSlot != null && transaction.nonceInfo != null)) {\n            _context.next = 18;\n            break;\n          }\n          nonceInstruction = transaction.nonceInfo.nonceInstruction;\n          nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n          _context.next = 15;\n          return connection.confirmTransaction({\n            abortSignal: options === null || options === void 0 ? void 0 : options.abortSignal,\n            minContextSlot: transaction.minNonceContextSlot,\n            nonceAccountPubkey: nonceAccountPubkey,\n            nonceValue: transaction.nonceInfo.nonce,\n            signature: signature\n          }, options && options.commitment);\n        case 15:\n          status = _context.sent.value;\n          _context.next = 22;\n          break;\n        case 18:\n          if ((options === null || options === void 0 ? void 0 : options.abortSignal) != null) {\n            console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');\n          }\n          _context.next = 21;\n          return connection.confirmTransaction(signature, options && options.commitment);\n        case 21:\n          status = _context.sent.value;\n        case 22:\n          if (!status.err) {\n            _context.next = 24;\n            break;\n          }\n          throw new Error(\"Transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n        case 24:\n          return _context.abrupt(\"return\", signature);\n        case 25:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _sendAndConfirmTransaction.apply(this, arguments);\n}\n\n// zzz\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n\n/**\n * @internal\n */\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */\nfunction encodeData(type, fields) {\n  var allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n  var data = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(allocLength);\n  var layoutFields = Object.assign({\n    instruction: type.index\n  }, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */\nfunction decodeData$1(type, buffer) {\n  var data;\n  try {\n    data = type.layout.decode(buffer);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (data.instruction !== type.index) {\n    throw new Error(\"invalid instruction; instruction index mismatch \".concat(data.instruction, \" != \").concat(type.index));\n  }\n  return data;\n}\n\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */\nvar FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('lamportsPerSignature');\n\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */\nvar NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('version'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([FeeCalculatorLayout], 'feeCalculator')]);\nvar NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */\n\n/**\n * NonceAccount class\n */\nvar NonceAccount = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function NonceAccount(args) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, NonceAccount);\n    this.authorizedPubkey = void 0;\n    this.nonce = void 0;\n    this.feeCalculator = void 0;\n    this.authorizedPubkey = args.authorizedPubkey;\n    this.nonce = args.nonce;\n    this.feeCalculator = args.feeCalculator;\n  }\n\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(NonceAccount, null, [{\n    key: \"fromAccountData\",\n    value: function fromAccountData(buffer) {\n      var nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n      return new NonceAccount({\n        authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n        nonce: new PublicKey(nonceAccount.nonce).toString(),\n        feeCalculator: nonceAccount.feeCalculator\n      });\n    }\n  }]);\n  return NonceAccount;\n}();\n\nvar encodeDecode = function encodeDecode(layout) {\n  var decode = layout.decode.bind(layout);\n  var encode = layout.encode.bind(layout);\n  return {\n    decode: decode,\n    encode: encode\n  };\n};\nvar bigInt = function bigInt(length) {\n  return function (property) {\n    var layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob)(length, property);\n    var _encodeDecode = encodeDecode(layout),\n      encode = _encodeDecode.encode,\n      decode = _encodeDecode.decode;\n    var bigIntLayout = layout;\n    bigIntLayout.decode = function (buffer, offset) {\n      var src = decode(buffer, offset);\n      return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_15__.toBigIntLE)(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(src));\n    };\n    bigIntLayout.encode = function (bigInt, buffer, offset) {\n      var src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_15__.toBufferLE)(bigInt, length);\n      return encode(src, buffer, offset);\n    };\n    return bigIntLayout;\n  };\n};\nvar u64 = bigInt(8);\n\n/**\n * Create account system transaction params\n */\n\n/**\n * Transfer system transaction params\n */\n\n/**\n * Assign system transaction params\n */\n\n/**\n * Create account with seed system transaction params\n */\n\n/**\n * Create nonce account system transaction params\n */\n\n/**\n * Create nonce account with seed system transaction params\n */\n\n/**\n * Initialize nonce account system instruction params\n */\n\n/**\n * Advance nonce account system instruction params\n */\n\n/**\n * Withdraw nonce account system transaction params\n */\n\n/**\n * Authorize nonce account system transaction params\n */\n\n/**\n * Allocate account system transaction params\n */\n\n/**\n * Allocate account with seed system transaction params\n */\n\n/**\n * Assign account with seed system transaction params\n */\n\n/**\n * Transfer with seed system transaction params\n */\n\n/** Decoded transfer system transaction instruction */\n\n/** Decoded transferWithSeed system transaction instruction */\n\n/**\n * System Instruction class\n */\nvar SystemInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function SystemInstruction() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, SystemInstruction);\n  }\n\n  /**\n   * Decode a system instruction and retrieve the instruction type.\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(SystemInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n      for (var _i = 0, _Object$entries = Object.entries(SYSTEM_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_Object$entries[_i], 2),\n          ixType = _Object$entries$_i[0],\n          layout = _Object$entries$_i[1];\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a SystemInstruction');\n      }\n      return type;\n    }\n\n    /**\n     * Decode a create account system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeCreateAccount\",\n    value: function decodeCreateAccount(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n      var _decodeData = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data),\n        lamports = _decodeData.lamports,\n        space = _decodeData.space,\n        programId = _decodeData.programId;\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        newAccountPubkey: instruction.keys[1].pubkey,\n        lamports: lamports,\n        space: space,\n        programId: new PublicKey(programId)\n      };\n    }\n\n    /**\n     * Decode a transfer system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeTransfer\",\n    value: function decodeTransfer(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n      var _decodeData2 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data),\n        lamports = _decodeData2.lamports;\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        toPubkey: instruction.keys[1].pubkey,\n        lamports: lamports\n      };\n    }\n\n    /**\n     * Decode a transfer with seed system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeTransferWithSeed\",\n    value: function decodeTransferWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData3 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data),\n        lamports = _decodeData3.lamports,\n        seed = _decodeData3.seed,\n        programId = _decodeData3.programId;\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        basePubkey: instruction.keys[1].pubkey,\n        toPubkey: instruction.keys[2].pubkey,\n        lamports: lamports,\n        seed: seed,\n        programId: new PublicKey(programId)\n      };\n    }\n\n    /**\n     * Decode an allocate system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAllocate\",\n    value: function decodeAllocate(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n      var _decodeData4 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data),\n        space = _decodeData4.space;\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        space: space\n      };\n    }\n\n    /**\n     * Decode an allocate with seed system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAllocateWithSeed\",\n    value: function decodeAllocateWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n      var _decodeData5 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data),\n        base = _decodeData5.base,\n        seed = _decodeData5.seed,\n        space = _decodeData5.space,\n        programId = _decodeData5.programId;\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        basePubkey: new PublicKey(base),\n        seed: seed,\n        space: space,\n        programId: new PublicKey(programId)\n      };\n    }\n\n    /**\n     * Decode an assign system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAssign\",\n    value: function decodeAssign(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n      var _decodeData6 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data),\n        programId = _decodeData6.programId;\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        programId: new PublicKey(programId)\n      };\n    }\n\n    /**\n     * Decode an assign with seed system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAssignWithSeed\",\n    value: function decodeAssignWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 1);\n      var _decodeData7 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data),\n        base = _decodeData7.base,\n        seed = _decodeData7.seed,\n        programId = _decodeData7.programId;\n      return {\n        accountPubkey: instruction.keys[0].pubkey,\n        basePubkey: new PublicKey(base),\n        seed: seed,\n        programId: new PublicKey(programId)\n      };\n    }\n\n    /**\n     * Decode a create account with seed system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeCreateWithSeed\",\n    value: function decodeCreateWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n      var _decodeData8 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data),\n        base = _decodeData8.base,\n        seed = _decodeData8.seed,\n        lamports = _decodeData8.lamports,\n        space = _decodeData8.space,\n        programId = _decodeData8.programId;\n      return {\n        fromPubkey: instruction.keys[0].pubkey,\n        newAccountPubkey: instruction.keys[1].pubkey,\n        basePubkey: new PublicKey(base),\n        seed: seed,\n        lamports: lamports,\n        space: space,\n        programId: new PublicKey(programId)\n      };\n    }\n\n    /**\n     * Decode a nonce initialize system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeNonceInitialize\",\n    value: function decodeNonceInitialize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData9 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data),\n        authorized = _decodeData9.authorized;\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: new PublicKey(authorized)\n      };\n    }\n\n    /**\n     * Decode a nonce advance system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeNonceAdvance\",\n    value: function decodeNonceAdvance(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey\n      };\n    }\n\n    /**\n     * Decode a nonce withdraw system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeNonceWithdraw\",\n    value: function decodeNonceWithdraw(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 5);\n      var _decodeData10 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data),\n        lamports = _decodeData10.lamports;\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        toPubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[4].pubkey,\n        lamports: lamports\n      };\n    }\n\n    /**\n     * Decode a nonce authorize system instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeNonceAuthorize\",\n    value: function decodeNonceAuthorize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n      var _decodeData11 = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data),\n        authorized = _decodeData11.authorized;\n      return {\n        noncePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[1].pubkey,\n        newAuthorizedPubkey: new PublicKey(authorized)\n      };\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(SystemProgram.programId)) {\n        throw new Error('invalid instruction; programId is not SystemProgram');\n      }\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkKeyLength\",\n    value: function checkKeyLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n  return SystemInstruction;\n}();\n\n/**\n * An enumeration of valid SystemInstructionType's\n */\n\n/**\n * An enumeration of valid system InstructionType's\n * @internal\n */\nvar SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n  Create: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('space'), publicKey('programId')])\n  },\n  Assign: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('programId')])\n  },\n  Transfer: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), u64('lamports')])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('space'), publicKey('programId')])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('lamports')])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('authorized')])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('authorized')])\n  },\n  Allocate: {\n    index: 8,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('space')])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('space'), publicKey('programId')])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  }\n});\n\n/**\n * Factory class for transactions to interact with the System program\n */\nvar SystemProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function SystemProgram() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, SystemProgram);\n  }\n\n  /**\n   * Public key that identifies the System program\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(SystemProgram, null, [{\n    key: \"createAccount\",\n    value:\n    /**\n     * Generate a transaction instruction that creates a new account\n     */\n    function createAccount(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n      var data = encodeData(type, {\n        lamports: params.lamports,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.fromPubkey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: params.newAccountPubkey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction instruction that transfers lamports from one account to another\n     */\n  }, {\n    key: \"transfer\",\n    value: function transfer(params) {\n      var data;\n      var keys;\n      if ('basePubkey' in params) {\n        var type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n        data = encodeData(type, {\n          lamports: BigInt(params.lamports),\n          seed: params.seed,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.fromPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }];\n      } else {\n        var _type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n        data = encodeData(_type, {\n          lamports: BigInt(params.lamports)\n        });\n        keys = [{\n          pubkey: params.fromPubkey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }];\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction instruction that assigns an account to a program\n     */\n  }, {\n    key: \"assign\",\n    value: function assign(params) {\n      var data;\n      var keys;\n      if ('basePubkey' in params) {\n        var type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n        data = encodeData(type, {\n          base: toBuffer(params.basePubkey.toBuffer()),\n          seed: params.seed,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }];\n      } else {\n        var _type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n        data = encodeData(_type2, {\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: true,\n          isWritable: true\n        }];\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction instruction that creates a new account at\n     *   an address generated with `from`, a seed, and programId\n     */\n  }, {\n    key: \"createAccountWithSeed\",\n    value: function createAccountWithSeed(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n      var data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        lamports: params.lamports,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      var keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.newAccountPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n      if (params.basePubkey != params.fromPubkey) {\n        keys.push({\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        });\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction that creates a new Nonce account\n     */\n  }, {\n    key: \"createNonceAccount\",\n    value: function createNonceAccount(params) {\n      var transaction = new Transaction();\n      if ('basePubkey' in params && 'seed' in params) {\n        transaction.add(SystemProgram.createAccountWithSeed({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          basePubkey: params.basePubkey,\n          seed: params.seed,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId\n        }));\n      } else {\n        transaction.add(SystemProgram.createAccount({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId\n        }));\n      }\n      var initParams = {\n        noncePubkey: params.noncePubkey,\n        authorizedPubkey: params.authorizedPubkey\n      };\n      transaction.add(this.nonceInitialize(initParams));\n      return transaction;\n    }\n\n    /**\n     * Generate an instruction to initialize a Nonce account\n     */\n  }, {\n    key: \"nonceInitialize\",\n    value: function nonceInitialize(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n      var data = encodeData(type, {\n        authorized: toBuffer(params.authorizedPubkey.toBuffer())\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n\n    /**\n     * Generate an instruction to advance the nonce in a Nonce account\n     */\n  }, {\n    key: \"nonceAdvance\",\n    value: function nonceAdvance(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n      var data = encodeData(type);\n      var instructionData = {\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n\n    /**\n     * Generate a transaction instruction that withdraws lamports from a Nonce account\n     */\n  }, {\n    key: \"nonceWithdraw\",\n    value: function nonceWithdraw(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n      var data = encodeData(type, {\n        lamports: params.lamports\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction instruction that authorizes a new PublicKey as the authority\n     * on a Nonce account.\n     */\n  }, {\n    key: \"nonceAuthorize\",\n    value: function nonceAuthorize(params) {\n      var type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n      var data = encodeData(type, {\n        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction instruction that allocates space in an account without funding\n     */\n  }, {\n    key: \"allocate\",\n    value: function allocate(params) {\n      var data;\n      var keys;\n      if ('basePubkey' in params) {\n        var type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n        data = encodeData(type, {\n          base: toBuffer(params.basePubkey.toBuffer()),\n          seed: params.seed,\n          space: params.space,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }];\n      } else {\n        var _type3 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n        data = encodeData(_type3, {\n          space: params.space\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: true,\n          isWritable: true\n        }];\n      }\n      return new TransactionInstruction({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n  return SystemProgram;\n}();\nSystemProgram.programId = new PublicKey('11111111111111111111111111111111');\n\nfunction _regeneratorRuntime$2() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$2 = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nvar CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n\n/**\n * Program loader interface\n */\nvar Loader = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function Loader() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Loader);\n  }\n\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Loader, null, [{\n    key: \"getMinNumSignatures\",\n    value:\n    /**\n     * Minimum number of signatures required to load a program not including\n     * retries\n     *\n     * Can be used to calculate transaction fees\n     */\n    function getMinNumSignatures(dataLength) {\n      return 2 * (\n      // Every transaction requires two signatures (payer + program)\n      Math.ceil(dataLength / Loader.chunkSize) + 1 +\n      // Add one for Create transaction\n      1) // Add one for Finalize transaction\n      ;\n    }\n\n    /**\n     * Loads a generic program\n     *\n     * @param connection The connection to use\n     * @param payer System account that pays to load the program\n     * @param program Account to load the program into\n     * @param programId Public key that identifies the loader\n     * @param data Program octets\n     * @return true if program was loaded successfully, false if program was already loaded\n     */\n  }, {\n    key: \"load\",\n    value: function () {\n      var _load = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$2().mark(function _callee(connection, payer, program, programId, data) {\n        var balanceNeeded, programInfo, transaction, dataLayout, chunkSize, offset, array, transactions, bytes, _data, _transaction, REQUESTS_PER_SECOND, _dataLayout, _data2, _transaction2, deployCommitment, finalizeSignature, _yield$connection$con, context, value, currentSlot;\n        return _regeneratorRuntime$2().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return connection.getMinimumBalanceForRentExemption(data.length);\n            case 2:\n              balanceNeeded = _context.sent;\n              _context.next = 5;\n              return connection.getAccountInfo(program.publicKey, 'confirmed');\n            case 5:\n              programInfo = _context.sent;\n              transaction = null;\n              if (!(programInfo !== null)) {\n                _context.next = 16;\n                break;\n              }\n              if (!programInfo.executable) {\n                _context.next = 11;\n                break;\n              }\n              console.error('Program load failed, account is already executable');\n              return _context.abrupt(\"return\", false);\n            case 11:\n              if (programInfo.data.length !== data.length) {\n                transaction = transaction || new Transaction();\n                transaction.add(SystemProgram.allocate({\n                  accountPubkey: program.publicKey,\n                  space: data.length\n                }));\n              }\n              if (!programInfo.owner.equals(programId)) {\n                transaction = transaction || new Transaction();\n                transaction.add(SystemProgram.assign({\n                  accountPubkey: program.publicKey,\n                  programId: programId\n                }));\n              }\n              if (programInfo.lamports < balanceNeeded) {\n                transaction = transaction || new Transaction();\n                transaction.add(SystemProgram.transfer({\n                  fromPubkey: payer.publicKey,\n                  toPubkey: program.publicKey,\n                  lamports: balanceNeeded - programInfo.lamports\n                }));\n              }\n              _context.next = 17;\n              break;\n            case 16:\n              transaction = new Transaction().add(SystemProgram.createAccount({\n                fromPubkey: payer.publicKey,\n                newAccountPubkey: program.publicKey,\n                lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n                space: data.length,\n                programId: programId\n              }));\n            case 17:\n              if (!(transaction !== null)) {\n                _context.next = 20;\n                break;\n              }\n              _context.next = 20;\n              return sendAndConfirmTransaction(connection, transaction, [payer, program], {\n                commitment: 'confirmed'\n              });\n            case 20:\n              dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('offset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('bytesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('bytesLengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('byte'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32(), -8), 'bytes')]);\n              chunkSize = Loader.chunkSize;\n              offset = 0;\n              array = data;\n              transactions = [];\n            case 25:\n              if (!(array.length > 0)) {\n                _context.next = 39;\n                break;\n              }\n              bytes = array.slice(0, chunkSize);\n              _data = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(chunkSize + 16);\n              dataLayout.encode({\n                instruction: 0,\n                // Load instruction\n                offset: offset,\n                bytes: bytes,\n                bytesLength: 0,\n                bytesLengthPadding: 0\n              }, _data);\n              _transaction = new Transaction().add({\n                keys: [{\n                  pubkey: program.publicKey,\n                  isSigner: true,\n                  isWritable: true\n                }],\n                programId: programId,\n                data: _data\n              });\n              transactions.push(sendAndConfirmTransaction(connection, _transaction, [payer, program], {\n                commitment: 'confirmed'\n              }));\n\n              // Delay between sends in an attempt to reduce rate limit errors\n              if (!connection._rpcEndpoint.includes('solana.com')) {\n                _context.next = 35;\n                break;\n              }\n              REQUESTS_PER_SECOND = 4;\n              _context.next = 35;\n              return sleep(1000 / REQUESTS_PER_SECOND);\n            case 35:\n              offset += chunkSize;\n              array = array.slice(chunkSize);\n              _context.next = 25;\n              break;\n            case 39:\n              _context.next = 41;\n              return Promise.all(transactions);\n            case 41:\n              _dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')]);\n              _data2 = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(_dataLayout.span);\n              _dataLayout.encode({\n                instruction: 1 // Finalize instruction\n              }, _data2);\n              _transaction2 = new Transaction().add({\n                keys: [{\n                  pubkey: program.publicKey,\n                  isSigner: true,\n                  isWritable: true\n                }, {\n                  pubkey: SYSVAR_RENT_PUBKEY,\n                  isSigner: false,\n                  isWritable: false\n                }],\n                programId: programId,\n                data: _data2\n              });\n              deployCommitment = 'processed';\n              _context.next = 48;\n              return connection.sendTransaction(_transaction2, [payer, program], {\n                preflightCommitment: deployCommitment\n              });\n            case 48:\n              finalizeSignature = _context.sent;\n              _context.next = 51;\n              return connection.confirmTransaction({\n                signature: finalizeSignature,\n                lastValidBlockHeight: _transaction2.lastValidBlockHeight,\n                blockhash: _transaction2.recentBlockhash\n              }, deployCommitment);\n            case 51:\n              _yield$connection$con = _context.sent;\n              context = _yield$connection$con.context;\n              value = _yield$connection$con.value;\n              if (!value.err) {\n                _context.next = 56;\n                break;\n              }\n              throw new Error(\"Transaction \".concat(finalizeSignature, \" failed (\").concat(JSON.stringify(value), \")\"));\n            case 56:\n              _context.prev = 57;\n              _context.next = 60;\n              return connection.getSlot({\n                commitment: deployCommitment\n              });\n            case 60:\n              currentSlot = _context.sent;\n              if (!(currentSlot > context.slot)) {\n                _context.next = 63;\n                break;\n              }\n              return _context.abrupt(\"break\", 71);\n            case 63:\n              _context.next = 67;\n              break;\n            case 65:\n              _context.prev = 65;\n              _context.t0 = _context[\"catch\"](57);\n            case 67:\n              _context.next = 69;\n              return new Promise(function (resolve) {\n                return setTimeout(resolve, Math.round(MS_PER_SLOT / 2));\n              });\n            case 69:\n              _context.next = 56;\n              break;\n            case 71:\n              return _context.abrupt(\"return\", true);\n            case 72:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, null, [[57, 65]]);\n      }));\n      function load(_x, _x2, _x3, _x4, _x5) {\n        return _load.apply(this, arguments);\n      }\n      return load;\n    }()\n  }]);\n  return Loader;\n}();\nLoader.chunkSize = CHUNK_SIZE;\n\nvar BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');\n\n/**\n * Factory class for transactions to interact with a program loader\n */\nvar BpfLoader = /*#__PURE__*/function () {\n  function BpfLoader() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, BpfLoader);\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(BpfLoader, null, [{\n    key: \"getMinNumSignatures\",\n    value:\n    /**\n     * Minimum number of signatures required to load a program not including\n     * retries\n     *\n     * Can be used to calculate transaction fees\n     */\n    function getMinNumSignatures(dataLength) {\n      return Loader.getMinNumSignatures(dataLength);\n    }\n\n    /**\n     * Load a SBF program\n     *\n     * @param connection The connection to use\n     * @param payer Account that will pay program loading fees\n     * @param program Account to load the program into\n     * @param elf The entire ELF containing the SBF program\n     * @param loaderProgramId The program id of the BPF loader to use\n     * @return true if program was loaded successfully, false if program was already loaded\n     */\n  }, {\n    key: \"load\",\n    value: function load(connection, payer, program, elf, loaderProgramId) {\n      return Loader.load(connection, payer, program, loaderProgramId, elf);\n    }\n  }]);\n  return BpfLoader;\n}();\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n\t\tvar keys = [];\n\t\tfor (var name in obj) {\n\t\t\tkeys.push(name);\n\t\t}\n\t\treturn keys;\n\t};\n\nfunction stringify(val, isArrayProp) {\n\tvar i, max, str, keys, key, propVal, toStr;\n\tif (val === true) {\n\t\treturn \"true\";\n\t}\n\tif (val === false) {\n\t\treturn \"false\";\n\t}\n\tswitch (typeof val) {\n\t\tcase \"object\":\n\t\t\tif (val === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (val.toJSON && typeof val.toJSON === \"function\") {\n\t\t\t\treturn stringify(val.toJSON(), isArrayProp);\n\t\t\t} else {\n\t\t\t\ttoStr = objToString.call(val);\n\t\t\t\tif (toStr === \"[object Array]\") {\n\t\t\t\t\tstr = '[';\n\t\t\t\t\tmax = val.length - 1;\n\t\t\t\t\tfor(i = 0; i < max; i++) {\n\t\t\t\t\t\tstr += stringify(val[i], true) + ',';\n\t\t\t\t\t}\n\t\t\t\t\tif (max > -1) {\n\t\t\t\t\t\tstr += stringify(val[i], true);\n\t\t\t\t\t}\n\t\t\t\t\treturn str + ']';\n\t\t\t\t} else if (toStr === \"[object Object]\") {\n\t\t\t\t\t// only object is left\n\t\t\t\t\tkeys = objKeys(val).sort();\n\t\t\t\t\tmax = keys.length;\n\t\t\t\t\tstr = \"\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < max) {\n\t\t\t\t\t\tkey = keys[i];\n\t\t\t\t\t\tpropVal = stringify(val[key], false);\n\t\t\t\t\t\tif (propVal !== undefined) {\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tstr += ',';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr += JSON.stringify(key) + ':' + propVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\treturn '{' + str + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn JSON.stringify(val);\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"function\":\n\t\tcase \"undefined\":\n\t\t\treturn isArrayProp ? null : undefined;\n\t\tcase \"string\":\n\t\t\treturn JSON.stringify(val);\n\t\tdefault:\n\t\t\treturn isFinite(val) ? val : null;\n\t}\n}\n\nvar fastStableStringify = function(val) {\n\tvar returnVal = stringify(val, false);\n\tif (returnVal !== undefined) {\n\t\treturn ''+ returnVal;\n\t}\n};\n\nvar fastStableStringify$1 = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringify);\n\nvar MINIMUM_SLOT_PER_EPOCH = 32;\n\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n  var trailingZeros = 0;\n  while (n > 1) {\n    n /= 2;\n    trailingZeros++;\n  }\n  return trailingZeros;\n}\n\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n  if (n === 0) return 1;\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n + 1;\n}\n\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */\nvar EpochSchedule = /*#__PURE__*/function () {\n  function EpochSchedule(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, EpochSchedule);\n    /** The maximum number of slots in each epoch */\n    this.slotsPerEpoch = void 0;\n    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */\n    this.leaderScheduleSlotOffset = void 0;\n    /** Indicates whether epochs start short and grow */\n    this.warmup = void 0;\n    /** The first epoch with `slotsPerEpoch` slots */\n    this.firstNormalEpoch = void 0;\n    /** The first slot of `firstNormalEpoch` */\n    this.firstNormalSlot = void 0;\n    this.slotsPerEpoch = slotsPerEpoch;\n    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n    this.warmup = warmup;\n    this.firstNormalEpoch = firstNormalEpoch;\n    this.firstNormalSlot = firstNormalSlot;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(EpochSchedule, [{\n    key: \"getEpoch\",\n    value: function getEpoch(slot) {\n      return this.getEpochAndSlotIndex(slot)[0];\n    }\n  }, {\n    key: \"getEpochAndSlotIndex\",\n    value: function getEpochAndSlotIndex(slot) {\n      if (slot < this.firstNormalSlot) {\n        var epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n        var epochLen = this.getSlotsInEpoch(epoch);\n        var slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n        return [epoch, slotIndex];\n      } else {\n        var normalSlotIndex = slot - this.firstNormalSlot;\n        var normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n        var _epoch = this.firstNormalEpoch + normalEpochIndex;\n        var _slotIndex = normalSlotIndex % this.slotsPerEpoch;\n        return [_epoch, _slotIndex];\n      }\n    }\n  }, {\n    key: \"getFirstSlotInEpoch\",\n    value: function getFirstSlotInEpoch(epoch) {\n      if (epoch <= this.firstNormalEpoch) {\n        return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n      } else {\n        return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n      }\n    }\n  }, {\n    key: \"getLastSlotInEpoch\",\n    value: function getLastSlotInEpoch(epoch) {\n      return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n    }\n  }, {\n    key: \"getSlotsInEpoch\",\n    value: function getSlotsInEpoch(epoch) {\n      if (epoch < this.firstNormalEpoch) {\n        return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n      } else {\n        return this.slotsPerEpoch;\n      }\n    }\n  }]);\n  return EpochSchedule;\n}();\n\nfunction _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct$1() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar SendTransactionError = /*#__PURE__*/function (_Error) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(SendTransactionError, _Error);\n  var _super = _createSuper$1(SendTransactionError);\n  function SendTransactionError(message, logs) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, SendTransactionError);\n    _this = _super.call(this, message);\n    _this.logs = void 0;\n    _this.logs = logs;\n    return _this;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(SendTransactionError);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(Error));\n\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nvar SolanaJSONRPCErrorCode = {\n  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n  JSON_RPC_SCAN_ERROR: -32012,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nvar SolanaJSONRPCError = /*#__PURE__*/function (_Error2) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(SolanaJSONRPCError, _Error2);\n  var _super2 = _createSuper$1(SolanaJSONRPCError);\n  function SolanaJSONRPCError(_ref, customMessage) {\n    var _this2;\n    var code = _ref.code,\n      message = _ref.message,\n      data = _ref.data;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, SolanaJSONRPCError);\n    _this2 = _super2.call(this, customMessage != null ? \"\".concat(customMessage, \": \").concat(message) : message);\n    _this2.code = void 0;\n    _this2.data = void 0;\n    _this2.code = code;\n    _this2.data = data;\n    _this2.name = 'SolanaJSONRPCError';\n    return _this2;\n  }\n  return (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(SolanaJSONRPCError);\n}( /*#__PURE__*/(0,_babel_runtime_helpers_wrapNativeSuper__WEBPACK_IMPORTED_MODULE_20__[\"default\"])(Error));\n\nvar fetchImpl = globalThis.fetch;\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0,_babel_runtime_helpers_possibleConstructorReturn__WEBPACK_IMPORTED_MODULE_7__[\"default\"])(this, result); }; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nvar RpcWebSocketClient = /*#__PURE__*/function (_RpcWebSocketCommonCl) {\n  (0,_babel_runtime_helpers_inherits__WEBPACK_IMPORTED_MODULE_6__[\"default\"])(RpcWebSocketClient, _RpcWebSocketCommonCl);\n  var _super = _createSuper(RpcWebSocketClient);\n  function RpcWebSocketClient(address, options, generate_request_id) {\n    var _this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, RpcWebSocketClient);\n    var webSocketFactory = function webSocketFactory(url) {\n      var rpc = (0,rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_23__[\"default\"])(url, _objectSpread$1({\n        autoconnect: true,\n        max_reconnects: 5,\n        reconnect: true,\n        reconnect_interval: 1000\n      }, options));\n      if ('socket' in rpc) {\n        _this.underlyingSocket = rpc.socket;\n      } else {\n        _this.underlyingSocket = rpc;\n      }\n      return rpc;\n    };\n    _this = _super.call(this, webSocketFactory, address, options, generate_request_id);\n    _this.underlyingSocket = void 0;\n    return _this;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(RpcWebSocketClient, [{\n    key: \"call\",\n    value: function call() {\n      var _this$underlyingSocke;\n      var readyState = (_this$underlyingSocke = this.underlyingSocket) === null || _this$underlyingSocke === void 0 ? void 0 : _this$underlyingSocke.readyState;\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      if (readyState === 1 /* WebSocket.OPEN */) {\n        var _get2;\n        return (_get2 = (0,_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_21__[\"default\"])((0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(RpcWebSocketClient.prototype), \"call\", this)).call.apply(_get2, [this].concat(args));\n      }\n      return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n    }\n  }, {\n    key: \"notify\",\n    value: function notify() {\n      var _this$underlyingSocke2;\n      var readyState = (_this$underlyingSocke2 = this.underlyingSocket) === null || _this$underlyingSocke2 === void 0 ? void 0 : _this$underlyingSocke2.readyState;\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      if (readyState === 1 /* WebSocket.OPEN */) {\n        var _get3;\n        return (_get3 = (0,_babel_runtime_helpers_get__WEBPACK_IMPORTED_MODULE_21__[\"default\"])((0,_babel_runtime_helpers_getPrototypeOf__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(RpcWebSocketClient.prototype), \"notify\", this)).call.apply(_get3, [this].concat(args));\n      }\n      return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n    }\n  }]);\n  return RpcWebSocketClient;\n}(rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_22__[\"default\"]);\n\n/**\n * @internal\n */\n\n/**\n * Decode account data buffer using an AccountType\n * @internal\n */\nfunction decodeData(type, data) {\n  var decoded;\n  try {\n    decoded = type.layout.decode(data);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (decoded.typeIndex !== type.index) {\n    throw new Error(\"invalid account data; account type mismatch \".concat(decoded.typeIndex, \" != \").concat(type.index));\n  }\n  return decoded;\n}\n\n/// The serialized size of lookup table metadata\nvar LOOKUP_TABLE_META_SIZE = 56;\nvar AddressLookupTableAccount = /*#__PURE__*/function () {\n  function AddressLookupTableAccount(args) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, AddressLookupTableAccount);\n    this.key = void 0;\n    this.state = void 0;\n    this.key = args.key;\n    this.state = args.state;\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(AddressLookupTableAccount, [{\n    key: \"isActive\",\n    value: function isActive() {\n      var U64_MAX = BigInt('0xffffffffffffffff');\n      return this.state.deactivationSlot === U64_MAX;\n    }\n  }], [{\n    key: \"deserialize\",\n    value: function deserialize(accountData) {\n      var meta = decodeData(LookupTableMetaLayout, accountData);\n      var serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n      assert(serializedAddressesLen >= 0, 'lookup table is invalid');\n      assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');\n      var numSerializedAddresses = serializedAddressesLen / 32;\n      var _BufferLayout$struct$ = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE)),\n        addresses = _BufferLayout$struct$.addresses;\n      return {\n        deactivationSlot: meta.deactivationSlot,\n        lastExtendedSlot: meta.lastExtendedSlot,\n        lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n        authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n        addresses: addresses.map(function (address) {\n          return new PublicKey(address);\n        })\n      };\n    }\n  }]);\n  return AddressLookupTableAccount;\n}();\nvar LookupTableMetaLayout = {\n  index: 1,\n  layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('typeIndex'), u64('deactivationSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('lastExtendedSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('lastExtendedStartIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8(),\n  // option\n  _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8(), -1), 'authority')])\n};\n\nvar URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n  var matches = endpoint.match(URL_RE);\n  if (matches == null) {\n    throw TypeError(\"Failed to validate endpoint URL `\".concat(endpoint, \"`\"));\n  }\n  var _matches = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(matches, 4);\n    _matches[0];\n    var // eslint-disable-line @typescript-eslint/no-unused-vars\n    hostish = _matches[1],\n    portWithColon = _matches[2],\n    rest = _matches[3];\n  var protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';\n  var startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n  var websocketPort =\n  // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n  // is explictly specifying the endpoint port (HTTP-based RPC), assuming\n  // we're directly trying to connect to solana-validator's ws listening port.\n  // When the endpoint omits the port, we're connecting to the protocol\n  // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n  // proxy which manages WebSocket upgrade and backend port redirection.\n  startPort == null ? '' : \":\".concat(startPort + 1);\n  return \"\".concat(protocol, \"//\").concat(hostish).concat(websocketPort).concat(rest);\n}\n\nvar _process$env$npm_pack;\nvar _excluded = [\"commitment\"],\n  _excluded2 = [\"encoding\"],\n  _excluded3 = [\"commitment\"],\n  _excluded4 = [\"commitment\"];\nfunction _regeneratorRuntime$1() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime$1 = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { (0,_babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_16__[\"default\"])(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nvar PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(), function (value) {\n  return new PublicKey(value);\n});\nvar RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.tuple)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('base64')]);\nvar BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.instance)(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer), RawAccountDataResult, function (value) {\n  return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(value[0], 'base64');\n});\n\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */\nvar BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */\n\n/** @internal */\n/** @internal */\n/** @internal */\n/** @internal */\n\n/** @internal */\n/**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */\n\n/**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */\n\n/**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */\n\n/**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */\n\n/**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */\n\n/**\n * @internal\n */\n\n/**\n * Extra contextual information for RPC responses\n */\n\n/**\n * Options for sending transactions\n */\n\n/**\n * Options for confirming transactions\n */\n\n/**\n * Options for getConfirmedSignaturesForAddress2\n */\n\n/**\n * Options for getSignaturesForAddress\n */\n\n/**\n * RPC Response with extra contextual information\n */\n\n/**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */\n\n/**\n * A strategy for confirming durable nonce transactions.\n */\n\n/**\n * Properties shared by all transaction confirmation strategies\n */\n\n/**\n * This type represents all transaction confirmation strategies\n */\n\n/* @internal */\nfunction assertEndpointUrl(putativeUrl) {\n  if (/^https?:/.test(putativeUrl) === false) {\n    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');\n  }\n  return putativeUrl;\n}\n\n/** @internal */\nfunction extractCommitmentFromConfig(commitmentOrConfig) {\n  var commitment;\n  var config;\n  if (typeof commitmentOrConfig === 'string') {\n    commitment = commitmentOrConfig;\n  } else if (commitmentOrConfig) {\n    var specifiedCommitment = commitmentOrConfig.commitment,\n      specifiedConfig = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(commitmentOrConfig, _excluded);\n    commitment = specifiedCommitment;\n    config = specifiedConfig;\n  }\n  return {\n    commitment: commitment,\n    config: config\n  };\n}\n\n/**\n * @internal\n */\nfunction createRpcResult(result) {\n  return (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('2.0'),\n    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n    result: result\n  }), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('2.0'),\n    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n    error: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n      code: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.unknown)(),\n      message: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.any)())\n    })\n  })]);\n}\nvar UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.unknown)());\n\n/**\n * @internal\n */\nfunction jsonRpcResult(schema) {\n  return (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.coerce)(createRpcResult(schema), UnknownRpcResult, function (value) {\n    if ('error' in value) {\n      return value;\n    } else {\n      return _objectSpread(_objectSpread({}, value), {}, {\n        result: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(value.result, schema)\n      });\n    }\n  });\n}\n\n/**\n * @internal\n */\nfunction jsonRpcResultAndContext(value) {\n  return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n    }),\n    value: value\n  }));\n}\n\n/**\n * @internal\n */\nfunction notificationResultAndContext(value) {\n  return (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n    }),\n    value: value\n  });\n}\n\n/**\n * @internal\n */\nfunction versionedMessageFromResponse(version, response) {\n  if (version === 0) {\n    return new MessageV0({\n      header: response.header,\n      staticAccountKeys: response.accountKeys.map(function (accountKey) {\n        return new PublicKey(accountKey);\n      }),\n      recentBlockhash: response.recentBlockhash,\n      compiledInstructions: response.instructions.map(function (ix) {\n        return {\n          programIdIndex: ix.programIdIndex,\n          accountKeyIndexes: ix.accounts,\n          data: bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(ix.data)\n        };\n      }),\n      addressTableLookups: response.addressTableLookups\n    });\n  } else {\n    return new Message(response);\n  }\n}\n\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n// Deprecated as of v1.5.5\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n/**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */\n/**\n * Configuration object for changing `getAccountInfo` query behavior\n */\n/**\n * Configuration object for changing `getBalance` query behavior\n */\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n/**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */\n/**\n * Configuration object for changing `getBlockHeight` query behavior\n */\n/**\n * Configuration object for changing `getEpochInfo` query behavior\n */\n/**\n * Configuration object for changing `getInflationReward` query behavior\n */\n/**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */\n/**\n * Configuration object for changing `isBlockhashValid` query behavior\n */\n/**\n * Configuration object for changing `getSlot` query behavior\n */\n/**\n * Configuration object for changing `getSlotLeader` query behavior\n */\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n/**\n * Configuration object for changing `getLargestAccounts` query behavior\n */\n/**\n * Configuration object for changing `getSupply` request behavior\n */\n/**\n * Configuration object for changing query behavior\n */\n/**\n * Information describing a cluster node\n */\n/**\n * Information describing a vote account\n */\n/**\n * A collection of cluster vote accounts\n */\n/**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */\nvar GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * The inflation reward for an epoch\n */\n\n/**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */\nvar GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()))\n}))));\n\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nvar GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nvar GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * Information about the current epoch\n */\n\nvar GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n});\nvar GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n  firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */\n\nvar GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n\n/**\n * Transaction error or null\n */\nvar TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()]));\n\n/**\n * Signature status for a transaction\n */\nvar SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  err: TransactionErrorResult\n});\n\n/**\n * Transaction signature received notification\n */\nvar SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('receivedSignature');\n\n/**\n * Version info for a node\n */\n\nvar VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  'solana-core': (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  'feature-set': (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n});\nvar SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()])),\n  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)())),\n  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n  }))))),\n  unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.tuple)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('base64')])\n  })))\n}));\n\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */\n\n/**\n * Collection of addresses loaded by a transaction using address table lookups\n */\n\n/**\n * Metadata for a parsed transaction on the ledger\n */\n\n/**\n * Metadata for a confirmed transaction on the ledger\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction message from the RPC API\n */\n\n/**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * A partially decoded transaction instruction\n */\n\n/**\n * A parsed transaction message account\n */\n\n/**\n * A parsed transaction instruction\n */\n\n/**\n * A parsed address table lookup\n */\n\n/**\n * A parsed transaction message\n */\n\n/**\n * A parsed transaction\n */\n\n/**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */\n\n/**\n * A parsed transaction on the ledger with meta\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A block with parsed transactions\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * A Block on the ledger with signatures only\n */\n\n/**\n * recent block production information\n */\n\n/**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */\nvar BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())),\n  range: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n  })\n}));\n\n/**\n * A performance sample\n */\n\nfunction createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n  var fetch = customFetch ? customFetch : fetchImpl;\n  var agent;\n  {\n    if (httpAgent != null) {\n      console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');\n    }\n  }\n  var fetchWithMiddleware;\n  if (fetchMiddleware) {\n    fetchWithMiddleware = /*#__PURE__*/function () {\n      var _ref = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee(info, init) {\n        var modifiedFetchArgs;\n        return _regeneratorRuntime$1().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return new Promise(function (resolve, reject) {\n                try {\n                  fetchMiddleware(info, init, function (modifiedInfo, modifiedInit) {\n                    return resolve([modifiedInfo, modifiedInit]);\n                  });\n                } catch (error) {\n                  reject(error);\n                }\n              });\n            case 2:\n              modifiedFetchArgs = _context.sent;\n              _context.next = 5;\n              return fetch.apply(void 0, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(modifiedFetchArgs));\n            case 5:\n              return _context.abrupt(\"return\", _context.sent);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return function fetchWithMiddleware(_x, _x2) {\n        return _ref.apply(this, arguments);\n      };\n    }();\n  }\n  var clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_19___default())( /*#__PURE__*/function () {\n    var _ref2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee2(request, callback) {\n      var options, too_many_requests_retries, res, waitTime, text;\n      return _regeneratorRuntime$1().wrap(function _callee2$(_context2) {\n        while (1) switch (_context2.prev = _context2.next) {\n          case 0:\n            options = {\n              method: 'POST',\n              body: request,\n              agent: agent,\n              headers: Object.assign({\n                'Content-Type': 'application/json'\n              }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n            };\n            _context2.prev = 1;\n            too_many_requests_retries = 5;\n            waitTime = 500;\n          case 4:\n            if (!fetchWithMiddleware) {\n              _context2.next = 10;\n              break;\n            }\n            _context2.next = 7;\n            return fetchWithMiddleware(url, options);\n          case 7:\n            res = _context2.sent;\n            _context2.next = 13;\n            break;\n          case 10:\n            _context2.next = 12;\n            return fetch(url, options);\n          case 12:\n            res = _context2.sent;\n          case 13:\n            if (!(res.status !== 429 /* Too many requests */)) {\n              _context2.next = 15;\n              break;\n            }\n            return _context2.abrupt(\"break\", 26);\n          case 15:\n            if (!(disableRetryOnRateLimit === true)) {\n              _context2.next = 17;\n              break;\n            }\n            return _context2.abrupt(\"break\", 26);\n          case 17:\n            too_many_requests_retries -= 1;\n            if (!(too_many_requests_retries === 0)) {\n              _context2.next = 20;\n              break;\n            }\n            return _context2.abrupt(\"break\", 26);\n          case 20:\n            console.log(\"Server responded with \".concat(res.status, \" \").concat(res.statusText, \".  Retrying after \").concat(waitTime, \"ms delay...\"));\n            _context2.next = 23;\n            return sleep(waitTime);\n          case 23:\n            waitTime *= 2;\n          case 24:\n            _context2.next = 4;\n            break;\n          case 26:\n            _context2.next = 28;\n            return res.text();\n          case 28:\n            text = _context2.sent;\n            if (res.ok) {\n              callback(null, text);\n            } else {\n              callback(new Error(\"\".concat(res.status, \" \").concat(res.statusText, \": \").concat(text)));\n            }\n            _context2.next = 35;\n            break;\n          case 32:\n            _context2.prev = 32;\n            _context2.t0 = _context2[\"catch\"](1);\n            if (_context2.t0 instanceof Error) callback(_context2.t0);\n          case 35:\n          case \"end\":\n            return _context2.stop();\n        }\n      }, _callee2, null, [[1, 32]]);\n    }));\n    return function (_x3, _x4) {\n      return _ref2.apply(this, arguments);\n    };\n  }(), {});\n  return clientBrowser;\n}\nfunction createRpcRequest(client) {\n  return function (method, args) {\n    return new Promise(function (resolve, reject) {\n      client.request(method, args, function (err, response) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\nfunction createRpcBatchRequest(client) {\n  return function (requests) {\n    return new Promise(function (resolve, reject) {\n      // Do nothing if requests is empty\n      if (requests.length === 0) resolve([]);\n      var batch = requests.map(function (params) {\n        return client.request(params.methodName, params.args);\n      });\n      client.request(batch, function (err, response) {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */\nvar GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nvar GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nvar GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\nvar GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\nvar GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */\nvar GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */\nvar SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)());\n\n/**\n * Supply\n */\n\n/**\n * Expected JSON RPC response for the \"getSupply\" message\n */\nvar GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(PublicKeyFromString)\n}));\n\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */\n\n/**\n * Expected JSON RPC structure for token amounts\n */\nvar TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)())\n});\n\n/**\n * Token address and balance.\n */\n\n/**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */\nvar GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  address: PublicKeyFromString,\n  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */\nvar GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: PublicKeyFromString,\n  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n  })\n})));\nvar ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.unknown)(),\n  space: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */\nvar GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: PublicKeyFromString,\n  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    data: ParsedAccountDataResult,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n  })\n})));\n\n/**\n * Pair of an account address and its balance\n */\n\n/**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */\nvar GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  address: PublicKeyFromString\n})));\n\n/**\n * @internal\n */\nvar AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n  owner: PublicKeyFromString,\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  data: BufferFromRawAccountData,\n  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * @internal\n */\nvar KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\nvar ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.instance)(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer), ParsedAccountDataResult]), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([RawAccountDataResult, ParsedAccountDataResult]), function (value) {\n  if (Array.isArray(value)) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(value, BufferFromRawAccountData);\n  } else {\n    return value;\n  }\n});\n\n/**\n * @internal\n */\nvar ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n  owner: PublicKeyFromString,\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  data: ParsedOrRawAccountData,\n  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\nvar KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: PublicKeyFromString,\n  account: ParsedAccountInfoResult\n});\n\n/**\n * @internal\n */\nvar StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  state: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('active'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('inactive'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('activating'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('deactivating')]),\n  active: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */\n\nvar GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  err: TransactionErrorResult,\n  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()))\n})));\n\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */\nvar GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  err: TransactionErrorResult,\n  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()))\n})));\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nvar AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  result: notificationResultAndContext(AccountInfoResult)\n});\n\n/**\n * @internal\n */\nvar ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\n\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\nvar ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n\n/**\n * @internal\n */\nvar SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  root: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\nvar SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  result: SlotInfoResult\n});\n\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */\n\n/**\n * @internal\n */\nvar SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('firstShredReceived'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('completed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('optimisticConfirmation'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('root')]),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('createdBank'),\n  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('frozen'),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n  })\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('dead'),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()\n})]);\n\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */\nvar SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  result: SlotUpdateResult\n});\n\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\nvar SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([SignatureStatusResult, SignatureReceivedResult]))\n});\n\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */\nvar RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  result: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\nvar ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)())\n});\nvar VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n  epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.tuple)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()])),\n  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n});\n\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\nvar GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  current: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(VoteAccountInfoResult),\n  delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(VoteAccountInfoResult)\n}));\nvar ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('processed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('confirmed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('finalized')]);\nvar SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  err: TransactionErrorResult,\n  confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(ConfirmationStatus)\n});\n\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */\nvar GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(SignatureStatusResponse)));\n\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\nvar GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)());\nvar AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  accountKey: PublicKeyFromString,\n  writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n});\nvar ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n    header: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n      numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n      numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n      numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n    }),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n    })),\n    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(AddressTableLookupStruct))\n  })\n});\nvar AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: PublicKeyFromString,\n  signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)(),\n  source: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('transaction'), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('lookupTable')]))\n});\nvar ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(AnnotatedAccountKey),\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)())\n});\nvar ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.unknown)(),\n  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  programId: PublicKeyFromString\n});\nvar RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(PublicKeyFromString),\n  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  programId: PublicKeyFromString\n});\nvar InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([RawInstructionResult, ParsedInstructionResult]);\nvar UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.unknown)(),\n  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()\n})]);\nvar ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.coerce)(InstructionResult, UnknownInstructionResult, function (value) {\n  if ('accounts' in value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(value, RawInstructionResult);\n  } else {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(value, ParsedInstructionResult);\n  }\n});\n\n/**\n * @internal\n */\nvar ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(AnnotatedAccountKey),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(ParsedOrRawInstruction),\n    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(AddressTableLookupStruct)))\n  })\n});\nvar TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  uiTokenAmount: TokenAmountResult\n});\nvar LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(PublicKeyFromString),\n  readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(PublicKeyFromString)\n});\n\n/**\n * @internal\n */\nvar ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  err: TransactionErrorResult,\n  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n    }))\n  })))),\n  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()))),\n  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(TokenBalanceResult))),\n  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(TokenBalanceResult))),\n  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(LoadedAddressesResult),\n  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n});\n\n/**\n * @internal\n */\nvar ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  err: TransactionErrorResult,\n  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(ParsedOrRawInstruction)\n  })))),\n  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()))),\n  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(TokenBalanceResult))),\n  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(TokenBalanceResult))),\n  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(LoadedAddressesResult),\n  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n});\nvar TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)(0), (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.literal)('legacy')]);\n\n/** @internal */\nvar RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()))\n});\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nvar GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    transaction: ConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */\nvar GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */\nvar GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */\nvar GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ParsedConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */\nvar GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ParsedConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */\nvar GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */\nvar GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    transaction: ConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ConfirmedTransactionMetaResult)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nvar GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */\nvar GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  meta: ConfirmedTransactionMetaResult,\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())),\n  transaction: ConfirmedTransactionResult,\n  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(TransactionVersionStruct)\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */\nvar GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  transaction: ParsedConfirmedTransactionResult,\n  meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ParsedConfirmedTransactionMetaResult),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())),\n  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)(TransactionVersionStruct)\n})));\n\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */\nvar GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n  })\n}));\n\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */\nvar GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n}));\n\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */\nvar IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.boolean)());\nvar PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)(),\n  samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */\nvar GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(PerfSampleResult));\n\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */\nvar GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n  })\n})));\n\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\nvar RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)());\n\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\nvar SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)());\n\n/**\n * Information about the latest slot being processed by a node\n */\n\n/**\n * Parsed account data\n */\n\n/**\n * Stake Activation data\n */\n\n/**\n * Data slice argument for getProgramAccounts\n */\n\n/**\n * Memory comparison filter for getProgramAccounts\n */\n\n/**\n * Data size comparison filter for getProgramAccounts\n */\n\n/**\n * A filter object for getProgramAccounts\n */\n\n/**\n * Configuration object for getProgramAccounts requests\n */\n\n/**\n * Configuration object for getParsedProgramAccounts\n */\n\n/**\n * Configuration object for getMultipleAccounts\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getNonce`\n */\n\n/**\n * Configuration object for `getNonceAndContext`\n */\n\n/**\n * Information describing an account\n */\n\n/**\n * Account information identified by pubkey\n */\n\n/**\n * Callback function for account change notifications\n */\n\n/**\n * Callback function for program account change notifications\n */\n\n/**\n * Callback function for slot change notifications\n */\n\n/**\n * Callback function for slot update notifications\n */\n\n/**\n * Callback function for signature status notifications\n */\n\n/**\n * Signature status notification with transaction result\n */\n\n/**\n * Signature received notification\n */\n\n/**\n * Callback function for signature notifications\n */\n\n/**\n * Signature subscription options\n */\n\n/**\n * Callback function for root change notifications\n */\n\n/**\n * @internal\n */\nvar LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  err: TransactionErrorResult,\n  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()\n});\n\n/**\n * Logs result.\n */\n\n/**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */\nvar LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  result: notificationResultAndContext(LogsResult),\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()\n});\n\n/**\n * Filter for log subscriptions.\n */\n\n/**\n * Callback function for log notifications.\n */\n\n/**\n * Signature result\n */\n\n/**\n * Transaction error\n */\n\n/**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Signature status\n */\n\n/**\n * A confirmed signature with its status\n */\n\n/**\n * An object defining headers to be passed to the RPC server\n */\n\n/**\n * The type of the JavaScript `fetch()` API\n */\n\n/**\n * A callback used to augment the outgoing HTTP request\n */\n\n/**\n * Configuration for instantiating a Connection\n */\n\n/** @internal */\nvar COMMON_HTTP_HEADERS = {\n  'solana-client': \"js/\".concat((_process$env$npm_pack = \"0.0.0-development\") !== null && _process$env$npm_pack !== void 0 ? _process$env$npm_pack : 'UNKNOWN')\n};\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nvar Connection = /*#__PURE__*/function () {\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */\n  function Connection(endpoint, _commitmentOrConfig) {\n    var _this = this;\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Connection);\n    /** @internal */\n    this._commitment = void 0;\n    /** @internal */\n    this._confirmTransactionInitialTimeout = void 0;\n    /** @internal */\n    this._rpcEndpoint = void 0;\n    /** @internal */\n    this._rpcWsEndpoint = void 0;\n    /** @internal */\n    this._rpcClient = void 0;\n    /** @internal */\n    this._rpcRequest = void 0;\n    /** @internal */\n    this._rpcBatchRequest = void 0;\n    /** @internal */\n    this._rpcWebSocket = void 0;\n    /** @internal */\n    this._rpcWebSocketConnected = false;\n    /** @internal */\n    this._rpcWebSocketHeartbeat = null;\n    /** @internal */\n    this._rpcWebSocketIdleTimeout = null;\n    /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */\n    this._rpcWebSocketGeneration = 0;\n    /** @internal */\n    this._disableBlockhashCaching = false;\n    /** @internal */\n    this._pollingBlockhash = false;\n    /** @internal */\n    this._blockhashInfo = {\n      latestBlockhash: null,\n      lastFetch: 0,\n      transactionSignatures: [],\n      simulatedSignatures: []\n    };\n    /** @internal */\n    this._nextClientSubscriptionId = 0;\n    /** @internal */\n    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionHashByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionStateChangeCallbacksByHash = {};\n    /** @internal */\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    /** @internal */\n    this._subscriptionsByHash = {};\n    /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */\n    /** @internal */\n    this._subscriptionsAutoDisposedByRpc = new Set();\n    /*\n     * Returns the current block height of the node\n     */\n    this.getBlockHeight = function () {\n      var requestPromises = {};\n      return /*#__PURE__*/function () {\n        var _ref3 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee4(commitmentOrConfig) {\n          var _requestPromises$requ;\n          var _extractCommitmentFro, commitment, config, args, requestHash;\n          return _regeneratorRuntime$1().wrap(function _callee4$(_context4) {\n            while (1) switch (_context4.prev = _context4.next) {\n              case 0:\n                _extractCommitmentFro = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro.commitment, config = _extractCommitmentFro.config;\n                args = _this._buildArgs([], commitment, undefined /* encoding */, config);\n                requestHash = fastStableStringify$1(args);\n                requestPromises[requestHash] = (_requestPromises$requ = requestPromises[requestHash]) !== null && _requestPromises$requ !== void 0 ? _requestPromises$requ : (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee3() {\n                  var unsafeRes, res;\n                  return _regeneratorRuntime$1().wrap(function _callee3$(_context3) {\n                    while (1) switch (_context3.prev = _context3.next) {\n                      case 0:\n                        _context3.prev = 0;\n                        _context3.next = 3;\n                        return _this._rpcRequest('getBlockHeight', args);\n                      case 3:\n                        unsafeRes = _context3.sent;\n                        res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n                        if (!('error' in res)) {\n                          _context3.next = 7;\n                          break;\n                        }\n                        throw new SolanaJSONRPCError(res.error, 'failed to get block height information');\n                      case 7:\n                        return _context3.abrupt(\"return\", res.result);\n                      case 8:\n                        _context3.prev = 8;\n                        delete requestPromises[requestHash];\n                        return _context3.finish(8);\n                      case 11:\n                      case \"end\":\n                        return _context3.stop();\n                    }\n                  }, _callee3, null, [[0,, 8, 11]]);\n                }))();\n                _context4.next = 6;\n                return requestPromises[requestHash];\n              case 6:\n                return _context4.abrupt(\"return\", _context4.sent);\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }, _callee4);\n        }));\n        return function (_x5) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n    }();\n    var wsEndpoint;\n    var httpHeaders;\n    var fetch;\n    var fetchMiddleware;\n    var disableRetryOnRateLimit;\n    var httpAgent;\n    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {\n      this._commitment = _commitmentOrConfig;\n    } else if (_commitmentOrConfig) {\n      this._commitment = _commitmentOrConfig.commitment;\n      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n      wsEndpoint = _commitmentOrConfig.wsEndpoint;\n      httpHeaders = _commitmentOrConfig.httpHeaders;\n      fetch = _commitmentOrConfig.fetch;\n      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n      httpAgent = _commitmentOrConfig.httpAgent;\n    }\n    this._rpcEndpoint = assertEndpointUrl(endpoint);\n    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n    this._rpcRequest = createRpcRequest(this._rpcClient);\n    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n      autoconnect: false,\n      max_reconnects: Infinity\n    });\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));\n    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));\n    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));\n    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));\n    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));\n    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));\n    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));\n  }\n\n  /**\n   * The default commitment used for requests\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Connection, [{\n    key: \"commitment\",\n    get: function get() {\n      return this._commitment;\n    }\n\n    /**\n     * The RPC endpoint\n     */\n  }, {\n    key: \"rpcEndpoint\",\n    get: function get() {\n      return this._rpcEndpoint;\n    }\n\n    /**\n     * Fetch the balance for the specified public key, return with context\n     */\n  }, {\n    key: \"getBalanceAndContext\",\n    value: function () {\n      var _getBalanceAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee5(publicKey, commitmentOrConfig) {\n        var _extractCommitmentFro2, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              /** @internal */\n              _extractCommitmentFro2 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro2.commitment, config = _extractCommitmentFro2.config;\n              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);\n              _context5.next = 4;\n              return this._rpcRequest('getBalance', args);\n            case 4:\n              unsafeRes = _context5.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n              if (!('error' in res)) {\n                _context5.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get balance for \".concat(publicKey.toBase58()));\n            case 8:\n              return _context5.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this);\n      }));\n      function getBalanceAndContext(_x6, _x7) {\n        return _getBalanceAndContext.apply(this, arguments);\n      }\n      return getBalanceAndContext;\n    }()\n    /**\n     * Fetch the balance for the specified public key\n     */\n  }, {\n    key: \"getBalance\",\n    value: function () {\n      var _getBalance = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee6(publicKey, commitmentOrConfig) {\n        return _regeneratorRuntime$1().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.getBalanceAndContext(publicKey, commitmentOrConfig).then(function (x) {\n                return x.value;\n              })[\"catch\"](function (e) {\n                throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);\n              });\n            case 2:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 3:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n      function getBalance(_x8, _x9) {\n        return _getBalance.apply(this, arguments);\n      }\n      return getBalance;\n    }()\n    /**\n     * Fetch the estimated production time of a block\n     */\n  }, {\n    key: \"getBlockTime\",\n    value: function () {\n      var _getBlockTime = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee7(slot) {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return this._rpcRequest('getBlockTime', [slot]);\n            case 2:\n              unsafeRes = _context7.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())));\n              if (!('error' in res)) {\n                _context7.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get block time for slot \".concat(slot));\n            case 6:\n              return _context7.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function getBlockTime(_x10) {\n        return _getBlockTime.apply(this, arguments);\n      }\n      return getBlockTime;\n    }()\n    /**\n     * Fetch the lowest slot that the node has information about in its ledger.\n     * This value may increase over time if the node is configured to purge older ledger data\n     */\n  }, {\n    key: \"getMinimumLedgerSlot\",\n    value: function () {\n      var _getMinimumLedgerSlot = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee8() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return this._rpcRequest('minimumLedgerSlot', []);\n            case 2:\n              unsafeRes = _context8.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n              if (!('error' in res)) {\n                _context8.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');\n            case 6:\n              return _context8.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this);\n      }));\n      function getMinimumLedgerSlot() {\n        return _getMinimumLedgerSlot.apply(this, arguments);\n      }\n      return getMinimumLedgerSlot;\n    }()\n    /**\n     * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n     */\n  }, {\n    key: \"getFirstAvailableBlock\",\n    value: function () {\n      var _getFirstAvailableBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee9() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.next = 2;\n              return this._rpcRequest('getFirstAvailableBlock', []);\n            case 2:\n              unsafeRes = _context9.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, SlotRpcResult);\n              if (!('error' in res)) {\n                _context9.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get first available block');\n            case 6:\n              return _context9.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this);\n      }));\n      function getFirstAvailableBlock() {\n        return _getFirstAvailableBlock.apply(this, arguments);\n      }\n      return getFirstAvailableBlock;\n    }()\n    /**\n     * Fetch information about the current supply\n     */\n  }, {\n    key: \"getSupply\",\n    value: function () {\n      var _getSupply = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee10(config) {\n        var configArg, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              configArg = {};\n              if (typeof config === 'string') {\n                configArg = {\n                  commitment: config\n                };\n              } else if (config) {\n                configArg = _objectSpread(_objectSpread({}, config), {}, {\n                  commitment: config && config.commitment || this.commitment\n                });\n              } else {\n                configArg = {\n                  commitment: this.commitment\n                };\n              }\n              _context10.next = 4;\n              return this._rpcRequest('getSupply', [configArg]);\n            case 4:\n              unsafeRes = _context10.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetSupplyRpcResult);\n              if (!('error' in res)) {\n                _context10.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get supply');\n            case 8:\n              return _context10.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this);\n      }));\n      function getSupply(_x11) {\n        return _getSupply.apply(this, arguments);\n      }\n      return getSupply;\n    }()\n    /**\n     * Fetch the current supply of a token mint\n     */\n  }, {\n    key: \"getTokenSupply\",\n    value: function () {\n      var _getTokenSupply = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee11(tokenMintAddress, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              args = this._buildArgs([tokenMintAddress.toBase58()], commitment);\n              _context11.next = 3;\n              return this._rpcRequest('getTokenSupply', args);\n            case 3:\n              unsafeRes = _context11.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n              if (!('error' in res)) {\n                _context11.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get token supply');\n            case 7:\n              return _context11.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this);\n      }));\n      function getTokenSupply(_x12, _x13) {\n        return _getTokenSupply.apply(this, arguments);\n      }\n      return getTokenSupply;\n    }()\n    /**\n     * Fetch the current balance of a token account\n     */\n  }, {\n    key: \"getTokenAccountBalance\",\n    value: function () {\n      var _getTokenAccountBalance = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee12(tokenAddress, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              args = this._buildArgs([tokenAddress.toBase58()], commitment);\n              _context12.next = 3;\n              return this._rpcRequest('getTokenAccountBalance', args);\n            case 3:\n              unsafeRes = _context12.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n              if (!('error' in res)) {\n                _context12.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');\n            case 7:\n              return _context12.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this);\n      }));\n      function getTokenAccountBalance(_x14, _x15) {\n        return _getTokenAccountBalance.apply(this, arguments);\n      }\n      return getTokenAccountBalance;\n    }()\n    /**\n     * Fetch all the token accounts owned by the specified account\n     *\n     * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n     */\n  }, {\n    key: \"getTokenAccountsByOwner\",\n    value: function () {\n      var _getTokenAccountsByOwner = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee13(ownerAddress, filter, commitmentOrConfig) {\n        var _extractCommitmentFro3, commitment, config, _args, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _extractCommitmentFro3 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro3.commitment, config = _extractCommitmentFro3.config;\n              _args = [ownerAddress.toBase58()];\n              if ('mint' in filter) {\n                _args.push({\n                  mint: filter.mint.toBase58()\n                });\n              } else {\n                _args.push({\n                  programId: filter.programId.toBase58()\n                });\n              }\n              args = this._buildArgs(_args, commitment, 'base64', config);\n              _context13.next = 6;\n              return this._rpcRequest('getTokenAccountsByOwner', args);\n            case 6:\n              unsafeRes = _context13.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetTokenAccountsByOwner);\n              if (!('error' in res)) {\n                _context13.next = 10;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get token accounts owned by account \".concat(ownerAddress.toBase58()));\n            case 10:\n              return _context13.abrupt(\"return\", res.result);\n            case 11:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function getTokenAccountsByOwner(_x16, _x17, _x18) {\n        return _getTokenAccountsByOwner.apply(this, arguments);\n      }\n      return getTokenAccountsByOwner;\n    }()\n    /**\n     * Fetch parsed token accounts owned by the specified account\n     *\n     * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n     */\n  }, {\n    key: \"getParsedTokenAccountsByOwner\",\n    value: function () {\n      var _getParsedTokenAccountsByOwner = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee14(ownerAddress, filter, commitment) {\n        var _args, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _args = [ownerAddress.toBase58()];\n              if ('mint' in filter) {\n                _args.push({\n                  mint: filter.mint.toBase58()\n                });\n              } else {\n                _args.push({\n                  programId: filter.programId.toBase58()\n                });\n              }\n              args = this._buildArgs(_args, commitment, 'jsonParsed');\n              _context14.next = 5;\n              return this._rpcRequest('getTokenAccountsByOwner', args);\n            case 5:\n              unsafeRes = _context14.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n              if (!('error' in res)) {\n                _context14.next = 9;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get token accounts owned by account \".concat(ownerAddress.toBase58()));\n            case 9:\n              return _context14.abrupt(\"return\", res.result);\n            case 10:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function getParsedTokenAccountsByOwner(_x19, _x20, _x21) {\n        return _getParsedTokenAccountsByOwner.apply(this, arguments);\n      }\n      return getParsedTokenAccountsByOwner;\n    }()\n    /**\n     * Fetch the 20 largest accounts with their current balances\n     */\n  }, {\n    key: \"getLargestAccounts\",\n    value: function () {\n      var _getLargestAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee15(config) {\n        var arg, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              arg = _objectSpread(_objectSpread({}, config), {}, {\n                commitment: config && config.commitment || this.commitment\n              });\n              args = arg.filter || arg.commitment ? [arg] : [];\n              _context15.next = 4;\n              return this._rpcRequest('getLargestAccounts', args);\n            case 4:\n              unsafeRes = _context15.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetLargestAccountsRpcResult);\n              if (!('error' in res)) {\n                _context15.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');\n            case 8:\n              return _context15.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this);\n      }));\n      function getLargestAccounts(_x22) {\n        return _getLargestAccounts.apply(this, arguments);\n      }\n      return getLargestAccounts;\n    }()\n    /**\n     * Fetch the 20 largest token accounts with their current balances\n     * for a given mint.\n     */\n  }, {\n    key: \"getTokenLargestAccounts\",\n    value: function () {\n      var _getTokenLargestAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee16(mintAddress, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              args = this._buildArgs([mintAddress.toBase58()], commitment);\n              _context16.next = 3;\n              return this._rpcRequest('getTokenLargestAccounts', args);\n            case 3:\n              unsafeRes = _context16.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetTokenLargestAccountsResult);\n              if (!('error' in res)) {\n                _context16.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');\n            case 7:\n              return _context16.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function getTokenLargestAccounts(_x23, _x24) {\n        return _getTokenLargestAccounts.apply(this, arguments);\n      }\n      return getTokenLargestAccounts;\n    }()\n    /**\n     * Fetch all the account info for the specified public key, return with context\n     */\n  }, {\n    key: \"getAccountInfoAndContext\",\n    value: function () {\n      var _getAccountInfoAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee17(publicKey, commitmentOrConfig) {\n        var _extractCommitmentFro4, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _extractCommitmentFro4 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro4.commitment, config = _extractCommitmentFro4.config;\n              args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);\n              _context17.next = 4;\n              return this._rpcRequest('getAccountInfo', args);\n            case 4:\n              unsafeRes = _context17.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(AccountInfoResult)));\n              if (!('error' in res)) {\n                _context17.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get info about account \".concat(publicKey.toBase58()));\n            case 8:\n              return _context17.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this);\n      }));\n      function getAccountInfoAndContext(_x25, _x26) {\n        return _getAccountInfoAndContext.apply(this, arguments);\n      }\n      return getAccountInfoAndContext;\n    }()\n    /**\n     * Fetch parsed account info for the specified public key\n     */\n  }, {\n    key: \"getParsedAccountInfo\",\n    value: function () {\n      var _getParsedAccountInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee18(publicKey, commitmentOrConfig) {\n        var _extractCommitmentFro5, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _extractCommitmentFro5 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro5.commitment, config = _extractCommitmentFro5.config;\n              args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);\n              _context18.next = 4;\n              return this._rpcRequest('getAccountInfo', args);\n            case 4:\n              unsafeRes = _context18.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ParsedAccountInfoResult)));\n              if (!('error' in res)) {\n                _context18.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get info about account \".concat(publicKey.toBase58()));\n            case 8:\n              return _context18.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this);\n      }));\n      function getParsedAccountInfo(_x27, _x28) {\n        return _getParsedAccountInfo.apply(this, arguments);\n      }\n      return getParsedAccountInfo;\n    }()\n    /**\n     * Fetch all the account info for the specified public key\n     */\n  }, {\n    key: \"getAccountInfo\",\n    value: function () {\n      var _getAccountInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee19(publicKey, commitmentOrConfig) {\n        var res;\n        return _regeneratorRuntime$1().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.prev = 0;\n              _context19.next = 3;\n              return this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n            case 3:\n              res = _context19.sent;\n              return _context19.abrupt(\"return\", res.value);\n            case 7:\n              _context19.prev = 7;\n              _context19.t0 = _context19[\"catch\"](0);\n              throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + _context19.t0);\n            case 10:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this, [[0, 7]]);\n      }));\n      function getAccountInfo(_x29, _x30) {\n        return _getAccountInfo.apply(this, arguments);\n      }\n      return getAccountInfo;\n    }()\n    /**\n     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n     */\n  }, {\n    key: \"getMultipleParsedAccounts\",\n    value: function () {\n      var _getMultipleParsedAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee20(publicKeys, rawConfig) {\n        var _extractCommitmentFro6, commitment, config, keys, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _extractCommitmentFro6 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro6.commitment, config = _extractCommitmentFro6.config;\n              keys = publicKeys.map(function (key) {\n                return key.toBase58();\n              });\n              args = this._buildArgs([keys], commitment, 'jsonParsed', config);\n              _context20.next = 5;\n              return this._rpcRequest('getMultipleAccounts', args);\n            case 5:\n              unsafeRes = _context20.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(ParsedAccountInfoResult))));\n              if (!('error' in res)) {\n                _context20.next = 9;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get info for accounts \".concat(keys));\n            case 9:\n              return _context20.abrupt(\"return\", res.result);\n            case 10:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n      function getMultipleParsedAccounts(_x31, _x32) {\n        return _getMultipleParsedAccounts.apply(this, arguments);\n      }\n      return getMultipleParsedAccounts;\n    }()\n    /**\n     * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n     */\n  }, {\n    key: \"getMultipleAccountsInfoAndContext\",\n    value: function () {\n      var _getMultipleAccountsInfoAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee21(publicKeys, commitmentOrConfig) {\n        var _extractCommitmentFro7, commitment, config, keys, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _extractCommitmentFro7 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro7.commitment, config = _extractCommitmentFro7.config;\n              keys = publicKeys.map(function (key) {\n                return key.toBase58();\n              });\n              args = this._buildArgs([keys], commitment, 'base64', config);\n              _context21.next = 5;\n              return this._rpcRequest('getMultipleAccounts', args);\n            case 5:\n              unsafeRes = _context21.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)(AccountInfoResult))));\n              if (!('error' in res)) {\n                _context21.next = 9;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get info for accounts \".concat(keys));\n            case 9:\n              return _context21.abrupt(\"return\", res.result);\n            case 10:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n      function getMultipleAccountsInfoAndContext(_x33, _x34) {\n        return _getMultipleAccountsInfoAndContext.apply(this, arguments);\n      }\n      return getMultipleAccountsInfoAndContext;\n    }()\n    /**\n     * Fetch all the account info for multiple accounts specified by an array of public keys\n     */\n  }, {\n    key: \"getMultipleAccountsInfo\",\n    value: function () {\n      var _getMultipleAccountsInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee22(publicKeys, commitmentOrConfig) {\n        var res;\n        return _regeneratorRuntime$1().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.next = 2;\n              return this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n            case 2:\n              res = _context22.sent;\n              return _context22.abrupt(\"return\", res.value);\n            case 4:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this);\n      }));\n      function getMultipleAccountsInfo(_x35, _x36) {\n        return _getMultipleAccountsInfo.apply(this, arguments);\n      }\n      return getMultipleAccountsInfo;\n    }()\n    /**\n     * Returns epoch activation information for a stake account that has been delegated\n     */\n  }, {\n    key: \"getStakeActivation\",\n    value: function () {\n      var _getStakeActivation = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee23(publicKey, commitmentOrConfig, epoch) {\n        var _extractCommitmentFro8, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              _extractCommitmentFro8 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro8.commitment, config = _extractCommitmentFro8.config;\n              args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {\n                epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch\n              }));\n              _context23.next = 4;\n              return this._rpcRequest('getStakeActivation', args);\n            case 4:\n              unsafeRes = _context23.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n              if (!('error' in res)) {\n                _context23.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get Stake Activation \".concat(publicKey.toBase58()));\n            case 8:\n              return _context23.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this);\n      }));\n      function getStakeActivation(_x37, _x38, _x39) {\n        return _getStakeActivation.apply(this, arguments);\n      }\n      return getStakeActivation;\n    }()\n    /**\n     * Fetch all the accounts owned by the specified program id\n     *\n     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n     */\n  }, {\n    key: \"getProgramAccounts\",\n    value: // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _getProgramAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee24(programId, configOrCommitment) {\n        var _extractCommitmentFro9, commitment, config, _ref5, encoding, configWithoutEncoding, args, unsafeRes, baseSchema, res;\n        return _regeneratorRuntime$1().wrap(function _callee24$(_context24) {\n          while (1) switch (_context24.prev = _context24.next) {\n            case 0:\n              _extractCommitmentFro9 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro9.commitment, config = _extractCommitmentFro9.config;\n              _ref5 = config || {}, encoding = _ref5.encoding, configWithoutEncoding = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(_ref5, _excluded2);\n              args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);\n              _context24.next = 5;\n              return this._rpcRequest('getProgramAccounts', args);\n            case 5:\n              unsafeRes = _context24.sent;\n              baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(KeyedAccountInfoResult);\n              res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult(baseSchema));\n              if (!('error' in res)) {\n                _context24.next = 10;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get accounts owned by program \".concat(programId.toBase58()));\n            case 10:\n              return _context24.abrupt(\"return\", res.result);\n            case 11:\n            case \"end\":\n              return _context24.stop();\n          }\n        }, _callee24, this);\n      }));\n      function getProgramAccounts(_x40, _x41) {\n        return _getProgramAccounts.apply(this, arguments);\n      }\n      return getProgramAccounts;\n    }()\n    /**\n     * Fetch and parse all the accounts owned by the specified program id\n     *\n     * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n     */\n  }, {\n    key: \"getParsedProgramAccounts\",\n    value: function () {\n      var _getParsedProgramAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee25(programId, configOrCommitment) {\n        var _extractCommitmentFro10, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _extractCommitmentFro10 = extractCommitmentFromConfig(configOrCommitment), commitment = _extractCommitmentFro10.commitment, config = _extractCommitmentFro10.config;\n              args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);\n              _context25.next = 4;\n              return this._rpcRequest('getProgramAccounts', args);\n            case 4:\n              unsafeRes = _context25.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(KeyedParsedAccountInfoResult)));\n              if (!('error' in res)) {\n                _context25.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get accounts owned by program \".concat(programId.toBase58()));\n            case 8:\n              return _context25.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, this);\n      }));\n      function getParsedProgramAccounts(_x42, _x43) {\n        return _getParsedProgramAccounts.apply(this, arguments);\n      }\n      return getParsedProgramAccounts;\n    }()\n  }, {\n    key: \"confirmTransaction\",\n    value: // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _confirmTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee26(strategy, commitment) {\n        var rawSignature, _config$abortSignal, _config, decodedSignature;\n        return _regeneratorRuntime$1().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              if (!(typeof strategy == 'string')) {\n                _context26.next = 4;\n                break;\n              }\n              rawSignature = strategy;\n              _context26.next = 8;\n              break;\n            case 4:\n              _config = strategy;\n              if (!((_config$abortSignal = _config.abortSignal) !== null && _config$abortSignal !== void 0 && _config$abortSignal.aborted)) {\n                _context26.next = 7;\n                break;\n              }\n              return _context26.abrupt(\"return\", Promise.reject(_config.abortSignal.reason));\n            case 7:\n              rawSignature = _config.signature;\n            case 8:\n              _context26.prev = 8;\n              decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_10___default().decode(rawSignature);\n              _context26.next = 15;\n              break;\n            case 12:\n              _context26.prev = 12;\n              _context26.t0 = _context26[\"catch\"](8);\n              throw new Error('signature must be base58 encoded: ' + rawSignature);\n            case 15:\n              assert(decodedSignature.length === 64, 'signature has invalid length');\n              if (!(typeof strategy === 'string')) {\n                _context26.next = 22;\n                break;\n              }\n              _context26.next = 19;\n              return this.confirmTransactionUsingLegacyTimeoutStrategy({\n                commitment: commitment || this.commitment,\n                signature: rawSignature\n              });\n            case 19:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 22:\n              if (!('lastValidBlockHeight' in strategy)) {\n                _context26.next = 28;\n                break;\n              }\n              _context26.next = 25;\n              return this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n                commitment: commitment || this.commitment,\n                strategy: strategy\n              });\n            case 25:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 28:\n              _context26.next = 30;\n              return this.confirmTransactionUsingDurableNonceStrategy({\n                commitment: commitment || this.commitment,\n                strategy: strategy\n              });\n            case 30:\n              return _context26.abrupt(\"return\", _context26.sent);\n            case 31:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this, [[8, 12]]);\n      }));\n      function confirmTransaction(_x44, _x45) {\n        return _confirmTransaction.apply(this, arguments);\n      }\n      return confirmTransaction;\n    }()\n  }, {\n    key: \"getCancellationPromise\",\n    value: function getCancellationPromise(signal) {\n      return new Promise(function (_, reject) {\n        if (signal == null) {\n          return;\n        }\n        if (signal.aborted) {\n          reject(signal.reason);\n        } else {\n          signal.addEventListener('abort', function () {\n            reject(signal.reason);\n          });\n        }\n      });\n    }\n  }, {\n    key: \"getTransactionConfirmationPromise\",\n    value: function getTransactionConfirmationPromise(_ref6) {\n      var _this2 = this;\n      var commitment = _ref6.commitment,\n        signature = _ref6.signature;\n      var signatureSubscriptionId;\n      var disposeSignatureSubscriptionStateChangeObserver;\n      var done = false;\n      var confirmationPromise = new Promise(function (resolve, reject) {\n        try {\n          signatureSubscriptionId = _this2.onSignature(signature, function (result, context) {\n            signatureSubscriptionId = undefined;\n            var response = {\n              context: context,\n              value: result\n            };\n            resolve({\n              __type: TransactionStatus.PROCESSED,\n              response: response\n            });\n          }, commitment);\n          var subscriptionSetupPromise = new Promise(function (resolveSubscriptionSetup) {\n            if (signatureSubscriptionId == null) {\n              resolveSubscriptionSetup();\n            } else {\n              disposeSignatureSubscriptionStateChangeObserver = _this2._onSubscriptionStateChange(signatureSubscriptionId, function (nextState) {\n                if (nextState === 'subscribed') {\n                  resolveSubscriptionSetup();\n                }\n              });\n            }\n          });\n          (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee27() {\n            var response, context, value;\n            return _regeneratorRuntime$1().wrap(function _callee27$(_context27) {\n              while (1) switch (_context27.prev = _context27.next) {\n                case 0:\n                  _context27.next = 2;\n                  return subscriptionSetupPromise;\n                case 2:\n                  if (!done) {\n                    _context27.next = 4;\n                    break;\n                  }\n                  return _context27.abrupt(\"return\");\n                case 4:\n                  _context27.next = 6;\n                  return _this2.getSignatureStatus(signature);\n                case 6:\n                  response = _context27.sent;\n                  if (!done) {\n                    _context27.next = 9;\n                    break;\n                  }\n                  return _context27.abrupt(\"return\");\n                case 9:\n                  if (!(response == null)) {\n                    _context27.next = 11;\n                    break;\n                  }\n                  return _context27.abrupt(\"return\");\n                case 11:\n                  context = response.context, value = response.value;\n                  if (!(value == null)) {\n                    _context27.next = 14;\n                    break;\n                  }\n                  return _context27.abrupt(\"return\");\n                case 14:\n                  if (!(value !== null && value !== void 0 && value.err)) {\n                    _context27.next = 18;\n                    break;\n                  }\n                  reject(value.err);\n                  _context27.next = 29;\n                  break;\n                case 18:\n                  _context27.t0 = commitment;\n                  _context27.next = _context27.t0 === 'confirmed' ? 21 : _context27.t0 === 'single' ? 21 : _context27.t0 === 'singleGossip' ? 21 : _context27.t0 === 'finalized' ? 24 : _context27.t0 === 'max' ? 24 : _context27.t0 === 'root' ? 24 : _context27.t0 === 'processed' ? 27 : _context27.t0 === 'recent' ? 27 : 27;\n                  break;\n                case 21:\n                  if (!(value.confirmationStatus === 'processed')) {\n                    _context27.next = 23;\n                    break;\n                  }\n                  return _context27.abrupt(\"return\");\n                case 23:\n                  return _context27.abrupt(\"break\", 27);\n                case 24:\n                  if (!(value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed')) {\n                    _context27.next = 26;\n                    break;\n                  }\n                  return _context27.abrupt(\"return\");\n                case 26:\n                  return _context27.abrupt(\"break\", 27);\n                case 27:\n                  done = true;\n                  resolve({\n                    __type: TransactionStatus.PROCESSED,\n                    response: {\n                      context: context,\n                      value: value\n                    }\n                  });\n                case 29:\n                case \"end\":\n                  return _context27.stop();\n              }\n            }, _callee27);\n          }))();\n        } catch (err) {\n          reject(err);\n        }\n      });\n      var abortConfirmation = function abortConfirmation() {\n        if (disposeSignatureSubscriptionStateChangeObserver) {\n          disposeSignatureSubscriptionStateChangeObserver();\n          disposeSignatureSubscriptionStateChangeObserver = undefined;\n        }\n        if (signatureSubscriptionId != null) {\n          _this2.removeSignatureListener(signatureSubscriptionId);\n          signatureSubscriptionId = undefined;\n        }\n      };\n      return {\n        abortConfirmation: abortConfirmation,\n        confirmationPromise: confirmationPromise\n      };\n    }\n  }, {\n    key: \"confirmTransactionUsingBlockHeightExceedanceStrategy\",\n    value: function () {\n      var _confirmTransactionUsingBlockHeightExceedanceStrategy = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee30(_ref8) {\n        var _this3 = this;\n        var commitment, _ref8$strategy, abortSignal, lastValidBlockHeight, signature, done, expiryPromise, _this$getTransactionC, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome;\n        return _regeneratorRuntime$1().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              commitment = _ref8.commitment, _ref8$strategy = _ref8.strategy, abortSignal = _ref8$strategy.abortSignal, lastValidBlockHeight = _ref8$strategy.lastValidBlockHeight, signature = _ref8$strategy.signature;\n              done = false;\n              expiryPromise = new Promise(function (resolve) {\n                var checkBlockHeight = /*#__PURE__*/function () {\n                  var _ref9 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee28() {\n                    var blockHeight;\n                    return _regeneratorRuntime$1().wrap(function _callee28$(_context28) {\n                      while (1) switch (_context28.prev = _context28.next) {\n                        case 0:\n                          _context28.prev = 0;\n                          _context28.next = 3;\n                          return _this3.getBlockHeight(commitment);\n                        case 3:\n                          blockHeight = _context28.sent;\n                          return _context28.abrupt(\"return\", blockHeight);\n                        case 7:\n                          _context28.prev = 7;\n                          _context28.t0 = _context28[\"catch\"](0);\n                          return _context28.abrupt(\"return\", -1);\n                        case 10:\n                        case \"end\":\n                          return _context28.stop();\n                      }\n                    }, _callee28, null, [[0, 7]]);\n                  }));\n                  return function checkBlockHeight() {\n                    return _ref9.apply(this, arguments);\n                  };\n                }();\n                (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee29() {\n                  var currentBlockHeight;\n                  return _regeneratorRuntime$1().wrap(function _callee29$(_context29) {\n                    while (1) switch (_context29.prev = _context29.next) {\n                      case 0:\n                        _context29.next = 2;\n                        return checkBlockHeight();\n                      case 2:\n                        currentBlockHeight = _context29.sent;\n                        if (!done) {\n                          _context29.next = 5;\n                          break;\n                        }\n                        return _context29.abrupt(\"return\");\n                      case 5:\n                        if (!(currentBlockHeight <= lastValidBlockHeight)) {\n                          _context29.next = 17;\n                          break;\n                        }\n                        _context29.next = 8;\n                        return sleep(1000);\n                      case 8:\n                        if (!done) {\n                          _context29.next = 10;\n                          break;\n                        }\n                        return _context29.abrupt(\"return\");\n                      case 10:\n                        _context29.next = 12;\n                        return checkBlockHeight();\n                      case 12:\n                        currentBlockHeight = _context29.sent;\n                        if (!done) {\n                          _context29.next = 15;\n                          break;\n                        }\n                        return _context29.abrupt(\"return\");\n                      case 15:\n                        _context29.next = 5;\n                        break;\n                      case 17:\n                        resolve({\n                          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n                        });\n                      case 18:\n                      case \"end\":\n                        return _context29.stop();\n                    }\n                  }, _callee29);\n                }))();\n              });\n              _this$getTransactionC = this.getTransactionConfirmationPromise({\n                commitment: commitment,\n                signature: signature\n              }), abortConfirmation = _this$getTransactionC.abortConfirmation, confirmationPromise = _this$getTransactionC.confirmationPromise;\n              cancellationPromise = this.getCancellationPromise(abortSignal);\n              _context30.prev = 5;\n              _context30.next = 8;\n              return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n            case 8:\n              outcome = _context30.sent;\n              if (!(outcome.__type === TransactionStatus.PROCESSED)) {\n                _context30.next = 13;\n                break;\n              }\n              result = outcome.response;\n              _context30.next = 14;\n              break;\n            case 13:\n              throw new TransactionExpiredBlockheightExceededError(signature);\n            case 14:\n              _context30.prev = 14;\n              done = true;\n              abortConfirmation();\n              return _context30.finish(14);\n            case 18:\n              return _context30.abrupt(\"return\", result);\n            case 19:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this, [[5,, 14, 18]]);\n      }));\n      function confirmTransactionUsingBlockHeightExceedanceStrategy(_x46) {\n        return _confirmTransactionUsingBlockHeightExceedanceStrategy.apply(this, arguments);\n      }\n      return confirmTransactionUsingBlockHeightExceedanceStrategy;\n    }()\n  }, {\n    key: \"confirmTransactionUsingDurableNonceStrategy\",\n    value: function () {\n      var _confirmTransactionUsingDurableNonceStrategy = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee33(_ref11) {\n        var _this4 = this;\n        var commitment, _ref11$strategy, abortSignal, minContextSlot, nonceAccountPubkey, nonceValue, signature, done, expiryPromise, _this$getTransactionC2, abortConfirmation, confirmationPromise, cancellationPromise, result, outcome, _signatureStatus, signatureStatus, _outcome$slotInWhichN, status, commitmentForStatus, confirmationStatus;\n        return _regeneratorRuntime$1().wrap(function _callee33$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              commitment = _ref11.commitment, _ref11$strategy = _ref11.strategy, abortSignal = _ref11$strategy.abortSignal, minContextSlot = _ref11$strategy.minContextSlot, nonceAccountPubkey = _ref11$strategy.nonceAccountPubkey, nonceValue = _ref11$strategy.nonceValue, signature = _ref11$strategy.signature;\n              done = false;\n              expiryPromise = new Promise(function (resolve) {\n                var currentNonceValue = nonceValue;\n                var lastCheckedSlot = null;\n                var getCurrentNonceValue = /*#__PURE__*/function () {\n                  var _ref12 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee31() {\n                    var _yield$_this4$getNonc, _context31, nonceAccount;\n                    return _regeneratorRuntime$1().wrap(function _callee31$(_context32) {\n                      while (1) switch (_context32.prev = _context32.next) {\n                        case 0:\n                          _context32.prev = 0;\n                          _context32.next = 3;\n                          return _this4.getNonceAndContext(nonceAccountPubkey, {\n                            commitment: commitment,\n                            minContextSlot: minContextSlot\n                          });\n                        case 3:\n                          _yield$_this4$getNonc = _context32.sent;\n                          _context31 = _yield$_this4$getNonc.context;\n                          nonceAccount = _yield$_this4$getNonc.value;\n                          lastCheckedSlot = _context31.slot;\n                          return _context32.abrupt(\"return\", nonceAccount === null || nonceAccount === void 0 ? void 0 : nonceAccount.nonce);\n                        case 10:\n                          _context32.prev = 10;\n                          _context32.t0 = _context32[\"catch\"](0);\n                          return _context32.abrupt(\"return\", currentNonceValue);\n                        case 13:\n                        case \"end\":\n                          return _context32.stop();\n                      }\n                    }, _callee31, null, [[0, 10]]);\n                  }));\n                  return function getCurrentNonceValue() {\n                    return _ref12.apply(this, arguments);\n                  };\n                }();\n                (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee32() {\n                  return _regeneratorRuntime$1().wrap(function _callee32$(_context33) {\n                    while (1) switch (_context33.prev = _context33.next) {\n                      case 0:\n                        _context33.next = 2;\n                        return getCurrentNonceValue();\n                      case 2:\n                        currentNonceValue = _context33.sent;\n                        if (!done) {\n                          _context33.next = 5;\n                          break;\n                        }\n                        return _context33.abrupt(\"return\");\n                      case 5:\n                        if (!(nonceValue !== currentNonceValue)) {\n                          _context33.next = 9;\n                          break;\n                        }\n                        resolve({\n                          __type: TransactionStatus.NONCE_INVALID,\n                          slotInWhichNonceDidAdvance: lastCheckedSlot\n                        });\n                        return _context33.abrupt(\"return\");\n                      case 9:\n                        _context33.next = 11;\n                        return sleep(2000);\n                      case 11:\n                        if (!done) {\n                          _context33.next = 13;\n                          break;\n                        }\n                        return _context33.abrupt(\"return\");\n                      case 13:\n                        _context33.next = 15;\n                        return getCurrentNonceValue();\n                      case 15:\n                        currentNonceValue = _context33.sent;\n                        if (!done) {\n                          _context33.next = 18;\n                          break;\n                        }\n                        return _context33.abrupt(\"return\");\n                      case 18:\n                        _context33.next = 5;\n                        break;\n                      case 20:\n                      case \"end\":\n                        return _context33.stop();\n                    }\n                  }, _callee32);\n                }))();\n              });\n              _this$getTransactionC2 = this.getTransactionConfirmationPromise({\n                commitment: commitment,\n                signature: signature\n              }), abortConfirmation = _this$getTransactionC2.abortConfirmation, confirmationPromise = _this$getTransactionC2.confirmationPromise;\n              cancellationPromise = this.getCancellationPromise(abortSignal);\n              _context34.prev = 5;\n              _context34.next = 8;\n              return Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n            case 8:\n              outcome = _context34.sent;\n              if (!(outcome.__type === TransactionStatus.PROCESSED)) {\n                _context34.next = 13;\n                break;\n              }\n              result = outcome.response;\n              _context34.next = 47;\n              break;\n            case 13:\n              _context34.next = 16;\n              return this.getSignatureStatus(signature);\n            case 16:\n              status = _context34.sent;\n              if (!(status == null)) {\n                _context34.next = 19;\n                break;\n              }\n              return _context34.abrupt(\"break\", 27);\n            case 19:\n              if (!(status.context.slot < ((_outcome$slotInWhichN = outcome.slotInWhichNonceDidAdvance) !== null && _outcome$slotInWhichN !== void 0 ? _outcome$slotInWhichN : minContextSlot))) {\n                _context34.next = 23;\n                break;\n              }\n              _context34.next = 22;\n              return sleep(400);\n            case 22:\n              return _context34.abrupt(\"continue\", 13);\n            case 23:\n              signatureStatus = status;\n              return _context34.abrupt(\"break\", 27);\n            case 27:\n              if (!((_signatureStatus = signatureStatus) !== null && _signatureStatus !== void 0 && _signatureStatus.value)) {\n                _context34.next = 46;\n                break;\n              }\n              commitmentForStatus = commitment || 'finalized';\n              confirmationStatus = signatureStatus.value.confirmationStatus;\n              _context34.t0 = commitmentForStatus;\n              _context34.next = _context34.t0 === 'processed' ? 33 : _context34.t0 === 'recent' ? 33 : _context34.t0 === 'confirmed' ? 36 : _context34.t0 === 'single' ? 36 : _context34.t0 === 'singleGossip' ? 36 : _context34.t0 === 'finalized' ? 39 : _context34.t0 === 'max' ? 39 : _context34.t0 === 'root' ? 39 : 42;\n              break;\n            case 33:\n              if (!(confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {\n                _context34.next = 35;\n                break;\n              }\n              throw new TransactionExpiredNonceInvalidError(signature);\n            case 35:\n              return _context34.abrupt(\"break\", 43);\n            case 36:\n              if (!(confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized')) {\n                _context34.next = 38;\n                break;\n              }\n              throw new TransactionExpiredNonceInvalidError(signature);\n            case 38:\n              return _context34.abrupt(\"break\", 43);\n            case 39:\n              if (!(confirmationStatus !== 'finalized')) {\n                _context34.next = 41;\n                break;\n              }\n              throw new TransactionExpiredNonceInvalidError(signature);\n            case 41:\n              return _context34.abrupt(\"break\", 43);\n            case 42:\n            case 43:\n              result = {\n                context: signatureStatus.context,\n                value: {\n                  err: signatureStatus.value.err\n                }\n              };\n              _context34.next = 47;\n              break;\n            case 46:\n              throw new TransactionExpiredNonceInvalidError(signature);\n            case 47:\n              _context34.prev = 47;\n              done = true;\n              abortConfirmation();\n              return _context34.finish(47);\n            case 51:\n              return _context34.abrupt(\"return\", result);\n            case 52:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee33, this, [[5,, 47, 51]]);\n      }));\n      function confirmTransactionUsingDurableNonceStrategy(_x47) {\n        return _confirmTransactionUsingDurableNonceStrategy.apply(this, arguments);\n      }\n      return confirmTransactionUsingDurableNonceStrategy;\n    }()\n  }, {\n    key: \"confirmTransactionUsingLegacyTimeoutStrategy\",\n    value: function () {\n      var _confirmTransactionUsingLegacyTimeoutStrategy = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee34(_ref14) {\n        var _this5 = this;\n        var commitment, signature, timeoutId, expiryPromise, _this$getTransactionC3, abortConfirmation, confirmationPromise, result, outcome;\n        return _regeneratorRuntime$1().wrap(function _callee34$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              commitment = _ref14.commitment, signature = _ref14.signature;\n              expiryPromise = new Promise(function (resolve) {\n                var timeoutMs = _this5._confirmTransactionInitialTimeout || 60 * 1000;\n                switch (commitment) {\n                  case 'processed':\n                  case 'recent':\n                  case 'single':\n                  case 'confirmed':\n                  case 'singleGossip':\n                    {\n                      timeoutMs = _this5._confirmTransactionInitialTimeout || 30 * 1000;\n                      break;\n                    }\n                }\n                timeoutId = setTimeout(function () {\n                  return resolve({\n                    __type: TransactionStatus.TIMED_OUT,\n                    timeoutMs: timeoutMs\n                  });\n                }, timeoutMs);\n              });\n              _this$getTransactionC3 = this.getTransactionConfirmationPromise({\n                commitment: commitment,\n                signature: signature\n              }), abortConfirmation = _this$getTransactionC3.abortConfirmation, confirmationPromise = _this$getTransactionC3.confirmationPromise;\n              _context35.prev = 3;\n              _context35.next = 6;\n              return Promise.race([confirmationPromise, expiryPromise]);\n            case 6:\n              outcome = _context35.sent;\n              if (!(outcome.__type === TransactionStatus.PROCESSED)) {\n                _context35.next = 11;\n                break;\n              }\n              result = outcome.response;\n              _context35.next = 12;\n              break;\n            case 11:\n              throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n            case 12:\n              _context35.prev = 12;\n              clearTimeout(timeoutId);\n              abortConfirmation();\n              return _context35.finish(12);\n            case 16:\n              return _context35.abrupt(\"return\", result);\n            case 17:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee34, this, [[3,, 12, 16]]);\n      }));\n      function confirmTransactionUsingLegacyTimeoutStrategy(_x48) {\n        return _confirmTransactionUsingLegacyTimeoutStrategy.apply(this, arguments);\n      }\n      return confirmTransactionUsingLegacyTimeoutStrategy;\n    }()\n    /**\n     * Return the list of nodes that are currently participating in the cluster\n     */\n  }, {\n    key: \"getClusterNodes\",\n    value: function () {\n      var _getClusterNodes = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee35() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee35$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              _context36.next = 2;\n              return this._rpcRequest('getClusterNodes', []);\n            case 2:\n              unsafeRes = _context36.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(ContactInfoResult)));\n              if (!('error' in res)) {\n                _context36.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');\n            case 6:\n              return _context36.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee35, this);\n      }));\n      function getClusterNodes() {\n        return _getClusterNodes.apply(this, arguments);\n      }\n      return getClusterNodes;\n    }()\n    /**\n     * Return the list of nodes that are currently participating in the cluster\n     */\n  }, {\n    key: \"getVoteAccounts\",\n    value: function () {\n      var _getVoteAccounts = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee36(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee36$(_context37) {\n          while (1) switch (_context37.prev = _context37.next) {\n            case 0:\n              args = this._buildArgs([], commitment);\n              _context37.next = 3;\n              return this._rpcRequest('getVoteAccounts', args);\n            case 3:\n              unsafeRes = _context37.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetVoteAccounts);\n              if (!('error' in res)) {\n                _context37.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');\n            case 7:\n              return _context37.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context37.stop();\n          }\n        }, _callee36, this);\n      }));\n      function getVoteAccounts(_x49) {\n        return _getVoteAccounts.apply(this, arguments);\n      }\n      return getVoteAccounts;\n    }()\n    /**\n     * Fetch the current slot that the node is processing\n     */\n  }, {\n    key: \"getSlot\",\n    value: function () {\n      var _getSlot = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee37(commitmentOrConfig) {\n        var _extractCommitmentFro11, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee37$(_context38) {\n          while (1) switch (_context38.prev = _context38.next) {\n            case 0:\n              _extractCommitmentFro11 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro11.commitment, config = _extractCommitmentFro11.config;\n              args = this._buildArgs([], commitment, undefined /* encoding */, config);\n              _context38.next = 4;\n              return this._rpcRequest('getSlot', args);\n            case 4:\n              unsafeRes = _context38.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n              if (!('error' in res)) {\n                _context38.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n            case 8:\n              return _context38.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context38.stop();\n          }\n        }, _callee37, this);\n      }));\n      function getSlot(_x50) {\n        return _getSlot.apply(this, arguments);\n      }\n      return getSlot;\n    }()\n    /**\n     * Fetch the current slot leader of the cluster\n     */\n  }, {\n    key: \"getSlotLeader\",\n    value: function () {\n      var _getSlotLeader = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee38(commitmentOrConfig) {\n        var _extractCommitmentFro12, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee38$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              _extractCommitmentFro12 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro12.commitment, config = _extractCommitmentFro12.config;\n              args = this._buildArgs([], commitment, undefined /* encoding */, config);\n              _context39.next = 4;\n              return this._rpcRequest('getSlotLeader', args);\n            case 4:\n              unsafeRes = _context39.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()));\n              if (!('error' in res)) {\n                _context39.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');\n            case 8:\n              return _context39.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee38, this);\n      }));\n      function getSlotLeader(_x51) {\n        return _getSlotLeader.apply(this, arguments);\n      }\n      return getSlotLeader;\n    }()\n    /**\n     * Fetch `limit` number of slot leaders starting from `startSlot`\n     *\n     * @param startSlot fetch slot leaders starting from this slot\n     * @param limit number of slot leaders to return\n     */\n  }, {\n    key: \"getSlotLeaders\",\n    value: function () {\n      var _getSlotLeaders = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee39(startSlot, limit) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee39$(_context40) {\n          while (1) switch (_context40.prev = _context40.next) {\n            case 0:\n              args = [startSlot, limit];\n              _context40.next = 3;\n              return this._rpcRequest('getSlotLeaders', args);\n            case 3:\n              unsafeRes = _context40.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)(PublicKeyFromString)));\n              if (!('error' in res)) {\n                _context40.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');\n            case 7:\n              return _context40.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context40.stop();\n          }\n        }, _callee39, this);\n      }));\n      function getSlotLeaders(_x52, _x53) {\n        return _getSlotLeaders.apply(this, arguments);\n      }\n      return getSlotLeaders;\n    }()\n    /**\n     * Fetch the current status of a signature\n     */\n  }, {\n    key: \"getSignatureStatus\",\n    value: function () {\n      var _getSignatureStatus = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee40(signature, config) {\n        var _yield$this$getSignat, context, values, value;\n        return _regeneratorRuntime$1().wrap(function _callee40$(_context41) {\n          while (1) switch (_context41.prev = _context41.next) {\n            case 0:\n              _context41.next = 2;\n              return this.getSignatureStatuses([signature], config);\n            case 2:\n              _yield$this$getSignat = _context41.sent;\n              context = _yield$this$getSignat.context;\n              values = _yield$this$getSignat.value;\n              assert(values.length === 1);\n              value = values[0];\n              return _context41.abrupt(\"return\", {\n                context: context,\n                value: value\n              });\n            case 8:\n            case \"end\":\n              return _context41.stop();\n          }\n        }, _callee40, this);\n      }));\n      function getSignatureStatus(_x54, _x55) {\n        return _getSignatureStatus.apply(this, arguments);\n      }\n      return getSignatureStatus;\n    }()\n    /**\n     * Fetch the current statuses of a batch of signatures\n     */\n  }, {\n    key: \"getSignatureStatuses\",\n    value: function () {\n      var _getSignatureStatuses = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee41(signatures, config) {\n        var params, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee41$(_context42) {\n          while (1) switch (_context42.prev = _context42.next) {\n            case 0:\n              params = [signatures];\n              if (config) {\n                params.push(config);\n              }\n              _context42.next = 4;\n              return this._rpcRequest('getSignatureStatuses', params);\n            case 4:\n              unsafeRes = _context42.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n              if (!('error' in res)) {\n                _context42.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get signature status');\n            case 8:\n              return _context42.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context42.stop();\n          }\n        }, _callee41, this);\n      }));\n      function getSignatureStatuses(_x56, _x57) {\n        return _getSignatureStatuses.apply(this, arguments);\n      }\n      return getSignatureStatuses;\n    }()\n    /**\n     * Fetch the current transaction count of the cluster\n     */\n  }, {\n    key: \"getTransactionCount\",\n    value: function () {\n      var _getTransactionCount = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee42(commitmentOrConfig) {\n        var _extractCommitmentFro13, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee42$(_context43) {\n          while (1) switch (_context43.prev = _context43.next) {\n            case 0:\n              _extractCommitmentFro13 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro13.commitment, config = _extractCommitmentFro13.config;\n              args = this._buildArgs([], commitment, undefined /* encoding */, config);\n              _context43.next = 4;\n              return this._rpcRequest('getTransactionCount', args);\n            case 4:\n              unsafeRes = _context43.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n              if (!('error' in res)) {\n                _context43.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');\n            case 8:\n              return _context43.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context43.stop();\n          }\n        }, _callee42, this);\n      }));\n      function getTransactionCount(_x58) {\n        return _getTransactionCount.apply(this, arguments);\n      }\n      return getTransactionCount;\n    }()\n    /**\n     * Fetch the current total currency supply of the cluster in lamports\n     *\n     * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n     */\n  }, {\n    key: \"getTotalSupply\",\n    value: function () {\n      var _getTotalSupply = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee43(commitment) {\n        var result;\n        return _regeneratorRuntime$1().wrap(function _callee43$(_context44) {\n          while (1) switch (_context44.prev = _context44.next) {\n            case 0:\n              _context44.next = 2;\n              return this.getSupply({\n                commitment: commitment,\n                excludeNonCirculatingAccountsList: true\n              });\n            case 2:\n              result = _context44.sent;\n              return _context44.abrupt(\"return\", result.value.total);\n            case 4:\n            case \"end\":\n              return _context44.stop();\n          }\n        }, _callee43, this);\n      }));\n      function getTotalSupply(_x59) {\n        return _getTotalSupply.apply(this, arguments);\n      }\n      return getTotalSupply;\n    }()\n    /**\n     * Fetch the cluster InflationGovernor parameters\n     */\n  }, {\n    key: \"getInflationGovernor\",\n    value: function () {\n      var _getInflationGovernor = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee44(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee44$(_context45) {\n          while (1) switch (_context45.prev = _context45.next) {\n            case 0:\n              args = this._buildArgs([], commitment);\n              _context45.next = 3;\n              return this._rpcRequest('getInflationGovernor', args);\n            case 3:\n              unsafeRes = _context45.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetInflationGovernorRpcResult);\n              if (!('error' in res)) {\n                _context45.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get inflation');\n            case 7:\n              return _context45.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context45.stop();\n          }\n        }, _callee44, this);\n      }));\n      function getInflationGovernor(_x60) {\n        return _getInflationGovernor.apply(this, arguments);\n      }\n      return getInflationGovernor;\n    }()\n    /**\n     * Fetch the inflation reward for a list of addresses for an epoch\n     */\n  }, {\n    key: \"getInflationReward\",\n    value: function () {\n      var _getInflationReward = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee45(addresses, epoch, commitmentOrConfig) {\n        var _extractCommitmentFro14, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee45$(_context46) {\n          while (1) switch (_context46.prev = _context46.next) {\n            case 0:\n              _extractCommitmentFro14 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro14.commitment, config = _extractCommitmentFro14.config;\n              args = this._buildArgs([addresses.map(function (pubkey) {\n                return pubkey.toBase58();\n              })], commitment, undefined /* encoding */, _objectSpread(_objectSpread({}, config), {}, {\n                epoch: epoch != null ? epoch : config === null || config === void 0 ? void 0 : config.epoch\n              }));\n              _context46.next = 4;\n              return this._rpcRequest('getInflationReward', args);\n            case 4:\n              unsafeRes = _context46.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetInflationRewardResult);\n              if (!('error' in res)) {\n                _context46.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');\n            case 8:\n              return _context46.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context46.stop();\n          }\n        }, _callee45, this);\n      }));\n      function getInflationReward(_x61, _x62, _x63) {\n        return _getInflationReward.apply(this, arguments);\n      }\n      return getInflationReward;\n    }()\n    /**\n     * Fetch the specific inflation values for the current epoch\n     */\n  }, {\n    key: \"getInflationRate\",\n    value: function () {\n      var _getInflationRate = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee46() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee46$(_context47) {\n          while (1) switch (_context47.prev = _context47.next) {\n            case 0:\n              _context47.next = 2;\n              return this._rpcRequest('getInflationRate', []);\n            case 2:\n              unsafeRes = _context47.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetInflationRateRpcResult);\n              if (!('error' in res)) {\n                _context47.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');\n            case 6:\n              return _context47.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context47.stop();\n          }\n        }, _callee46, this);\n      }));\n      function getInflationRate() {\n        return _getInflationRate.apply(this, arguments);\n      }\n      return getInflationRate;\n    }()\n    /**\n     * Fetch the Epoch Info parameters\n     */\n  }, {\n    key: \"getEpochInfo\",\n    value: function () {\n      var _getEpochInfo = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee47(commitmentOrConfig) {\n        var _extractCommitmentFro15, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee47$(_context48) {\n          while (1) switch (_context48.prev = _context48.next) {\n            case 0:\n              _extractCommitmentFro15 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro15.commitment, config = _extractCommitmentFro15.config;\n              args = this._buildArgs([], commitment, undefined /* encoding */, config);\n              _context48.next = 4;\n              return this._rpcRequest('getEpochInfo', args);\n            case 4:\n              unsafeRes = _context48.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetEpochInfoRpcResult);\n              if (!('error' in res)) {\n                _context48.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');\n            case 8:\n              return _context48.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context48.stop();\n          }\n        }, _callee47, this);\n      }));\n      function getEpochInfo(_x64) {\n        return _getEpochInfo.apply(this, arguments);\n      }\n      return getEpochInfo;\n    }()\n    /**\n     * Fetch the Epoch Schedule parameters\n     */\n  }, {\n    key: \"getEpochSchedule\",\n    value: function () {\n      var _getEpochSchedule = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee48() {\n        var unsafeRes, res, epochSchedule;\n        return _regeneratorRuntime$1().wrap(function _callee48$(_context49) {\n          while (1) switch (_context49.prev = _context49.next) {\n            case 0:\n              _context49.next = 2;\n              return this._rpcRequest('getEpochSchedule', []);\n            case 2:\n              unsafeRes = _context49.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetEpochScheduleRpcResult);\n              if (!('error' in res)) {\n                _context49.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');\n            case 6:\n              epochSchedule = res.result;\n              return _context49.abrupt(\"return\", new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot));\n            case 8:\n            case \"end\":\n              return _context49.stop();\n          }\n        }, _callee48, this);\n      }));\n      function getEpochSchedule() {\n        return _getEpochSchedule.apply(this, arguments);\n      }\n      return getEpochSchedule;\n    }()\n    /**\n     * Fetch the leader schedule for the current epoch\n     * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n     */\n  }, {\n    key: \"getLeaderSchedule\",\n    value: function () {\n      var _getLeaderSchedule = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee49() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee49$(_context50) {\n          while (1) switch (_context50.prev = _context50.next) {\n            case 0:\n              _context50.next = 2;\n              return this._rpcRequest('getLeaderSchedule', []);\n            case 2:\n              unsafeRes = _context50.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n              if (!('error' in res)) {\n                _context50.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');\n            case 6:\n              return _context50.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context50.stop();\n          }\n        }, _callee49, this);\n      }));\n      function getLeaderSchedule() {\n        return _getLeaderSchedule.apply(this, arguments);\n      }\n      return getLeaderSchedule;\n    }()\n    /**\n     * Fetch the minimum balance needed to exempt an account of `dataLength`\n     * size from rent\n     */\n  }, {\n    key: \"getMinimumBalanceForRentExemption\",\n    value: function () {\n      var _getMinimumBalanceForRentExemption = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee50(dataLength, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee50$(_context51) {\n          while (1) switch (_context51.prev = _context51.next) {\n            case 0:\n              args = this._buildArgs([dataLength], commitment);\n              _context51.next = 3;\n              return this._rpcRequest('getMinimumBalanceForRentExemption', args);\n            case 3:\n              unsafeRes = _context51.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n              if (!('error' in res)) {\n                _context51.next = 8;\n                break;\n              }\n              console.warn('Unable to fetch minimum balance for rent exemption');\n              return _context51.abrupt(\"return\", 0);\n            case 8:\n              return _context51.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context51.stop();\n          }\n        }, _callee50, this);\n      }));\n      function getMinimumBalanceForRentExemption(_x65, _x66) {\n        return _getMinimumBalanceForRentExemption.apply(this, arguments);\n      }\n      return getMinimumBalanceForRentExemption;\n    }()\n    /**\n     * Fetch a recent blockhash from the cluster, return with context\n     * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n     */\n  }, {\n    key: \"getRecentBlockhashAndContext\",\n    value: function () {\n      var _getRecentBlockhashAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee51(commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee51$(_context52) {\n          while (1) switch (_context52.prev = _context52.next) {\n            case 0:\n              args = this._buildArgs([], commitment);\n              _context52.next = 3;\n              return this._rpcRequest('getRecentBlockhash', args);\n            case 3:\n              unsafeRes = _context52.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n              if (!('error' in res)) {\n                _context52.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');\n            case 7:\n              return _context52.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context52.stop();\n          }\n        }, _callee51, this);\n      }));\n      function getRecentBlockhashAndContext(_x67) {\n        return _getRecentBlockhashAndContext.apply(this, arguments);\n      }\n      return getRecentBlockhashAndContext;\n    }()\n    /**\n     * Fetch recent performance samples\n     * @return {Promise<Array<PerfSample>>}\n     */\n  }, {\n    key: \"getRecentPerformanceSamples\",\n    value: function () {\n      var _getRecentPerformanceSamples = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee52(limit) {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee52$(_context53) {\n          while (1) switch (_context53.prev = _context53.next) {\n            case 0:\n              _context53.next = 2;\n              return this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);\n            case 2:\n              unsafeRes = _context53.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n              if (!('error' in res)) {\n                _context53.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');\n            case 6:\n              return _context53.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context53.stop();\n          }\n        }, _callee52, this);\n      }));\n      function getRecentPerformanceSamples(_x68) {\n        return _getRecentPerformanceSamples.apply(this, arguments);\n      }\n      return getRecentPerformanceSamples;\n    }()\n    /**\n     * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n     */\n  }, {\n    key: \"getFeeCalculatorForBlockhash\",\n    value: function () {\n      var _getFeeCalculatorForBlockhash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee53(blockhash, commitment) {\n        var args, unsafeRes, res, _res$result, context, value;\n        return _regeneratorRuntime$1().wrap(function _callee53$(_context54) {\n          while (1) switch (_context54.prev = _context54.next) {\n            case 0:\n              args = this._buildArgs([blockhash], commitment);\n              _context54.next = 3;\n              return this._rpcRequest('getFeeCalculatorForBlockhash', args);\n            case 3:\n              unsafeRes = _context54.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n              if (!('error' in res)) {\n                _context54.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');\n            case 7:\n              _res$result = res.result, context = _res$result.context, value = _res$result.value;\n              return _context54.abrupt(\"return\", {\n                context: context,\n                value: value !== null ? value.feeCalculator : null\n              });\n            case 9:\n            case \"end\":\n              return _context54.stop();\n          }\n        }, _callee53, this);\n      }));\n      function getFeeCalculatorForBlockhash(_x69, _x70) {\n        return _getFeeCalculatorForBlockhash.apply(this, arguments);\n      }\n      return getFeeCalculatorForBlockhash;\n    }()\n    /**\n     * Fetch the fee for a message from the cluster, return with context\n     */\n  }, {\n    key: \"getFeeForMessage\",\n    value: function () {\n      var _getFeeForMessage = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee54(message, commitment) {\n        var wireMessage, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee54$(_context55) {\n          while (1) switch (_context55.prev = _context55.next) {\n            case 0:\n              wireMessage = toBuffer(message.serialize()).toString('base64');\n              args = this._buildArgs([wireMessage], commitment);\n              _context55.next = 4;\n              return this._rpcRequest('getFeeForMessage', args);\n            case 4:\n              unsafeRes = _context55.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())));\n              if (!('error' in res)) {\n                _context55.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');\n            case 8:\n              if (!(res.result === null)) {\n                _context55.next = 10;\n                break;\n              }\n              throw new Error('invalid blockhash');\n            case 10:\n              return _context55.abrupt(\"return\", res.result);\n            case 11:\n            case \"end\":\n              return _context55.stop();\n          }\n        }, _callee54, this);\n      }));\n      function getFeeForMessage(_x71, _x72) {\n        return _getFeeForMessage.apply(this, arguments);\n      }\n      return getFeeForMessage;\n    }()\n    /**\n     * Fetch a list of prioritization fees from recent blocks.\n     */\n  }, {\n    key: \"getRecentPrioritizationFees\",\n    value: function () {\n      var _getRecentPrioritizationFees = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee55(config) {\n        var _config$lockedWritabl;\n        var accounts, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee55$(_context56) {\n          while (1) switch (_context56.prev = _context56.next) {\n            case 0:\n              accounts = config === null || config === void 0 ? void 0 : (_config$lockedWritabl = config.lockedWritableAccounts) === null || _config$lockedWritabl === void 0 ? void 0 : _config$lockedWritabl.map(function (key) {\n                return key.toBase58();\n              });\n              args = accounts !== null && accounts !== void 0 && accounts.length ? [accounts] : [];\n              _context56.next = 4;\n              return this._rpcRequest('getRecentPrioritizationFees', args);\n            case 4:\n              unsafeRes = _context56.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n              if (!('error' in res)) {\n                _context56.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');\n            case 8:\n              return _context56.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context56.stop();\n          }\n        }, _callee55, this);\n      }));\n      function getRecentPrioritizationFees(_x73) {\n        return _getRecentPrioritizationFees.apply(this, arguments);\n      }\n      return getRecentPrioritizationFees;\n    }()\n    /**\n     * Fetch a recent blockhash from the cluster\n     * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n     */\n  }, {\n    key: \"getRecentBlockhash\",\n    value: function () {\n      var _getRecentBlockhash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee56(commitment) {\n        var res;\n        return _regeneratorRuntime$1().wrap(function _callee56$(_context57) {\n          while (1) switch (_context57.prev = _context57.next) {\n            case 0:\n              _context57.prev = 0;\n              _context57.next = 3;\n              return this.getRecentBlockhashAndContext(commitment);\n            case 3:\n              res = _context57.sent;\n              return _context57.abrupt(\"return\", res.value);\n            case 7:\n              _context57.prev = 7;\n              _context57.t0 = _context57[\"catch\"](0);\n              throw new Error('failed to get recent blockhash: ' + _context57.t0);\n            case 10:\n            case \"end\":\n              return _context57.stop();\n          }\n        }, _callee56, this, [[0, 7]]);\n      }));\n      function getRecentBlockhash(_x74) {\n        return _getRecentBlockhash.apply(this, arguments);\n      }\n      return getRecentBlockhash;\n    }()\n    /**\n     * Fetch the latest blockhash from the cluster\n     * @return {Promise<BlockhashWithExpiryBlockHeight>}\n     */\n  }, {\n    key: \"getLatestBlockhash\",\n    value: function () {\n      var _getLatestBlockhash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee57(commitmentOrConfig) {\n        var res;\n        return _regeneratorRuntime$1().wrap(function _callee57$(_context58) {\n          while (1) switch (_context58.prev = _context58.next) {\n            case 0:\n              _context58.prev = 0;\n              _context58.next = 3;\n              return this.getLatestBlockhashAndContext(commitmentOrConfig);\n            case 3:\n              res = _context58.sent;\n              return _context58.abrupt(\"return\", res.value);\n            case 7:\n              _context58.prev = 7;\n              _context58.t0 = _context58[\"catch\"](0);\n              throw new Error('failed to get recent blockhash: ' + _context58.t0);\n            case 10:\n            case \"end\":\n              return _context58.stop();\n          }\n        }, _callee57, this, [[0, 7]]);\n      }));\n      function getLatestBlockhash(_x75) {\n        return _getLatestBlockhash.apply(this, arguments);\n      }\n      return getLatestBlockhash;\n    }()\n    /**\n     * Fetch the latest blockhash from the cluster\n     * @return {Promise<BlockhashWithExpiryBlockHeight>}\n     */\n  }, {\n    key: \"getLatestBlockhashAndContext\",\n    value: function () {\n      var _getLatestBlockhashAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee58(commitmentOrConfig) {\n        var _extractCommitmentFro16, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee58$(_context59) {\n          while (1) switch (_context59.prev = _context59.next) {\n            case 0:\n              _extractCommitmentFro16 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro16.commitment, config = _extractCommitmentFro16.config;\n              args = this._buildArgs([], commitment, undefined /* encoding */, config);\n              _context59.next = 4;\n              return this._rpcRequest('getLatestBlockhash', args);\n            case 4:\n              unsafeRes = _context59.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n              if (!('error' in res)) {\n                _context59.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');\n            case 8:\n              return _context59.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context59.stop();\n          }\n        }, _callee58, this);\n      }));\n      function getLatestBlockhashAndContext(_x76) {\n        return _getLatestBlockhashAndContext.apply(this, arguments);\n      }\n      return getLatestBlockhashAndContext;\n    }()\n    /**\n     * Returns whether a blockhash is still valid or not\n     */\n  }, {\n    key: \"isBlockhashValid\",\n    value: function () {\n      var _isBlockhashValid = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee59(blockhash, rawConfig) {\n        var _extractCommitmentFro17, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee59$(_context60) {\n          while (1) switch (_context60.prev = _context60.next) {\n            case 0:\n              _extractCommitmentFro17 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro17.commitment, config = _extractCommitmentFro17.config;\n              args = this._buildArgs([blockhash], commitment, undefined /* encoding */, config);\n              _context60.next = 4;\n              return this._rpcRequest('isBlockhashValid', args);\n            case 4:\n              unsafeRes = _context60.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, IsBlockhashValidRpcResult);\n              if (!('error' in res)) {\n                _context60.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to determine if the blockhash `' + blockhash + '`is valid');\n            case 8:\n              return _context60.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context60.stop();\n          }\n        }, _callee59, this);\n      }));\n      function isBlockhashValid(_x77, _x78) {\n        return _isBlockhashValid.apply(this, arguments);\n      }\n      return isBlockhashValid;\n    }()\n    /**\n     * Fetch the node version\n     */\n  }, {\n    key: \"getVersion\",\n    value: function () {\n      var _getVersion = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee60() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee60$(_context61) {\n          while (1) switch (_context61.prev = _context61.next) {\n            case 0:\n              _context61.next = 2;\n              return this._rpcRequest('getVersion', []);\n            case 2:\n              unsafeRes = _context61.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult(VersionResult));\n              if (!('error' in res)) {\n                _context61.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get version');\n            case 6:\n              return _context61.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context61.stop();\n          }\n        }, _callee60, this);\n      }));\n      function getVersion() {\n        return _getVersion.apply(this, arguments);\n      }\n      return getVersion;\n    }()\n    /**\n     * Fetch the genesis hash\n     */\n  }, {\n    key: \"getGenesisHash\",\n    value: function () {\n      var _getGenesisHash = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee61() {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee61$(_context62) {\n          while (1) switch (_context62.prev = _context62.next) {\n            case 0:\n              _context62.next = 2;\n              return this._rpcRequest('getGenesisHash', []);\n            case 2:\n              unsafeRes = _context62.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()));\n              if (!('error' in res)) {\n                _context62.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');\n            case 6:\n              return _context62.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context62.stop();\n          }\n        }, _callee61, this);\n      }));\n      function getGenesisHash() {\n        return _getGenesisHash.apply(this, arguments);\n      }\n      return getGenesisHash;\n    }()\n    /**\n     * Fetch a processed block from the cluster.\n     *\n     * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n     * setting the `maxSupportedTransactionVersion` property.\n     */\n  }, {\n    key: \"getBlock\",\n    value:\n    /**\n     * Fetch a processed block from the cluster.\n     */\n    // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _getBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee62(slot, rawConfig) {\n        var _extractCommitmentFro18, commitment, config, args, unsafeRes, res, _res, _res2, result;\n        return _regeneratorRuntime$1().wrap(function _callee62$(_context63) {\n          while (1) switch (_context63.prev = _context63.next) {\n            case 0:\n              _extractCommitmentFro18 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro18.commitment, config = _extractCommitmentFro18.config;\n              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);\n              _context63.next = 4;\n              return this._rpcRequest('getBlock', args);\n            case 4:\n              unsafeRes = _context63.sent;\n              _context63.prev = 5;\n              _context63.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;\n              _context63.next = _context63.t0 === 'accounts' ? 9 : _context63.t0 === 'none' ? 13 : 17;\n              break;\n            case 9:\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n              if (!('error' in res)) {\n                _context63.next = 12;\n                break;\n              }\n              throw res.error;\n            case 12:\n              return _context63.abrupt(\"return\", res.result);\n            case 13:\n              _res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n              if (!('error' in _res)) {\n                _context63.next = 16;\n                break;\n              }\n              throw _res.error;\n            case 16:\n              return _context63.abrupt(\"return\", _res.result);\n            case 17:\n              _res2 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetBlockRpcResult);\n              if (!('error' in _res2)) {\n                _context63.next = 20;\n                break;\n              }\n              throw _res2.error;\n            case 20:\n              result = _res2.result;\n              return _context63.abrupt(\"return\", result ? _objectSpread(_objectSpread({}, result), {}, {\n                transactions: result.transactions.map(function (_ref15) {\n                  var transaction = _ref15.transaction,\n                    meta = _ref15.meta,\n                    version = _ref15.version;\n                  return {\n                    meta: meta,\n                    transaction: _objectSpread(_objectSpread({}, transaction), {}, {\n                      message: versionedMessageFromResponse(version, transaction.message)\n                    }),\n                    version: version\n                  };\n                })\n              }) : null);\n            case 22:\n              _context63.next = 27;\n              break;\n            case 24:\n              _context63.prev = 24;\n              _context63.t1 = _context63[\"catch\"](5);\n              throw new SolanaJSONRPCError(_context63.t1, 'failed to get confirmed block');\n            case 27:\n            case \"end\":\n              return _context63.stop();\n          }\n        }, _callee62, this, [[5, 24]]);\n      }));\n      function getBlock(_x79, _x80) {\n        return _getBlock.apply(this, arguments);\n      }\n      return getBlock;\n    }()\n    /**\n     * Fetch parsed transaction details for a confirmed or finalized block\n     */\n  }, {\n    key: \"getParsedBlock\",\n    value: // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _getParsedBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee63(slot, rawConfig) {\n        var _extractCommitmentFro19, commitment, config, args, unsafeRes, res, _res3, _res4;\n        return _regeneratorRuntime$1().wrap(function _callee63$(_context64) {\n          while (1) switch (_context64.prev = _context64.next) {\n            case 0:\n              _extractCommitmentFro19 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro19.commitment, config = _extractCommitmentFro19.config;\n              args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);\n              _context64.next = 4;\n              return this._rpcRequest('getBlock', args);\n            case 4:\n              unsafeRes = _context64.sent;\n              _context64.prev = 5;\n              _context64.t0 = config === null || config === void 0 ? void 0 : config.transactionDetails;\n              _context64.next = _context64.t0 === 'accounts' ? 9 : _context64.t0 === 'none' ? 13 : 17;\n              break;\n            case 9:\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n              if (!('error' in res)) {\n                _context64.next = 12;\n                break;\n              }\n              throw res.error;\n            case 12:\n              return _context64.abrupt(\"return\", res.result);\n            case 13:\n              _res3 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n              if (!('error' in _res3)) {\n                _context64.next = 16;\n                break;\n              }\n              throw _res3.error;\n            case 16:\n              return _context64.abrupt(\"return\", _res3.result);\n            case 17:\n              _res4 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedBlockRpcResult);\n              if (!('error' in _res4)) {\n                _context64.next = 20;\n                break;\n              }\n              throw _res4.error;\n            case 20:\n              return _context64.abrupt(\"return\", _res4.result);\n            case 21:\n              _context64.next = 26;\n              break;\n            case 23:\n              _context64.prev = 23;\n              _context64.t1 = _context64[\"catch\"](5);\n              throw new SolanaJSONRPCError(_context64.t1, 'failed to get block');\n            case 26:\n            case \"end\":\n              return _context64.stop();\n          }\n        }, _callee63, this, [[5, 23]]);\n      }));\n      function getParsedBlock(_x81, _x82) {\n        return _getParsedBlock.apply(this, arguments);\n      }\n      return getParsedBlock;\n    }()\n  }, {\n    key: \"getBlockProduction\",\n    value:\n    /*\n     * Returns recent block production information from the current or previous epoch\n     */\n    function () {\n      var _getBlockProduction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee64(configOrCommitment) {\n        var extra, commitment, c, rest, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee64$(_context65) {\n          while (1) switch (_context65.prev = _context65.next) {\n            case 0:\n              if (typeof configOrCommitment === 'string') {\n                commitment = configOrCommitment;\n              } else if (configOrCommitment) {\n                c = configOrCommitment.commitment, rest = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(configOrCommitment, _excluded3);\n                commitment = c;\n                extra = rest;\n              }\n              args = this._buildArgs([], commitment, 'base64', extra);\n              _context65.next = 4;\n              return this._rpcRequest('getBlockProduction', args);\n            case 4:\n              unsafeRes = _context65.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, BlockProductionResponseStruct);\n              if (!('error' in res)) {\n                _context65.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get block production information');\n            case 8:\n              return _context65.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context65.stop();\n          }\n        }, _callee64, this);\n      }));\n      function getBlockProduction(_x83) {\n        return _getBlockProduction.apply(this, arguments);\n      }\n      return getBlockProduction;\n    }()\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster.\n     *\n     * @deprecated Instead, call `getTransaction` using a\n     * `GetVersionedTransactionConfig` by setting the\n     * `maxSupportedTransactionVersion` property.\n     */\n  }, {\n    key: \"getTransaction\",\n    value:\n    /**\n     * Fetch a confirmed or finalized transaction from the cluster.\n     */\n    // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _getTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee65(signature, rawConfig) {\n        var _extractCommitmentFro20, commitment, config, args, unsafeRes, res, result;\n        return _regeneratorRuntime$1().wrap(function _callee65$(_context66) {\n          while (1) switch (_context66.prev = _context66.next) {\n            case 0:\n              _extractCommitmentFro20 = extractCommitmentFromConfig(rawConfig), commitment = _extractCommitmentFro20.commitment, config = _extractCommitmentFro20.config;\n              args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n              _context66.next = 4;\n              return this._rpcRequest('getTransaction', args);\n            case 4:\n              unsafeRes = _context66.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetTransactionRpcResult);\n              if (!('error' in res)) {\n                _context66.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n            case 8:\n              result = res.result;\n              if (result) {\n                _context66.next = 11;\n                break;\n              }\n              return _context66.abrupt(\"return\", result);\n            case 11:\n              return _context66.abrupt(\"return\", _objectSpread(_objectSpread({}, result), {}, {\n                transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {\n                  message: versionedMessageFromResponse(result.version, result.transaction.message)\n                })\n              }));\n            case 12:\n            case \"end\":\n              return _context66.stop();\n          }\n        }, _callee65, this);\n      }));\n      function getTransaction(_x84, _x85) {\n        return _getTransaction.apply(this, arguments);\n      }\n      return getTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a confirmed or finalized transaction\n     */\n  }, {\n    key: \"getParsedTransaction\",\n    value: function () {\n      var _getParsedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee66(signature, commitmentOrConfig) {\n        var _extractCommitmentFro21, commitment, config, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee66$(_context67) {\n          while (1) switch (_context67.prev = _context67.next) {\n            case 0:\n              _extractCommitmentFro21 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro21.commitment, config = _extractCommitmentFro21.config;\n              args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n              _context67.next = 4;\n              return this._rpcRequest('getTransaction', args);\n            case 4:\n              unsafeRes = _context67.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedTransactionRpcResult);\n              if (!('error' in res)) {\n                _context67.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n            case 8:\n              return _context67.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context67.stop();\n          }\n        }, _callee66, this);\n      }));\n      function getParsedTransaction(_x86, _x87) {\n        return _getParsedTransaction.apply(this, arguments);\n      }\n      return getParsedTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a batch of confirmed transactions\n     */\n  }, {\n    key: \"getParsedTransactions\",\n    value: function () {\n      var _getParsedTransactions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee67(signatures, commitmentOrConfig) {\n        var _this6 = this;\n        var _extractCommitmentFro22, commitment, config, batch, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee67$(_context68) {\n          while (1) switch (_context68.prev = _context68.next) {\n            case 0:\n              _extractCommitmentFro22 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro22.commitment, config = _extractCommitmentFro22.config;\n              batch = signatures.map(function (signature) {\n                var args = _this6._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n                return {\n                  methodName: 'getTransaction',\n                  args: args\n                };\n              });\n              _context68.next = 4;\n              return this._rpcBatchRequest(batch);\n            case 4:\n              unsafeRes = _context68.sent;\n              res = unsafeRes.map(function (unsafeRes) {\n                var res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedTransactionRpcResult);\n                if ('error' in res) {\n                  throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n                }\n                return res.result;\n              });\n              return _context68.abrupt(\"return\", res);\n            case 7:\n            case \"end\":\n              return _context68.stop();\n          }\n        }, _callee67, this);\n      }));\n      function getParsedTransactions(_x88, _x89) {\n        return _getParsedTransactions.apply(this, arguments);\n      }\n      return getParsedTransactions;\n    }()\n    /**\n     * Fetch transaction details for a batch of confirmed transactions.\n     * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n     *\n     * @deprecated Instead, call `getTransactions` using a\n     * `GetVersionedTransactionConfig` by setting the\n     * `maxSupportedTransactionVersion` property.\n     */\n  }, {\n    key: \"getTransactions\",\n    value:\n    /**\n     * Fetch transaction details for a batch of confirmed transactions.\n     * Similar to {@link getParsedTransactions} but returns a {@link\n     * VersionedTransactionResponse}.\n     */\n    // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _getTransactions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee68(signatures, commitmentOrConfig) {\n        var _this7 = this;\n        var _extractCommitmentFro23, commitment, config, batch, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee68$(_context69) {\n          while (1) switch (_context69.prev = _context69.next) {\n            case 0:\n              _extractCommitmentFro23 = extractCommitmentFromConfig(commitmentOrConfig), commitment = _extractCommitmentFro23.commitment, config = _extractCommitmentFro23.config;\n              batch = signatures.map(function (signature) {\n                var args = _this7._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n                return {\n                  methodName: 'getTransaction',\n                  args: args\n                };\n              });\n              _context69.next = 4;\n              return this._rpcBatchRequest(batch);\n            case 4:\n              unsafeRes = _context69.sent;\n              res = unsafeRes.map(function (unsafeRes) {\n                var res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetTransactionRpcResult);\n                if ('error' in res) {\n                  throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n                }\n                var result = res.result;\n                if (!result) return result;\n                return _objectSpread(_objectSpread({}, result), {}, {\n                  transaction: _objectSpread(_objectSpread({}, result.transaction), {}, {\n                    message: versionedMessageFromResponse(result.version, result.transaction.message)\n                  })\n                });\n              });\n              return _context69.abrupt(\"return\", res);\n            case 7:\n            case \"end\":\n              return _context69.stop();\n          }\n        }, _callee68, this);\n      }));\n      function getTransactions(_x90, _x91) {\n        return _getTransactions.apply(this, arguments);\n      }\n      return getTransactions;\n    }()\n    /**\n     * Fetch a list of Transactions and transaction statuses from the cluster\n     * for a confirmed block.\n     *\n     * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n     */\n  }, {\n    key: \"getConfirmedBlock\",\n    value: function () {\n      var _getConfirmedBlock = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee69(slot, commitment) {\n        var args, unsafeRes, res, result, block;\n        return _regeneratorRuntime$1().wrap(function _callee69$(_context70) {\n          while (1) switch (_context70.prev = _context70.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([slot], commitment);\n              _context70.next = 3;\n              return this._rpcRequest('getConfirmedBlock', args);\n            case 3:\n              unsafeRes = _context70.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n              if (!('error' in res)) {\n                _context70.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n            case 7:\n              result = res.result;\n              if (result) {\n                _context70.next = 10;\n                break;\n              }\n              throw new Error('Confirmed block ' + slot + ' not found');\n            case 10:\n              block = _objectSpread(_objectSpread({}, result), {}, {\n                transactions: result.transactions.map(function (_ref16) {\n                  var transaction = _ref16.transaction,\n                    meta = _ref16.meta;\n                  var message = new Message(transaction.message);\n                  return {\n                    meta: meta,\n                    transaction: _objectSpread(_objectSpread({}, transaction), {}, {\n                      message: message\n                    })\n                  };\n                })\n              });\n              return _context70.abrupt(\"return\", _objectSpread(_objectSpread({}, block), {}, {\n                transactions: block.transactions.map(function (_ref17) {\n                  var transaction = _ref17.transaction,\n                    meta = _ref17.meta;\n                  return {\n                    meta: meta,\n                    transaction: Transaction.populate(transaction.message, transaction.signatures)\n                  };\n                })\n              }));\n            case 12:\n            case \"end\":\n              return _context70.stop();\n          }\n        }, _callee69, this);\n      }));\n      function getConfirmedBlock(_x92, _x93) {\n        return _getConfirmedBlock.apply(this, arguments);\n      }\n      return getConfirmedBlock;\n    }()\n    /**\n     * Fetch confirmed blocks between two slots\n     */\n  }, {\n    key: \"getBlocks\",\n    value: function () {\n      var _getBlocks = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee70(startSlot, endSlot, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee70$(_context71) {\n          while (1) switch (_context71.prev = _context71.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);\n              _context71.next = 3;\n              return this._rpcRequest('getBlocks', args);\n            case 3:\n              unsafeRes = _context71.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)())));\n              if (!('error' in res)) {\n                _context71.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get blocks');\n            case 7:\n              return _context71.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context71.stop();\n          }\n        }, _callee70, this);\n      }));\n      function getBlocks(_x94, _x95, _x96) {\n        return _getBlocks.apply(this, arguments);\n      }\n      return getBlocks;\n    }()\n    /**\n     * Fetch a list of Signatures from the cluster for a block, excluding rewards\n     */\n  }, {\n    key: \"getBlockSignatures\",\n    value: function () {\n      var _getBlockSignatures = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee71(slot, commitment) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime$1().wrap(function _callee71$(_context72) {\n          while (1) switch (_context72.prev = _context72.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n                transactionDetails: 'signatures',\n                rewards: false\n              });\n              _context72.next = 3;\n              return this._rpcRequest('getBlock', args);\n            case 3:\n              unsafeRes = _context72.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n              if (!('error' in res)) {\n                _context72.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get block');\n            case 7:\n              result = res.result;\n              if (result) {\n                _context72.next = 10;\n                break;\n              }\n              throw new Error('Block ' + slot + ' not found');\n            case 10:\n              return _context72.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context72.stop();\n          }\n        }, _callee71, this);\n      }));\n      function getBlockSignatures(_x97, _x98) {\n        return _getBlockSignatures.apply(this, arguments);\n      }\n      return getBlockSignatures;\n    }()\n    /**\n     * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n     */\n  }, {\n    key: \"getConfirmedBlockSignatures\",\n    value: function () {\n      var _getConfirmedBlockSignatures = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee72(slot, commitment) {\n        var args, unsafeRes, res, result;\n        return _regeneratorRuntime$1().wrap(function _callee72$(_context73) {\n          while (1) switch (_context73.prev = _context73.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n                transactionDetails: 'signatures',\n                rewards: false\n              });\n              _context73.next = 3;\n              return this._rpcRequest('getConfirmedBlock', args);\n            case 3:\n              unsafeRes = _context73.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n              if (!('error' in res)) {\n                _context73.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n            case 7:\n              result = res.result;\n              if (result) {\n                _context73.next = 10;\n                break;\n              }\n              throw new Error('Confirmed block ' + slot + ' not found');\n            case 10:\n              return _context73.abrupt(\"return\", result);\n            case 11:\n            case \"end\":\n              return _context73.stop();\n          }\n        }, _callee72, this);\n      }));\n      function getConfirmedBlockSignatures(_x99, _x100) {\n        return _getConfirmedBlockSignatures.apply(this, arguments);\n      }\n      return getConfirmedBlockSignatures;\n    }()\n    /**\n     * Fetch a transaction details for a confirmed transaction\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n     */\n  }, {\n    key: \"getConfirmedTransaction\",\n    value: function () {\n      var _getConfirmedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee73(signature, commitment) {\n        var args, unsafeRes, res, result, message, signatures;\n        return _regeneratorRuntime$1().wrap(function _callee73$(_context74) {\n          while (1) switch (_context74.prev = _context74.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([signature], commitment);\n              _context74.next = 3;\n              return this._rpcRequest('getConfirmedTransaction', args);\n            case 3:\n              unsafeRes = _context74.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetTransactionRpcResult);\n              if (!('error' in res)) {\n                _context74.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n            case 7:\n              result = res.result;\n              if (result) {\n                _context74.next = 10;\n                break;\n              }\n              return _context74.abrupt(\"return\", result);\n            case 10:\n              message = new Message(result.transaction.message);\n              signatures = result.transaction.signatures;\n              return _context74.abrupt(\"return\", _objectSpread(_objectSpread({}, result), {}, {\n                transaction: Transaction.populate(message, signatures)\n              }));\n            case 13:\n            case \"end\":\n              return _context74.stop();\n          }\n        }, _callee73, this);\n      }));\n      function getConfirmedTransaction(_x101, _x102) {\n        return _getConfirmedTransaction.apply(this, arguments);\n      }\n      return getConfirmedTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a confirmed transaction\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n     */\n  }, {\n    key: \"getParsedConfirmedTransaction\",\n    value: function () {\n      var _getParsedConfirmedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee74(signature, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee74$(_context75) {\n          while (1) switch (_context75.prev = _context75.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n              _context75.next = 3;\n              return this._rpcRequest('getConfirmedTransaction', args);\n            case 3:\n              unsafeRes = _context75.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedTransactionRpcResult);\n              if (!('error' in res)) {\n                _context75.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');\n            case 7:\n              return _context75.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context75.stop();\n          }\n        }, _callee74, this);\n      }));\n      function getParsedConfirmedTransaction(_x103, _x104) {\n        return _getParsedConfirmedTransaction.apply(this, arguments);\n      }\n      return getParsedConfirmedTransaction;\n    }()\n    /**\n     * Fetch parsed transaction details for a batch of confirmed transactions\n     *\n     * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n     */\n  }, {\n    key: \"getParsedConfirmedTransactions\",\n    value: function () {\n      var _getParsedConfirmedTransactions = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee75(signatures, commitment) {\n        var _this8 = this;\n        var batch, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee75$(_context76) {\n          while (1) switch (_context76.prev = _context76.next) {\n            case 0:\n              batch = signatures.map(function (signature) {\n                var args = _this8._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n                return {\n                  methodName: 'getConfirmedTransaction',\n                  args: args\n                };\n              });\n              _context76.next = 3;\n              return this._rpcBatchRequest(batch);\n            case 3:\n              unsafeRes = _context76.sent;\n              res = unsafeRes.map(function (unsafeRes) {\n                var res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetParsedTransactionRpcResult);\n                if ('error' in res) {\n                  throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');\n                }\n                return res.result;\n              });\n              return _context76.abrupt(\"return\", res);\n            case 6:\n            case \"end\":\n              return _context76.stop();\n          }\n        }, _callee75, this);\n      }));\n      function getParsedConfirmedTransactions(_x105, _x106) {\n        return _getParsedConfirmedTransactions.apply(this, arguments);\n      }\n      return getParsedConfirmedTransactions;\n    }()\n    /**\n     * Fetch a list of all the confirmed signatures for transactions involving an address\n     * within a specified slot range. Max range allowed is 10,000 slots.\n     *\n     * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n     *\n     * @param address queried address\n     * @param startSlot start slot, inclusive\n     * @param endSlot end slot, inclusive\n     */\n  }, {\n    key: \"getConfirmedSignaturesForAddress\",\n    value: function () {\n      var _getConfirmedSignaturesForAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee76(address, startSlot, endSlot) {\n        var options, firstAvailableBlock, block, highestConfirmedRoot, _block, confirmedSignatureInfo;\n        return _regeneratorRuntime$1().wrap(function _callee76$(_context77) {\n          while (1) switch (_context77.prev = _context77.next) {\n            case 0:\n              options = {};\n              _context77.next = 3;\n              return this.getFirstAvailableBlock();\n            case 3:\n              firstAvailableBlock = _context77.sent;\n            case 4:\n              if ('until' in options) {\n                _context77.next = 24;\n                break;\n              }\n              startSlot--;\n              if (!(startSlot <= 0 || startSlot < firstAvailableBlock)) {\n                _context77.next = 8;\n                break;\n              }\n              return _context77.abrupt(\"break\", 24);\n            case 8:\n              _context77.prev = 8;\n              _context77.next = 11;\n              return this.getConfirmedBlockSignatures(startSlot, 'finalized');\n            case 11:\n              block = _context77.sent;\n              if (block.signatures.length > 0) {\n                options.until = block.signatures[block.signatures.length - 1].toString();\n              }\n              _context77.next = 22;\n              break;\n            case 15:\n              _context77.prev = 15;\n              _context77.t0 = _context77[\"catch\"](8);\n              if (!(_context77.t0 instanceof Error && _context77.t0.message.includes('skipped'))) {\n                _context77.next = 21;\n                break;\n              }\n              return _context77.abrupt(\"continue\", 4);\n            case 21:\n              throw _context77.t0;\n            case 22:\n              _context77.next = 4;\n              break;\n            case 24:\n              _context77.next = 26;\n              return this.getSlot('finalized');\n            case 26:\n              highestConfirmedRoot = _context77.sent;\n            case 27:\n              if ('before' in options) {\n                _context77.next = 47;\n                break;\n              }\n              endSlot++;\n              if (!(endSlot > highestConfirmedRoot)) {\n                _context77.next = 31;\n                break;\n              }\n              return _context77.abrupt(\"break\", 47);\n            case 31:\n              _context77.prev = 31;\n              _context77.next = 34;\n              return this.getConfirmedBlockSignatures(endSlot);\n            case 34:\n              _block = _context77.sent;\n              if (_block.signatures.length > 0) {\n                options.before = _block.signatures[_block.signatures.length - 1].toString();\n              }\n              _context77.next = 45;\n              break;\n            case 38:\n              _context77.prev = 38;\n              _context77.t1 = _context77[\"catch\"](31);\n              if (!(_context77.t1 instanceof Error && _context77.t1.message.includes('skipped'))) {\n                _context77.next = 44;\n                break;\n              }\n              return _context77.abrupt(\"continue\", 27);\n            case 44:\n              throw _context77.t1;\n            case 45:\n              _context77.next = 27;\n              break;\n            case 47:\n              _context77.next = 49;\n              return this.getConfirmedSignaturesForAddress2(address, options);\n            case 49:\n              confirmedSignatureInfo = _context77.sent;\n              return _context77.abrupt(\"return\", confirmedSignatureInfo.map(function (info) {\n                return info.signature;\n              }));\n            case 51:\n            case \"end\":\n              return _context77.stop();\n          }\n        }, _callee76, this, [[8, 15], [31, 38]]);\n      }));\n      function getConfirmedSignaturesForAddress(_x107, _x108, _x109) {\n        return _getConfirmedSignaturesForAddress.apply(this, arguments);\n      }\n      return getConfirmedSignaturesForAddress;\n    }()\n    /**\n     * Returns confirmed signatures for transactions involving an\n     * address backwards in time from the provided signature or most recent confirmed block\n     *\n     *\n     * @param address queried address\n     * @param options\n     */\n  }, {\n    key: \"getConfirmedSignaturesForAddress2\",\n    value: function () {\n      var _getConfirmedSignaturesForAddress2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee77(address, options, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee77$(_context78) {\n          while (1) switch (_context78.prev = _context78.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n              _context78.next = 3;\n              return this._rpcRequest('getConfirmedSignaturesForAddress2', args);\n            case 3:\n              unsafeRes = _context78.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n              if (!('error' in res)) {\n                _context78.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');\n            case 7:\n              return _context78.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context78.stop();\n          }\n        }, _callee77, this);\n      }));\n      function getConfirmedSignaturesForAddress2(_x110, _x111, _x112) {\n        return _getConfirmedSignaturesForAddress2.apply(this, arguments);\n      }\n      return getConfirmedSignaturesForAddress2;\n    }()\n    /**\n     * Returns confirmed signatures for transactions involving an\n     * address backwards in time from the provided signature or most recent confirmed block\n     *\n     *\n     * @param address queried address\n     * @param options\n     */\n  }, {\n    key: \"getSignaturesForAddress\",\n    value: function () {\n      var _getSignaturesForAddress = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee78(address, options, commitment) {\n        var args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee78$(_context79) {\n          while (1) switch (_context79.prev = _context79.next) {\n            case 0:\n              args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n              _context79.next = 3;\n              return this._rpcRequest('getSignaturesForAddress', args);\n            case 3:\n              unsafeRes = _context79.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n              if (!('error' in res)) {\n                _context79.next = 7;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');\n            case 7:\n              return _context79.abrupt(\"return\", res.result);\n            case 8:\n            case \"end\":\n              return _context79.stop();\n          }\n        }, _callee78, this);\n      }));\n      function getSignaturesForAddress(_x113, _x114, _x115) {\n        return _getSignaturesForAddress.apply(this, arguments);\n      }\n      return getSignaturesForAddress;\n    }()\n  }, {\n    key: \"getAddressLookupTable\",\n    value: function () {\n      var _getAddressLookupTable = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee79(accountKey, config) {\n        var _yield$this$getAccoun, context, accountInfo, value;\n        return _regeneratorRuntime$1().wrap(function _callee79$(_context80) {\n          while (1) switch (_context80.prev = _context80.next) {\n            case 0:\n              _context80.next = 2;\n              return this.getAccountInfoAndContext(accountKey, config);\n            case 2:\n              _yield$this$getAccoun = _context80.sent;\n              context = _yield$this$getAccoun.context;\n              accountInfo = _yield$this$getAccoun.value;\n              value = null;\n              if (accountInfo !== null) {\n                value = new AddressLookupTableAccount({\n                  key: accountKey,\n                  state: AddressLookupTableAccount.deserialize(accountInfo.data)\n                });\n              }\n              return _context80.abrupt(\"return\", {\n                context: context,\n                value: value\n              });\n            case 8:\n            case \"end\":\n              return _context80.stop();\n          }\n        }, _callee79, this);\n      }));\n      function getAddressLookupTable(_x116, _x117) {\n        return _getAddressLookupTable.apply(this, arguments);\n      }\n      return getAddressLookupTable;\n    }()\n    /**\n     * Fetch the contents of a Nonce account from the cluster, return with context\n     */\n  }, {\n    key: \"getNonceAndContext\",\n    value: function () {\n      var _getNonceAndContext = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee80(nonceAccount, commitmentOrConfig) {\n        var _yield$this$getAccoun2, context, accountInfo, value;\n        return _regeneratorRuntime$1().wrap(function _callee80$(_context81) {\n          while (1) switch (_context81.prev = _context81.next) {\n            case 0:\n              _context81.next = 2;\n              return this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n            case 2:\n              _yield$this$getAccoun2 = _context81.sent;\n              context = _yield$this$getAccoun2.context;\n              accountInfo = _yield$this$getAccoun2.value;\n              value = null;\n              if (accountInfo !== null) {\n                value = NonceAccount.fromAccountData(accountInfo.data);\n              }\n              return _context81.abrupt(\"return\", {\n                context: context,\n                value: value\n              });\n            case 8:\n            case \"end\":\n              return _context81.stop();\n          }\n        }, _callee80, this);\n      }));\n      function getNonceAndContext(_x118, _x119) {\n        return _getNonceAndContext.apply(this, arguments);\n      }\n      return getNonceAndContext;\n    }()\n    /**\n     * Fetch the contents of a Nonce account from the cluster\n     */\n  }, {\n    key: \"getNonce\",\n    value: function () {\n      var _getNonce = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee81(nonceAccount, commitmentOrConfig) {\n        return _regeneratorRuntime$1().wrap(function _callee81$(_context82) {\n          while (1) switch (_context82.prev = _context82.next) {\n            case 0:\n              _context82.next = 2;\n              return this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(function (x) {\n                return x.value;\n              })[\"catch\"](function (e) {\n                throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);\n              });\n            case 2:\n              return _context82.abrupt(\"return\", _context82.sent);\n            case 3:\n            case \"end\":\n              return _context82.stop();\n          }\n        }, _callee81, this);\n      }));\n      function getNonce(_x120, _x121) {\n        return _getNonce.apply(this, arguments);\n      }\n      return getNonce;\n    }()\n    /**\n     * Request an allocation of lamports to the specified address\n     *\n     * ```typescript\n     * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n     *\n     * (async () => {\n     *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n     *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n     *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n     *   await connection.confirmTransaction(signature);\n     * })();\n     * ```\n     */\n  }, {\n    key: \"requestAirdrop\",\n    value: function () {\n      var _requestAirdrop = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee82(to, lamports) {\n        var unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee82$(_context83) {\n          while (1) switch (_context83.prev = _context83.next) {\n            case 0:\n              _context83.next = 2;\n              return this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);\n            case 2:\n              unsafeRes = _context83.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, RequestAirdropRpcResult);\n              if (!('error' in res)) {\n                _context83.next = 6;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"airdrop to \".concat(to.toBase58(), \" failed\"));\n            case 6:\n              return _context83.abrupt(\"return\", res.result);\n            case 7:\n            case \"end\":\n              return _context83.stop();\n          }\n        }, _callee82, this);\n      }));\n      function requestAirdrop(_x122, _x123) {\n        return _requestAirdrop.apply(this, arguments);\n      }\n      return requestAirdrop;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_blockhashWithExpiryBlockHeight\",\n    value: function () {\n      var _blockhashWithExpiryBlockHeight2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee83(disableCache) {\n        var timeSinceFetch, expired;\n        return _regeneratorRuntime$1().wrap(function _callee83$(_context84) {\n          while (1) switch (_context84.prev = _context84.next) {\n            case 0:\n              if (disableCache) {\n                _context84.next = 10;\n                break;\n              }\n            case 1:\n              if (!this._pollingBlockhash) {\n                _context84.next = 6;\n                break;\n              }\n              _context84.next = 4;\n              return sleep(100);\n            case 4:\n              _context84.next = 1;\n              break;\n            case 6:\n              timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n              expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n              if (!(this._blockhashInfo.latestBlockhash !== null && !expired)) {\n                _context84.next = 10;\n                break;\n              }\n              return _context84.abrupt(\"return\", this._blockhashInfo.latestBlockhash);\n            case 10:\n              _context84.next = 12;\n              return this._pollNewBlockhash();\n            case 12:\n              return _context84.abrupt(\"return\", _context84.sent);\n            case 13:\n            case \"end\":\n              return _context84.stop();\n          }\n        }, _callee83, this);\n      }));\n      function _blockhashWithExpiryBlockHeight(_x124) {\n        return _blockhashWithExpiryBlockHeight2.apply(this, arguments);\n      }\n      return _blockhashWithExpiryBlockHeight;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_pollNewBlockhash\",\n    value: function () {\n      var _pollNewBlockhash2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee84() {\n        var startTime, cachedLatestBlockhash, cachedBlockhash, i, latestBlockhash;\n        return _regeneratorRuntime$1().wrap(function _callee84$(_context85) {\n          while (1) switch (_context85.prev = _context85.next) {\n            case 0:\n              this._pollingBlockhash = true;\n              _context85.prev = 1;\n              startTime = Date.now();\n              cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n              cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n              i = 0;\n            case 6:\n              if (!(i < 50)) {\n                _context85.next = 18;\n                break;\n              }\n              _context85.next = 9;\n              return this.getLatestBlockhash('finalized');\n            case 9:\n              latestBlockhash = _context85.sent;\n              if (!(cachedBlockhash !== latestBlockhash.blockhash)) {\n                _context85.next = 13;\n                break;\n              }\n              this._blockhashInfo = {\n                latestBlockhash: latestBlockhash,\n                lastFetch: Date.now(),\n                transactionSignatures: [],\n                simulatedSignatures: []\n              };\n              return _context85.abrupt(\"return\", latestBlockhash);\n            case 13:\n              _context85.next = 15;\n              return sleep(MS_PER_SLOT / 2);\n            case 15:\n              i++;\n              _context85.next = 6;\n              break;\n            case 18:\n              throw new Error(\"Unable to obtain a new blockhash after \".concat(Date.now() - startTime, \"ms\"));\n            case 19:\n              _context85.prev = 19;\n              this._pollingBlockhash = false;\n              return _context85.finish(19);\n            case 22:\n            case \"end\":\n              return _context85.stop();\n          }\n        }, _callee84, this, [[1,, 19, 22]]);\n      }));\n      function _pollNewBlockhash() {\n        return _pollNewBlockhash2.apply(this, arguments);\n      }\n      return _pollNewBlockhash;\n    }()\n    /**\n     * get the stake minimum delegation\n     */\n  }, {\n    key: \"getStakeMinimumDelegation\",\n    value: function () {\n      var _getStakeMinimumDelegation = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee85(config) {\n        var _extractCommitmentFro24, commitment, configArg, args, unsafeRes, res;\n        return _regeneratorRuntime$1().wrap(function _callee85$(_context86) {\n          while (1) switch (_context86.prev = _context86.next) {\n            case 0:\n              _extractCommitmentFro24 = extractCommitmentFromConfig(config), commitment = _extractCommitmentFro24.commitment, configArg = _extractCommitmentFro24.config;\n              args = this._buildArgs([], commitment, 'base64', configArg);\n              _context86.next = 4;\n              return this._rpcRequest('getStakeMinimumDelegation', args);\n            case 4:\n              unsafeRes = _context86.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.number)()));\n              if (!('error' in res)) {\n                _context86.next = 8;\n                break;\n              }\n              throw new SolanaJSONRPCError(res.error, \"failed to get stake minimum delegation\");\n            case 8:\n              return _context86.abrupt(\"return\", res.result);\n            case 9:\n            case \"end\":\n              return _context86.stop();\n          }\n        }, _callee85, this);\n      }));\n      function getStakeMinimumDelegation(_x125) {\n        return _getStakeMinimumDelegation.apply(this, arguments);\n      }\n      return getStakeMinimumDelegation;\n    }()\n    /**\n     * Simulate a transaction\n     *\n     * @deprecated Instead, call {@link simulateTransaction} with {@link\n     * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n     */\n  }, {\n    key: \"simulateTransaction\",\n    value:\n    /**\n     * Simulate a transaction\n     */\n    // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _simulateTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee86(transactionOrMessage, configOrSigners, includeAccounts) {\n        var versionedTx, _wireTransaction, _encodedTransaction, _config2, _args87, _unsafeRes, _res5, transaction, originalTx, signers, _transaction, disableCache, _transaction2, latestBlockhash, _signature, message, signData, wireTransaction, encodedTransaction, config, addresses, args, unsafeRes, res, _logs, traceIndent, logTrace;\n        return _regeneratorRuntime$1().wrap(function _callee86$(_context87) {\n          while (1) switch (_context87.prev = _context87.next) {\n            case 0:\n              if (!('message' in transactionOrMessage)) {\n                _context87.next = 17;\n                break;\n              }\n              versionedTx = transactionOrMessage;\n              _wireTransaction = versionedTx.serialize();\n              _encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(_wireTransaction).toString('base64');\n              if (!(Array.isArray(configOrSigners) || includeAccounts !== undefined)) {\n                _context87.next = 6;\n                break;\n              }\n              throw new Error('Invalid arguments');\n            case 6:\n              _config2 = configOrSigners || {};\n              _config2.encoding = 'base64';\n              if (!('commitment' in _config2)) {\n                _config2.commitment = this.commitment;\n              }\n              _args87 = [_encodedTransaction, _config2];\n              _context87.next = 12;\n              return this._rpcRequest('simulateTransaction', _args87);\n            case 12:\n              _unsafeRes = _context87.sent;\n              _res5 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(_unsafeRes, SimulatedTransactionResponseStruct);\n              if (!('error' in _res5)) {\n                _context87.next = 16;\n                break;\n              }\n              throw new Error('failed to simulate transaction: ' + _res5.error.message);\n            case 16:\n              return _context87.abrupt(\"return\", _res5.result);\n            case 17:\n              if (transactionOrMessage instanceof Transaction) {\n                originalTx = transactionOrMessage;\n                transaction = new Transaction();\n                transaction.feePayer = originalTx.feePayer;\n                transaction.instructions = transactionOrMessage.instructions;\n                transaction.nonceInfo = originalTx.nonceInfo;\n                transaction.signatures = originalTx.signatures;\n              } else {\n                transaction = Transaction.populate(transactionOrMessage);\n                // HACK: this function relies on mutating the populated transaction\n                transaction._message = transaction._json = undefined;\n              }\n              if (!(configOrSigners !== undefined && !Array.isArray(configOrSigners))) {\n                _context87.next = 20;\n                break;\n              }\n              throw new Error('Invalid arguments');\n            case 20:\n              signers = configOrSigners;\n              if (!(transaction.nonceInfo && signers)) {\n                _context87.next = 25;\n                break;\n              }\n              (_transaction = transaction).sign.apply(_transaction, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(signers));\n              _context87.next = 45;\n              break;\n            case 25:\n              disableCache = this._disableBlockhashCaching;\n            case 26:\n              _context87.next = 28;\n              return this._blockhashWithExpiryBlockHeight(disableCache);\n            case 28:\n              latestBlockhash = _context87.sent;\n              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n              transaction.recentBlockhash = latestBlockhash.blockhash;\n              if (signers) {\n                _context87.next = 33;\n                break;\n              }\n              return _context87.abrupt(\"break\", 45);\n            case 33:\n              (_transaction2 = transaction).sign.apply(_transaction2, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(signers));\n              if (transaction.signature) {\n                _context87.next = 36;\n                break;\n              }\n              throw new Error('!signature');\n            case 36:\n              _signature = transaction.signature.toString('base64');\n              if (!(!this._blockhashInfo.simulatedSignatures.includes(_signature) && !this._blockhashInfo.transactionSignatures.includes(_signature))) {\n                _context87.next = 42;\n                break;\n              }\n              // The signature of this transaction has not been seen before with the\n              // current recentBlockhash, all done. Let's break\n              this._blockhashInfo.simulatedSignatures.push(_signature);\n              return _context87.abrupt(\"break\", 45);\n            case 42:\n              // This transaction would be treated as duplicate (its derived signature\n              // matched to one of already recorded signatures).\n              // So, we must fetch a new blockhash for a different signature by disabling\n              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n              disableCache = true;\n            case 43:\n              _context87.next = 26;\n              break;\n            case 45:\n              message = transaction._compile();\n              signData = message.serialize();\n              wireTransaction = transaction._serialize(signData);\n              encodedTransaction = wireTransaction.toString('base64');\n              config = {\n                encoding: 'base64',\n                commitment: this.commitment\n              };\n              if (includeAccounts) {\n                addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(function (key) {\n                  return key.toBase58();\n                });\n                config['accounts'] = {\n                  encoding: 'base64',\n                  addresses: addresses\n                };\n              }\n              if (signers) {\n                config.sigVerify = true;\n              }\n              args = [encodedTransaction, config];\n              _context87.next = 55;\n              return this._rpcRequest('simulateTransaction', args);\n            case 55:\n              unsafeRes = _context87.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n              if (!('error' in res)) {\n                _context87.next = 60;\n                break;\n              }\n              if ('data' in res.error) {\n                _logs = res.error.data.logs;\n                if (_logs && Array.isArray(_logs)) {\n                  traceIndent = '\\n    ';\n                  logTrace = traceIndent + _logs.join(traceIndent);\n                  console.error(res.error.message, logTrace);\n                }\n              }\n              throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, _logs);\n            case 60:\n              return _context87.abrupt(\"return\", res.result);\n            case 61:\n            case \"end\":\n              return _context87.stop();\n          }\n        }, _callee86, this);\n      }));\n      function simulateTransaction(_x126, _x127, _x128) {\n        return _simulateTransaction.apply(this, arguments);\n      }\n      return simulateTransaction;\n    }()\n    /**\n     * Sign and send a transaction\n     *\n     * @deprecated Instead, call {@link sendTransaction} with a {@link\n     * VersionedTransaction}\n     */\n  }, {\n    key: \"sendTransaction\",\n    value:\n    /**\n     * Sign and send a transaction\n     */\n    // eslint-disable-next-line no-dupe-class-members\n    function () {\n      var _sendTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee87(transaction, signersOrOptions, options) {\n        var _wireTransaction2, signers, disableCache, latestBlockhash, _signature2, wireTransaction;\n        return _regeneratorRuntime$1().wrap(function _callee87$(_context88) {\n          while (1) switch (_context88.prev = _context88.next) {\n            case 0:\n              if (!('version' in transaction)) {\n                _context88.next = 7;\n                break;\n              }\n              if (!(signersOrOptions && Array.isArray(signersOrOptions))) {\n                _context88.next = 3;\n                break;\n              }\n              throw new Error('Invalid arguments');\n            case 3:\n              _wireTransaction2 = transaction.serialize();\n              _context88.next = 6;\n              return this.sendRawTransaction(_wireTransaction2, signersOrOptions);\n            case 6:\n              return _context88.abrupt(\"return\", _context88.sent);\n            case 7:\n              if (!(signersOrOptions === undefined || !Array.isArray(signersOrOptions))) {\n                _context88.next = 9;\n                break;\n              }\n              throw new Error('Invalid arguments');\n            case 9:\n              signers = signersOrOptions;\n              if (!transaction.nonceInfo) {\n                _context88.next = 14;\n                break;\n              }\n              transaction.sign.apply(transaction, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(signers));\n              _context88.next = 32;\n              break;\n            case 14:\n              disableCache = this._disableBlockhashCaching;\n            case 15:\n              _context88.next = 17;\n              return this._blockhashWithExpiryBlockHeight(disableCache);\n            case 17:\n              latestBlockhash = _context88.sent;\n              transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n              transaction.recentBlockhash = latestBlockhash.blockhash;\n              transaction.sign.apply(transaction, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(signers));\n              if (transaction.signature) {\n                _context88.next = 23;\n                break;\n              }\n              throw new Error('!signature');\n            case 23:\n              _signature2 = transaction.signature.toString('base64');\n              if (this._blockhashInfo.transactionSignatures.includes(_signature2)) {\n                _context88.next = 29;\n                break;\n              }\n              // The signature of this transaction has not been seen before with the\n              // current recentBlockhash, all done. Let's break\n              this._blockhashInfo.transactionSignatures.push(_signature2);\n              return _context88.abrupt(\"break\", 32);\n            case 29:\n              // This transaction would be treated as duplicate (its derived signature\n              // matched to one of already recorded signatures).\n              // So, we must fetch a new blockhash for a different signature by disabling\n              // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n              disableCache = true;\n            case 30:\n              _context88.next = 15;\n              break;\n            case 32:\n              wireTransaction = transaction.serialize();\n              _context88.next = 35;\n              return this.sendRawTransaction(wireTransaction, options);\n            case 35:\n              return _context88.abrupt(\"return\", _context88.sent);\n            case 36:\n            case \"end\":\n              return _context88.stop();\n          }\n        }, _callee87, this);\n      }));\n      function sendTransaction(_x129, _x130, _x131) {\n        return _sendTransaction.apply(this, arguments);\n      }\n      return sendTransaction;\n    }()\n    /**\n     * Send a transaction that has already been signed and serialized into the\n     * wire format\n     */\n  }, {\n    key: \"sendRawTransaction\",\n    value: function () {\n      var _sendRawTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee88(rawTransaction, options) {\n        var encodedTransaction, result;\n        return _regeneratorRuntime$1().wrap(function _callee88$(_context89) {\n          while (1) switch (_context89.prev = _context89.next) {\n            case 0:\n              encodedTransaction = toBuffer(rawTransaction).toString('base64');\n              _context89.next = 3;\n              return this.sendEncodedTransaction(encodedTransaction, options);\n            case 3:\n              result = _context89.sent;\n              return _context89.abrupt(\"return\", result);\n            case 5:\n            case \"end\":\n              return _context89.stop();\n          }\n        }, _callee88, this);\n      }));\n      function sendRawTransaction(_x132, _x133) {\n        return _sendRawTransaction.apply(this, arguments);\n      }\n      return sendRawTransaction;\n    }()\n    /**\n     * Send a transaction that has already been signed, serialized into the\n     * wire format, and encoded as a base64 string\n     */\n  }, {\n    key: \"sendEncodedTransaction\",\n    value: function () {\n      var _sendEncodedTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee89(encodedTransaction, options) {\n        var config, skipPreflight, preflightCommitment, args, unsafeRes, res, _logs2;\n        return _regeneratorRuntime$1().wrap(function _callee89$(_context90) {\n          while (1) switch (_context90.prev = _context90.next) {\n            case 0:\n              config = {\n                encoding: 'base64'\n              };\n              skipPreflight = options && options.skipPreflight;\n              preflightCommitment = options && options.preflightCommitment || this.commitment;\n              if (options && options.maxRetries != null) {\n                config.maxRetries = options.maxRetries;\n              }\n              if (options && options.minContextSlot != null) {\n                config.minContextSlot = options.minContextSlot;\n              }\n              if (skipPreflight) {\n                config.skipPreflight = skipPreflight;\n              }\n              if (preflightCommitment) {\n                config.preflightCommitment = preflightCommitment;\n              }\n              args = [encodedTransaction, config];\n              _context90.next = 10;\n              return this._rpcRequest('sendTransaction', args);\n            case 10:\n              unsafeRes = _context90.sent;\n              res = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(unsafeRes, SendTransactionRpcResult);\n              if (!('error' in res)) {\n                _context90.next = 15;\n                break;\n              }\n              if ('data' in res.error) {\n                _logs2 = res.error.data.logs;\n              }\n              throw new SendTransactionError('failed to send transaction: ' + res.error.message, _logs2);\n            case 15:\n              return _context90.abrupt(\"return\", res.result);\n            case 16:\n            case \"end\":\n              return _context90.stop();\n          }\n        }, _callee89, this);\n      }));\n      function sendEncodedTransaction(_x134, _x135) {\n        return _sendEncodedTransaction.apply(this, arguments);\n      }\n      return sendEncodedTransaction;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnOpen\",\n    value: function _wsOnOpen() {\n      var _this9 = this;\n      this._rpcWebSocketConnected = true;\n      this._rpcWebSocketHeartbeat = setInterval(function () {\n        // Ping server every 5s to prevent idle timeouts\n        (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee90() {\n          return _regeneratorRuntime$1().wrap(function _callee90$(_context91) {\n            while (1) switch (_context91.prev = _context91.next) {\n              case 0:\n                _context91.prev = 0;\n                _context91.next = 3;\n                return _this9._rpcWebSocket.notify('ping');\n              case 3:\n                _context91.next = 7;\n                break;\n              case 5:\n                _context91.prev = 5;\n                _context91.t0 = _context91[\"catch\"](0);\n              case 7:\n              case \"end\":\n                return _context91.stop();\n            }\n          }, _callee90, null, [[0, 5]]);\n        }))();\n      }, 5000);\n      this._updateSubscriptions();\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnError\",\n    value: function _wsOnError(err) {\n      this._rpcWebSocketConnected = false;\n      console.error('ws error:', err.message);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnClose\",\n    value: function _wsOnClose(code) {\n      var _this10 = this;\n      this._rpcWebSocketConnected = false;\n      this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n      if (this._rpcWebSocketIdleTimeout) {\n        clearTimeout(this._rpcWebSocketIdleTimeout);\n        this._rpcWebSocketIdleTimeout = null;\n      }\n      if (this._rpcWebSocketHeartbeat) {\n        clearInterval(this._rpcWebSocketHeartbeat);\n        this._rpcWebSocketHeartbeat = null;\n      }\n      if (code === 1000) {\n        // explicit close, check if any subscriptions have been made since close\n        this._updateSubscriptions();\n        return;\n      }\n\n      // implicit close, prepare subscriptions for auto-reconnect\n      this._subscriptionCallbacksByServerSubscriptionId = {};\n      Object.entries(this._subscriptionsByHash).forEach(function (_ref19) {\n        var _ref20 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ref19, 2),\n          hash = _ref20[0],\n          subscription = _ref20[1];\n        _this10._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n          state: 'pending'\n        }));\n      });\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_setSubscription\",\n    value: function _setSubscription(hash, nextSubscription) {\n      var _this$_subscriptionsB;\n      var prevState = (_this$_subscriptionsB = this._subscriptionsByHash[hash]) === null || _this$_subscriptionsB === void 0 ? void 0 : _this$_subscriptionsB.state;\n      this._subscriptionsByHash[hash] = nextSubscription;\n      if (prevState !== nextSubscription.state) {\n        var stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n        if (stateChangeCallbacks) {\n          stateChangeCallbacks.forEach(function (cb) {\n            try {\n              cb(nextSubscription.state);\n              // eslint-disable-next-line no-empty\n            } catch (_unused2) {}\n          });\n        }\n      }\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_onSubscriptionStateChange\",\n    value: function _onSubscriptionStateChange(clientSubscriptionId, callback) {\n      var _this$_subscriptionSt,\n        _this11 = this;\n      var hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n      if (hash == null) {\n        return function () {};\n      }\n      var stateChangeCallbacks = (_this$_subscriptionSt = this._subscriptionStateChangeCallbacksByHash)[hash] || (_this$_subscriptionSt[hash] = new Set());\n      stateChangeCallbacks.add(callback);\n      return function () {\n        stateChangeCallbacks[\"delete\"](callback);\n        if (stateChangeCallbacks.size === 0) {\n          delete _this11._subscriptionStateChangeCallbacksByHash[hash];\n        }\n      };\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_updateSubscriptions\",\n    value: function () {\n      var _updateSubscriptions2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee94() {\n        var _this12 = this;\n        var activeWebSocketGeneration, isCurrentConnectionStillActive;\n        return _regeneratorRuntime$1().wrap(function _callee94$(_context95) {\n          while (1) switch (_context95.prev = _context95.next) {\n            case 0:\n              if (!(Object.keys(this._subscriptionsByHash).length === 0)) {\n                _context95.next = 3;\n                break;\n              }\n              if (this._rpcWebSocketConnected) {\n                this._rpcWebSocketConnected = false;\n                this._rpcWebSocketIdleTimeout = setTimeout(function () {\n                  _this12._rpcWebSocketIdleTimeout = null;\n                  try {\n                    _this12._rpcWebSocket.close();\n                  } catch (err) {\n                    // swallow error if socket has already been closed.\n                    if (err instanceof Error) {\n                      console.log(\"Error when closing socket connection: \".concat(err.message));\n                    }\n                  }\n                }, 500);\n              }\n              return _context95.abrupt(\"return\");\n            case 3:\n              if (this._rpcWebSocketIdleTimeout !== null) {\n                clearTimeout(this._rpcWebSocketIdleTimeout);\n                this._rpcWebSocketIdleTimeout = null;\n                this._rpcWebSocketConnected = true;\n              }\n              if (this._rpcWebSocketConnected) {\n                _context95.next = 7;\n                break;\n              }\n              this._rpcWebSocket.connect();\n              return _context95.abrupt(\"return\");\n            case 7:\n              activeWebSocketGeneration = this._rpcWebSocketGeneration;\n              isCurrentConnectionStillActive = function isCurrentConnectionStillActive() {\n                return activeWebSocketGeneration === _this12._rpcWebSocketGeneration;\n              };\n              _context95.next = 11;\n              return Promise.all(\n              // Don't be tempted to change this to `Object.entries`. We call\n              // `_updateSubscriptions` recursively when processing the state,\n              // so it's important that we look up the *current* version of\n              // each subscription, every time we process a hash.\n              Object.keys(this._subscriptionsByHash).map( /*#__PURE__*/function () {\n                var _ref21 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee93(hash) {\n                  var subscription;\n                  return _regeneratorRuntime$1().wrap(function _callee93$(_context94) {\n                    while (1) switch (_context94.prev = _context94.next) {\n                      case 0:\n                        subscription = _this12._subscriptionsByHash[hash];\n                        if (!(subscription === undefined)) {\n                          _context94.next = 3;\n                          break;\n                        }\n                        return _context94.abrupt(\"return\");\n                      case 3:\n                        _context94.t0 = subscription.state;\n                        _context94.next = _context94.t0 === 'pending' ? 6 : _context94.t0 === 'unsubscribed' ? 6 : _context94.t0 === 'subscribed' ? 15 : _context94.t0 === 'subscribing' ? 19 : _context94.t0 === 'unsubscribing' ? 19 : 20;\n                        break;\n                      case 6:\n                        if (!(subscription.callbacks.size === 0)) {\n                          _context94.next = 12;\n                          break;\n                        }\n                        /**\n                         * You can end up here when:\n                         *\n                         * - a subscription has recently unsubscribed\n                         *   without having new callbacks added to it\n                         *   while the unsubscribe was in flight, or\n                         * - when a pending subscription has its\n                         *   listeners removed before a request was\n                         *   sent to the server.\n                         *\n                         * Being that nobody is interested in this\n                         * subscription any longer, delete it.\n                         */\n                        delete _this12._subscriptionsByHash[hash];\n                        if (subscription.state === 'unsubscribed') {\n                          delete _this12._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n                        }\n                        _context94.next = 11;\n                        return _this12._updateSubscriptions();\n                      case 11:\n                        return _context94.abrupt(\"return\");\n                      case 12:\n                        _context94.next = 14;\n                        return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee91() {\n                          var args, method, _serverSubscriptionId;\n                          return _regeneratorRuntime$1().wrap(function _callee91$(_context92) {\n                            while (1) switch (_context92.prev = _context92.next) {\n                              case 0:\n                                args = subscription.args, method = subscription.method;\n                                _context92.prev = 1;\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  state: 'subscribing'\n                                }));\n                                _context92.next = 5;\n                                return _this12._rpcWebSocket.call(method, args);\n                              case 5:\n                                _serverSubscriptionId = _context92.sent;\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  serverSubscriptionId: _serverSubscriptionId,\n                                  state: 'subscribed'\n                                }));\n                                _this12._subscriptionCallbacksByServerSubscriptionId[_serverSubscriptionId] = subscription.callbacks;\n                                _context92.next = 10;\n                                return _this12._updateSubscriptions();\n                              case 10:\n                                _context92.next = 20;\n                                break;\n                              case 12:\n                                _context92.prev = 12;\n                                _context92.t0 = _context92[\"catch\"](1);\n                                if (_context92.t0 instanceof Error) {\n                                  console.error(\"\".concat(method, \" error for argument\"), args, _context92.t0.message);\n                                }\n                                if (isCurrentConnectionStillActive()) {\n                                  _context92.next = 17;\n                                  break;\n                                }\n                                return _context92.abrupt(\"return\");\n                              case 17:\n                                // TODO: Maybe add an 'errored' state or a retry limit?\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  state: 'pending'\n                                }));\n                                _context92.next = 20;\n                                return _this12._updateSubscriptions();\n                              case 20:\n                              case \"end\":\n                                return _context92.stop();\n                            }\n                          }, _callee91, null, [[1, 12]]);\n                        }))();\n                      case 14:\n                        return _context94.abrupt(\"break\", 20);\n                      case 15:\n                        if (!(subscription.callbacks.size === 0)) {\n                          _context94.next = 18;\n                          break;\n                        }\n                        _context94.next = 18;\n                        return (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee92() {\n                          var serverSubscriptionId, unsubscribeMethod;\n                          return _regeneratorRuntime$1().wrap(function _callee92$(_context93) {\n                            while (1) switch (_context93.prev = _context93.next) {\n                              case 0:\n                                serverSubscriptionId = subscription.serverSubscriptionId, unsubscribeMethod = subscription.unsubscribeMethod;\n                                if (!_this12._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                                  _context93.next = 5;\n                                  break;\n                                }\n                                /**\n                                 * Special case.\n                                 * If we're dealing with a subscription that has been auto-\n                                 * disposed by the RPC, then we can skip the RPC call to\n                                 * tear down the subscription here.\n                                 *\n                                 * NOTE: There is a proposal to eliminate this special case, here:\n                                 * https://github.com/solana-labs/solana/issues/18892\n                                 */\n                                _this12._subscriptionsAutoDisposedByRpc[\"delete\"](serverSubscriptionId);\n                                _context93.next = 21;\n                                break;\n                              case 5:\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  state: 'unsubscribing'\n                                }));\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  state: 'unsubscribing'\n                                }));\n                                _context93.prev = 7;\n                                _context93.next = 10;\n                                return _this12._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);\n                              case 10:\n                                _context93.next = 21;\n                                break;\n                              case 12:\n                                _context93.prev = 12;\n                                _context93.t0 = _context93[\"catch\"](7);\n                                if (_context93.t0 instanceof Error) {\n                                  console.error(\"\".concat(unsubscribeMethod, \" error:\"), _context93.t0.message);\n                                }\n                                if (isCurrentConnectionStillActive()) {\n                                  _context93.next = 17;\n                                  break;\n                                }\n                                return _context93.abrupt(\"return\");\n                              case 17:\n                                // TODO: Maybe add an 'errored' state or a retry limit?\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  state: 'subscribed'\n                                }));\n                                _context93.next = 20;\n                                return _this12._updateSubscriptions();\n                              case 20:\n                                return _context93.abrupt(\"return\");\n                              case 21:\n                                _this12._setSubscription(hash, _objectSpread(_objectSpread({}, subscription), {}, {\n                                  state: 'unsubscribed'\n                                }));\n                                _context93.next = 24;\n                                return _this12._updateSubscriptions();\n                              case 24:\n                              case \"end\":\n                                return _context93.stop();\n                            }\n                          }, _callee92, null, [[7, 12]]);\n                        }))();\n                      case 18:\n                        return _context94.abrupt(\"break\", 20);\n                      case 19:\n                        return _context94.abrupt(\"break\", 20);\n                      case 20:\n                      case \"end\":\n                        return _context94.stop();\n                    }\n                  }, _callee93);\n                }));\n                return function (_x136) {\n                  return _ref21.apply(this, arguments);\n                };\n              }()));\n            case 11:\n            case \"end\":\n              return _context95.stop();\n          }\n        }, _callee94, this);\n      }));\n      function _updateSubscriptions() {\n        return _updateSubscriptions2.apply(this, arguments);\n      }\n      return _updateSubscriptions;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_handleServerNotification\",\n    value: function _handleServerNotification(serverSubscriptionId, callbackArgs) {\n      var callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n      if (callbacks === undefined) {\n        return;\n      }\n      callbacks.forEach(function (cb) {\n        try {\n          cb.apply(void 0, (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(callbackArgs));\n        } catch (e) {\n          console.error(e);\n        }\n      });\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnAccountNotification\",\n    value: function _wsOnAccountNotification(notification) {\n      var _create = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, AccountNotificationResult),\n        result = _create.result,\n        subscription = _create.subscription;\n      this._handleServerNotification(subscription, [result.value, result.context]);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_makeSubscription\",\n    value: function _makeSubscription(subscriptionConfig,\n    /**\n     * When preparing `args` for a call to `_makeSubscription`, be sure\n     * to carefully apply a default `commitment` property, if necessary.\n     *\n     * - If the user supplied a `commitment` use that.\n     * - Otherwise, if the `Connection::commitment` is set, use that.\n     * - Otherwise, set it to the RPC server default: `finalized`.\n     *\n     * This is extremely important to ensure that these two fundamentally\n     * identical subscriptions produce the same identifying hash:\n     *\n     * - A subscription made without specifying a commitment.\n     * - A subscription made where the commitment specified is the same\n     *   as the default applied to the subscription above.\n     *\n     * Example; these two subscriptions must produce the same hash:\n     *\n     * - An `accountSubscribe` subscription for `'PUBKEY'`\n     * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n     *   `'finalized'`.\n     *\n     * See the 'making a subscription with defaulted params omitted' test\n     * in `connection-subscriptions.ts` for more.\n     */\n    args) {\n      var _this13 = this;\n      var clientSubscriptionId = this._nextClientSubscriptionId++;\n      var hash = fastStableStringify$1([subscriptionConfig.method, args], true /* isArrayProp */);\n\n      var existingSubscription = this._subscriptionsByHash[hash];\n      if (existingSubscription === undefined) {\n        this._subscriptionsByHash[hash] = _objectSpread(_objectSpread({}, subscriptionConfig), {}, {\n          args: args,\n          callbacks: new Set([subscriptionConfig.callback]),\n          state: 'pending'\n        });\n      } else {\n        existingSubscription.callbacks.add(subscriptionConfig.callback);\n      }\n      this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n      this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = /*#__PURE__*/(0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee95() {\n        var subscription;\n        return _regeneratorRuntime$1().wrap(function _callee95$(_context96) {\n          while (1) switch (_context96.prev = _context96.next) {\n            case 0:\n              delete _this13._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n              delete _this13._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n              subscription = _this13._subscriptionsByHash[hash];\n              assert(subscription !== undefined, \"Could not find a `Subscription` when tearing down client subscription #\".concat(clientSubscriptionId));\n              subscription.callbacks[\"delete\"](subscriptionConfig.callback);\n              _context96.next = 7;\n              return _this13._updateSubscriptions();\n            case 7:\n            case \"end\":\n              return _context96.stop();\n          }\n        }, _callee95);\n      }));\n      this._updateSubscriptions();\n      return clientSubscriptionId;\n    }\n\n    /**\n     * Register a callback to be invoked whenever the specified account changes\n     *\n     * @param publicKey Public key of the account to monitor\n     * @param callback Function to invoke whenever the account is changed\n     * @param commitment Specify the commitment level account changes must reach before notification\n     * @return subscription id\n     */\n  }, {\n    key: \"onAccountChange\",\n    value: function onAccountChange(publicKey, callback, commitment) {\n      var args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',\n      // Apply connection/server default.\n      'base64');\n      return this._makeSubscription({\n        callback: callback,\n        method: 'accountSubscribe',\n        unsubscribeMethod: 'accountUnsubscribe'\n      }, args);\n    }\n\n    /**\n     * Deregister an account notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n  }, {\n    key: \"removeAccountChangeListener\",\n    value: function () {\n      var _removeAccountChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee96(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee96$(_context97) {\n          while (1) switch (_context97.prev = _context97.next) {\n            case 0:\n              _context97.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');\n            case 2:\n            case \"end\":\n              return _context97.stop();\n          }\n        }, _callee96, this);\n      }));\n      function removeAccountChangeListener(_x137) {\n        return _removeAccountChangeListener.apply(this, arguments);\n      }\n      return removeAccountChangeListener;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnProgramAccountNotification\",\n    value: function _wsOnProgramAccountNotification(notification) {\n      var _create2 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, ProgramAccountNotificationResult),\n        result = _create2.result,\n        subscription = _create2.subscription;\n      this._handleServerNotification(subscription, [{\n        accountId: result.value.pubkey,\n        accountInfo: result.value.account\n      }, result.context]);\n    }\n\n    /**\n     * Register a callback to be invoked whenever accounts owned by the\n     * specified program change\n     *\n     * @param programId Public key of the program to monitor\n     * @param callback Function to invoke whenever the account is changed\n     * @param commitment Specify the commitment level account changes must reach before notification\n     * @param filters The program account filters to pass into the RPC method\n     * @return subscription id\n     */\n  }, {\n    key: \"onProgramAccountChange\",\n    value: function onProgramAccountChange(programId, callback, commitment, filters) {\n      var args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',\n      // Apply connection/server default.\n      'base64' /* encoding */, filters ? {\n        filters: filters\n      } : undefined /* extra */);\n\n      return this._makeSubscription({\n        callback: callback,\n        method: 'programSubscribe',\n        unsubscribeMethod: 'programUnsubscribe'\n      }, args);\n    }\n\n    /**\n     * Deregister an account notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n  }, {\n    key: \"removeProgramAccountChangeListener\",\n    value: function () {\n      var _removeProgramAccountChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee97(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee97$(_context98) {\n          while (1) switch (_context98.prev = _context98.next) {\n            case 0:\n              _context98.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');\n            case 2:\n            case \"end\":\n              return _context98.stop();\n          }\n        }, _callee97, this);\n      }));\n      function removeProgramAccountChangeListener(_x138) {\n        return _removeProgramAccountChangeListener.apply(this, arguments);\n      }\n      return removeProgramAccountChangeListener;\n    }()\n    /**\n     * Registers a callback to be invoked whenever logs are emitted.\n     */\n  }, {\n    key: \"onLogs\",\n    value: function onLogs(filter, callback, commitment) {\n      var args = this._buildArgs([(0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(filter) === 'object' ? {\n        mentions: [filter.toString()]\n      } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.\n      );\n\n      return this._makeSubscription({\n        callback: callback,\n        method: 'logsSubscribe',\n        unsubscribeMethod: 'logsUnsubscribe'\n      }, args);\n    }\n\n    /**\n     * Deregister a logs callback.\n     *\n     * @param id client subscription id to deregister.\n     */\n  }, {\n    key: \"removeOnLogsListener\",\n    value: function () {\n      var _removeOnLogsListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee98(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee98$(_context99) {\n          while (1) switch (_context99.prev = _context99.next) {\n            case 0:\n              _context99.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');\n            case 2:\n            case \"end\":\n              return _context99.stop();\n          }\n        }, _callee98, this);\n      }));\n      function removeOnLogsListener(_x139) {\n        return _removeOnLogsListener.apply(this, arguments);\n      }\n      return removeOnLogsListener;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnLogsNotification\",\n    value: function _wsOnLogsNotification(notification) {\n      var _create3 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, LogsNotificationResult),\n        result = _create3.result,\n        subscription = _create3.subscription;\n      this._handleServerNotification(subscription, [result.value, result.context]);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnSlotNotification\",\n    value: function _wsOnSlotNotification(notification) {\n      var _create4 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, SlotNotificationResult),\n        result = _create4.result,\n        subscription = _create4.subscription;\n      this._handleServerNotification(subscription, [result]);\n    }\n\n    /**\n     * Register a callback to be invoked upon slot changes\n     *\n     * @param callback Function to invoke whenever the slot changes\n     * @return subscription id\n     */\n  }, {\n    key: \"onSlotChange\",\n    value: function onSlotChange(callback) {\n      return this._makeSubscription({\n        callback: callback,\n        method: 'slotSubscribe',\n        unsubscribeMethod: 'slotUnsubscribe'\n      }, [] /* args */);\n    }\n\n    /**\n     * Deregister a slot notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n  }, {\n    key: \"removeSlotChangeListener\",\n    value: function () {\n      var _removeSlotChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee99(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee99$(_context100) {\n          while (1) switch (_context100.prev = _context100.next) {\n            case 0:\n              _context100.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');\n            case 2:\n            case \"end\":\n              return _context100.stop();\n          }\n        }, _callee99, this);\n      }));\n      function removeSlotChangeListener(_x140) {\n        return _removeSlotChangeListener.apply(this, arguments);\n      }\n      return removeSlotChangeListener;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnSlotUpdatesNotification\",\n    value: function _wsOnSlotUpdatesNotification(notification) {\n      var _create5 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, SlotUpdateNotificationResult),\n        result = _create5.result,\n        subscription = _create5.subscription;\n      this._handleServerNotification(subscription, [result]);\n    }\n\n    /**\n     * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n     * may be useful to track live progress of a cluster.\n     *\n     * @param callback Function to invoke whenever the slot updates\n     * @return subscription id\n     */\n  }, {\n    key: \"onSlotUpdate\",\n    value: function onSlotUpdate(callback) {\n      return this._makeSubscription({\n        callback: callback,\n        method: 'slotsUpdatesSubscribe',\n        unsubscribeMethod: 'slotsUpdatesUnsubscribe'\n      }, [] /* args */);\n    }\n\n    /**\n     * Deregister a slot update notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n  }, {\n    key: \"removeSlotUpdateListener\",\n    value: function () {\n      var _removeSlotUpdateListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee100(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee100$(_context101) {\n          while (1) switch (_context101.prev = _context101.next) {\n            case 0:\n              _context101.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');\n            case 2:\n            case \"end\":\n              return _context101.stop();\n          }\n        }, _callee100, this);\n      }));\n      function removeSlotUpdateListener(_x141) {\n        return _removeSlotUpdateListener.apply(this, arguments);\n      }\n      return removeSlotUpdateListener;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_unsubscribeClientSubscription\",\n    value: function () {\n      var _unsubscribeClientSubscription2 = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee101(clientSubscriptionId, subscriptionName) {\n        var dispose;\n        return _regeneratorRuntime$1().wrap(function _callee101$(_context102) {\n          while (1) switch (_context102.prev = _context102.next) {\n            case 0:\n              dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n              if (!dispose) {\n                _context102.next = 6;\n                break;\n              }\n              _context102.next = 4;\n              return dispose();\n            case 4:\n              _context102.next = 7;\n              break;\n            case 6:\n              console.warn('Ignored unsubscribe request because an active subscription with id ' + \"`\".concat(clientSubscriptionId, \"` for '\").concat(subscriptionName, \"' events \") + 'could not be found.');\n            case 7:\n            case \"end\":\n              return _context102.stop();\n          }\n        }, _callee101, this);\n      }));\n      function _unsubscribeClientSubscription(_x142, _x143) {\n        return _unsubscribeClientSubscription2.apply(this, arguments);\n      }\n      return _unsubscribeClientSubscription;\n    }()\n  }, {\n    key: \"_buildArgs\",\n    value: function _buildArgs(args, override, encoding, extra) {\n      var commitment = override || this._commitment;\n      if (commitment || encoding || extra) {\n        var _options = {};\n        if (encoding) {\n          _options.encoding = encoding;\n        }\n        if (commitment) {\n          _options.commitment = commitment;\n        }\n        if (extra) {\n          _options = Object.assign(_options, extra);\n        }\n        args.push(_options);\n      }\n      return args;\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_buildArgsAtLeastConfirmed\",\n    value: function _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n      var commitment = override || this._commitment;\n      if (commitment && !['confirmed', 'finalized'].includes(commitment)) {\n        throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');\n      }\n      return this._buildArgs(args, override, encoding, extra);\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnSignatureNotification\",\n    value: function _wsOnSignatureNotification(notification) {\n      var _create6 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, SignatureNotificationResult),\n        result = _create6.result,\n        subscription = _create6.subscription;\n      if (result.value !== 'receivedSignature') {\n        /**\n         * Special case.\n         * After a signature is processed, RPCs automatically dispose of the\n         * subscription on the server side. We need to track which of these\n         * subscriptions have been disposed in such a way, so that we know\n         * whether the client is dealing with a not-yet-processed signature\n         * (in which case we must tear down the server subscription) or an\n         * already-processed signature (in which case the client can simply\n         * clear out the subscription locally without telling the server).\n         *\n         * NOTE: There is a proposal to eliminate this special case, here:\n         * https://github.com/solana-labs/solana/issues/18892\n         */\n        this._subscriptionsAutoDisposedByRpc.add(subscription);\n      }\n      this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{\n        type: 'received'\n      }, result.context] : [{\n        type: 'status',\n        result: result.value\n      }, result.context]);\n    }\n\n    /**\n     * Register a callback to be invoked upon signature updates\n     *\n     * @param signature Transaction signature string in base 58\n     * @param callback Function to invoke on signature notifications\n     * @param commitment Specify the commitment level signature must reach before notification\n     * @return subscription id\n     */\n  }, {\n    key: \"onSignature\",\n    value: function onSignature(signature, _callback, commitment) {\n      var _this14 = this;\n      var args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.\n      );\n\n      var clientSubscriptionId = this._makeSubscription({\n        callback: function callback(notification, context) {\n          if (notification.type === 'status') {\n            _callback(notification.result, context);\n            // Signatures subscriptions are auto-removed by the RPC service\n            // so no need to explicitly send an unsubscribe message.\n            try {\n              _this14.removeSignatureListener(clientSubscriptionId);\n              // eslint-disable-next-line no-empty\n            } catch (_err) {\n              // Already removed.\n            }\n          }\n        },\n        method: 'signatureSubscribe',\n        unsubscribeMethod: 'signatureUnsubscribe'\n      }, args);\n      return clientSubscriptionId;\n    }\n\n    /**\n     * Register a callback to be invoked when a transaction is\n     * received and/or processed.\n     *\n     * @param signature Transaction signature string in base 58\n     * @param callback Function to invoke on signature notifications\n     * @param options Enable received notifications and set the commitment\n     *   level that signature must reach before notification\n     * @return subscription id\n     */\n  }, {\n    key: \"onSignatureWithOptions\",\n    value: function onSignatureWithOptions(signature, _callback2, options) {\n      var _this15 = this;\n      var _options$commitment = _objectSpread(_objectSpread({}, options), {}, {\n          commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.\n        }),\n        commitment = _options$commitment.commitment,\n        extra = (0,_babel_runtime_helpers_objectWithoutProperties__WEBPACK_IMPORTED_MODULE_18__[\"default\"])(_options$commitment, _excluded4);\n      var args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);\n      var clientSubscriptionId = this._makeSubscription({\n        callback: function callback(notification, context) {\n          _callback2(notification, context);\n          // Signatures subscriptions are auto-removed by the RPC service\n          // so no need to explicitly send an unsubscribe message.\n          try {\n            _this15.removeSignatureListener(clientSubscriptionId);\n            // eslint-disable-next-line no-empty\n          } catch (_err) {\n            // Already removed.\n          }\n        },\n        method: 'signatureSubscribe',\n        unsubscribeMethod: 'signatureUnsubscribe'\n      }, args);\n      return clientSubscriptionId;\n    }\n\n    /**\n     * Deregister a signature notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n  }, {\n    key: \"removeSignatureListener\",\n    value: function () {\n      var _removeSignatureListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee102(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee102$(_context103) {\n          while (1) switch (_context103.prev = _context103.next) {\n            case 0:\n              _context103.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');\n            case 2:\n            case \"end\":\n              return _context103.stop();\n          }\n        }, _callee102, this);\n      }));\n      function removeSignatureListener(_x144) {\n        return _removeSignatureListener.apply(this, arguments);\n      }\n      return removeSignatureListener;\n    }()\n    /**\n     * @internal\n     */\n  }, {\n    key: \"_wsOnRootNotification\",\n    value: function _wsOnRootNotification(notification) {\n      var _create7 = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.create)(notification, RootNotificationResult),\n        result = _create7.result,\n        subscription = _create7.subscription;\n      this._handleServerNotification(subscription, [result]);\n    }\n\n    /**\n     * Register a callback to be invoked upon root changes\n     *\n     * @param callback Function to invoke whenever the root changes\n     * @return subscription id\n     */\n  }, {\n    key: \"onRootChange\",\n    value: function onRootChange(callback) {\n      return this._makeSubscription({\n        callback: callback,\n        method: 'rootSubscribe',\n        unsubscribeMethod: 'rootUnsubscribe'\n      }, [] /* args */);\n    }\n\n    /**\n     * Deregister a root notification callback\n     *\n     * @param id client subscription id to deregister\n     */\n  }, {\n    key: \"removeRootChangeListener\",\n    value: function () {\n      var _removeRootChangeListener = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime$1().mark(function _callee103(clientSubscriptionId) {\n        return _regeneratorRuntime$1().wrap(function _callee103$(_context104) {\n          while (1) switch (_context104.prev = _context104.next) {\n            case 0:\n              _context104.next = 2;\n              return this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');\n            case 2:\n            case \"end\":\n              return _context104.stop();\n          }\n        }, _callee103, this);\n      }));\n      function removeRootChangeListener(_x145) {\n        return _removeRootChangeListener.apply(this, arguments);\n      }\n      return removeRootChangeListener;\n    }()\n  }]);\n  return Connection;\n}();\n\n/**\n * Keypair signer interface\n */\n\n/**\n * An account keypair used for signing transactions.\n */\nvar Keypair = /*#__PURE__*/function () {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */\n  function Keypair(keypair) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Keypair);\n    this._keypair = void 0;\n    this._keypair = keypair !== null && keypair !== void 0 ? keypair : generateKeypair();\n  }\n\n  /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Keypair, [{\n    key: \"publicKey\",\n    get:\n    /**\n     * The public key for this keypair\n     *\n     * @returns {PublicKey} PublicKey\n     */\n    function get() {\n      return new PublicKey(this._keypair.publicKey);\n    }\n\n    /**\n     * The raw secret key for this keypair\n     * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n     */\n  }, {\n    key: \"secretKey\",\n    get: function get() {\n      return new Uint8Array(this._keypair.secretKey);\n    }\n  }], [{\n    key: \"generate\",\n    value: function generate() {\n      return new Keypair(generateKeypair());\n    }\n\n    /**\n     * Create a keypair from a raw secret key byte array.\n     *\n     * This method should only be used to recreate a keypair from a previously\n     * generated secret key. Generating keypairs from a random seed should be done\n     * with the {@link Keypair.fromSeed} method.\n     *\n     * @throws error if the provided secret key is invalid and validation is not skipped.\n     *\n     * @param secretKey secret key byte array\n     * @param options skip secret key validation\n     *\n     * @returns {Keypair} Keypair\n     */\n  }, {\n    key: \"fromSecretKey\",\n    value: function fromSecretKey(secretKey, options) {\n      if (secretKey.byteLength !== 64) {\n        throw new Error('bad secret key size');\n      }\n      var publicKey = secretKey.slice(32, 64);\n      if (!options || !options.skipValidation) {\n        var privateScalar = secretKey.slice(0, 32);\n        var computedPublicKey = getPublicKey(privateScalar);\n        for (var ii = 0; ii < 32; ii++) {\n          if (publicKey[ii] !== computedPublicKey[ii]) {\n            throw new Error('provided secretKey is invalid');\n          }\n        }\n      }\n      return new Keypair({\n        publicKey: publicKey,\n        secretKey: secretKey\n      });\n    }\n\n    /**\n     * Generate a keypair from a 32 byte seed.\n     *\n     * @param seed seed byte array\n     *\n     * @returns {Keypair} Keypair\n     */\n  }, {\n    key: \"fromSeed\",\n    value: function fromSeed(seed) {\n      var publicKey = getPublicKey(seed);\n      var secretKey = new Uint8Array(64);\n      secretKey.set(seed);\n      secretKey.set(publicKey, 32);\n      return new Keypair({\n        publicKey: publicKey,\n        secretKey: secretKey\n      });\n    }\n  }]);\n  return Keypair;\n}();\n\n/**\n * An enumeration of valid LookupTableInstructionType's\n */\n\n/**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */\nvar LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), u64('recentSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('bumpSeed')])\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), u64(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32(), -8), 'addresses')])\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  }\n});\nvar AddressLookupTableInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function AddressLookupTableInstruction() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, AddressLookupTableInstruction);\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(AddressLookupTableInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction');\n      var index = instructionTypeLayout.decode(instruction.data);\n      var type;\n      for (var _i = 0, _Object$entries = Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_Object$entries[_i], 2),\n          layoutType = _Object$entries$_i[0],\n          layout = _Object$entries$_i[1];\n        if (layout.index == index) {\n          type = layoutType;\n          break;\n        }\n      }\n      if (!type) {\n        throw new Error('Invalid Instruction. Should be a LookupTable Instruction');\n      }\n      return type;\n    }\n  }, {\n    key: \"decodeCreateLookupTable\",\n    value: function decodeCreateLookupTable(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeysLength(instruction.keys, 4);\n      var _decodeData = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data),\n        recentSlot = _decodeData.recentSlot;\n      return {\n        authority: instruction.keys[1].pubkey,\n        payer: instruction.keys[2].pubkey,\n        recentSlot: Number(recentSlot)\n      };\n    }\n  }, {\n    key: \"decodeExtendLookupTable\",\n    value: function decodeExtendLookupTable(instruction) {\n      this.checkProgramId(instruction.programId);\n      if (instruction.keys.length < 2) {\n        throw new Error(\"invalid instruction; found \".concat(instruction.keys.length, \" keys, expected at least 2\"));\n      }\n      var _decodeData2 = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data),\n        addresses = _decodeData2.addresses;\n      return {\n        lookupTable: instruction.keys[0].pubkey,\n        authority: instruction.keys[1].pubkey,\n        payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n        addresses: addresses.map(function (buffer) {\n          return new PublicKey(buffer);\n        })\n      };\n    }\n  }, {\n    key: \"decodeCloseLookupTable\",\n    value: function decodeCloseLookupTable(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeysLength(instruction.keys, 3);\n      return {\n        lookupTable: instruction.keys[0].pubkey,\n        authority: instruction.keys[1].pubkey,\n        recipient: instruction.keys[2].pubkey\n      };\n    }\n  }, {\n    key: \"decodeFreezeLookupTable\",\n    value: function decodeFreezeLookupTable(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeysLength(instruction.keys, 2);\n      return {\n        lookupTable: instruction.keys[0].pubkey,\n        authority: instruction.keys[1].pubkey\n      };\n    }\n  }, {\n    key: \"decodeDeactivateLookupTable\",\n    value: function decodeDeactivateLookupTable(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeysLength(instruction.keys, 2);\n      return {\n        lookupTable: instruction.keys[0].pubkey,\n        authority: instruction.keys[1].pubkey\n      };\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(AddressLookupTableProgram.programId)) {\n        throw new Error('invalid instruction; programId is not AddressLookupTable Program');\n      }\n    }\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkKeysLength\",\n    value: function checkKeysLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n  return AddressLookupTableInstruction;\n}();\nvar AddressLookupTableProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function AddressLookupTableProgram() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, AddressLookupTableProgram);\n  }\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(AddressLookupTableProgram, null, [{\n    key: \"createLookupTable\",\n    value: function createLookupTable(params) {\n      var _PublicKey$findProgra = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_15__.toBufferLE)(BigInt(params.recentSlot), 8)], this.programId),\n        _PublicKey$findProgra2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_PublicKey$findProgra, 2),\n        lookupTableAddress = _PublicKey$findProgra2[0],\n        bumpSeed = _PublicKey$findProgra2[1];\n      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n      var data = encodeData(type, {\n        recentSlot: BigInt(params.recentSlot),\n        bumpSeed: bumpSeed\n      });\n      var keys = [{\n        pubkey: lookupTableAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return [new TransactionInstruction({\n        programId: this.programId,\n        keys: keys,\n        data: data\n      }), lookupTableAddress];\n    }\n  }, {\n    key: \"freezeLookupTable\",\n    value: function freezeLookupTable(params) {\n      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n      var data = encodeData(type);\n      var keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys: keys,\n        data: data\n      });\n    }\n  }, {\n    key: \"extendLookupTable\",\n    value: function extendLookupTable(params) {\n      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n      var data = encodeData(type, {\n        addresses: params.addresses.map(function (addr) {\n          return addr.toBytes();\n        })\n      });\n      var keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }];\n      if (params.payer) {\n        keys.push({\n          pubkey: params.payer,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys: keys,\n        data: data\n      });\n    }\n  }, {\n    key: \"deactivateLookupTable\",\n    value: function deactivateLookupTable(params) {\n      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n      var data = encodeData(type);\n      var keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys: keys,\n        data: data\n      });\n    }\n  }, {\n    key: \"closeLookupTable\",\n    value: function closeLookupTable(params) {\n      var type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n      var data = encodeData(type);\n      var keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.recipient,\n        isSigner: false,\n        isWritable: true\n      }];\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys: keys,\n        data: data\n      });\n    }\n  }]);\n  return AddressLookupTableProgram;\n}();\nAddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');\n\n/**\n * Compute Budget Instruction class\n */\nvar ComputeBudgetInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function ComputeBudgetInstruction() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, ComputeBudgetInstruction);\n  }\n\n  /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ComputeBudgetInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n      for (var _i = 0, _Object$entries = Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_Object$entries[_i], 2),\n          ixType = _Object$entries$_i[0],\n          layout = _Object$entries$_i[1];\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');\n      }\n      return type;\n    }\n\n    /**\n     * Decode request units compute budget instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeRequestUnits\",\n    value: function decodeRequestUnits(instruction) {\n      this.checkProgramId(instruction.programId);\n      var _decodeData = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data),\n        units = _decodeData.units,\n        additionalFee = _decodeData.additionalFee;\n      return {\n        units: units,\n        additionalFee: additionalFee\n      };\n    }\n\n    /**\n     * Decode request heap frame compute budget instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeRequestHeapFrame\",\n    value: function decodeRequestHeapFrame(instruction) {\n      this.checkProgramId(instruction.programId);\n      var _decodeData2 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data),\n        bytes = _decodeData2.bytes;\n      return {\n        bytes: bytes\n      };\n    }\n\n    /**\n     * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeSetComputeUnitLimit\",\n    value: function decodeSetComputeUnitLimit(instruction) {\n      this.checkProgramId(instruction.programId);\n      var _decodeData3 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data),\n        units = _decodeData3.units;\n      return {\n        units: units\n      };\n    }\n\n    /**\n     * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeSetComputeUnitPrice\",\n    value: function decodeSetComputeUnitPrice(instruction) {\n      this.checkProgramId(instruction.programId);\n      var _decodeData4 = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data),\n        microLamports = _decodeData4.microLamports;\n      return {\n        microLamports: microLamports\n      };\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(ComputeBudgetProgram.programId)) {\n        throw new Error('invalid instruction; programId is not ComputeBudgetProgram');\n      }\n    }\n  }]);\n  return ComputeBudgetInstruction;\n}();\n\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */\n\n/**\n * Request units instruction params\n */\n\n/**\n * Request heap frame instruction params\n */\n\n/**\n * Set compute unit limit instruction params\n */\n\n/**\n * Set compute unit price instruction params\n */\n\n/**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */\nvar COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n  RequestUnits: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('units'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('additionalFee')])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('bytes')])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('units')])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('instruction'), u64('microLamports')])\n  }\n});\n\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */\nvar ComputeBudgetProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function ComputeBudgetProgram() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, ComputeBudgetProgram);\n  }\n\n  /**\n   * Public key that identifies the Compute Budget program\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ComputeBudgetProgram, null, [{\n    key: \"requestUnits\",\n    value:\n    /**\n     * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n     */\n    function requestUnits(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n      var data = encodeData(type, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"requestHeapFrame\",\n    value: function requestHeapFrame(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n      var data = encodeData(type, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"setComputeUnitLimit\",\n    value: function setComputeUnitLimit(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n      var data = encodeData(type, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }, {\n    key: \"setComputeUnitPrice\",\n    value: function setComputeUnitPrice(params) {\n      var type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n      var data = encodeData(type, {\n        microLamports: BigInt(params.microLamports)\n      });\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n  return ComputeBudgetProgram;\n}();\nComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');\n\nvar PRIVATE_KEY_BYTES$1 = 64;\nvar PUBLIC_KEY_BYTES$1 = 32;\nvar SIGNATURE_BYTES = 64;\n\n/**\n * Params for creating an ed25519 instruction using a public key\n */\n\n/**\n * Params for creating an ed25519 instruction using a private key\n */\n\nvar ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('padding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('publicKeyOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('publicKeyInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('messageInstructionIndex')]);\nvar Ed25519Program = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function Ed25519Program() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Ed25519Program);\n  }\n\n  /**\n   * Public key that identifies the ed25519 program\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Ed25519Program, null, [{\n    key: \"createInstructionWithPublicKey\",\n    value:\n    /**\n     * Create an ed25519 instruction with a public key and signature. The\n     * public key must be a buffer that is 32 bytes long, and the signature\n     * must be a buffer of 64 bytes.\n     */\n    function createInstructionWithPublicKey(params) {\n      var publicKey = params.publicKey,\n        message = params.message,\n        signature = params.signature,\n        instructionIndex = params.instructionIndex;\n      assert(publicKey.length === PUBLIC_KEY_BYTES$1, \"Public Key must be \".concat(PUBLIC_KEY_BYTES$1, \" bytes but received \").concat(publicKey.length, \" bytes\"));\n      assert(signature.length === SIGNATURE_BYTES, \"Signature must be \".concat(SIGNATURE_BYTES, \" bytes but received \").concat(signature.length, \" bytes\"));\n      var publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n      var signatureOffset = publicKeyOffset + publicKey.length;\n      var messageDataOffset = signatureOffset + signature.length;\n      var numSignatures = 1;\n      var instructionData = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(messageDataOffset + message.length);\n      var index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n      : instructionIndex;\n      ED25519_INSTRUCTION_LAYOUT.encode({\n        numSignatures: numSignatures,\n        padding: 0,\n        signatureOffset: signatureOffset,\n        signatureInstructionIndex: index,\n        publicKeyOffset: publicKeyOffset,\n        publicKeyInstructionIndex: index,\n        messageDataOffset: messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: index\n      }, instructionData);\n      instructionData.fill(publicKey, publicKeyOffset);\n      instructionData.fill(signature, signatureOffset);\n      instructionData.fill(message, messageDataOffset);\n      return new TransactionInstruction({\n        keys: [],\n        programId: Ed25519Program.programId,\n        data: instructionData\n      });\n    }\n\n    /**\n     * Create an ed25519 instruction with a private key. The private key\n     * must be a buffer that is 64 bytes long.\n     */\n  }, {\n    key: \"createInstructionWithPrivateKey\",\n    value: function createInstructionWithPrivateKey(params) {\n      var privateKey = params.privateKey,\n        message = params.message,\n        instructionIndex = params.instructionIndex;\n      assert(privateKey.length === PRIVATE_KEY_BYTES$1, \"Private key must be \".concat(PRIVATE_KEY_BYTES$1, \" bytes but received \").concat(privateKey.length, \" bytes\"));\n      try {\n        var keypair = Keypair.fromSecretKey(privateKey);\n        var publicKey = keypair.publicKey.toBytes();\n        var signature = sign(message, keypair.secretKey);\n        return this.createInstructionWithPublicKey({\n          publicKey: publicKey,\n          message: message,\n          signature: signature,\n          instructionIndex: instructionIndex\n        });\n      } catch (error) {\n        throw new Error(\"Error creating instruction; \".concat(error));\n      }\n    }\n  }]);\n  return Ed25519Program;\n}();\nEd25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');\n\nvar ecdsaSign = function ecdsaSign(msgHash, privKey) {\n  var signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_25__.secp256k1.sign(msgHash, privKey);\n  return [signature.toCompactRawBytes(), signature.recovery];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_25__.secp256k1.utils.isValidPrivateKey;\nvar publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_25__.secp256k1.getPublicKey;\n\nvar PRIVATE_KEY_BYTES = 32;\nvar ETHEREUM_ADDRESS_BYTES = 20;\nvar PUBLIC_KEY_BYTES = 64;\nvar SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n\n/**\n * Params for creating an secp256k1 instruction using a public key\n */\n\n/**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */\n\n/**\n * Params for creating an secp256k1 instruction using a private key\n */\n\nvar SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('ethAddressOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('ethAddressInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u16('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('messageInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(20, 'ethAddress'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.blob(64, 'signature'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('recoveryId')]);\nvar Secp256k1Program = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function Secp256k1Program() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Secp256k1Program);\n  }\n\n  /**\n   * Public key that identifies the secp256k1 program\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Secp256k1Program, null, [{\n    key: \"publicKeyToEthAddress\",\n    value:\n    /**\n     * Construct an Ethereum address from a secp256k1 public key buffer.\n     * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n     */\n    function publicKeyToEthAddress(publicKey) {\n      assert(publicKey.length === PUBLIC_KEY_BYTES, \"Public key must be \".concat(PUBLIC_KEY_BYTES, \" bytes but received \").concat(publicKey.length, \" bytes\"));\n      try {\n        return buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_24__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n      } catch (error) {\n        throw new Error(\"Error constructing Ethereum address: \".concat(error));\n      }\n    }\n\n    /**\n     * Create an secp256k1 instruction with a public key. The public key\n     * must be a buffer that is 64 bytes long.\n     */\n  }, {\n    key: \"createInstructionWithPublicKey\",\n    value: function createInstructionWithPublicKey(params) {\n      var publicKey = params.publicKey,\n        message = params.message,\n        signature = params.signature,\n        recoveryId = params.recoveryId,\n        instructionIndex = params.instructionIndex;\n      return Secp256k1Program.createInstructionWithEthAddress({\n        ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n        message: message,\n        signature: signature,\n        recoveryId: recoveryId,\n        instructionIndex: instructionIndex\n      });\n    }\n\n    /**\n     * Create an secp256k1 instruction with an Ethereum address. The address\n     * must be a hex string or a buffer that is 20 bytes long.\n     */\n  }, {\n    key: \"createInstructionWithEthAddress\",\n    value: function createInstructionWithEthAddress(params) {\n      var rawAddress = params.ethAddress,\n        message = params.message,\n        signature = params.signature,\n        recoveryId = params.recoveryId,\n        _params$instructionIn = params.instructionIndex,\n        instructionIndex = _params$instructionIn === void 0 ? 0 : _params$instructionIn;\n      var ethAddress;\n      if (typeof rawAddress === 'string') {\n        if (rawAddress.startsWith('0x')) {\n          ethAddress = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(rawAddress.substr(2), 'hex');\n        } else {\n          ethAddress = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(rawAddress, 'hex');\n        }\n      } else {\n        ethAddress = rawAddress;\n      }\n      assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, \"Address must be \".concat(ETHEREUM_ADDRESS_BYTES, \" bytes but received \").concat(ethAddress.length, \" bytes\"));\n      var dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n      var ethAddressOffset = dataStart;\n      var signatureOffset = dataStart + ethAddress.length;\n      var messageDataOffset = signatureOffset + signature.length + 1;\n      var numSignatures = 1;\n      var instructionData = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n      SECP256K1_INSTRUCTION_LAYOUT.encode({\n        numSignatures: numSignatures,\n        signatureOffset: signatureOffset,\n        signatureInstructionIndex: instructionIndex,\n        ethAddressOffset: ethAddressOffset,\n        ethAddressInstructionIndex: instructionIndex,\n        messageDataOffset: messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: instructionIndex,\n        signature: toBuffer(signature),\n        ethAddress: toBuffer(ethAddress),\n        recoveryId: recoveryId\n      }, instructionData);\n      instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n      return new TransactionInstruction({\n        keys: [],\n        programId: Secp256k1Program.programId,\n        data: instructionData\n      });\n    }\n\n    /**\n     * Create an secp256k1 instruction with a private key. The private key\n     * must be a buffer that is 32 bytes long.\n     */\n  }, {\n    key: \"createInstructionWithPrivateKey\",\n    value: function createInstructionWithPrivateKey(params) {\n      var pkey = params.privateKey,\n        message = params.message,\n        instructionIndex = params.instructionIndex;\n      assert(pkey.length === PRIVATE_KEY_BYTES, \"Private key must be \".concat(PRIVATE_KEY_BYTES, \" bytes but received \").concat(pkey.length, \" bytes\"));\n      try {\n        var privateKey = toBuffer(pkey);\n        var publicKey = publicKeyCreate(privateKey, false /* isCompressed */).slice(1); // throw away leading byte\n        var messageHash = buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_24__.keccak_256)(toBuffer(message)));\n        var _ecdsaSign = ecdsaSign(messageHash, privateKey),\n          _ecdsaSign2 = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_ecdsaSign, 2),\n          signature = _ecdsaSign2[0],\n          recoveryId = _ecdsaSign2[1];\n        return this.createInstructionWithPublicKey({\n          publicKey: publicKey,\n          message: message,\n          signature: signature,\n          recoveryId: recoveryId,\n          instructionIndex: instructionIndex\n        });\n      } catch (error) {\n        throw new Error(\"Error creating instruction; \".concat(error));\n      }\n    }\n  }]);\n  return Secp256k1Program;\n}();\nSecp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');\n\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */\nvar STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');\n\n/**\n * Stake account authority info\n */\nvar Authorized = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n/**\n * Create a new Authorized object\n * @param staker the stake authority\n * @param withdrawer the withdraw authority\n */\nfunction Authorized(staker, withdrawer) {\n  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Authorized);\n  /** stake authority */\n  this.staker = void 0;\n  /** withdraw authority */\n  this.withdrawer = void 0;\n  this.staker = staker;\n  this.withdrawer = withdrawer;\n});\n/**\n * Stake account lockup info\n */\nvar Lockup = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(\n/**\n * Create a new Lockup object\n */\nfunction Lockup(unixTimestamp, epoch, custodian) {\n  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, Lockup);\n  /** Unix timestamp of lockup expiration */\n  this.unixTimestamp = void 0;\n  /** Epoch of lockup expiration */\n  this.epoch = void 0;\n  /** Lockup custodian authority */\n  this.custodian = void 0;\n  this.unixTimestamp = unixTimestamp;\n  this.epoch = epoch;\n  this.custodian = custodian;\n}\n\n/**\n * Default, inactive Lockup value\n */);\nLockup[\"default\"] = new Lockup(0, 0, PublicKey[\"default\"]);\n/**\n * Create stake account transaction params\n */\n/**\n * Create stake account with seed transaction params\n */\n/**\n * Initialize stake instruction params\n */\n/**\n * Delegate stake instruction params\n */\n/**\n * Authorize stake instruction params\n */\n/**\n * Authorize stake instruction params using a derived key\n */\n/**\n * Split stake instruction params\n */\n/**\n * Split with seed transaction params\n */\n/**\n * Withdraw stake instruction params\n */\n/**\n * Deactivate stake instruction params\n */\n/**\n * Merge stake instruction params\n */\n/**\n * Stake Instruction class\n */\nvar StakeInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function StakeInstruction() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, StakeInstruction);\n  }\n\n  /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(StakeInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n      for (var _i = 0, _Object$entries = Object.entries(STAKE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_Object$entries[_i], 2),\n          ixType = _Object$entries$_i[0],\n          layout = _Object$entries$_i[1];\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a StakeInstruction');\n      }\n      return type;\n    }\n\n    /**\n     * Decode a initialize stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeInitialize\",\n    value: function decodeInitialize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n      var _decodeData = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data),\n        authorized = _decodeData.authorized,\n        lockup = _decodeData.lockup;\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n        lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n      };\n    }\n\n    /**\n     * Decode a delegate stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeDelegate\",\n    value: function decodeDelegate(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 6);\n      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        votePubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[5].pubkey\n      };\n    }\n\n    /**\n     * Decode an authorize stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAuthorize\",\n    value: function decodeAuthorize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData2 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),\n        newAuthorized = _decodeData2.newAuthorized,\n        stakeAuthorizationType = _decodeData2.stakeAuthorizationType;\n      var o = {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey,\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        stakeAuthorizationType: {\n          index: stakeAuthorizationType\n        }\n      };\n      if (instruction.keys.length > 3) {\n        o.custodianPubkey = instruction.keys[3].pubkey;\n      }\n      return o;\n    }\n\n    /**\n     * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAuthorizeWithSeed\",\n    value: function decodeAuthorizeWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 2);\n      var _decodeData3 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),\n        newAuthorized = _decodeData3.newAuthorized,\n        stakeAuthorizationType = _decodeData3.stakeAuthorizationType,\n        authoritySeed = _decodeData3.authoritySeed,\n        authorityOwner = _decodeData3.authorityOwner;\n      var o = {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorityBase: instruction.keys[1].pubkey,\n        authoritySeed: authoritySeed,\n        authorityOwner: new PublicKey(authorityOwner),\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        stakeAuthorizationType: {\n          index: stakeAuthorizationType\n        }\n      };\n      if (instruction.keys.length > 3) {\n        o.custodianPubkey = instruction.keys[3].pubkey;\n      }\n      return o;\n    }\n\n    /**\n     * Decode a split stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeSplit\",\n    value: function decodeSplit(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData4 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data),\n        lamports = _decodeData4.lamports;\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        splitStakePubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey,\n        lamports: lamports\n      };\n    }\n\n    /**\n     * Decode a merge stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeMerge\",\n    value: function decodeMerge(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        sourceStakePubKey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[4].pubkey\n      };\n    }\n\n    /**\n     * Decode a withdraw stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeWithdraw\",\n    value: function decodeWithdraw(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 5);\n      var _decodeData5 = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),\n        lamports = _decodeData5.lamports;\n      var o = {\n        stakePubkey: instruction.keys[0].pubkey,\n        toPubkey: instruction.keys[1].pubkey,\n        authorizedPubkey: instruction.keys[4].pubkey,\n        lamports: lamports\n      };\n      if (instruction.keys.length > 5) {\n        o.custodianPubkey = instruction.keys[5].pubkey;\n      }\n      return o;\n    }\n\n    /**\n     * Decode a deactivate stake instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeDeactivate\",\n    value: function decodeDeactivate(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n      return {\n        stakePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey\n      };\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(StakeProgram.programId)) {\n        throw new Error('invalid instruction; programId is not StakeProgram');\n      }\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkKeyLength\",\n    value: function checkKeyLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n  return StakeInstruction;\n}();\n\n/**\n * An enumeration of valid StakeInstructionType's\n */\n\n/**\n * An enumeration of valid stake InstructionType's\n * @internal\n */\nvar STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n  Initialize: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), authorized(), lockup()])\n  },\n  Authorize: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('stakeAuthorizationType')])\n  },\n  Delegate: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  },\n  Split: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('lamports')])\n  },\n  Withdraw: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('lamports')])\n  },\n  Deactivate: {\n    index: 5,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  },\n  Merge: {\n    index: 7,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])\n  }\n});\n\n/**\n * Stake authorization type\n */\n\n/**\n * An enumeration of valid StakeAuthorizationLayout's\n */\nvar StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Stake program\n */\nvar StakeProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function StakeProgram() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, StakeProgram);\n  }\n\n  /**\n   * Public key that identifies the Stake program\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(StakeProgram, null, [{\n    key: \"initialize\",\n    value:\n    /**\n     * Generate an Initialize instruction to add to a Stake Create transaction\n     */\n    function initialize(params) {\n      var stakePubkey = params.stakePubkey,\n        authorized = params.authorized,\n        maybeLockup = params.lockup;\n      var lockup = maybeLockup || Lockup[\"default\"];\n      var type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n      var data = encodeData(type, {\n        authorized: {\n          staker: toBuffer(authorized.staker.toBuffer()),\n          withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n        },\n        lockup: {\n          unixTimestamp: lockup.unixTimestamp,\n          epoch: lockup.epoch,\n          custodian: toBuffer(lockup.custodian.toBuffer())\n        }\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n\n    /**\n     * Generate a Transaction that creates a new Stake account at\n     *   an address generated with `from`, a seed, and the Stake programId\n     */\n  }, {\n    key: \"createAccountWithSeed\",\n    value: function createAccountWithSeed(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      var stakePubkey = params.stakePubkey,\n        authorized = params.authorized,\n        lockup = params.lockup;\n      return transaction.add(this.initialize({\n        stakePubkey: stakePubkey,\n        authorized: authorized,\n        lockup: lockup\n      }));\n    }\n\n    /**\n     * Generate a Transaction that creates a new Stake account\n     */\n  }, {\n    key: \"createAccount\",\n    value: function createAccount(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      var stakePubkey = params.stakePubkey,\n        authorized = params.authorized,\n        lockup = params.lockup;\n      return transaction.add(this.initialize({\n        stakePubkey: stakePubkey,\n        authorized: authorized,\n        lockup: lockup\n      }));\n    }\n\n    /**\n     * Generate a Transaction that delegates Stake tokens to a validator\n     * Vote PublicKey. This transaction can also be used to redelegate Stake\n     * to a new validator Vote PublicKey.\n     */\n  }, {\n    key: \"delegate\",\n    value: function delegate(params) {\n      var stakePubkey = params.stakePubkey,\n        authorizedPubkey = params.authorizedPubkey,\n        votePubkey = params.votePubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: STAKE_CONFIG_ID,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n  }, {\n    key: \"authorize\",\n    value: function authorize(params) {\n      var stakePubkey = params.stakePubkey,\n        authorizedPubkey = params.authorizedPubkey,\n        newAuthorizedPubkey = params.newAuthorizedPubkey,\n        stakeAuthorizationType = params.stakeAuthorizationType,\n        custodianPubkey = params.custodianPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n      var data = encodeData(type, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        stakeAuthorizationType: stakeAuthorizationType.index\n      });\n      var keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n  }, {\n    key: \"authorizeWithSeed\",\n    value: function authorizeWithSeed(params) {\n      var stakePubkey = params.stakePubkey,\n        authorityBase = params.authorityBase,\n        authoritySeed = params.authoritySeed,\n        authorityOwner = params.authorityOwner,\n        newAuthorizedPubkey = params.newAuthorizedPubkey,\n        stakeAuthorizationType = params.stakeAuthorizationType,\n        custodianPubkey = params.custodianPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n      var data = encodeData(type, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        stakeAuthorizationType: stakeAuthorizationType.index,\n        authoritySeed: authoritySeed,\n        authorityOwner: toBuffer(authorityOwner.toBuffer())\n      });\n      var keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorityBase,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"splitInstruction\",\n    value: function splitInstruction(params) {\n      var stakePubkey = params.stakePubkey,\n        authorizedPubkey = params.authorizedPubkey,\n        splitStakePubkey = params.splitStakePubkey,\n        lamports = params.lamports;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Split;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: splitStakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a Transaction that splits Stake tokens into another stake account\n     */\n  }, {\n    key: \"split\",\n    value: function split(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.authorizedPubkey,\n        newAccountPubkey: params.splitStakePubkey,\n        lamports: 0,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.splitInstruction(params));\n    }\n\n    /**\n     * Generate a Transaction that splits Stake tokens into another account\n     * derived from a base public key and seed\n     */\n  }, {\n    key: \"splitWithSeed\",\n    value: function splitWithSeed(params) {\n      var stakePubkey = params.stakePubkey,\n        authorizedPubkey = params.authorizedPubkey,\n        splitStakePubkey = params.splitStakePubkey,\n        basePubkey = params.basePubkey,\n        seed = params.seed,\n        lamports = params.lamports;\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.allocate({\n        accountPubkey: splitStakePubkey,\n        basePubkey: basePubkey,\n        seed: seed,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.splitInstruction({\n        stakePubkey: stakePubkey,\n        authorizedPubkey: authorizedPubkey,\n        splitStakePubkey: splitStakePubkey,\n        lamports: lamports\n      }));\n    }\n\n    /**\n     * Generate a Transaction that merges Stake accounts.\n     */\n  }, {\n    key: \"merge\",\n    value: function merge(params) {\n      var stakePubkey = params.stakePubkey,\n        sourceStakePubKey = params.sourceStakePubKey,\n        authorizedPubkey = params.authorizedPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: sourceStakePubKey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a Transaction that withdraws deactivated Stake tokens.\n     */\n  }, {\n    key: \"withdraw\",\n    value: function withdraw(params) {\n      var stakePubkey = params.stakePubkey,\n        authorizedPubkey = params.authorizedPubkey,\n        toPubkey = params.toPubkey,\n        lamports = params.lamports,\n        custodianPubkey = params.custodianPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      var keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a Transaction that deactivates Stake tokens.\n     */\n  }, {\n    key: \"deactivate\",\n    value: function deactivate(params) {\n      var stakePubkey = params.stakePubkey,\n        authorizedPubkey = params.authorizedPubkey;\n      var type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n      var data = encodeData(type);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      });\n    }\n  }]);\n  return StakeProgram;\n}();\nStakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeState::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeState.html\n */\nStakeProgram.space = 200;\n\n/**\n * Vote account info\n */\nvar VoteInit = /*#__PURE__*/(0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])( /** [0, 100] */\n\nfunction VoteInit(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {\n  (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, VoteInit);\n  this.nodePubkey = void 0;\n  this.authorizedVoter = void 0;\n  this.authorizedWithdrawer = void 0;\n  this.commission = void 0;\n  this.nodePubkey = nodePubkey;\n  this.authorizedVoter = authorizedVoter;\n  this.authorizedWithdrawer = authorizedWithdrawer;\n  this.commission = commission;\n});\n\n/**\n * Create vote account transaction params\n */\n\n/**\n * InitializeAccount instruction params\n */\n\n/**\n * Authorize instruction params\n */\n\n/**\n * AuthorizeWithSeed instruction params\n */\n\n/**\n * Withdraw from vote account transaction params\n */\n\n/**\n * Vote Instruction class\n */\nvar VoteInstruction = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function VoteInstruction() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, VoteInstruction);\n  }\n\n  /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(VoteInstruction, null, [{\n    key: \"decodeInstructionType\",\n    value: function decodeInstructionType(instruction) {\n      this.checkProgramId(instruction.programId);\n      var instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction');\n      var typeIndex = instructionTypeLayout.decode(instruction.data);\n      var type;\n      for (var _i = 0, _Object$entries = Object.entries(VOTE_INSTRUCTION_LAYOUTS); _i < _Object$entries.length; _i++) {\n        var _Object$entries$_i = (0,_babel_runtime_helpers_slicedToArray__WEBPACK_IMPORTED_MODULE_14__[\"default\"])(_Object$entries[_i], 2),\n          ixType = _Object$entries$_i[0],\n          layout = _Object$entries$_i[1];\n        if (layout.index == typeIndex) {\n          type = ixType;\n          break;\n        }\n      }\n      if (!type) {\n        throw new Error('Instruction type incorrect; not a VoteInstruction');\n      }\n      return type;\n    }\n\n    /**\n     * Decode an initialize vote instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeInitializeAccount\",\n    value: function decodeInitializeAccount(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 4);\n      var _decodeData = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data),\n        voteInit = _decodeData.voteInit;\n      return {\n        votePubkey: instruction.keys[0].pubkey,\n        nodePubkey: instruction.keys[3].pubkey,\n        voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n      };\n    }\n\n    /**\n     * Decode an authorize instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAuthorize\",\n    value: function decodeAuthorize(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData2 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data),\n        newAuthorized = _decodeData2.newAuthorized,\n        voteAuthorizationType = _decodeData2.voteAuthorizationType;\n      return {\n        votePubkey: instruction.keys[0].pubkey,\n        authorizedPubkey: instruction.keys[2].pubkey,\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        voteAuthorizationType: {\n          index: voteAuthorizationType\n        }\n      };\n    }\n\n    /**\n     * Decode an authorize instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeAuthorizeWithSeed\",\n    value: function decodeAuthorizeWithSeed(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData3 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data),\n        _decodeData3$voteAuth = _decodeData3.voteAuthorizeWithSeedArgs,\n        currentAuthorityDerivedKeyOwnerPubkey = _decodeData3$voteAuth.currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed = _decodeData3$voteAuth.currentAuthorityDerivedKeySeed,\n        newAuthorized = _decodeData3$voteAuth.newAuthorized,\n        voteAuthorizationType = _decodeData3$voteAuth.voteAuthorizationType;\n      return {\n        currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n        currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n        newAuthorizedPubkey: new PublicKey(newAuthorized),\n        voteAuthorizationType: {\n          index: voteAuthorizationType\n        },\n        votePubkey: instruction.keys[0].pubkey\n      };\n    }\n\n    /**\n     * Decode a withdraw instruction and retrieve the instruction params.\n     */\n  }, {\n    key: \"decodeWithdraw\",\n    value: function decodeWithdraw(instruction) {\n      this.checkProgramId(instruction.programId);\n      this.checkKeyLength(instruction.keys, 3);\n      var _decodeData4 = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data),\n        lamports = _decodeData4.lamports;\n      return {\n        votePubkey: instruction.keys[0].pubkey,\n        authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n        lamports: lamports,\n        toPubkey: instruction.keys[1].pubkey\n      };\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkProgramId\",\n    value: function checkProgramId(programId) {\n      if (!programId.equals(VoteProgram.programId)) {\n        throw new Error('invalid instruction; programId is not VoteProgram');\n      }\n    }\n\n    /**\n     * @internal\n     */\n  }, {\n    key: \"checkKeyLength\",\n    value: function checkKeyLength(keys, expectedLength) {\n      if (keys.length < expectedLength) {\n        throw new Error(\"invalid instruction; found \".concat(keys.length, \" keys, expected at least \").concat(expectedLength));\n      }\n    }\n  }]);\n  return VoteInstruction;\n}();\n\n/**\n * An enumeration of valid VoteInstructionType's\n */\n\n/** @internal */\n\nvar VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), voteInit()])\n  },\n  Authorize: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('voteAuthorizationType')])\n  },\n  Withdraw: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.ns64('lamports')])\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('instruction'), voteAuthorizeWithSeedArgs()])\n  }\n});\n\n/**\n * VoteAuthorize type\n */\n\n/**\n * An enumeration of valid VoteAuthorization layouts.\n */\nvar VoteAuthorizationLayout = Object.freeze({\n  Voter: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Vote program\n */\nvar VoteProgram = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function VoteProgram() {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, VoteProgram);\n  }\n\n  /**\n   * Public key that identifies the Vote program\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(VoteProgram, null, [{\n    key: \"initializeAccount\",\n    value:\n    /**\n     * Generate an Initialize instruction.\n     */\n    function initializeAccount(params) {\n      var votePubkey = params.votePubkey,\n        nodePubkey = params.nodePubkey,\n        voteInit = params.voteInit;\n      var type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n      var data = encodeData(type, {\n        voteInit: {\n          nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n          authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n          authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n          commission: voteInit.commission\n        }\n      });\n      var instructionData = {\n        keys: [{\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: nodePubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data: data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n\n    /**\n     * Generate a transaction that creates a new Vote account.\n     */\n  }, {\n    key: \"createAccount\",\n    value: function createAccount(params) {\n      var transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.votePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.initializeAccount({\n        votePubkey: params.votePubkey,\n        nodePubkey: params.voteInit.nodePubkey,\n        voteInit: params.voteInit\n      }));\n    }\n\n    /**\n     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n     */\n  }, {\n    key: \"authorize\",\n    value: function authorize(params) {\n      var votePubkey = params.votePubkey,\n        authorizedPubkey = params.authorizedPubkey,\n        newAuthorizedPubkey = params.newAuthorizedPubkey,\n        voteAuthorizationType = params.voteAuthorizationType;\n      var type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n      var data = encodeData(type, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index\n      });\n      var keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n     * where the current Voter or Withdrawer authority is a derived key.\n     */\n  }, {\n    key: \"authorizeWithSeed\",\n    value: function authorizeWithSeed(params) {\n      var currentAuthorityDerivedKeyBasePubkey = params.currentAuthorityDerivedKeyBasePubkey,\n        currentAuthorityDerivedKeyOwnerPubkey = params.currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed = params.currentAuthorityDerivedKeySeed,\n        newAuthorizedPubkey = params.newAuthorizedPubkey,\n        voteAuthorizationType = params.voteAuthorizationType,\n        votePubkey = params.votePubkey;\n      var type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n      var data = encodeData(type, {\n        voteAuthorizeWithSeedArgs: {\n          currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n          currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n          voteAuthorizationType: voteAuthorizationType.index\n        }\n      });\n      var keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: currentAuthorityDerivedKeyBasePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction to withdraw from a Vote account.\n     */\n  }, {\n    key: \"withdraw\",\n    value: function withdraw(params) {\n      var votePubkey = params.votePubkey,\n        authorizedWithdrawerPubkey = params.authorizedWithdrawerPubkey,\n        lamports = params.lamports,\n        toPubkey = params.toPubkey;\n      var type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n      var data = encodeData(type, {\n        lamports: lamports\n      });\n      var keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedWithdrawerPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys: keys,\n        programId: this.programId,\n        data: data\n      });\n    }\n\n    /**\n     * Generate a transaction to withdraw safely from a Vote account.\n     *\n     * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n     * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n     * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n     * `withdraw` method directly.\n     */\n  }, {\n    key: \"safeWithdraw\",\n    value: function safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n      if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n        throw new Error('Withdraw will leave vote account with insuffcient funds.');\n      }\n      return VoteProgram.withdraw(params);\n    }\n  }]);\n  return VoteProgram;\n}();\nVoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */\nVoteProgram.space = 3731;\n\nvar VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');\n\n/**\n * @internal\n */\n\n/**\n * Info used to identity validators.\n */\n\nvar InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.type)({\n  name: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)(),\n  website: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  details: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)()),\n  keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_26__.string)())\n});\n\n/**\n * ValidatorInfo class\n */\nvar ValidatorInfo = /*#__PURE__*/function () {\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  function ValidatorInfo(key, info) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, ValidatorInfo);\n    /**\n     * validator public key\n     */\n    this.key = void 0;\n    /**\n     * validator information\n     */\n    this.info = void 0;\n    this.key = key;\n    this.info = info;\n  }\n\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(ValidatorInfo, null, [{\n    key: \"fromConfigData\",\n    value: function fromConfigData(buffer) {\n      var byteArray = (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(buffer);\n      var configKeyCount = decodeLength(byteArray);\n      if (configKeyCount !== 2) return null;\n      var configKeys = [];\n      for (var i = 0; i < 2; i++) {\n        var publicKey = new PublicKey(byteArray.slice(0, PUBLIC_KEY_LENGTH));\n        byteArray = byteArray.slice(PUBLIC_KEY_LENGTH);\n        var isSigner = byteArray.slice(0, 1)[0] === 1;\n        byteArray = byteArray.slice(1);\n        configKeys.push({\n          publicKey: publicKey,\n          isSigner: isSigner\n        });\n      }\n      if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n        if (configKeys[1].isSigner) {\n          var rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_2__.Buffer.from(byteArray));\n          var info = JSON.parse(rawInfo);\n          (0,superstruct__WEBPACK_IMPORTED_MODULE_26__.assert)(info, InfoString);\n          return new ValidatorInfo(configKeys[1].publicKey, info);\n        }\n      }\n      return null;\n    }\n  }]);\n  return ValidatorInfo;\n}();\n\nvar VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');\n\n/**\n * History of how many credits earned by the end of each epoch\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */\nvar VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('commission'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64(),\n// votes.length\n_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32('confirmationCount')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32(), -8), 'votes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('rootSlotValid'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('rootSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64(),\n// authorizedVoters.length\n_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('epoch'), publicKey('authorizedVoter')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32(), -8), 'authorizedVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([publicKey('authorizedPubkey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('epochOfLastAuthorizedSwitch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('targetEpoch')]), 32, 'buf'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('idx'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u8('isEmpty')], 'priorVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64(),\n// epochCredits.length\n_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('epoch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('credits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('prevCredits')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.u32(), -8), 'epochCredits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_13__.nu64('timestamp')], 'lastTimestamp')]);\n/**\n * VoteAccount class\n */\nvar VoteAccount = /*#__PURE__*/function () {\n  /**\n   * @internal\n   */\n  function VoteAccount(args) {\n    (0,_babel_runtime_helpers_classCallCheck__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this, VoteAccount);\n    this.nodePubkey = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.rootSlot = void 0;\n    this.votes = void 0;\n    this.authorizedVoters = void 0;\n    this.priorVoters = void 0;\n    this.epochCredits = void 0;\n    this.lastTimestamp = void 0;\n    this.nodePubkey = args.nodePubkey;\n    this.authorizedWithdrawer = args.authorizedWithdrawer;\n    this.commission = args.commission;\n    this.rootSlot = args.rootSlot;\n    this.votes = args.votes;\n    this.authorizedVoters = args.authorizedVoters;\n    this.priorVoters = args.priorVoters;\n    this.epochCredits = args.epochCredits;\n    this.lastTimestamp = args.lastTimestamp;\n  }\n\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n  (0,_babel_runtime_helpers_createClass__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(VoteAccount, null, [{\n    key: \"fromAccountData\",\n    value: function fromAccountData(buffer) {\n      var versionOffset = 4;\n      var va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n      var rootSlot = va.rootSlot;\n      if (!va.rootSlotValid) {\n        rootSlot = null;\n      }\n      return new VoteAccount({\n        nodePubkey: new PublicKey(va.nodePubkey),\n        authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n        commission: va.commission,\n        votes: va.votes,\n        rootSlot: rootSlot,\n        authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n        priorVoters: getPriorVoters(va.priorVoters),\n        epochCredits: va.epochCredits,\n        lastTimestamp: va.lastTimestamp\n      });\n    }\n  }]);\n  return VoteAccount;\n}();\nfunction parseAuthorizedVoter(_ref) {\n  var authorizedVoter = _ref.authorizedVoter,\n    epoch = _ref.epoch;\n  return {\n    epoch: epoch,\n    authorizedVoter: new PublicKey(authorizedVoter)\n  };\n}\nfunction parsePriorVoters(_ref2) {\n  var authorizedPubkey = _ref2.authorizedPubkey,\n    epochOfLastAuthorizedSwitch = _ref2.epochOfLastAuthorizedSwitch,\n    targetEpoch = _ref2.targetEpoch;\n  return {\n    authorizedPubkey: new PublicKey(authorizedPubkey),\n    epochOfLastAuthorizedSwitch: epochOfLastAuthorizedSwitch,\n    targetEpoch: targetEpoch\n  };\n}\nfunction getPriorVoters(_ref3) {\n  var buf = _ref3.buf,\n    idx = _ref3.idx,\n    isEmpty = _ref3.isEmpty;\n  if (isEmpty) {\n    return [];\n  }\n  return [].concat((0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(buf.slice(idx + 1).map(parsePriorVoters)), (0,_babel_runtime_helpers_toConsumableArray__WEBPACK_IMPORTED_MODULE_17__[\"default\"])(buf.slice(0, idx).map(parsePriorVoters)));\n}\n\nvar endpoint = {\n  http: {\n    devnet: 'http://api.devnet.solana.com',\n    testnet: 'http://api.testnet.solana.com',\n    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'\n  },\n  https: {\n    devnet: 'https://api.devnet.solana.com',\n    testnet: 'https://api.testnet.solana.com',\n    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'\n  }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */\nfunction clusterApiUrl(cluster, tls) {\n  var key = tls === false ? 'http' : 'https';\n  if (!cluster) {\n    return endpoint[key]['devnet'];\n  }\n  var url = endpoint[key][cluster];\n  if (!url) {\n    throw new Error(\"Unknown \".concat(key, \" cluster: \").concat(cluster));\n  }\n  return url;\n}\n\nfunction _regeneratorRuntime() { /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == (0,_babel_runtime_helpers_typeof__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\n\n/**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */ // eslint-disable-next-line no-redeclare\n// eslint-disable-next-line no-redeclare\nfunction sendAndConfirmRawTransaction(_x, _x2, _x3, _x4) {\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\nfunction _sendAndConfirmRawTransaction() {\n  _sendAndConfirmRawTransaction = (0,_babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_5__[\"default\"])( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n    var confirmationStrategy, options, sendOptions, signature, commitment, confirmationPromise, status;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {\n            confirmationStrategy = confirmationStrategyOrConfirmOptions;\n            options = maybeConfirmOptions;\n          } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {\n            confirmationStrategy = confirmationStrategyOrConfirmOptions;\n            options = maybeConfirmOptions;\n          } else {\n            options = confirmationStrategyOrConfirmOptions;\n          }\n          sendOptions = options && {\n            skipPreflight: options.skipPreflight,\n            preflightCommitment: options.preflightCommitment || options.commitment,\n            minContextSlot: options.minContextSlot\n          };\n          _context.next = 4;\n          return connection.sendRawTransaction(rawTransaction, sendOptions);\n        case 4:\n          signature = _context.sent;\n          commitment = options && options.commitment;\n          confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n          _context.next = 9;\n          return confirmationPromise;\n        case 9:\n          status = _context.sent.value;\n          if (!status.err) {\n            _context.next = 12;\n            break;\n          }\n          throw new Error(\"Raw transaction \".concat(signature, \" failed (\").concat(JSON.stringify(status), \")\"));\n        case 12:\n          return _context.abrupt(\"return\", signature);\n        case 13:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n  return _sendAndConfirmRawTransaction.apply(this, arguments);\n}\n\n/**\n * There are 1-billion lamports in one SOL\n */\nvar LAMPORTS_PER_SOL = 1000000000;\n\n\n//# sourceMappingURL=index.browser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL2xpYi9pbmRleC5icm93c2VyLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFvRTtBQUNOO0FBQzlCO0FBQ2dCO0FBQ0k7QUFDb0I7QUFDaEI7QUFDa0M7QUFDdEI7QUFDN0M7QUFDQztBQUNzQjtBQUN1QjtBQUNmO0FBQ1Q7QUFDcUI7QUFDWDtBQUNhO0FBQ007QUFDWTtBQUM0RjtBQUNoSTtBQUNvQjtBQUN4QjtBQUN3QjtBQUNHO0FBQ3pCO0FBQ0k7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHlCQUF5QiwwREFBTztBQUNoQztBQUNBLHNCQUFzQiwwREFBTztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMERBQU87QUFDMUI7QUFDQTtBQUNBLElBQUksMERBQU87QUFDWDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQU87QUFDaEI7QUFDQSxhQUFhLDBEQUFPOztBQUVwQjtBQUNBLE1BQU0sMENBQU07QUFDWjtBQUNBLElBQUk7QUFDSixXQUFXLDBDQUFNO0FBQ2pCLElBQUk7QUFDSixXQUFXLDBDQUFNO0FBQ2pCO0FBQ0E7O0FBRUEsbUNBQW1DLCtEQUErRCx5Q0FBeUMsWUFBWSxpRkFBZSxtQkFBbUIsaUNBQWlDLGdCQUFnQixpRkFBZSxvQkFBb0IsMkRBQTJELE9BQU8seUNBQXlDLE9BQU8sNEZBQTBCO0FBQ3paLHlDQUF5Qyx3RUFBd0UsMENBQTBDLDhDQUE4QyxNQUFNLDRFQUE0RSxJQUFJLGVBQWUsWUFBWTs7QUFFMVQ7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNu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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCLGlCQUFpQix3REFBaUIsY0FBYyx3REFBaUI7QUFDbEgsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixFQUFFLHVEQUFnQjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0Isd0RBQXdELHdEQUFpQixjQUFjLHdEQUFpQjtBQUN6SixHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0IsaUJBQWlCLHdEQUFpQjtBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0I7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixFQUFFLHVEQUFnQixpQkFBaUIsd0RBQWlCO0FBQ25GLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0Isd0RBQXdELHdEQUFpQjtBQUMxSCxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0I7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixFQUFFLHVEQUFnQjtBQUNqRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUZBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSw4RUFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUIsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBLElBQUksaUZBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhFQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxH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QSw0Q0FBNEMsb0RBQU07O0FBRWxEO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxvREFBTTs7QUFFbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGtEQUFJO0FBQ3JCO0FBQ0EsUUFBUSxtREFBSyxDQUFDLG9EQUFNO0FBQ3BCLGFBQWEsb0RBQU07QUFDbkIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLGtEQUFJO0FBQ2pDO0FBQ0EsZ0JBQWdCLG9EQUFNO0FBQ3RCLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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QjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMERBQTBELG1GQUFpQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDZCQUE2QixtRkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTSwwQkFBMEIsbURBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHFCQUFxQixtRkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU0sMEJBQTBCLG9EQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMkJBQTJCLG1GQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTSwwQkFBMEIsb0RBQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw0QkFBNEIsbUZBQWlCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTSwwQkFBMEIsbURBQUs7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsbUZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsbUZBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlDQUFpQyxtRkFBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU0sMEJBQTBCLG9EQUFNO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxpQkFBaUI7QUFDekU7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0QixtRkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsbUZBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxtRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHdFQUF3RSxhQUFhO0FBQ3BHO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLG1GQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLG1GQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDhCQUE4QixtRkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixtRkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0NBQStDLG1GQUFpQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQixtREFBbUQ7QUFDbEc7QUFDQSwrREFBK0QsMEJBQTBCO0FBQ3pGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQ0FBMEMsbUZBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5Q0FBeUMsbUZBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHdCQUF3QjtBQUN2RjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMENBQTBDLG1GQUFpQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLG1GQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTSxvQ0FBb0Msc0RBQVEsQ0FBQyxvREFBTTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHlDQUF5QyxtRkFBaUI7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVMsbURBQW1EO0FBQzVFO0FBQ0EsK0RBQStELDBCQUEwQjtBQUN6RjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsZ0NBQWdDLG1GQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxtRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwwQ0FBMEMsbUZBQWlCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsOEJBQThCLG1GQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLHdCQUF3QixtRkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRCQUE0QixtRkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTSwwQkFBMEIsb0RBQU07QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG1GQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixvREFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGLGFBQWE7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGtCQUFrQjtBQUNqRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1GQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9EQUFNO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxtRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLDBEQUEwRCwyRkFBd0I7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixtRkFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsYUFBYTtBQUM1RiwyREFBMkQseUJBQXlCO0FBQ3BGO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxrQ0FBa0MsbUZBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsbUNBQW1DLG1GQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBTTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QixlQUFlLDBCQUEwQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QixlQUFlO0FBQy9ELG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUZBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsYUFBYTtBQUNsRSw2REFBNkQseUJBQXlCO0FBQ3RGO0FBQ0EsbUJBQW1CO0FBQ25CLGlCQUFpQjtBQUNqQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQkFBK0IsbUZBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxrQkFBa0I7QUFDakY7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxpQkFBaUI7QUFDakIsZUFBZTtBQUNmLCtFQUErRSxZQUFZO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUIsbUZBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTSwwQkFBMEIsbURBQUssQ0FBQyxvREFBTTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxtRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsMEJBQTBCO0FBQ3pGO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx5Q0FBeUMsbUZBQWlCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsK0RBQStELHNCQUFzQjtBQUNyRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EscUNBQXFDLG1GQUFpQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGFBQWE7QUFDNUY7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0QkFBNEI7QUFDM0Y7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJDQUEyQyxtRkFBaUI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw2QkFBNkI7QUFDNUY7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDRDQUE0QyxtRkFBaUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9EQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlDQUF5QztBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSw4Q0FBOEMsbUZBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSwrQ0FBK0MsbUZBQWlCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxxQ0FBcUMsbUZBQWlCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvREFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQyxtRkFBaUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdDQUFnQyxtRkFBaUI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxzQkFBc0IsbUZBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDBDQUEwQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCLG1GQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNkNBQTZDLG1GQUFpQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLCtCQUErQixtRkFBaUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1Q0FBdUMsbUZBQWlCO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9EQUFNLG9DQUFvQyxvREFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsMkJBQTJCLE1BQU07QUFDbkUsNkJBQTZCLEtBQUssaUNBQWlDO0FBQ25FO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1GQUFpQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywwQ0FBTTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvREFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLHFGQUFrQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLHFGQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1QkFBdUIsUUFBUTtBQUNqRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1GQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxRkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxxRkFBa0I7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxnQ0FBZ0MsbUZBQWlCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxvQ0FBb0MsbUZBQWlCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isb0RBQU07QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQSxvRkFBb0YsNkJBQTZCO0FBQ2pILGlDQUFpQyxpRkFBYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0IsNkNBQTZDLHVEQUFnQjtBQUM5RyxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0IsaUJBQWlCLHdEQUFpQjtBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCLGlCQUFpQix3REFBaUI7QUFDbkYsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixFQUFFLHVEQUFnQjtBQUNqRCxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0IsNkNBQTZDLHVEQUFnQjtBQUM5RztBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOEVBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw4RUFBWTs7QUFFeEM7QUFDQSxFQUFFLGlGQUFlO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUksaUZBQWU7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRSw4RUFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyx1REFBZ0I7QUFDbEQ7QUFDQTtBQUNBLG1GQUFtRiw2QkFBNkI7QUFDaEgsaUNBQWlDLGlGQUFjO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsRUFBRSx1REFBZ0IsNkNBQTZDLHVEQUFnQjtBQUM5RyxHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVksMERBQW1CLEVBQUUsdURBQWdCLGlCQUFpQix3REFBaUI7QUFDbkYsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLDBEQUFtQixFQUFFLHVEQUFnQjtBQUNqRDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOEVBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrREFBSTtBQUNyQixRQUFRLG9EQUFNO0FBQ2QsV0FBVyxzREFBUSxDQUFDLG9EQUFNO0FBQzFCLFdBQVcsc0RBQVEsQ0FBQyxvREFBTTtBQUMxQixtQkFBbUIsc0RBQVEsQ0FBQyxvREFBTTtBQUNsQyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlGQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhFQUFZO0FBQ2Q7QUFDQTtBQUNBLHNCQUFzQixxRkFBa0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLDBDQUFNO0FBQ2xEO0FBQ0EsVUFBVSxvREFBUTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QiwwREFBbUIsOERBQThELHNEQUFlLGdCQUFnQix3REFBaUI7QUFDeko7QUFDQSx1REFBZ0IsQ0FBQywwREFBbUIsRUFBRSx3REFBaUIsVUFBVSx1REFBZ0IseUJBQXlCLDBEQUFtQixDQUFDLHVEQUFnQixtQkFBbUIsc0RBQWUsbUJBQW1CLHdEQUFpQixjQUFjLHdEQUFpQjtBQUNuUDtBQUNBLHVEQUFnQixDQUFDLDBEQUFtQixFQUFFLHdEQUFpQiwyQ0FBMkMsMERBQW1CLENBQUMsdURBQWdCLDhCQUE4QiwwREFBbUIsRUFBRSx1REFBZ0IsQ0FBQywwREFBbUIsaUNBQWlDLHdEQUFpQixpQ0FBaUMsd0RBQWlCLCtCQUErQix3REFBaUIsU0FBUyxzREFBZSw4QkFBOEIsd0RBQWlCO0FBQ3hiO0FBQ0EsdURBQWdCLENBQUMsMERBQW1CLEVBQUUsd0RBQWlCLFdBQVcsd0RBQWlCLGFBQWEsd0RBQWlCLG1CQUFtQiwwREFBbUIsQ0FBQyx1REFBZ0IsMEJBQTBCLDBEQUFtQixFQUFFLHdEQUFpQixVQUFVLHdEQUFpQjtBQUNuUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxpRkFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDhFQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFGQUFrQiw0Q0FBNEMscUZBQWtCO0FBQ25HOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQyw0TUFBNE0sbUJBQW1CLGdCQUFnQiwySEFBMkgsd0JBQXdCLHFEQUFxRCxtTEFBbUwsbUNBQW1DLHlDQUF5Qyw4REFBOEQsZUFBZSxNQUFNLFNBQVMsU0FBUyxjQUFjLDRDQUE0Qyw4QkFBOEIscURBQXFELDZMQUE2TCw4Q0FBOEMsaURBQWlELGdCQUFnQixrQ0FBa0MsTUFBTSxTQUFTLDRDQUE0QyxjQUFjLFNBQVMsK0JBQStCLHFCQUFxQiwyQkFBMkIsd0JBQXdCLGdDQUFnQyx5Q0FBeUMsNEJBQTRCLHdEQUF3RCxjQUFjLEdBQUcsNEdBQTRHLG9LQUFvSyx3R0FBd0csNENBQTRDLHdEQUF3RCwyQ0FBMkMsbUNBQW1DLElBQUksS0FBSyxpREFBaUQsZ0RBQWdELDBEQUEwRCwrQkFBK0IsK0NBQStDLDRCQUE0Qix5RUFBTyxzR0FBc0cseUNBQXlDLG1CQUFtQix3Q0FBd0MsMkRBQTJELDRDQUE0QyxxQkFBcUIsaURBQWlELEtBQUssc0JBQXNCLHFCQUFxQixrQ0FBa0MscUNBQXFDLHdDQUF3QyxvREFBb0QsdUNBQXVDLEtBQUssMkpBQTJKLEtBQUssb0RBQW9ELDhCQUE4QixnQ0FBZ0MsNEVBQTRFLDZCQUE2QixtQ0FBbUMsdUJBQXVCLGlEQUFpRCxJQUFJLGlDQUFpQyxnQkFBZ0IsNkRBQTZELHNCQUFzQixtREFBbUQsMkJBQTJCLDBFQUEwRSx1Q0FBdUMsd0VBQXdFLDBDQUEwQywyRUFBMkUscUJBQXFCLCtDQUErQyxnQ0FBZ0Msc0dBQXNHLFNBQVMsMkNBQTJDLDZHQUE2RyxrREFBa0QseUVBQXlFLG9aQUFvWiwrREFBK0QsbUlBQW1JLHVCQUF1Qix3WEFBd1gsOEJBQThCLGNBQWMsbUJBQW1CLDZJQUE2SSxnQ0FBZ0MscUNBQXFDLHdFQUF3RSxnQ0FBZ0MscUJBQXFCLGdCQUFnQiw4REFBOEQsNEJBQTRCLGdCQUFnQiwrQ0FBK0MsMERBQTBELHlEQUF5RCwrQkFBK0IscUNBQXFDLE9BQU8sc0JBQXNCLHVGQUF1Rix3REFBd0QsNkJBQTZCLFNBQVMsc0JBQXNCLHdCQUF3QixTQUFTLGdDQUFnQyxxR0FBcUcscURBQXFELCtEQUErRCw0Q0FBNEMsaUtBQWlLLDhEQUE4RCwyR0FBMkcscUNBQXFDLG1QQUFtUCxtQ0FBbUMsU0FBUyxpQkFBaUIscUhBQXFILGNBQWMsd0hBQXdILG1EQUFtRCxzRkFBc0YsMEZBQTBGLGtEQUFrRCxJQUFJLGtIQUFrSCxjQUFjLHdDQUF3Qyw4QkFBOEIsbUNBQW1DLHFDQUFxQyx3Q0FBd0MseUNBQXlDLE9BQU8sWUFBWSxJQUFJLHNCQUFzQixvRUFBb0UsaUNBQWlDLGlEQUFpRCw2REFBNkQsaVZBQWlWLDBCQUEwQixnQkFBZ0IsZ0RBQWdELHVEQUF1RCxtQkFBbUIsNkRBQTZELGdDQUFnQyxvQkFBb0IsK0JBQStCLG9KQUFvSix5Q0FBeUMsUUFBUSxPQUFPLDJEQUEyRCxtREFBbUQsaUNBQWlDLDhGQUE4Riw4QkFBOEIsbUVBQW1FLHFFQUFxRSxxQkFBcUIscUVBQXFFLE9BQU8sNEVBQTRFLDBFQUEwRSx1Q0FBdUMseUNBQXlDLFFBQVEsT0FBTyxnQ0FBZ0MscUdBQXFHLDBCQUEwQixXQUFXLG9KQUFvSiwwREFBMEQsb0tBQW9LLGtEQUFrRCwrQ0FBK0MsdVJBQXVSLHdDQUF3Qyx5Q0FBeUMsUUFBUSxPQUFPLGdDQUFnQyx3SUFBd0kscUNBQXFDLHlDQUF5QyxRQUFRLE9BQU8sZ0NBQWdDLCtCQUErQiwrQkFBK0IsK0JBQStCLHlCQUF5Qix3QkFBd0IsbUJBQW1CLDJDQUEyQyx5RUFBeUUseUJBQXlCLHNFQUFzRSx5RUFBeUU7QUFDdHlYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVk7QUFDdkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUNBQWlDO0FBQzVDLFdBQVcsZ0JBQWdCO0FBQzNCLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsbUZBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRXNpRDtBQUN0aUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguYnJvd3Nlci5lc20uanM/MTU2ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2NsYXNzQ2FsbENoZWNrIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2snO1xuaW1wb3J0IF9jcmVhdGVDbGFzcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzJztcbmltcG9ydCB7IEJ1ZmZlciB9IGZyb20gJ2J1ZmZlcic7XG5pbXBvcnQgeyBlZDI1NTE5IH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9lZDI1NTE5JztcbmltcG9ydCBfdHlwZW9mIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mJztcbmltcG9ydCBfYXN5bmNUb0dlbmVyYXRvciBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3InO1xuaW1wb3J0IF9pbmhlcml0cyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzJztcbmltcG9ydCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4nO1xuaW1wb3J0IF9nZXRQcm90b3R5cGVPZiBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mJztcbmltcG9ydCBCTiBmcm9tICdibi5qcyc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4JztcbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHNlcmlhbGl6ZSwgZGVzZXJpYWxpemUsIGRlc2VyaWFsaXplVW5jaGVja2VkIH0gZnJvbSAnYm9yc2gnO1xuaW1wb3J0ICogYXMgQnVmZmVyTGF5b3V0IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyBibG9iIH0gZnJvbSAnQHNvbGFuYS9idWZmZXItbGF5b3V0JztcbmltcG9ydCBfc2xpY2VkVG9BcnJheSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL3NsaWNlZFRvQXJyYXknO1xuaW1wb3J0IHsgdG9CaWdJbnRMRSwgdG9CdWZmZXJMRSB9IGZyb20gJ2JpZ2ludC1idWZmZXInO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCBfdG9Db25zdW1hYmxlQXJyYXkgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheSc7XG5pbXBvcnQgX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvb2JqZWN0V2l0aG91dFByb3BlcnRpZXMnO1xuaW1wb3J0IHsgY29lcmNlLCBpbnN0YW5jZSwgc3RyaW5nLCB0dXBsZSwgbGl0ZXJhbCwgdW5rbm93biwgdHlwZSwgbnVtYmVyLCBhcnJheSwgbnVsbGFibGUsIG9wdGlvbmFsLCBib29sZWFuLCByZWNvcmQsIHVuaW9uLCBjcmVhdGUsIGFueSwgYXNzZXJ0IGFzIGFzc2VydCQxIH0gZnJvbSAnc3VwZXJzdHJ1Y3QnO1xuaW1wb3J0IFJwY0NsaWVudCBmcm9tICdqYXlzb24vbGliL2NsaWVudC9icm93c2VyJztcbmltcG9ydCBfd3JhcE5hdGl2ZVN1cGVyIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvd3JhcE5hdGl2ZVN1cGVyJztcbmltcG9ydCBfZ2V0IGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZ2V0JztcbmltcG9ydCBScGNXZWJTb2NrZXRDb21tb25DbGllbnQgZnJvbSAncnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50JztcbmltcG9ydCBjcmVhdGVScGMgZnJvbSAncnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50L3dlYnNvY2tldC5icm93c2VyJztcbmltcG9ydCB7IGtlY2Nha18yNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTMnO1xuaW1wb3J0IHsgc2VjcDI1NmsxIH0gZnJvbSAnQG5vYmxlL2N1cnZlcy9zZWNwMjU2azEnO1xuXG4vKipcbiAqIEEgNjQgYnl0ZSBzZWNyZXQga2V5LCB0aGUgZmlyc3QgMzIgYnl0ZXMgb2Ygd2hpY2ggaXMgdGhlXG4gKiBwcml2YXRlIHNjYWxhciBhbmQgdGhlIGxhc3QgMzIgYnl0ZXMgaXMgdGhlIHB1YmxpYyBrZXkuXG4gKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gKi9cblxuLyoqXG4gKiBFZDI1NTE5IEtleXBhaXJcbiAqL1xuXG52YXIgZ2VuZXJhdGVQcml2YXRlS2V5ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5O1xudmFyIGdlbmVyYXRlS2V5cGFpciA9IGZ1bmN0aW9uIGdlbmVyYXRlS2V5cGFpcigpIHtcbiAgdmFyIHByaXZhdGVTY2FsYXIgPSBlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAgdmFyIHB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgdmFyIHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgc2VjcmV0S2V5LnNldChwcml2YXRlU2NhbGFyKTtcbiAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICBzZWNyZXRLZXk6IHNlY3JldEtleVxuICB9O1xufTtcbnZhciBnZXRQdWJsaWNLZXkgPSBlZDI1NTE5LmdldFB1YmxpY0tleTtcbmZ1bmN0aW9uIGlzT25DdXJ2ZShwdWJsaWNLZXkpIHtcbiAgdHJ5IHtcbiAgICBlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUhleChwdWJsaWNLZXkpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChfdW51c2VkKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgc2lnbiA9IGZ1bmN0aW9uIHNpZ24obWVzc2FnZSwgc2VjcmV0S2V5KSB7XG4gIHJldHVybiBlZDI1NTE5LnNpZ24obWVzc2FnZSwgc2VjcmV0S2V5LnNsaWNlKDAsIDMyKSk7XG59O1xudmFyIHZlcmlmeSA9IGVkMjU1MTkudmVyaWZ5O1xuXG52YXIgdG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlcihhcnIpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQ0KERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDQoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQ0KCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cblxuLy8gQ2xhc3Mgd3JhcHBpbmcgYSBwbGFpbiBvYmplY3RcbnZhciBTdHJ1Y3QgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBTdHJ1Y3QocHJvcGVydGllcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdHJ1Y3QpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcHJvcGVydGllcyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFN0cnVjdCwgW3tcbiAgICBrZXk6IFwiZW5jb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuY29kZSgpIHtcbiAgICAgIHJldHVybiBCdWZmZXIuZnJvbShzZXJpYWxpemUoU09MQU5BX1NDSEVNQSwgdGhpcykpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImRlY29kZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGUoZGF0YSkge1xuICAgICAgcmV0dXJuIGRlc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVVbmNoZWNrZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlVW5jaGVja2VkKGRhdGEpIHtcbiAgICAgIHJldHVybiBkZXNlcmlhbGl6ZVVuY2hlY2tlZChTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0cnVjdDtcbn0oKTtcblxuLy8gQ2xhc3MgcmVwcmVzZW50aW5nIGEgUnVzdC1jb21wYXRpYmxlIGVudW0sIHNpbmNlIGVudW1zIGFyZSBvbmx5IHN0cmluZ3Mgb3Jcbi8vIG51bWJlcnMgaW4gcHVyZSBKU1xudmFyIEVudW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHJ1Y3QpIHtcbiAgX2luaGVyaXRzKEVudW0sIF9TdHJ1Y3QpO1xuICB2YXIgX3N1cGVyID0gX2NyZWF0ZVN1cGVyJDQoRW51bSk7XG4gIGZ1bmN0aW9uIEVudW0ocHJvcGVydGllcykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRW51bSk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgICBfdGhpc1tcImVudW1cIl0gPSAnJztcbiAgICBpZiAoT2JqZWN0LmtleXMocHJvcGVydGllcykubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VudW0gY2FuIG9ubHkgdGFrZSBzaW5nbGUgdmFsdWUnKTtcbiAgICB9XG4gICAgT2JqZWN0LmtleXMocHJvcGVydGllcykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgIF90aGlzW1wiZW51bVwiXSA9IGtleTtcbiAgICB9KTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhFbnVtKTtcbn0oU3RydWN0KTtcbnZhciBTT0xBTkFfU0NIRU1BID0gbmV3IE1hcCgpO1xuXG52YXIgX1N5bWJvbCR0b1N0cmluZ1RhZztcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUkNSgpIHsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lJDUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG5mdW5jdGlvbiBfY3JlYXRlU3VwZXIkMyhEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQzKCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMygpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbi8qKlxuICogTWF4aW11bSBsZW5ndGggb2YgZGVyaXZlZCBwdWJrZXkgc2VlZFxuICovXG52YXIgTUFYX1NFRURfTEVOR1RIID0gMzI7XG5cbi8qKlxuICogU2l6ZSBvZiBwdWJsaWMga2V5IGluIGJ5dGVzXG4gKi9cbnZhciBQVUJMSUNfS0VZX0xFTkdUSCA9IDMyO1xuXG4vKipcbiAqIFZhbHVlIHRvIGJlIGNvbnZlcnRlZCBpbnRvIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIEpTT04gb2JqZWN0IHJlcHJlc2VudGF0aW9uIG9mIFB1YmxpY0tleSBjbGFzc1xuICovXG5cbmZ1bmN0aW9uIGlzUHVibGljS2V5RGF0YSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUuX2JuICE9PSB1bmRlZmluZWQ7XG59XG5cbi8vIGxvY2FsIGNvdW50ZXIgdXNlZCBieSBQdWJsaWNLZXkudW5pcXVlKClcbnZhciB1bmlxdWVQdWJsaWNLZXlDb3VudGVyID0gMTtcblxuLyoqXG4gKiBBIHB1YmxpYyBrZXlcbiAqL1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbnZhciBQdWJsaWNLZXkgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9TdHJ1Y3QpIHtcbiAgX2luaGVyaXRzKFB1YmxpY0tleSwgX1N0cnVjdCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMyhQdWJsaWNLZXkpO1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFB1YmxpY0tleSBvYmplY3RcbiAgICogQHBhcmFtIHZhbHVlIGVkMjU1MTkgcHVibGljIGtleSBhcyBidWZmZXIgb3IgYmFzZS01OCBlbmNvZGVkIHN0cmluZ1xuICAgKi9cbiAgZnVuY3Rpb24gUHVibGljS2V5KHZhbHVlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQdWJsaWNLZXkpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywge30pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBfdGhpcy5fYm4gPSB2b2lkIDA7XG4gICAgaWYgKGlzUHVibGljS2V5RGF0YSh2YWx1ZSkpIHtcbiAgICAgIF90aGlzLl9ibiA9IHZhbHVlLl9ibjtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gYXNzdW1lIGJhc2UgNTggZW5jb2RpbmcgYnkgZGVmYXVsdFxuICAgICAgICB2YXIgZGVjb2RlZCA9IGJzNTguZGVjb2RlKHZhbHVlKTtcbiAgICAgICAgaWYgKGRlY29kZWQubGVuZ3RoICE9IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwdWJsaWMga2V5IGlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLl9ibiA9IG5ldyBCTihkZWNvZGVkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIF90aGlzLl9ibiA9IG5ldyBCTih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAoX3RoaXMuX2JuLmJ5dGVMZW5ndGgoKSA+IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcHVibGljIGtleSBpbnB1dFwiKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSB1bmlxdWUgUHVibGljS2V5IGZvciB0ZXN0cyBhbmQgYmVuY2htYXJrcyB1c2luZyBhIGNvdW50ZXJcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhQdWJsaWNLZXksIFt7XG4gICAga2V5OiBcImVxdWFsc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0d28gcHVibGljS2V5cyBhcmUgZXF1YWxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbHMocHVibGljS2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fYm4uZXEocHVibGljS2V5Ll9ibik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9CYXNlNThcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CYXNlNTgoKSB7XG4gICAgICByZXR1cm4gYnM1OC5lbmNvZGUodGhpcy50b0J5dGVzKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInRvQnl0ZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CeXRlcygpIHtcbiAgICAgIHZhciBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIEJ1ZmZlciByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleSBpbiBiaWcgZW5kaWFuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidG9CdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9CdWZmZXIoKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX2JuLnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgICBpZiAoYi5sZW5ndGggPT09IFBVQkxJQ19LRVlfTEVOR1RIKSB7XG4gICAgICAgIHJldHVybiBiO1xuICAgICAgfVxuICAgICAgdmFyIHplcm9QYWQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICAgICAgYi5jb3B5KHplcm9QYWQsIDMyIC0gYi5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHplcm9QYWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBfU3ltYm9sJHRvU3RyaW5nVGFnLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIFwiUHVibGljS2V5KFwiLmNvbmNhdCh0aGlzLnRvU3RyaW5nKCksIFwiKVwiKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJhc2UtNTggcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0b1N0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQmFzZTU4KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVyaXZlIGEgcHVibGljIGtleSBmcm9tIGFub3RoZXIga2V5LCBhIHNlZWQsIGFuZCBhIHByb2dyYW0gSUQuXG4gICAgICogVGhlIHByb2dyYW0gSUQgd2lsbCBhbHNvIHNlcnZlIGFzIHRoZSBvd25lciBvZiB0aGUgcHVibGljIGtleSwgZ2l2aW5nXG4gICAgICogaXQgcGVybWlzc2lvbiB0byB3cml0ZSBkYXRhIHRvIHRoZSBhY2NvdW50LlxuICAgICAqL1xuICAgIC8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXdhaXQgKi9cbiAgfV0sIFt7XG4gICAga2V5OiBcInVuaXF1ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmlxdWUoKSB7XG4gICAgICB2YXIga2V5ID0gbmV3IFB1YmxpY0tleSh1bmlxdWVQdWJsaWNLZXlDb3VudGVyKTtcbiAgICAgIHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGtleS50b0J1ZmZlcigpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWZhdWx0IHB1YmxpYyBrZXkgdmFsdWUuIFRoZSBiYXNlNTgtZW5jb2RlZCBzdHJpbmcgcmVwcmVzZW50YXRpb24gaXMgYWxsIG9uZXMgKGFzIHNlZW4gYmVsb3cpXG4gICAgICogVGhlIHVuZGVybHlpbmcgQk4gbnVtYmVyIGlzIDMyIGJ5dGVzIHRoYXQgYXJlIGFsbCB6ZXJvc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVdpdGhTZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY3JlYXRlV2l0aFNlZWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkNSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShmcm9tUHVibGljS2V5LCBzZWVkLCBwcm9ncmFtSWQpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciwgcHVibGljS2V5Qnl0ZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbZnJvbVB1YmxpY0tleS50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbShzZWVkKSwgcHJvZ3JhbUlkLnRvQnVmZmVyKCldKTtcbiAgICAgICAgICAgICAgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKSk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGNyZWF0ZVdpdGhTZWVkKF94LCBfeDIsIF94Mykge1xuICAgICAgICByZXR1cm4gX2NyZWF0ZVdpdGhTZWVkLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlV2l0aFNlZWQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRGVyaXZlIGEgcHJvZ3JhbSBhZGRyZXNzIGZyb20gc2VlZHMgYW5kIGEgcHJvZ3JhbSBJRC5cbiAgICAgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSByZXF1aXJlLWF3YWl0ICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSB7XG4gICAgICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgc2VlZHMuZm9yRWFjaChmdW5jdGlvbiAoc2VlZCkge1xuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPiBNQVhfU0VFRF9MRU5HVEgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiTWF4IHNlZWQgbGVuZ3RoIGV4Y2VlZGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgdG9CdWZmZXIoc2VlZCldKTtcbiAgICAgIH0pO1xuICAgICAgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbYnVmZmVyLCBwcm9ncmFtSWQudG9CdWZmZXIoKSwgQnVmZmVyLmZyb20oJ1Byb2dyYW1EZXJpdmVkQWRkcmVzcycpXSk7XG4gICAgICB2YXIgcHVibGljS2V5Qnl0ZXMgPSBzaGEyNTYoYnVmZmVyKTtcbiAgICAgIGlmIChpc09uQ3VydmUocHVibGljS2V5Qnl0ZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgc2VlZHMsIGFkZHJlc3MgbXVzdCBmYWxsIG9mZiB0aGUgY3VydmVcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShwdWJsaWNLZXlCeXRlcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXN5bmMgdmVyc2lvbiBvZiBjcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmNcbiAgICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAgICovXG4gICAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVByb2dyYW1BZGRyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfY3JlYXRlUHJvZ3JhbUFkZHJlc3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkNSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQ1KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMiQoX2NvbnRleHQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcInJldHVyblwiLCB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKSk7XG4gICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gY3JlYXRlUHJvZ3JhbUFkZHJlc3MoX3g0LCBfeDUpIHtcbiAgICAgICAgcmV0dXJuIF9jcmVhdGVQcm9ncmFtQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVByb2dyYW1BZGRyZXNzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZpbmQgYSB2YWxpZCBwcm9ncmFtIGFkZHJlc3NcbiAgICAgKlxuICAgICAqIFZhbGlkIHByb2dyYW0gYWRkcmVzc2VzIG11c3QgZmFsbCBvZmYgdGhlIGVkMjU1MTkgY3VydmUuICBUaGlzIGZ1bmN0aW9uXG4gICAgICogaXRlcmF0ZXMgYSBub25jZSB1bnRpbCBpdCBmaW5kcyBvbmUgdGhhdCB3aGVuIGNvbWJpbmVkIHdpdGggdGhlIHNlZWRzXG4gICAgICogcmVzdWx0cyBpbiBhIHZhbGlkIHByb2dyYW0gYWRkcmVzcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgICAgdmFyIG5vbmNlID0gMjU1O1xuICAgICAgdmFyIGFkZHJlc3M7XG4gICAgICB3aGlsZSAobm9uY2UgIT0gMCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBzZWVkc1dpdGhOb25jZSA9IHNlZWRzLmNvbmNhdChCdWZmZXIuZnJvbShbbm9uY2VdKSk7XG4gICAgICAgICAgYWRkcmVzcyA9IHRoaXMuY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzV2l0aE5vbmNlLCBwcm9ncmFtSWQpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgVHlwZUVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vbmNlLS07XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFthZGRyZXNzLCBub25jZV07XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gZmluZCBhIHZpYWJsZSBwcm9ncmFtIGFkZHJlc3Mgbm9uY2VcIik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXN5bmMgdmVyc2lvbiBvZiBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAgICogRm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmN9IGluc3RlYWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmaW5kUHJvZ3JhbUFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9maW5kUHJvZ3JhbUFkZHJlc3MgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkNSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQ1KCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMyQoX2NvbnRleHQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLmFicnVwdChcInJldHVyblwiLCB0aGlzLmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkpO1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGZpbmRQcm9ncmFtQWRkcmVzcyhfeDYsIF94Nykge1xuICAgICAgICByZXR1cm4gX2ZpbmRQcm9ncmFtQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmRQcm9ncmFtQWRkcmVzcztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBDaGVjayB0aGF0IGEgcHVia2V5IGlzIG9uIHRoZSBlZDI1NTE5IGN1cnZlLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzT25DdXJ2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc09uQ3VydmUkMShwdWJrZXlEYXRhKSB7XG4gICAgICB2YXIgcHVia2V5ID0gbmV3IFB1YmxpY0tleShwdWJrZXlEYXRhKTtcbiAgICAgIHJldHVybiBpc09uQ3VydmUocHVia2V5LnRvQnl0ZXMoKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBQdWJsaWNLZXk7XG59KFN0cnVjdCk7XG5QdWJsaWNLZXlbXCJkZWZhdWx0XCJdID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblNPTEFOQV9TQ0hFTUEuc2V0KFB1YmxpY0tleSwge1xuICBraW5kOiAnc3RydWN0JyxcbiAgZmllbGRzOiBbWydfYm4nLCAndTI1NiddXVxufSk7XG5cbi8qKlxuICogQW4gYWNjb3VudCBrZXkgcGFpciAocHVibGljIGFuZCBzZWNyZXQga2V5cykuXG4gKlxuICogQGRlcHJlY2F0ZWQgc2luY2UgdjEuMTAuMCwgcGxlYXNlIHVzZSB7QGxpbmsgS2V5cGFpcn0gaW5zdGVhZC5cbiAqL1xudmFyIEFjY291bnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IEFjY291bnQgb2JqZWN0XG4gICAqXG4gICAqIElmIHRoZSBzZWNyZXRLZXkgcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZCBhIG5ldyBrZXkgcGFpciBpcyByYW5kb21seVxuICAgKiBjcmVhdGVkIGZvciB0aGUgYWNjb3VudFxuICAgKlxuICAgKiBAcGFyYW0gc2VjcmV0S2V5IFNlY3JldCBrZXkgZm9yIHRoZSBhY2NvdW50XG4gICAqL1xuICBmdW5jdGlvbiBBY2NvdW50KHNlY3JldEtleSkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvdW50KTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcHVibGljS2V5ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zZWNyZXRLZXkgPSB2b2lkIDA7XG4gICAgaWYgKHNlY3JldEtleSkge1xuICAgICAgdmFyIHNlY3JldEtleUJ1ZmZlciA9IHRvQnVmZmVyKHNlY3JldEtleSk7XG4gICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMzIsIDY0KTtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgwLCAzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHRvQnVmZmVyKGdlbmVyYXRlUHJpdmF0ZUtleSgpKTtcbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHRvQnVmZmVyKGdldFB1YmxpY0tleSh0aGlzLl9zZWNyZXRLZXkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMgYWNjb3VudFxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEFjY291bnQsIFt7XG4gICAga2V5OiBcInB1YmxpY0tleVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fcHVibGljS2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgKip1bmVuY3J5cHRlZCoqIHNlY3JldCBrZXkgZm9yIHRoaXMgYWNjb3VudC4gVGhlIGZpcnN0IDMyIGJ5dGVzXG4gICAgICogaXMgdGhlIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAgICAgKiBSZWFkIG1vcmU6IGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93YXJuZXIvMjAxMS8xMS8yOS9lZDI1NTE5LWtleXMvXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VjcmV0S2V5XCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5fc2VjcmV0S2V5LCB0aGlzLl9wdWJsaWNLZXldLCA2NCk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBY2NvdW50O1xufSgpO1xuXG52YXIgQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdCUEZMb2FkZXIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogTWF4aW11bSBvdmVyLXRoZS13aXJlIHNpemUgb2YgYSBUcmFuc2FjdGlvblxuICpcbiAqIDEyODAgaXMgSVB2NiBtaW5pbXVtIE1UVVxuICogNDAgYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIElQdjYgaGVhZGVyXG4gKiA4IGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBmcmFnbWVudCBoZWFkZXJcbiAqL1xudmFyIFBBQ0tFVF9EQVRBX1NJWkUgPSAxMjgwIC0gNDAgLSA4O1xudmFyIFZFUlNJT05fUFJFRklYX01BU0sgPSAweDdmO1xudmFyIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMgPSA2NDtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyJDIoRGVyaXZlZCkgeyB2YXIgaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCA9IF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QkMigpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9IF9nZXRQcm90b3R5cGVPZihEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gX2dldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yOyByZXN1bHQgPSBSZWZsZWN0LmNvbnN0cnVjdChTdXBlciwgYXJndW1lbnRzLCBOZXdUYXJnZXQpOyB9IGVsc2UgeyByZXN1bHQgPSBTdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpOyB9IHJldHVybiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0aGlzLCByZXN1bHQpOyB9OyB9XG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDIoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxudmFyIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IsIF9FcnJvcik7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIkMihUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IpO1xuICBmdW5jdGlvbiBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3Ioc2lnbmF0dXJlKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3IpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgXCJTaWduYXR1cmUgXCIuY29uY2F0KHNpZ25hdHVyZSwgXCIgaGFzIGV4cGlyZWQ6IGJsb2NrIGhlaWdodCBleGNlZWRlZC5cIikpO1xuICAgIF90aGlzLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICBfdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yKTtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yJ1xufSk7XG52YXIgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IyKSB7XG4gIF9pbmhlcml0cyhUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IsIF9FcnJvcjIpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlciQyKFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcik7XG4gIGZ1bmN0aW9uIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcihzaWduYXR1cmUsIHRpbWVvdXRTZWNvbmRzKSB7XG4gICAgdmFyIF90aGlzMjtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yKTtcbiAgICBfdGhpczIgPSBfc3VwZXIyLmNhbGwodGhpcywgXCJUcmFuc2FjdGlvbiB3YXMgbm90IGNvbmZpcm1lZCBpbiBcIi5jb25jYXQodGltZW91dFNlY29uZHMudG9GaXhlZCgyKSwgXCIgc2Vjb25kcy4gSXQgaXMgXCIpICsgJ3Vua25vd24gaWYgaXQgc3VjY2VlZGVkIG9yIGZhaWxlZC4gQ2hlY2sgc2lnbmF0dXJlICcgKyBcIlwiLmNvbmNhdChzaWduYXR1cmUsIFwiIHVzaW5nIHRoZSBTb2xhbmEgRXhwbG9yZXIgb3IgQ0xJIHRvb2xzLlwiKSk7XG4gICAgX3RoaXMyLnNpZ25hdHVyZSA9IHZvaWQgMDtcbiAgICBfdGhpczIuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICAgIHJldHVybiBfdGhpczI7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IpO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IucHJvdG90eXBlLCAnbmFtZScsIHtcbiAgdmFsdWU6ICdUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3InXG59KTtcbnZhciBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yMykge1xuICBfaW5oZXJpdHMoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IsIF9FcnJvcjMpO1xuICB2YXIgX3N1cGVyMyA9IF9jcmVhdGVTdXBlciQyKFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKTtcbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKSB7XG4gICAgdmFyIF90aGlzMztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IpO1xuICAgIF90aGlzMyA9IF9zdXBlcjMuY2FsbCh0aGlzLCBcIlNpZ25hdHVyZSBcIi5jb25jYXQoc2lnbmF0dXJlLCBcIiBoYXMgZXhwaXJlZDogdGhlIG5vbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5cIikpO1xuICAgIF90aGlzMy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgX3RoaXMzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICByZXR1cm4gX3RoaXMzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IpO1xufSggLyojX19QVVJFX18qL193cmFwTmF0aXZlU3VwZXIoRXJyb3IpKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yJ1xufSk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUobywgYWxsb3dBcnJheUxpa2UpIHsgdmFyIGl0ID0gdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcIkBAaXRlcmF0b3JcIl07IGlmICghaXQpIHsgaWYgKEFycmF5LmlzQXJyYXkobykgfHwgKGl0ID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDUobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ1KG8sIG1pbkxlbikgeyBpZiAoIW8pIHJldHVybjsgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkNShvLCBtaW5MZW4pOyB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7IGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7IGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pOyBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDUobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkkNShhcnIsIGxlbikgeyBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDsgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldOyByZXR1cm4gYXJyMjsgfVxudmFyIE1lc3NhZ2VBY2NvdW50S2V5cyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cywgYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXNzYWdlQWNjb3VudEtleXMpO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSBzdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhNZXNzYWdlQWNjb3VudEtleXMsIFt7XG4gICAga2V5OiBcImtleVNlZ21lbnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtleVNlZ21lbnRzKCkge1xuICAgICAgdmFyIGtleVNlZ21lbnRzID0gW3RoaXMuc3RhdGljQWNjb3VudEtleXNdO1xuICAgICAgaWYgKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAgICBrZXlTZWdtZW50cy5wdXNoKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZSk7XG4gICAgICAgIGtleVNlZ21lbnRzLnB1c2godGhpcy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlTZWdtZW50cztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldChpbmRleCkge1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDUodGhpcy5rZXlTZWdtZW50cygpKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBrZXlTZWdtZW50ID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgaWYgKGluZGV4IDwga2V5U2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlTZWdtZW50W2luZGV4XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaW5kZXggLT0ga2V5U2VnbWVudC5sZW5ndGg7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvci5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImxlbmd0aFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5U2VnbWVudHMoKS5mbGF0KCkubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21waWxlSW5zdHJ1Y3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGVJbnN0cnVjdGlvbnMoaW5zdHJ1Y3Rpb25zKSB7XG4gICAgICAvLyBCYWlsIGVhcmx5IGlmIGFueSBhY2NvdW50IGluZGV4ZXMgd291bGQgb3ZlcmZsb3cgYSB1OFxuICAgICAgdmFyIFU4X01BWCA9IDI1NTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IFU4X01BWCArIDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBY2NvdW50IGluZGV4IG92ZXJmbG93IGVuY291bnRlcmVkIGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgICAgfVxuICAgICAgdmFyIGtleUluZGV4TWFwID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXksIGluZGV4KSB7XG4gICAgICAgIGtleUluZGV4TWFwLnNldChrZXkudG9CYXNlNTgoKSwgaW5kZXgpO1xuICAgICAgfSk7XG4gICAgICB2YXIgZmluZEtleUluZGV4ID0gZnVuY3Rpb24gZmluZEtleUluZGV4KGtleSkge1xuICAgICAgICB2YXIga2V5SW5kZXggPSBrZXlJbmRleE1hcC5nZXQoa2V5LnRvQmFzZTU4KCkpO1xuICAgICAgICBpZiAoa2V5SW5kZXggPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKCdFbmNvdW50ZXJlZCBhbiB1bmtub3duIGluc3RydWN0aW9uIGFjY291bnQga2V5IGR1cmluZyBjb21waWxhdGlvbicpO1xuICAgICAgICByZXR1cm4ga2V5SW5kZXg7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIGluc3RydWN0aW9ucy5tYXAoZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGZpbmRLZXlJbmRleChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpLFxuICAgICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpbnN0cnVjdGlvbi5rZXlzLm1hcChmdW5jdGlvbiAobWV0YSkge1xuICAgICAgICAgICAgcmV0dXJuIGZpbmRLZXlJbmRleChtZXRhLnB1YmtleSk7XG4gICAgICAgICAgfSksXG4gICAgICAgICAgZGF0YTogaW5zdHJ1Y3Rpb24uZGF0YVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNZXNzYWdlQWNjb3VudEtleXM7XG59KCk7XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHB1YmxpYyBrZXlcbiAqL1xudmFyIHB1YmxpY0tleSA9IGZ1bmN0aW9uIHB1YmxpY0tleSgpIHtcbiAgdmFyIHByb3BlcnR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAncHVibGljS2V5JztcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDMyLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYSBzaWduYXR1cmVcbiAqL1xudmFyIHNpZ25hdHVyZSA9IGZ1bmN0aW9uIHNpZ25hdHVyZSgpIHtcbiAgdmFyIHByb3BlcnR5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnc2lnbmF0dXJlJztcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5ibG9iKDY0LCBwcm9wZXJ0eSk7XG59O1xuLyoqXG4gKiBMYXlvdXQgZm9yIGEgUnVzdCBTdHJpbmcgdHlwZVxuICovXG52YXIgcnVzdFN0cmluZyA9IGZ1bmN0aW9uIHJ1c3RTdHJpbmcoKSB7XG4gIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3N0cmluZyc7XG4gIHZhciByc2wgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignbGVuZ3RoUGFkZGluZycpLCBCdWZmZXJMYXlvdXQuYmxvYihCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnY2hhcnMnKV0sIHByb3BlcnR5KTtcbiAgdmFyIF9kZWNvZGUgPSByc2wuZGVjb2RlLmJpbmQocnNsKTtcbiAgdmFyIF9lbmNvZGUgPSByc2wuZW5jb2RlLmJpbmQocnNsKTtcbiAgdmFyIHJzbFNoaW0gPSByc2w7XG4gIHJzbFNoaW0uZGVjb2RlID0gZnVuY3Rpb24gKGIsIG9mZnNldCkge1xuICAgIHZhciBkYXRhID0gX2RlY29kZShiLCBvZmZzZXQpO1xuICAgIHJldHVybiBkYXRhWydjaGFycyddLnRvU3RyaW5nKCk7XG4gIH07XG4gIHJzbFNoaW0uZW5jb2RlID0gZnVuY3Rpb24gKHN0ciwgYiwgb2Zmc2V0KSB7XG4gICAgdmFyIGRhdGEgPSB7XG4gICAgICBjaGFyczogQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpXG4gICAgfTtcbiAgICByZXR1cm4gX2VuY29kZShkYXRhLCBiLCBvZmZzZXQpO1xuICB9O1xuICByc2xTaGltLmFsbG9jID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHJldHVybiBCdWZmZXJMYXlvdXQudTMyKCkuc3BhbiArIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICsgQnVmZmVyLmZyb20oc3RyLCAndXRmOCcpLmxlbmd0aDtcbiAgfTtcbiAgcmV0dXJuIHJzbFNoaW07XG59O1xuXG4vKipcbiAqIExheW91dCBmb3IgYW4gQXV0aG9yaXplZCBvYmplY3RcbiAqL1xudmFyIGF1dGhvcml6ZWQgPSBmdW5jdGlvbiBhdXRob3JpemVkKCkge1xuICB2YXIgcHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdhdXRob3JpemVkJztcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnc3Rha2VyJyksIHB1YmxpY0tleSgnd2l0aGRyYXdlcicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgTG9ja3VwIG9iamVjdFxuICovXG52YXIgbG9ja3VwID0gZnVuY3Rpb24gbG9ja3VwKCkge1xuICB2YXIgcHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICdsb2NrdXAnO1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm5zNjQoJ3VuaXhUaW1lc3RhbXAnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnY3VzdG9kaWFuJyldLCBwcm9wZXJ0eSk7XG59O1xuXG4vKipcbiAqICBMYXlvdXQgZm9yIGEgVm90ZUluaXQgb2JqZWN0XG4gKi9cbnZhciB2b3RlSW5pdCA9IGZ1bmN0aW9uIHZvdGVJbml0KCkge1xuICB2YXIgcHJvcGVydHkgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6ICd2b3RlSW5pdCc7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ25vZGVQdWJrZXknKSwgcHVibGljS2V5KCdhdXRob3JpemVkVm90ZXInKSwgcHVibGljS2V5KCdhdXRob3JpemVkV2l0aGRyYXdlcicpLCBCdWZmZXJMYXlvdXQudTgoJ2NvbW1pc3Npb24nKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogIExheW91dCBmb3IgYSBWb3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzIG9iamVjdFxuICovXG52YXIgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyA9IGZ1bmN0aW9uIHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MoKSB7XG4gIHZhciBwcm9wZXJ0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3ZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MnO1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyksIHB1YmxpY0tleSgnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleScpLCBydXN0U3RyaW5nKCdjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQnKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyldLCBwcm9wZXJ0eSk7XG59O1xuZnVuY3Rpb24gZ2V0QWxsb2ModHlwZSwgZmllbGRzKSB7XG4gIHZhciBnZXRJdGVtQWxsb2MgPSBmdW5jdGlvbiBnZXRJdGVtQWxsb2MoaXRlbSkge1xuICAgIGlmIChpdGVtLnNwYW4gPj0gMCkge1xuICAgICAgcmV0dXJuIGl0ZW0uc3BhbjtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpdGVtLmFsbG9jID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlbS5hbGxvYyhmaWVsZHNbaXRlbS5wcm9wZXJ0eV0pO1xuICAgIH0gZWxzZSBpZiAoJ2NvdW50JyBpbiBpdGVtICYmICdlbGVtZW50TGF5b3V0JyBpbiBpdGVtKSB7XG4gICAgICB2YXIgZmllbGQgPSBmaWVsZHNbaXRlbS5wcm9wZXJ0eV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmxlbmd0aCAqIGdldEl0ZW1BbGxvYyhpdGVtLmVsZW1lbnRMYXlvdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2ZpZWxkcycgaW4gaXRlbSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGBTdHJ1Y3R1cmVgIHdob3NlIHNpemUgbmVlZHMgdG8gYmUgcmVjdXJzaXZlbHkgbWVhc3VyZWQuXG4gICAgICByZXR1cm4gZ2V0QWxsb2Moe1xuICAgICAgICBsYXlvdXQ6IGl0ZW1cbiAgICAgIH0sIGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfVxuICAgIC8vIENvdWxkbid0IGRldGVybWluZSBhbGxvY2F0ZWQgc2l6ZSBvZiBsYXlvdXRcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgdmFyIGFsbG9jID0gMDtcbiAgdHlwZS5sYXlvdXQuZmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICBhbGxvYyArPSBnZXRJdGVtQWxsb2MoaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWxsb2M7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUxlbmd0aChieXRlcykge1xuICB2YXIgbGVuID0gMDtcbiAgdmFyIHNpemUgPSAwO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIGVsZW0gPSBieXRlcy5zaGlmdCgpO1xuICAgIGxlbiB8PSAoZWxlbSAmIDB4N2YpIDw8IHNpemUgKiA3O1xuICAgIHNpemUgKz0gMTtcbiAgICBpZiAoKGVsZW0gJiAweDgwKSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBsZW47XG59XG5mdW5jdGlvbiBlbmNvZGVMZW5ndGgoYnl0ZXMsIGxlbikge1xuICB2YXIgcmVtX2xlbiA9IGxlbjtcbiAgZm9yICg7Oykge1xuICAgIHZhciBlbGVtID0gcmVtX2xlbiAmIDB4N2Y7XG4gICAgcmVtX2xlbiA+Pj0gNztcbiAgICBpZiAocmVtX2xlbiA9PSAwKSB7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW0gfD0gMHg4MDtcbiAgICAgIGJ5dGVzLnB1c2goZWxlbSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2VydCAoY29uZGl0aW9uLCBtZXNzYWdlKSB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQ0KG8sIGFsbG93QXJyYXlMaWtlKSB7IHZhciBpdCA9IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdIHx8IG9bXCJAQGl0ZXJhdG9yXCJdOyBpZiAoIWl0KSB7IGlmIChBcnJheS5pc0FycmF5KG8pIHx8IChpdCA9IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSQ0KG8pKSB8fCBhbGxvd0FycmF5TGlrZSAmJiBvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgeyBpZiAoaXQpIG8gPSBpdDsgdmFyIGkgPSAwOyB2YXIgRiA9IGZ1bmN0aW9uIEYoKSB7fTsgcmV0dXJuIHsgczogRiwgbjogZnVuY3Rpb24gbigpIHsgaWYgKGkgPj0gby5sZW5ndGgpIHJldHVybiB7IGRvbmU6IHRydWUgfTsgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvW2krK10gfTsgfSwgZTogZnVuY3Rpb24gZShfZSkgeyB0aHJvdyBfZTsgfSwgZjogRiB9OyB9IHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gaXRlcmF0ZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTsgfSB2YXIgbm9ybWFsQ29tcGxldGlvbiA9IHRydWUsIGRpZEVyciA9IGZhbHNlLCBlcnI7IHJldHVybiB7IHM6IGZ1bmN0aW9uIHMoKSB7IGl0ID0gaXQuY2FsbChvKTsgfSwgbjogZnVuY3Rpb24gbigpIHsgdmFyIHN0ZXAgPSBpdC5uZXh0KCk7IG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7IHJldHVybiBzdGVwOyB9LCBlOiBmdW5jdGlvbiBlKF9lMikgeyBkaWRFcnIgPSB0cnVlOyBlcnIgPSBfZTI7IH0sIGY6IGZ1bmN0aW9uIGYoKSB7IHRyeSB7IGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdFtcInJldHVyblwiXSAhPSBudWxsKSBpdFtcInJldHVyblwiXSgpOyB9IGZpbmFsbHkgeyBpZiAoZGlkRXJyKSB0aHJvdyBlcnI7IH0gfSB9OyB9XG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkNChvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5JDQobywgbWluTGVuKTsgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpOyBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lOyBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTsgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQ0KG8sIG1pbkxlbik7IH1cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5JDQoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbnZhciBDb21waWxlZEtleXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBDb21waWxlZEtleXMocGF5ZXIsIGtleU1ldGFNYXApIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcGlsZWRLZXlzKTtcbiAgICB0aGlzLnBheWVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyID0gcGF5ZXI7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0ga2V5TWV0YU1hcDtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQ29tcGlsZWRLZXlzLCBbe1xuICAgIGtleTogXCJnZXRNZXNzYWdlQ29tcG9uZW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRNZXNzYWdlQ29tcG9uZW50cygpIHtcbiAgICAgIHZhciBtYXBFbnRyaWVzID0gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCkpO1xuICAgICAgYXNzZXJ0KG1hcEVudHJpZXMubGVuZ3RoIDw9IDI1NiwgJ01heCBzdGF0aWMgYWNjb3VudCBrZXlzIGxlbmd0aCBleGNlZWRlZCcpO1xuICAgICAgdmFyIHdyaXRhYmxlU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBfcmVmMiA9IF9zbGljZWRUb0FycmF5KF9yZWYsIDIpLFxuICAgICAgICAgIG1ldGEgPSBfcmVmMlsxXTtcbiAgICAgICAgcmV0dXJuIG1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlO1xuICAgICAgfSk7XG4gICAgICB2YXIgcmVhZG9ubHlTaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICAgIHZhciBfcmVmNCA9IF9zbGljZWRUb0FycmF5KF9yZWYzLCAyKSxcbiAgICAgICAgICBtZXRhID0gX3JlZjRbMV07XG4gICAgICAgIHJldHVybiBtZXRhLmlzU2lnbmVyICYmICFtZXRhLmlzV3JpdGFibGU7XG4gICAgICB9KTtcbiAgICAgIHZhciB3cml0YWJsZU5vblNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjUpIHtcbiAgICAgICAgdmFyIF9yZWY2ID0gX3NsaWNlZFRvQXJyYXkoX3JlZjUsIDIpLFxuICAgICAgICAgIG1ldGEgPSBfcmVmNlsxXTtcbiAgICAgICAgcmV0dXJuICFtZXRhLmlzU2lnbmVyICYmIG1ldGEuaXNXcml0YWJsZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHJlYWRvbmx5Tm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmNykge1xuICAgICAgICB2YXIgX3JlZjggPSBfc2xpY2VkVG9BcnJheShfcmVmNywgMiksXG4gICAgICAgICAgbWV0YSA9IF9yZWY4WzFdO1xuICAgICAgICByZXR1cm4gIW1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZTtcbiAgICAgIH0pO1xuICAgICAgdmFyIGhlYWRlciA9IHtcbiAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiB3cml0YWJsZVNpZ25lcnMubGVuZ3RoICsgcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiByZWFkb25seU5vblNpZ25lcnMubGVuZ3RoXG4gICAgICB9O1xuXG4gICAgICAvLyBzYW5pdHkgY2hlY2tzXG4gICAgICB7XG4gICAgICAgIGFzc2VydCh3cml0YWJsZVNpZ25lcnMubGVuZ3RoID4gMCwgJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5Jyk7XG4gICAgICAgIHZhciBfd3JpdGFibGVTaWduZXJzJCA9IF9zbGljZWRUb0FycmF5KHdyaXRhYmxlU2lnbmVyc1swXSwgMSksXG4gICAgICAgICAgcGF5ZXJBZGRyZXNzID0gX3dyaXRhYmxlU2lnbmVycyRbMF07XG4gICAgICAgIGFzc2VydChwYXllckFkZHJlc3MgPT09IHRoaXMucGF5ZXIudG9CYXNlNTgoKSwgJ0V4cGVjdGVkIGZpcnN0IHdyaXRhYmxlIHNpZ25lciBrZXkgdG8gYmUgdGhlIGZlZSBwYXllcicpO1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRpY0FjY291bnRLZXlzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh3cml0YWJsZVNpZ25lcnMubWFwKGZ1bmN0aW9uIChfcmVmOSkge1xuICAgICAgICB2YXIgX3JlZjEwID0gX3NsaWNlZFRvQXJyYXkoX3JlZjksIDEpLFxuICAgICAgICAgIGFkZHJlc3MgPSBfcmVmMTBbMF07XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgfSkpLCBfdG9Db25zdW1hYmxlQXJyYXkocmVhZG9ubHlTaWduZXJzLm1hcChmdW5jdGlvbiAoX3JlZjExKSB7XG4gICAgICAgIHZhciBfcmVmMTIgPSBfc2xpY2VkVG9BcnJheShfcmVmMTEsIDEpLFxuICAgICAgICAgIGFkZHJlc3MgPSBfcmVmMTJbMF07XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgfSkpLCBfdG9Db25zdW1hYmxlQXJyYXkod3JpdGFibGVOb25TaWduZXJzLm1hcChmdW5jdGlvbiAoX3JlZjEzKSB7XG4gICAgICAgIHZhciBfcmVmMTQgPSBfc2xpY2VkVG9BcnJheShfcmVmMTMsIDEpLFxuICAgICAgICAgIGFkZHJlc3MgPSBfcmVmMTRbMF07XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgfSkpLCBfdG9Db25zdW1hYmxlQXJyYXkocmVhZG9ubHlOb25TaWduZXJzLm1hcChmdW5jdGlvbiAoX3JlZjE1KSB7XG4gICAgICAgIHZhciBfcmVmMTYgPSBfc2xpY2VkVG9BcnJheShfcmVmMTUsIDEpLFxuICAgICAgICAgIGFkZHJlc3MgPSBfcmVmMTZbMF07XG4gICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgfSkpKTtcbiAgICAgIHJldHVybiBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dHJhY3RUYWJsZUxvb2t1cFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBleHRyYWN0VGFibGVMb29rdXAobG9va3VwVGFibGUpIHtcbiAgICAgIHZhciBfdGhpcyRkcmFpbktleXNGb3VuZEkgPSB0aGlzLmRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZS5zdGF0ZS5hZGRyZXNzZXMsIGZ1bmN0aW9uIChrZXlNZXRhKSB7XG4gICAgICAgICAgcmV0dXJuICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiBrZXlNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgIH0pLFxuICAgICAgICBfdGhpcyRkcmFpbktleXNGb3VuZEkyID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZHJhaW5LZXlzRm91bmRJLCAyKSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzID0gX3RoaXMkZHJhaW5LZXlzRm91bmRJMlswXSxcbiAgICAgICAgZHJhaW5lZFdyaXRhYmxlS2V5cyA9IF90aGlzJGRyYWluS2V5c0ZvdW5kSTJbMV07XG4gICAgICB2YXIgX3RoaXMkZHJhaW5LZXlzRm91bmRJMyA9IHRoaXMuZHJhaW5LZXlzRm91bmRJbkxvb2t1cFRhYmxlKGxvb2t1cFRhYmxlLnN0YXRlLmFkZHJlc3NlcywgZnVuY3Rpb24gKGtleU1ldGEpIHtcbiAgICAgICAgICByZXR1cm4gIWtleU1ldGEuaXNTaWduZXIgJiYgIWtleU1ldGEuaXNJbnZva2VkICYmICFrZXlNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgIH0pLFxuICAgICAgICBfdGhpcyRkcmFpbktleXNGb3VuZEk0ID0gX3NsaWNlZFRvQXJyYXkoX3RoaXMkZHJhaW5LZXlzRm91bmRJMywgMiksXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlcyA9IF90aGlzJGRyYWluS2V5c0ZvdW5kSTRbMF0sXG4gICAgICAgIGRyYWluZWRSZWFkb25seUtleXMgPSBfdGhpcyRkcmFpbktleXNGb3VuZEk0WzFdO1xuXG4gICAgICAvLyBEb24ndCBleHRyYWN0IGxvb2t1cCBpZiBubyBrZXlzIHdlcmUgZm91bmRcbiAgICAgIGlmICh3cml0YWJsZUluZGV4ZXMubGVuZ3RoID09PSAwICYmIHJlYWRvbmx5SW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFt7XG4gICAgICAgIGFjY291bnRLZXk6IGxvb2t1cFRhYmxlLmtleSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzOiB3cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlczogcmVhZG9ubHlJbmRleGVzXG4gICAgICB9LCB7XG4gICAgICAgIHdyaXRhYmxlOiBkcmFpbmVkV3JpdGFibGVLZXlzLFxuICAgICAgICByZWFkb25seTogZHJhaW5lZFJlYWRvbmx5S2V5c1xuICAgICAgfV07XG4gICAgfVxuXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICB9LCB7XG4gICAga2V5OiBcImRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGVFbnRyaWVzLCBrZXlNZXRhRmlsdGVyKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgdmFyIGxvb2t1cFRhYmxlSW5kZXhlcyA9IG5ldyBBcnJheSgpO1xuICAgICAgdmFyIGRyYWluZWRLZXlzID0gbmV3IEFycmF5KCk7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNCh0aGlzLmtleU1ldGFNYXAuZW50cmllcygpKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgX3N0ZXAkdmFsdWUgPSBfc2xpY2VkVG9BcnJheShfc3RlcC52YWx1ZSwgMiksXG4gICAgICAgICAgICBhZGRyZXNzID0gX3N0ZXAkdmFsdWVbMF0sXG4gICAgICAgICAgICBrZXlNZXRhID0gX3N0ZXAkdmFsdWVbMV07XG4gICAgICAgICAgaWYgKGtleU1ldGFGaWx0ZXIoa2V5TWV0YSkpIHtcbiAgICAgICAgICAgIHZhciBrZXkgPSBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgICAgICAgdmFyIGxvb2t1cFRhYmxlSW5kZXggPSBsb29rdXBUYWJsZUVudHJpZXMuZmluZEluZGV4KGZ1bmN0aW9uIChlbnRyeSkge1xuICAgICAgICAgICAgICByZXR1cm4gZW50cnkuZXF1YWxzKGtleSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChsb29rdXBUYWJsZUluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgYXNzZXJ0KGxvb2t1cFRhYmxlSW5kZXggPCAyNTYsICdNYXggbG9va3VwIHRhYmxlIGluZGV4IGV4Y2VlZGVkJyk7XG4gICAgICAgICAgICAgIGxvb2t1cFRhYmxlSW5kZXhlcy5wdXNoKGxvb2t1cFRhYmxlSW5kZXgpO1xuICAgICAgICAgICAgICBkcmFpbmVkS2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICAgIF90aGlzLmtleU1ldGFNYXBbXCJkZWxldGVcIl0oYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbbG9va3VwVGFibGVJbmRleGVzLCBkcmFpbmVkS2V5c107XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiY29tcGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21waWxlKGluc3RydWN0aW9ucywgcGF5ZXIpIHtcbiAgICAgIHZhciBrZXlNZXRhTWFwID0gbmV3IE1hcCgpO1xuICAgICAgdmFyIGdldE9ySW5zZXJ0RGVmYXVsdCA9IGZ1bmN0aW9uIGdldE9ySW5zZXJ0RGVmYXVsdChwdWJrZXkpIHtcbiAgICAgICAgdmFyIGFkZHJlc3MgPSBwdWJrZXkudG9CYXNlNTgoKTtcbiAgICAgICAgdmFyIGtleU1ldGEgPSBrZXlNZXRhTWFwLmdldChhZGRyZXNzKTtcbiAgICAgICAgaWYgKGtleU1ldGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGtleU1ldGEgPSB7XG4gICAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIGlzSW52b2tlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICAgIGtleU1ldGFNYXAuc2V0KGFkZHJlc3MsIGtleU1ldGEpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBrZXlNZXRhO1xuICAgICAgfTtcbiAgICAgIHZhciBwYXllcktleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQocGF5ZXIpO1xuICAgICAgcGF5ZXJLZXlNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgIHBheWVyS2V5TWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChpbnN0cnVjdGlvbnMpLFxuICAgICAgICBfc3RlcDI7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpeCA9IF9zdGVwMi52YWx1ZTtcbiAgICAgICAgICBnZXRPckluc2VydERlZmF1bHQoaXgucHJvZ3JhbUlkKS5pc0ludm9rZWQgPSB0cnVlO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IzID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkNChpeC5rZXlzKSxcbiAgICAgICAgICAgIF9zdGVwMztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGFjY291bnRNZXRhID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgX2tleU1ldGEgPSBnZXRPckluc2VydERlZmF1bHQoYWNjb3VudE1ldGEucHVia2V5KTtcbiAgICAgICAgICAgICAgX2tleU1ldGEuaXNTaWduZXIgfHwgKF9rZXlNZXRhLmlzU2lnbmVyID0gYWNjb3VudE1ldGEuaXNTaWduZXIpO1xuICAgICAgICAgICAgICBfa2V5TWV0YS5pc1dyaXRhYmxlIHx8IChfa2V5TWV0YS5pc1dyaXRhYmxlID0gYWNjb3VudE1ldGEuaXNXcml0YWJsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgX2l0ZXJhdG9yMi5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IyLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgQ29tcGlsZWRLZXlzKHBheWVyLCBrZXlNZXRhTWFwKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbXBpbGVkS2V5cztcbn0oKTtcblxuLyoqXG4gKiBBbiBpbnN0cnVjdGlvbiB0byBleGVjdXRlIGJ5IGEgcHJvZ3JhbVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9ncmFtSWRJbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYWNjb3VudHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhXG4gKi9cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBpbnN0cnVjdGlvbnMgdG8gYmUgcHJvY2Vzc2VkIGF0b21pY2FsbHlcbiAqL1xudmFyIE1lc3NhZ2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBNZXNzYWdlKGFyZ3MpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBNZXNzYWdlKTtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gYXJncy5hY2NvdW50S2V5cy5tYXAoZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGFjY291bnQpO1xuICAgIH0pO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYXJncy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLmluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpeCkge1xuICAgICAgcmV0dXJuIF90aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChpeC5wcm9ncmFtSWRJbmRleCwgX3RoaXMuYWNjb3VudEtleXNbaXgucHJvZ3JhbUlkSW5kZXhdKTtcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoTWVzc2FnZSwgW3tcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzdGF0aWNBY2NvdW50S2V5c1wiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbXBpbGVkSW5zdHJ1Y3Rpb25zXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGZ1bmN0aW9uIChpeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaXguZGF0YSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRyZXNzVGFibGVMb29rdXBzXCIsXG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEFjY291bnRLZXlzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEFjY291bnRLZXlzKCkge1xuICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQWNjb3VudFNpZ25lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FjY291bnRTaWduZXIoaW5kZXgpIHtcbiAgICAgIHJldHVybiBpbmRleCA8IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaXNBY2NvdW50V3JpdGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBY2NvdW50V3JpdGFibGUoaW5kZXgpIHtcbiAgICAgIHZhciBudW1TaWduZWRBY2NvdW50cyA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICAgIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgICAgdmFyIHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgICAgdmFyIG51bVVuc2lnbmVkQWNjb3VudHMgPSB0aGlzLmFjY291bnRLZXlzLmxlbmd0aCAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgICB2YXIgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzUHJvZ3JhbUlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzUHJvZ3JhbUlkKGluZGV4KSB7XG4gICAgICByZXR1cm4gdGhpcy5pbmRleFRvUHJvZ3JhbUlkcy5oYXMoaW5kZXgpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9ncmFtSWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2dyYW1JZHMoKSB7XG4gICAgICByZXR1cm4gX3RvQ29uc3VtYWJsZUFycmF5KHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMudmFsdWVzKCkpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub25Qcm9ncmFtSWRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vblByb2dyYW1JZHMoKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzLmZpbHRlcihmdW5jdGlvbiAoXywgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuICFfdGhpczIuaXNQcm9ncmFtSWQoaW5kZXgpO1xuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgbnVtS2V5cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoO1xuICAgICAgdmFyIGtleUNvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoa2V5Q291bnQsIG51bUtleXMpO1xuICAgICAgdmFyIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdmFyIGFjY291bnRzID0gaW5zdHJ1Y3Rpb24uYWNjb3VudHMsXG4gICAgICAgICAgcHJvZ3JhbUlkSW5kZXggPSBpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleDtcbiAgICAgICAgdmFyIGRhdGEgPSBBcnJheS5mcm9tKGJzNTguZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpKTtcbiAgICAgICAgdmFyIGtleUluZGljZXNDb3VudCA9IFtdO1xuICAgICAgICBlbmNvZGVMZW5ndGgoa2V5SW5kaWNlc0NvdW50LCBhY2NvdW50cy5sZW5ndGgpO1xuICAgICAgICB2YXIgZGF0YUNvdW50ID0gW107XG4gICAgICAgIGVuY29kZUxlbmd0aChkYXRhQ291bnQsIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBwcm9ncmFtSWRJbmRleDogcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgICAga2V5SW5kaWNlc0NvdW50OiBCdWZmZXIuZnJvbShrZXlJbmRpY2VzQ291bnQpLFxuICAgICAgICAgIGtleUluZGljZXM6IGFjY291bnRzLFxuICAgICAgICAgIGRhdGFMZW5ndGg6IEJ1ZmZlci5mcm9tKGRhdGFDb3VudCksXG4gICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICB2YXIgaW5zdHJ1Y3Rpb25Db3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGluc3RydWN0aW9uQ291bnQsIGluc3RydWN0aW9ucy5sZW5ndGgpO1xuICAgICAgdmFyIGluc3RydWN0aW9uQnVmZmVyID0gQnVmZmVyLmFsbG9jKFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgICAgQnVmZmVyLmZyb20oaW5zdHJ1Y3Rpb25Db3VudCkuY29weShpbnN0cnVjdGlvbkJ1ZmZlcik7XG4gICAgICB2YXIgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGggPSBpbnN0cnVjdGlvbkNvdW50Lmxlbmd0aDtcbiAgICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICB2YXIgaW5zdHJ1Y3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3Byb2dyYW1JZEluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmtleUluZGljZXNDb3VudC5sZW5ndGgsICdrZXlJbmRpY2VzQ291bnQnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2tleUluZGV4JyksIGluc3RydWN0aW9uLmtleUluZGljZXMubGVuZ3RoLCAna2V5SW5kaWNlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5kYXRhTGVuZ3RoLmxlbmd0aCwgJ2RhdGFMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ3VzZXJkYXR1bScpLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCwgJ2RhdGEnKV0pO1xuICAgICAgICB2YXIgbGVuZ3RoID0gaW5zdHJ1Y3Rpb25MYXlvdXQuZW5jb2RlKGluc3RydWN0aW9uLCBpbnN0cnVjdGlvbkJ1ZmZlciwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgICBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCArPSBsZW5ndGg7XG4gICAgICB9KTtcbiAgICAgIGluc3RydWN0aW9uQnVmZmVyID0gaW5zdHJ1Y3Rpb25CdWZmZXIuc2xpY2UoMCwgaW5zdHJ1Y3Rpb25CdWZmZXJMZW5ndGgpO1xuICAgICAgdmFyIHNpZ25EYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYigxLCAnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC5ibG9iKGtleUNvdW50Lmxlbmd0aCwgJ2tleUNvdW50JyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCdrZXknKSwgbnVtS2V5cywgJ2tleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKV0pO1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0ge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IEJ1ZmZlci5mcm9tKFt0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXNdKSxcbiAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHNdKSxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBCdWZmZXIuZnJvbShbdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXSksXG4gICAgICAgIGtleUNvdW50OiBCdWZmZXIuZnJvbShrZXlDb3VudCksXG4gICAgICAgIGtleXM6IHRoaXMuYWNjb3VudEtleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gdG9CdWZmZXIoa2V5LnRvQnl0ZXMoKSk7XG4gICAgICAgIH0pLFxuICAgICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKVxuICAgICAgfTtcbiAgICAgIHZhciBzaWduRGF0YSA9IEJ1ZmZlci5hbGxvYygyMDQ4KTtcbiAgICAgIHZhciBsZW5ndGggPSBzaWduRGF0YUxheW91dC5lbmNvZGUodHJhbnNhY3Rpb24sIHNpZ25EYXRhKTtcbiAgICAgIGluc3RydWN0aW9uQnVmZmVyLmNvcHkoc2lnbkRhdGEsIGxlbmd0aCk7XG4gICAgICByZXR1cm4gc2lnbkRhdGEuc2xpY2UoMCwgbGVuZ3RoICsgaW5zdHJ1Y3Rpb25CdWZmZXIubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBjb21waWxlZCBtZXNzYWdlIGludG8gYSBNZXNzYWdlIG9iamVjdC5cbiAgICAgKi9cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShhcmdzKSB7XG4gICAgICB2YXIgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgICAgdmFyIF9jb21waWxlZEtleXMkZ2V0TWVzcyA9IGNvbXBpbGVkS2V5cy5nZXRNZXNzYWdlQ29tcG9uZW50cygpLFxuICAgICAgICBfY29tcGlsZWRLZXlzJGdldE1lc3MyID0gX3NsaWNlZFRvQXJyYXkoX2NvbXBpbGVkS2V5cyRnZXRNZXNzLCAyKSxcbiAgICAgICAgaGVhZGVyID0gX2NvbXBpbGVkS2V5cyRnZXRNZXNzMlswXSxcbiAgICAgICAgc3RhdGljQWNjb3VudEtleXMgPSBfY29tcGlsZWRLZXlzJGdldE1lc3MyWzFdO1xuICAgICAgdmFyIGFjY291bnRLZXlzID0gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyhzdGF0aWNBY2NvdW50S2V5cyk7XG4gICAgICB2YXIgaW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucykubWFwKGZ1bmN0aW9uIChpeCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb2dyYW1JZEluZGV4OiBpeC5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgICBhY2NvdW50czogaXguYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgICAgZGF0YTogYnM1OC5lbmNvZGUoaXguZGF0YSlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIGFjY291bnRLZXlzOiBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgICAgcmVjZW50QmxvY2toYXNoOiBhcmdzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiBpbnN0cnVjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oYnVmZmVyKSB7XG4gICAgICAvLyBTbGljZSB1cCB3aXJlIGRhdGFcbiAgICAgIHZhciBieXRlQXJyYXkgPSBfdG9Db25zdW1hYmxlQXJyYXkoYnVmZmVyKTtcbiAgICAgIHZhciBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBieXRlQXJyYXkuc2hpZnQoKTtcbiAgICAgIGlmIChudW1SZXF1aXJlZFNpZ25hdHVyZXMgIT09IChudW1SZXF1aXJlZFNpZ25hdHVyZXMgJiBWRVJTSU9OX1BSRUZJWF9NQVNLKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnNpb25lZCBtZXNzYWdlcyBtdXN0IGJlIGRlc2VyaWFsaXplZCB3aXRoIFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUoKScpO1xuICAgICAgfVxuICAgICAgdmFyIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSBieXRlQXJyYXkuc2hpZnQoKTtcbiAgICAgIHZhciBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSBieXRlQXJyYXkuc2hpZnQoKTtcbiAgICAgIHZhciBhY2NvdW50Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIHZhciBhY2NvdW50S2V5cyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NvdW50Q291bnQ7IGkrKykge1xuICAgICAgICB2YXIgYWNjb3VudCA9IGJ5dGVBcnJheS5zbGljZSgwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgICAgIGJ5dGVBcnJheSA9IGJ5dGVBcnJheS5zbGljZShQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgICAgIGFjY291bnRLZXlzLnB1c2gobmV3IFB1YmxpY0tleShCdWZmZXIuZnJvbShhY2NvdW50KSkpO1xuICAgICAgfVxuICAgICAgdmFyIHJlY2VudEJsb2NraGFzaCA9IGJ5dGVBcnJheS5zbGljZSgwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgICBieXRlQXJyYXkgPSBieXRlQXJyYXkuc2xpY2UoUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgdmFyIGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIHZhciBpbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBpbnN0cnVjdGlvbkNvdW50OyBfaSsrKSB7XG4gICAgICAgIHZhciBwcm9ncmFtSWRJbmRleCA9IGJ5dGVBcnJheS5zaGlmdCgpO1xuICAgICAgICB2YXIgX2FjY291bnRDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgICB2YXIgYWNjb3VudHMgPSBieXRlQXJyYXkuc2xpY2UoMCwgX2FjY291bnRDb3VudCk7XG4gICAgICAgIGJ5dGVBcnJheSA9IGJ5dGVBcnJheS5zbGljZShfYWNjb3VudENvdW50KTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgICAgdmFyIGRhdGFTbGljZSA9IGJ5dGVBcnJheS5zbGljZSgwLCBkYXRhTGVuZ3RoKTtcbiAgICAgICAgdmFyIGRhdGEgPSBiczU4LmVuY29kZShCdWZmZXIuZnJvbShkYXRhU2xpY2UpKTtcbiAgICAgICAgYnl0ZUFycmF5ID0gYnl0ZUFycmF5LnNsaWNlKGRhdGFMZW5ndGgpO1xuICAgICAgICBpbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IHByb2dyYW1JZEluZGV4LFxuICAgICAgICAgIGFjY291bnRzOiBhY2NvdW50cyxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIG1lc3NhZ2VBcmdzID0ge1xuICAgICAgICBoZWFkZXI6IHtcbiAgICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IG51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBudW1SZWFkb25seVNpZ25lZEFjY291bnRzLFxuICAgICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzXG4gICAgICAgIH0sXG4gICAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20ocmVjZW50QmxvY2toYXNoKSksXG4gICAgICAgIGFjY291bnRLZXlzOiBhY2NvdW50S2V5cyxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiBpbnN0cnVjdGlvbnNcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IE1lc3NhZ2UobWVzc2FnZUFyZ3MpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTWVzc2FnZTtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMyhvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDMobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQzKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMyhvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQzKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5cbi8qKlxuICogTWVzc2FnZSBjb25zdHJ1Y3RvciBhcmd1bWVudHNcbiAqL1xuXG52YXIgTWVzc2FnZVYwID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTWVzc2FnZVYwKGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWVzc2FnZVYwKTtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzID0gdm9pZCAwO1xuICAgIHRoaXMuaGVhZGVyID0gYXJncy5oZWFkZXI7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IGFyZ3Muc3RhdGljQWNjb3VudEtleXM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgICB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYXJncy5jb21waWxlZEluc3RydWN0aW9ucztcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSBhcmdzLmFkZHJlc3NUYWJsZUxvb2t1cHM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE1lc3NhZ2VWMCwgW3tcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcIm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHZhciBjb3VudCA9IDA7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyh0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGxvb2t1cCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGNvdW50ICs9IGxvb2t1cC5yZWFkb25seUluZGV4ZXMubGVuZ3RoICsgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWNjb3VudEtleXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QWNjb3VudEtleXMoYXJncykge1xuICAgICAgdmFyIGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgICBpZiAoYXJncyAmJiAnYWNjb3VudEtleXNGcm9tTG9va3VwcycgaW4gYXJncyAmJiBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtQWNjb3VudEtleXNGcm9tTG9va3VwcyAhPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUubGVuZ3RoICsgYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5Lmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBvZiBhIG1pc21hdGNoIGluIHRoZSBudW1iZXIgb2YgYWNjb3VudCBrZXlzIGZyb20gbG9va3VwcycpO1xuICAgICAgICB9XG4gICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MgJiYgJ2FkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzJyBpbiBhcmdzICYmIGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMpIHtcbiAgICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHRoaXMucmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGdldCBhY2NvdW50IGtleXMgYmVjYXVzZSBhZGRyZXNzIHRhYmxlIGxvb2t1cHMgd2VyZSBub3QgcmVzb2x2ZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHRoaXMuc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJpc0FjY291bnRTaWduZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBY2NvdW50U2lnbmVyKGluZGV4KSB7XG4gICAgICByZXR1cm4gaW5kZXggPCB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImlzQWNjb3VudFdyaXRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGlzQWNjb3VudFdyaXRhYmxlKGluZGV4KSB7XG4gICAgICB2YXIgbnVtU2lnbmVkQWNjb3VudHMgPSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gICAgICB2YXIgbnVtU3RhdGljQWNjb3VudEtleXMgPSB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aDtcbiAgICAgIGlmIChpbmRleCA+PSBudW1TdGF0aWNBY2NvdW50S2V5cykge1xuICAgICAgICB2YXIgbG9va3VwQWNjb3VudEtleXNJbmRleCA9IGluZGV4IC0gbnVtU3RhdGljQWNjb3VudEtleXM7XG4gICAgICAgIHZhciBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzID0gdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLnJlZHVjZShmdW5jdGlvbiAoY291bnQsIGxvb2t1cCkge1xuICAgICAgICAgIHJldHVybiBjb3VudCArIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgcmV0dXJuIGxvb2t1cEFjY291bnRLZXlzSW5kZXggPCBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzO1xuICAgICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgICAgdmFyIHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgICAgdmFyIG51bVVuc2lnbmVkQWNjb3VudHMgPSBudW1TdGF0aWNBY2NvdW50S2V5cyAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgICB2YXIgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgICAgcmV0dXJuIHVuc2lnbmVkQWNjb3VudEluZGV4IDwgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICB2YXIgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHtcbiAgICAgICAgd3JpdGFibGU6IFtdLFxuICAgICAgICByZWFkb25seTogW11cbiAgICAgIH07XG4gICAgICB2YXIgX2l0ZXJhdG9yMiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDModGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSxcbiAgICAgICAgX3N0ZXAyO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgdmFyIHRhYmxlTG9va3VwID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgIHZhciB0YWJsZUFjY291bnQgPSBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cy5maW5kKGZ1bmN0aW9uIChhY2NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudC5rZXkuZXF1YWxzKHRhYmxlTG9va3VwLmFjY291bnRLZXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghdGFibGVBY2NvdW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBhY2NvdW50IGZvciB0YWJsZSBrZXkgXCIuY29uY2F0KHRhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgX2l0ZXJhdG9yMyA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDModGFibGVMb29rdXAud3JpdGFibGVJbmRleGVzKSxcbiAgICAgICAgICAgIF9zdGVwMztcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IzLnMoKTsgIShfc3RlcDMgPSBfaXRlcmF0b3IzLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGluZGV4ID0gX3N0ZXAzLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggXCIuY29uY2F0KGluZGV4LCBcIiBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSBcIikuY29uY2F0KHRhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IzLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMy5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBfaXRlcmF0b3I0ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyh0YWJsZUxvb2t1cC5yZWFkb25seUluZGV4ZXMpLFxuICAgICAgICAgICAgX3N0ZXA0O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKF9pdGVyYXRvcjQucygpOyAhKF9zdGVwNCA9IF9pdGVyYXRvcjQubigpKS5kb25lOykge1xuICAgICAgICAgICAgICB2YXIgX2luZGV4ID0gX3N0ZXA0LnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoX2luZGV4IDwgdGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5LnB1c2godGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlc1tfaW5kZXhdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCBcIi5jb25jYXQoX2luZGV4LCBcIiBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSBcIikuY29uY2F0KHRhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3I0LmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yNC5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjIucygpOyAhKF9zdGVwMiA9IF9pdGVyYXRvcjIubigpKS5kb25lOykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XG4gICAgICB2YXIgZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgsIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoKTtcbiAgICAgIHZhciBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zID0gdGhpcy5zZXJpYWxpemVJbnN0cnVjdGlvbnMoKTtcbiAgICAgIHZhciBlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoLCB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgICB2YXIgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSB0aGlzLnNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKTtcbiAgICAgIHZhciBlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgsIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcy5sZW5ndGgpO1xuICAgICAgdmFyIG1lc3NhZ2VMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ3ByZWZpeCcpLCBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ251bVJlcXVpcmVkU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMnKV0sICdoZWFkZXInKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFN0YXRpY0FjY291bnRLZXlzTGVuZ3RoLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoLCAnc3RhdGljQWNjb3VudEtleXMnKSwgcHVibGljS2V5KCdyZWNlbnRCbG9ja2hhc2gnKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZEluc3RydWN0aW9uc0xlbmd0aC5sZW5ndGgsICdpbnN0cnVjdGlvbnNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEluc3RydWN0aW9ucy5sZW5ndGgsICdzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLmxlbmd0aCwgJ2FkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LmJsb2Ioc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoLCAnc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMnKV0pO1xuICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgICB2YXIgTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYID0gMSA8PCA3O1xuICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlTGVuZ3RoID0gbWVzc2FnZUxheW91dC5lbmNvZGUoe1xuICAgICAgICBwcmVmaXg6IE1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCxcbiAgICAgICAgaGVhZGVyOiB0aGlzLmhlYWRlcixcbiAgICAgICAgc3RhdGljQWNjb3VudEtleXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCksXG4gICAgICAgIHN0YXRpY0FjY291bnRLZXlzOiB0aGlzLnN0YXRpY0FjY291bnRLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgcmV0dXJuIGtleS50b0J5dGVzKCk7XG4gICAgICAgIH0pLFxuICAgICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoKSxcbiAgICAgICAgc2VyaWFsaXplZEluc3RydWN0aW9uczogc2VyaWFsaXplZEluc3RydWN0aW9ucyxcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZEFkZHJlc3NUYWJsZUxvb2t1cHNMZW5ndGgpLFxuICAgICAgICBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwczogc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICAgIH0sIHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkTWVzc2FnZS5zbGljZSgwLCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZUluc3RydWN0aW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVJbnN0cnVjdGlvbnMoKSB7XG4gICAgICB2YXIgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgICB2YXIgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgICAgdmFyIF9pdGVyYXRvcjUgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQzKHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMpLFxuICAgICAgICBfc3RlcDU7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9pdGVyYXRvcjUucygpOyAhKF9zdGVwNSA9IF9pdGVyYXRvcjUubigpKS5kb25lOykge1xuICAgICAgICAgIHZhciBpbnN0cnVjdGlvbiA9IF9zdGVwNS52YWx1ZTtcbiAgICAgICAgICB2YXIgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoLCBpbnN0cnVjdGlvbi5hY2NvdW50S2V5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgIHZhciBlbmNvZGVkRGF0YUxlbmd0aCA9IEFycmF5KCk7XG4gICAgICAgICAgZW5jb2RlTGVuZ3RoKGVuY29kZWREYXRhTGVuZ3RoLCBpbnN0cnVjdGlvbi5kYXRhLmxlbmd0aCk7XG4gICAgICAgICAgdmFyIGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCwgJ2FjY291bnRLZXlJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWREYXRhTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWREYXRhTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBpbnN0cnVjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGluc3RydWN0aW9uLnByb2dyYW1JZEluZGV4LFxuICAgICAgICAgICAgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICAgICAgZW5jb2RlZERhdGFMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWREYXRhTGVuZ3RoKSxcbiAgICAgICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgICAgICB9LCBzZXJpYWxpemVkSW5zdHJ1Y3Rpb25zLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjUuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNS5mKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VyaWFsaXplZEluc3RydWN0aW9ucy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2VyaWFsaXplQWRkcmVzc1RhYmxlTG9va3Vwc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWRMZW5ndGggPSAwO1xuICAgICAgdmFyIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IFVpbnQ4QXJyYXkoUEFDS0VUX0RBVEFfU0laRSk7XG4gICAgICB2YXIgX2l0ZXJhdG9yNiA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDModGhpcy5hZGRyZXNzVGFibGVMb29rdXBzKSxcbiAgICAgICAgX3N0ZXA2O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I2LnMoKTsgIShfc3RlcDYgPSBfaXRlcmF0b3I2Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgbG9va3VwID0gX3N0ZXA2LnZhbHVlO1xuICAgICAgICAgIHZhciBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgIHZhciBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgICAgIHZhciBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2FjY291bnRLZXknKSwgQnVmZmVyTGF5b3V0LmJsb2IoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGxvb2t1cC53cml0YWJsZUluZGV4ZXMubGVuZ3RoLCAnd3JpdGFibGVJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAucmVhZG9ubHlJbmRleGVzLmxlbmd0aCwgJ3JlYWRvbmx5SW5kZXhlcycpXSk7XG4gICAgICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgICAgIGFjY291bnRLZXk6IGxvb2t1cC5hY2NvdW50S2V5LnRvQnl0ZXMoKSxcbiAgICAgICAgICAgIGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICAgICAgd3JpdGFibGVJbmRleGVzOiBsb29rdXAud3JpdGFibGVJbmRleGVzLFxuICAgICAgICAgICAgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aDogbmV3IFVpbnQ4QXJyYXkoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCksXG4gICAgICAgICAgICByZWFkb25seUluZGV4ZXM6IGxvb2t1cC5yZWFkb25seUluZGV4ZXNcbiAgICAgICAgICB9LCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3I2LmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjYuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLnNsaWNlKDAsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgfV0sIFt7XG4gICAga2V5OiBcImNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZShhcmdzKSB7XG4gICAgICB2YXIgY29tcGlsZWRLZXlzID0gQ29tcGlsZWRLZXlzLmNvbXBpbGUoYXJncy5pbnN0cnVjdGlvbnMsIGFyZ3MucGF5ZXJLZXkpO1xuICAgICAgdmFyIGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBuZXcgQXJyYXkoKTtcbiAgICAgIHZhciBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0ge1xuICAgICAgICB3cml0YWJsZTogbmV3IEFycmF5KCksXG4gICAgICAgIHJlYWRvbmx5OiBuZXcgQXJyYXkoKVxuICAgICAgfTtcbiAgICAgIHZhciBsb29rdXBUYWJsZUFjY291bnRzID0gYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyB8fCBbXTtcbiAgICAgIHZhciBfaXRlcmF0b3I3ID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMyhsb29rdXBUYWJsZUFjY291bnRzKSxcbiAgICAgICAgX3N0ZXA3O1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yIChfaXRlcmF0b3I3LnMoKTsgIShfc3RlcDcgPSBfaXRlcmF0b3I3Lm4oKSkuZG9uZTspIHtcbiAgICAgICAgICB2YXIgbG9va3VwVGFibGUgPSBfc3RlcDcudmFsdWU7XG4gICAgICAgICAgdmFyIGV4dHJhY3RSZXN1bHQgPSBjb21waWxlZEtleXMuZXh0cmFjdFRhYmxlTG9va3VwKGxvb2t1cFRhYmxlKTtcbiAgICAgICAgICBpZiAoZXh0cmFjdFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgX2FjY291bnRLZXlzRnJvbUxvb2t1LCBfYWNjb3VudEtleXNGcm9tTG9va3UyO1xuICAgICAgICAgICAgdmFyIF9leHRyYWN0UmVzdWx0ID0gX3NsaWNlZFRvQXJyYXkoZXh0cmFjdFJlc3VsdCwgMiksXG4gICAgICAgICAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cCA9IF9leHRyYWN0UmVzdWx0WzBdLFxuICAgICAgICAgICAgICBfZXh0cmFjdFJlc3VsdCQgPSBfZXh0cmFjdFJlc3VsdFsxXSxcbiAgICAgICAgICAgICAgd3JpdGFibGUgPSBfZXh0cmFjdFJlc3VsdCQud3JpdGFibGUsXG4gICAgICAgICAgICAgIHJlYWRvbmx5ID0gX2V4dHJhY3RSZXN1bHQkLnJlYWRvbmx5O1xuICAgICAgICAgICAgYWRkcmVzc1RhYmxlTG9va3Vwcy5wdXNoKGFkZHJlc3NUYWJsZUxvb2t1cCk7XG4gICAgICAgICAgICAoX2FjY291bnRLZXlzRnJvbUxvb2t1ID0gYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZSkucHVzaC5hcHBseShfYWNjb3VudEtleXNGcm9tTG9va3UsIF90b0NvbnN1bWFibGVBcnJheSh3cml0YWJsZSkpO1xuICAgICAgICAgICAgKF9hY2NvdW50S2V5c0Zyb21Mb29rdTIgPSBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5KS5wdXNoLmFwcGx5KF9hY2NvdW50S2V5c0Zyb21Mb29rdTIsIF90b0NvbnN1bWFibGVBcnJheShyZWFkb25seSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvcjcuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yNy5mKCk7XG4gICAgICB9XG4gICAgICB2YXIgX2NvbXBpbGVkS2V5cyRnZXRNZXNzID0gY29tcGlsZWRLZXlzLmdldE1lc3NhZ2VDb21wb25lbnRzKCksXG4gICAgICAgIF9jb21waWxlZEtleXMkZ2V0TWVzczIgPSBfc2xpY2VkVG9BcnJheShfY29tcGlsZWRLZXlzJGdldE1lc3MsIDIpLFxuICAgICAgICBoZWFkZXIgPSBfY29tcGlsZWRLZXlzJGdldE1lc3MyWzBdLFxuICAgICAgICBzdGF0aWNBY2NvdW50S2V5cyA9IF9jb21waWxlZEtleXMkZ2V0TWVzczJbMV07XG4gICAgICB2YXIgYWNjb3VudEtleXMgPSBuZXcgTWVzc2FnZUFjY291bnRLZXlzKHN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKTtcbiAgICAgIHZhciBjb21waWxlZEluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpO1xuICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgICBoZWFkZXI6IGhlYWRlcixcbiAgICAgICAgc3RhdGljQWNjb3VudEtleXM6IHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgICBjb21waWxlZEluc3RydWN0aW9uczogY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IGFkZHJlc3NUYWJsZUxvb2t1cHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZXNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXNlcmlhbGl6ZShzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgICAgdmFyIGJ5dGVBcnJheSA9IF90b0NvbnN1bWFibGVBcnJheShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgICB2YXIgcHJlZml4ID0gYnl0ZUFycmF5LnNoaWZ0KCk7XG4gICAgICB2YXIgbWFza2VkUHJlZml4ID0gcHJlZml4ICYgVkVSU0lPTl9QUkVGSVhfTUFTSztcbiAgICAgIGFzc2VydChwcmVmaXggIT09IG1hc2tlZFByZWZpeCwgXCJFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSBidXQgcmVjZWl2ZWQgbGVnYWN5IG1lc3NhZ2VcIik7XG4gICAgICB2YXIgdmVyc2lvbiA9IG1hc2tlZFByZWZpeDtcbiAgICAgIGFzc2VydCh2ZXJzaW9uID09PSAwLCBcIkV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIHdpdGggdmVyc2lvbiAwIGJ1dCBmb3VuZCB2ZXJzaW9uIFwiLmNvbmNhdCh2ZXJzaW9uKSk7XG4gICAgICB2YXIgaGVhZGVyID0ge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IGJ5dGVBcnJheS5zaGlmdCgpLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzOiBieXRlQXJyYXkuc2hpZnQoKSxcbiAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBieXRlQXJyYXkuc2hpZnQoKVxuICAgICAgfTtcbiAgICAgIHZhciBzdGF0aWNBY2NvdW50S2V5cyA9IFtdO1xuICAgICAgdmFyIHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3RhdGljQWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KGJ5dGVBcnJheS5zcGxpY2UoMCwgUFVCTElDX0tFWV9MRU5HVEgpKSk7XG4gICAgICB9XG4gICAgICB2YXIgcmVjZW50QmxvY2toYXNoID0gYnM1OC5lbmNvZGUoYnl0ZUFycmF5LnNwbGljZSgwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgdmFyIGluc3RydWN0aW9uQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIHZhciBjb21waWxlZEluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGluc3RydWN0aW9uQ291bnQ7IF9pKyspIHtcbiAgICAgICAgdmFyIHByb2dyYW1JZEluZGV4ID0gYnl0ZUFycmF5LnNoaWZ0KCk7XG4gICAgICAgIHZhciBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgICB2YXIgYWNjb3VudEtleUluZGV4ZXMgPSBieXRlQXJyYXkuc3BsaWNlKDAsIGFjY291bnRLZXlJbmRleGVzTGVuZ3RoKTtcbiAgICAgICAgdmFyIGRhdGFMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgICAgdmFyIGRhdGEgPSBuZXcgVWludDhBcnJheShieXRlQXJyYXkuc3BsaWNlKDAsIGRhdGFMZW5ndGgpKTtcbiAgICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMucHVzaCh7XG4gICAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IHByb2dyYW1JZEluZGV4LFxuICAgICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBhY2NvdW50S2V5SW5kZXhlcyxcbiAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdmFyIGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgdmFyIGFkZHJlc3NUYWJsZUxvb2t1cHMgPSBbXTtcbiAgICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IGFkZHJlc3NUYWJsZUxvb2t1cHNDb3VudDsgX2kyKyspIHtcbiAgICAgICAgdmFyIGFjY291bnRLZXkgPSBuZXcgUHVibGljS2V5KGJ5dGVBcnJheS5zcGxpY2UoMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgICAgdmFyIHdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgICB2YXIgd3JpdGFibGVJbmRleGVzID0gYnl0ZUFycmF5LnNwbGljZSgwLCB3cml0YWJsZUluZGV4ZXNMZW5ndGgpO1xuICAgICAgICB2YXIgcmVhZG9ubHlJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICAgIHZhciByZWFkb25seUluZGV4ZXMgPSBieXRlQXJyYXkuc3BsaWNlKDAsIHJlYWRvbmx5SW5kZXhlc0xlbmd0aCk7XG4gICAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaCh7XG4gICAgICAgICAgYWNjb3VudEtleTogYWNjb3VudEtleSxcbiAgICAgICAgICB3cml0YWJsZUluZGV4ZXM6IHdyaXRhYmxlSW5kZXhlcyxcbiAgICAgICAgICByZWFkb25seUluZGV4ZXM6IHJlYWRvbmx5SW5kZXhlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIsXG4gICAgICAgIHN0YXRpY0FjY291bnRLZXlzOiBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgICAgcmVjZW50QmxvY2toYXNoOiByZWNlbnRCbG9ja2hhc2gsXG4gICAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zOiBjb21waWxlZEluc3RydWN0aW9ucyxcbiAgICAgICAgYWRkcmVzc1RhYmxlTG9va3VwczogYWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBNZXNzYWdlVjA7XG59KCk7XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbnZhciBWZXJzaW9uZWRNZXNzYWdlID0ge1xuICBkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uOiBmdW5jdGlvbiBkZXNlcmlhbGl6ZU1lc3NhZ2VWZXJzaW9uKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgdmFyIHByZWZpeCA9IHNlcmlhbGl6ZWRNZXNzYWdlWzBdO1xuICAgIHZhciBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuXG4gICAgLy8gaWYgdGhlIGhpZ2hlc3QgYml0IG9mIHRoZSBwcmVmaXggaXMgbm90IHNldCwgdGhlIG1lc3NhZ2UgaXMgbm90IHZlcnNpb25lZFxuICAgIGlmIChtYXNrZWRQcmVmaXggPT09IHByZWZpeCkge1xuICAgICAgcmV0dXJuICdsZWdhY3knO1xuICAgIH1cblxuICAgIC8vIHRoZSBsb3dlciA3IGJpdHMgb2YgdGhlIHByZWZpeCBpbmRpY2F0ZSB0aGUgbWVzc2FnZSB2ZXJzaW9uXG4gICAgcmV0dXJuIG1hc2tlZFByZWZpeDtcbiAgfSxcbiAgZGVzZXJpYWxpemU6IGZ1bmN0aW9uIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKSB7XG4gICAgdmFyIHZlcnNpb24gPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgcmV0dXJuIE1lc3NhZ2UuZnJvbShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZVYwLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gbWVzc2FnZSB2ZXJzaW9uIFwiLmNvbmNhdCh2ZXJzaW9uLCBcIiBkZXNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZFwiKSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lJDQoKSB7IC8qISByZWdlbmVyYXRvci1ydW50aW1lIC0tIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLiAtLSBsaWNlbnNlIChNSVQpOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVnZW5lcmF0b3IvYmxvYi9tYWluL0xJQ0VOU0UgKi8gX3JlZ2VuZXJhdG9yUnVudGltZSQ0ID0gZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSgpIHsgcmV0dXJuIGV4cG9ydHM7IH07IHZhciBleHBvcnRzID0ge30sIE9wID0gT2JqZWN0LnByb3RvdHlwZSwgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSwgZGVzYykgeyBvYmpba2V5XSA9IGRlc2MudmFsdWU7IH0sICRTeW1ib2wgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCA/IFN5bWJvbCA6IHt9LCBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsIGFzeW5jSXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLmFzeW5jSXRlcmF0b3IgfHwgXCJAQGFzeW5jSXRlcmF0b3JcIiwgdG9TdHJpbmdUYWdTeW1ib2wgPSAkU3ltYm9sLnRvU3RyaW5nVGFnIHx8IFwiQEB0b1N0cmluZ1RhZ1wiOyBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCwgd3JpdGFibGU6ICEwIH0pLCBvYmpba2V5XTsgfSB0cnkgeyBkZWZpbmUoe30sIFwiXCIpOyB9IGNhdGNoIChlcnIpIHsgZGVmaW5lID0gZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gb2JqW2tleV0gPSB2YWx1ZTsgfTsgfSBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7IHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLCBnZW5lcmF0b3IgPSBPYmplY3QuY3JlYXRlKHByb3RvR2VuZXJhdG9yLnByb3RvdHlwZSksIGNvbnRleHQgPSBuZXcgQ29udGV4dCh0cnlMb2NzTGlzdCB8fCBbXSk7IHJldHVybiBkZWZpbmVQcm9wZXJ0eShnZW5lcmF0b3IsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIH0pLCBnZW5lcmF0b3I7IH0gZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7IHRyeSB7IHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTsgfSBjYXRjaCAoZXJyKSB7IHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTsgfSB9IGV4cG9ydHMud3JhcCA9IHdyYXA7IHZhciBDb250aW51ZVNlbnRpbmVsID0ge307IGZ1bmN0aW9uIEdlbmVyYXRvcigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUoKSB7fSB2YXIgSXRlcmF0b3JQcm90b3R5cGUgPSB7fTsgZGVmaW5lKEl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSk7IHZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiwgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTsgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpOyBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7IFtcIm5leHRcIiwgXCJ0aHJvd1wiLCBcInJldHVyblwiXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHsgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpOyB9KTsgfSk7IH0gZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7IGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7IHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpOyBpZiAoXCJ0aHJvd1wiICE9PSByZWNvcmQudHlwZSkgeyB2YXIgcmVzdWx0ID0gcmVjb3JkLmFyZywgdmFsdWUgPSByZXN1bHQudmFsdWU7IHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7IGludm9rZShcIm5leHRcIiwgdmFsdWUsIHJlc29sdmUsIHJlamVjdCk7IH0sIGZ1bmN0aW9uIChlcnIpIHsgaW52b2tlKFwidGhyb3dcIiwgZXJyLCByZXNvbHZlLCByZWplY3QpOyB9KSA6IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUpLnRoZW4oZnVuY3Rpb24gKHVud3JhcHBlZCkgeyByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTsgfSwgZnVuY3Rpb24gKGVycm9yKSB7IHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCBlcnJvciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmVqZWN0KHJlY29yZC5hcmcpOyB9IHZhciBwcmV2aW91c1Byb21pc2U7IGRlZmluZVByb3BlcnR5KHRoaXMsIFwiX2ludm9rZVwiLCB7IHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShtZXRob2QsIGFyZykgeyBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHsgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KTsgfSk7IH0gcmV0dXJuIHByZXZpb3VzUHJvbWlzZSA9IHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLCBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZykgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpOyB9IH0pOyB9IGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgeyB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7IHJldHVybiBmdW5jdGlvbiAobWV0aG9kLCBhcmcpIHsgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpOyBpZiAoXCJjb21wbGV0ZWRcIiA9PT0gc3RhdGUpIHsgaWYgKFwidGhyb3dcIiA9PT0gbWV0aG9kKSB0aHJvdyBhcmc7IHJldHVybiBkb25lUmVzdWx0KCk7IH0gZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7OykgeyB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlOyBpZiAoZGVsZWdhdGUpIHsgdmFyIGRlbGVnYXRlUmVzdWx0ID0gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCk7IGlmIChkZWxlZ2F0ZVJlc3VsdCkgeyBpZiAoZGVsZWdhdGVSZXN1bHQgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7IH0gfSBpZiAoXCJuZXh0XCIgPT09IGNvbnRleHQubWV0aG9kKSBjb250ZXh0LnNlbnQgPSBjb250ZXh0Ll9zZW50ID0gY29udGV4dC5hcmc7ZWxzZSBpZiAoXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgeyBpZiAoXCJzdXNwZW5kZWRTdGFydFwiID09PSBzdGF0ZSkgdGhyb3cgc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0LmFyZzsgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7IH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7IHN0YXRlID0gXCJleGVjdXRpbmdcIjsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpOyBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHsgaWYgKHN0YXRlID0gY29udGV4dC5kb25lID8gXCJjb21wbGV0ZWRcIiA6IFwic3VzcGVuZGVkWWllbGRcIiwgcmVjb3JkLmFyZyA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiB7IHZhbHVlOiByZWNvcmQuYXJnLCBkb25lOiBjb250ZXh0LmRvbmUgfTsgfSBcInRocm93XCIgPT09IHJlY29yZC50eXBlICYmIChzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcpOyB9IH07IH0gZnVuY3Rpb24gbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCkgeyB2YXIgbWV0aG9kTmFtZSA9IGNvbnRleHQubWV0aG9kLCBtZXRob2QgPSBkZWxlZ2F0ZS5pdGVyYXRvclttZXRob2ROYW1lXTsgaWYgKHVuZGVmaW5lZCA9PT0gbWV0aG9kKSByZXR1cm4gY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIFwidGhyb3dcIiA9PT0gbWV0aG9kTmFtZSAmJiBkZWxlZ2F0ZS5pdGVyYXRvcltcInJldHVyblwiXSAmJiAoY29udGV4dC5tZXRob2QgPSBcInJldHVyblwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCwgbWF5YmVJbnZva2VEZWxlZ2F0ZShkZWxlZ2F0ZSwgY29udGV4dCksIFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHx8IFwicmV0dXJuXCIgIT09IG1ldGhvZE5hbWUgJiYgKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJUaGUgaXRlcmF0b3IgZG9lcyBub3QgcHJvdmlkZSBhICdcIiArIG1ldGhvZE5hbWUgKyBcIicgbWV0aG9kXCIpKSwgQ29udGludWVTZW50aW5lbDsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHJldHVybiBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbDsgdmFyIGluZm8gPSByZWNvcmQuYXJnOyByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTsgfSBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykgeyB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9OyAxIGluIGxvY3MgJiYgKGVudHJ5LmNhdGNoTG9jID0gbG9jc1sxXSksIDIgaW4gbG9jcyAmJiAoZW50cnkuZmluYWxseUxvYyA9IGxvY3NbMl0sIGVudHJ5LmFmdGVyTG9jID0gbG9jc1szXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTsgfSBmdW5jdGlvbiByZXNldFRyeUVudHJ5KGVudHJ5KSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9OyByZWNvcmQudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSByZWNvcmQuYXJnLCBlbnRyeS5jb21wbGV0aW9uID0gcmVjb3JkOyB9IGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHsgdGhpcy50cnlFbnRyaWVzID0gW3sgdHJ5TG9jOiBcInJvb3RcIiB9XSwgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpLCB0aGlzLnJlc2V0KCEwKTsgfSBmdW5jdGlvbiB2YWx1ZXMoaXRlcmFibGUpIHsgaWYgKGl0ZXJhYmxlKSB7IHZhciBpdGVyYXRvck1ldGhvZCA9IGl0ZXJhYmxlW2l0ZXJhdG9yU3ltYm9sXTsgaWYgKGl0ZXJhdG9yTWV0aG9kKSByZXR1cm4gaXRlcmF0b3JNZXRob2QuY2FsbChpdGVyYWJsZSk7IGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTsgaWYgKCFpc05hTihpdGVyYWJsZS5sZW5ndGgpKSB7IHZhciBpID0gLTEsIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsgKytpIDwgaXRlcmFibGUubGVuZ3RoOykgaWYgKGhhc093bi5jYWxsKGl0ZXJhYmxlLCBpKSkgcmV0dXJuIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXSwgbmV4dC5kb25lID0gITEsIG5leHQ7IHJldHVybiBuZXh0LnZhbHVlID0gdW5kZWZpbmVkLCBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgcmV0dXJuIG5leHQubmV4dCA9IG5leHQ7IH0gfSByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07IH0gZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHsgcmV0dXJuIHsgdmFsdWU6IHVuZGVmaW5lZCwgZG9uZTogITAgfTsgfSByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBjb25maWd1cmFibGU6ICEwIH0pLCBkZWZpbmVQcm9wZXJ0eShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbiwgY29uZmlndXJhYmxlOiAhMCB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpLCBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24gPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHZhciBjdG9yID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBnZW5GdW4gJiYgZ2VuRnVuLmNvbnN0cnVjdG9yOyByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpOyB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7IHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YoZ2VuRnVuLCBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSkgOiAoZ2VuRnVuLl9fcHJvdG9fXyA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSksIGdlbkZ1bi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEdwKSwgZ2VuRnVuOyB9LCBleHBvcnRzLmF3cmFwID0gZnVuY3Rpb24gKGFyZykgeyByZXR1cm4geyBfX2F3YWl0OiBhcmcgfTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlKSwgZGVmaW5lKEFzeW5jSXRlcmF0b3IucHJvdG90eXBlLCBhc3luY0l0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHsgdm9pZCAwID09PSBQcm9taXNlSW1wbCAmJiAoUHJvbWlzZUltcGwgPSBQcm9taXNlKTsgdmFyIGl0ZXIgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSwgUHJvbWlzZUltcGwpOyByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkgeyByZXR1cm4gcmVzdWx0LmRvbmUgPyByZXN1bHQudmFsdWUgOiBpdGVyLm5leHQoKTsgfSk7IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KSwgZGVmaW5lKEdwLCBcInRvU3RyaW5nXCIsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7IH0pLCBleHBvcnRzLmtleXMgPSBmdW5jdGlvbiAodmFsKSB7IHZhciBvYmplY3QgPSBPYmplY3QodmFsKSwga2V5cyA9IFtdOyBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTsgcmV0dXJuIGtleXMucmV2ZXJzZSgpLCBmdW5jdGlvbiBuZXh0KCkgeyBmb3IgKDsga2V5cy5sZW5ndGg7KSB7IHZhciBrZXkgPSBrZXlzLnBvcCgpOyBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0OyB9IHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDsgfTsgfSwgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXMsIENvbnRleHQucHJvdG90eXBlID0geyBjb25zdHJ1Y3RvcjogQ29udGV4dCwgcmVzZXQ6IGZ1bmN0aW9uIHJlc2V0KHNraXBUZW1wUmVzZXQpIHsgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7IH0sIHN0b3A6IGZ1bmN0aW9uIHN0b3AoKSB7IHRoaXMuZG9uZSA9ICEwOyB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByb290UmVjb3JkLnR5cGUpIHRocm93IHJvb3RSZWNvcmQuYXJnOyByZXR1cm4gdGhpcy5ydmFsOyB9LCBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7IGlmICh0aGlzLmRvbmUpIHRocm93IGV4Y2VwdGlvbjsgdmFyIGNvbnRleHQgPSB0aGlzOyBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHsgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDsgfSBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXSwgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwicm9vdFwiID09PSBlbnRyeS50cnlMb2MpIHJldHVybiBoYW5kbGUoXCJlbmRcIik7IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7IHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLCBoYXNGaW5hbGx5ID0gaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKTsgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyB9IGVsc2UgeyBpZiAoIWhhc0ZpbmFsbHkpIHRocm93IG5ldyBFcnJvcihcInRyeSBzdGF0ZW1lbnQgd2l0aG91dCBjYXRjaCBvciBmaW5hbGx5XCIpOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSB9IH0gfSwgYWJydXB0OiBmdW5jdGlvbiBhYnJ1cHQodHlwZSwgYXJnKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldiAmJiBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpICYmIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHsgdmFyIGZpbmFsbHlFbnRyeSA9IGVudHJ5OyBicmVhazsgfSB9IGZpbmFsbHlFbnRyeSAmJiAoXCJicmVha1wiID09PSB0eXBlIHx8IFwiY29udGludWVcIiA9PT0gdHlwZSkgJiYgZmluYWxseUVudHJ5LnRyeUxvYyA8PSBhcmcgJiYgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jICYmIChmaW5hbGx5RW50cnkgPSBudWxsKTsgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307IHJldHVybiByZWNvcmQudHlwZSA9IHR5cGUsIHJlY29yZC5hcmcgPSBhcmcsIGZpbmFsbHlFbnRyeSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBmaW5hbGx5RW50cnkuZmluYWxseUxvYywgQ29udGludWVTZW50aW5lbCkgOiB0aGlzLmNvbXBsZXRlKHJlY29yZCk7IH0sIGNvbXBsZXRlOiBmdW5jdGlvbiBjb21wbGV0ZShyZWNvcmQsIGFmdGVyTG9jKSB7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnOyByZXR1cm4gXCJicmVha1wiID09PSByZWNvcmQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHJlY29yZC50eXBlID8gdGhpcy5uZXh0ID0gcmVjb3JkLmFyZyA6IFwicmV0dXJuXCIgPT09IHJlY29yZC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZywgdGhpcy5tZXRob2QgPSBcInJldHVyblwiLCB0aGlzLm5leHQgPSBcImVuZFwiKSA6IFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlICYmIGFmdGVyTG9jICYmICh0aGlzLm5leHQgPSBhZnRlckxvYyksIENvbnRpbnVlU2VudGluZWw7IH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGZpbmFsbHlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIFwiY2F0Y2hcIjogZnVuY3Rpb24gX2NhdGNoKHRyeUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7IHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgeyB2YXIgdGhyb3duID0gcmVjb3JkLmFyZzsgcmVzZXRUcnlFbnRyeShlbnRyeSk7IH0gcmV0dXJuIHRocm93bjsgfSB9IHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTsgfSwgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gZGVsZWdhdGVZaWVsZChpdGVyYWJsZSwgcmVzdWx0TmFtZSwgbmV4dExvYykgeyByZXR1cm4gdGhpcy5kZWxlZ2F0ZSA9IHsgaXRlcmF0b3I6IHZhbHVlcyhpdGVyYWJsZSksIHJlc3VsdE5hbWU6IHJlc3VsdE5hbWUsIG5leHRMb2M6IG5leHRMb2MgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgZXhwb3J0czsgfVxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMihvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDIobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQyKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMihvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQyKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMkMihPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBhcyBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gKi9cblxudmFyIFRyYW5zYWN0aW9uU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIkJMT0NLSEVJR0hUX0VYQ0VFREVEXCJdID0gMF0gPSBcIkJMT0NLSEVJR0hUX0VYQ0VFREVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiUFJPQ0VTU0VEXCJdID0gMV0gPSBcIlBST0NFU1NFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlRJTUVEX09VVFwiXSA9IDJdID0gXCJUSU1FRF9PVVRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJOT05DRV9JTlZBTElEXCJdID0gM10gPSBcIk5PTkNFX0lOVkFMSURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzO1xufSh7fSk7XG5cbi8qKlxuICogRGVmYXVsdCAoZW1wdHkpIHNpZ25hdHVyZVxuICovXG52YXIgREVGQVVMVF9TSUdOQVRVUkUgPSBCdWZmZXIuYWxsb2MoU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUykuZmlsbCgwKTtcblxuLyoqXG4gKiBBY2NvdW50IG1ldGFkYXRhIHVzZWQgdG8gZGVmaW5lIGluc3RydWN0aW9uc1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBUcmFuc2FjdGlvbkluc3RydWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgVHJhbnNhY3Rpb24uc2VyaWFsaXplKClcbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xudmFyIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBUcmFuc2FjdGlvbkluc3RydWN0aW9uKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbik7XG4gICAgLyoqXG4gICAgICogUHVibGljIGtleXMgdG8gaW5jbHVkZSBpbiB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICogQm9vbGVhbiByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwdWJrZXkgbmVlZHMgdG8gc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICB0aGlzLmtleXMgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBJZCB0byBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5wcm9ncmFtSWQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogUHJvZ3JhbSBpbnB1dFxuICAgICAqL1xuICAgIHRoaXMuZGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB0aGlzLnByb2dyYW1JZCA9IG9wdHMucHJvZ3JhbUlkO1xuICAgIHRoaXMua2V5cyA9IG9wdHMua2V5cztcbiAgICBpZiAob3B0cy5kYXRhKSB7XG4gICAgICB0aGlzLmRhdGEgPSBvcHRzLmRhdGE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24sIFt7XG4gICAga2V5OiBcInRvSlNPTlwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlzOiB0aGlzLmtleXMubWFwKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgICAgdmFyIHB1YmtleSA9IF9yZWYucHVia2V5LFxuICAgICAgICAgICAgaXNTaWduZXIgPSBfcmVmLmlzU2lnbmVyLFxuICAgICAgICAgICAgaXNXcml0YWJsZSA9IF9yZWYuaXNXcml0YWJsZTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVia2V5OiBwdWJrZXkudG9KU09OKCksXG4gICAgICAgICAgICBpc1NpZ25lcjogaXNTaWduZXIsXG4gICAgICAgICAgICBpc1dyaXRhYmxlOiBpc1dyaXRhYmxlXG4gICAgICAgICAgfTtcbiAgICAgICAgfSksXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICAgIGRhdGE6IF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmRhdGEpXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJhbnNhY3Rpb25JbnN0cnVjdGlvbjtcbn0oKTtcblxuLyoqXG4gKiBQYWlyIG9mIHNpZ25hdHVyZSBhbmQgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk7IGFuIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nXG4vLyBmb3JjZWQgdG8gb3Zlci1leHBvcnQgdHlwZXMgYnkgdGhlIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yNTgyMFxuLyoqXG4gKiBCbG9ja2hhc2gtYmFzZWQgdHJhbnNhY3Rpb25zIGhhdmUgYSBsaWZldGltZSB0aGF0IGFyZSBkZWZpbmVkIGJ5XG4gKiB0aGUgYmxvY2toYXNoIHRoZXkgaW5jbHVkZS4gQW55IHRyYW5zYWN0aW9uIHdob3NlIGJsb2NraGFzaCBpc1xuICogdG9vIG9sZCB3aWxsIGJlIHJlamVjdGVkLlxuICovXG4vKipcbiAqIFVzZSB0aGVzZSBvcHRpb25zIHRvIGNvbnN0cnVjdCBhIGR1cmFibGUgbm9uY2UgdHJhbnNhY3Rpb24uXG4gKi9cbi8qKlxuICogTm9uY2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCB0byBidWlsZCBhbiBvZmZsaW5lIFRyYW5zYWN0aW9uLlxuICovXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbnZhciBUcmFuc2FjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gZW1wdHkgVHJhbnNhY3Rpb25cbiAgICovXG4gIGZ1bmN0aW9uIFRyYW5zYWN0aW9uKG9wdHMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNhY3Rpb24pO1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFR5cGljYWxseSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZVxuICAgICAqIGBzaWduKClgIG1ldGhvZFxuICAgICAqL1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIFRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXJcbiAgICAgKi9cbiAgICB0aGlzLmZlZVBheWVyID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFRoZSBpbnN0cnVjdGlvbnMgdG8gYXRvbWljYWxseSBleGVjdXRlXG4gICAgICovXG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBbXTtcbiAgICAvKipcbiAgICAgKiBBIHJlY2VudCB0cmFuc2FjdGlvbiBpZC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHRoZSBsYXN0IGJsb2NrIGNoYWluIGNhbiBhZHZhbmNlIHRvIGJlZm9yZSB0eCBpcyBkZWNsYXJlZCBleHBpcmVkXG4gICAgICogKi9cbiAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIE9wdGlvbmFsIE5vbmNlIGluZm9ybWF0aW9uLiBJZiBwb3B1bGF0ZWQsIHRyYW5zYWN0aW9uIHdpbGwgdXNlIGEgZHVyYWJsZVxuICAgICAqIE5vbmNlIGhhc2ggaW5zdGVhZCBvZiBhIHJlY2VudEJsb2NraGFzaC4gTXVzdCBiZSBwb3B1bGF0ZWQgYnkgdGhlIGNhbGxlclxuICAgICAqL1xuICAgIHRoaXMubm9uY2VJbmZvID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYSBub25jZSB0cmFuc2FjdGlvbiB0aGlzIHJlcHJlc2VudHMgdGhlIG1pbmltdW0gc2xvdCBmcm9tIHdoaWNoXG4gICAgICogdG8gZXZhbHVhdGUgaWYgdGhlIG5vbmNlIGhhcyBhZHZhbmNlZCB3aGVuIGF0dGVtcHRpbmcgdG8gY29uZmlybSB0aGVcbiAgICAgKiB0cmFuc2FjdGlvbi4gVGhpcyBwcm90ZWN0cyBhZ2FpbnN0IGEgY2FzZSB3aGVyZSB0aGUgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uXG4gICAgICogbG9naWMgbG9hZHMgdGhlIG5vbmNlIGFjY291bnQgZnJvbSBhbiBvbGQgc2xvdCBhbmQgYXNzdW1lcyB0aGUgbWlzbWF0Y2ggaW5cbiAgICAgKiBub25jZSB2YWx1ZSBpbXBsaWVzIHRoYXQgdGhlIG5vbmNlIGhhcyBiZWVuIGFkdmFuY2VkLlxuICAgICAqL1xuICAgIHRoaXMubWluTm9uY2VDb250ZXh0U2xvdCA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB0aGlzLl9tZXNzYWdlID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX2pzb24gPSB2b2lkIDA7XG4gICAgaWYgKCFvcHRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChvcHRzLmZlZVBheWVyKSB7XG4gICAgICB0aGlzLmZlZVBheWVyID0gb3B0cy5mZWVQYXllcjtcbiAgICB9XG4gICAgaWYgKG9wdHMuc2lnbmF0dXJlcykge1xuICAgICAgdGhpcy5zaWduYXR1cmVzID0gb3B0cy5zaWduYXR1cmVzO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9wdHMsICdub25jZUluZm8nKSkge1xuICAgICAgdmFyIF9yZWYyID0gb3B0cyxcbiAgICAgICAgbWluQ29udGV4dFNsb3QgPSBfcmVmMi5taW5Db250ZXh0U2xvdCxcbiAgICAgICAgbm9uY2VJbmZvID0gX3JlZjIubm9uY2VJbmZvO1xuICAgICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gbWluQ29udGV4dFNsb3Q7XG4gICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgICAgdmFyIF9yZWYzID0gb3B0cyxcbiAgICAgICAgYmxvY2toYXNoID0gX3JlZjMuYmxvY2toYXNoLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodCA9IF9yZWYzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBibG9ja2hhc2g7XG4gICAgICB0aGlzLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcmVmNCA9IG9wdHMsXG4gICAgICAgIHJlY2VudEJsb2NraGFzaCA9IF9yZWY0LnJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgX25vbmNlSW5mbyA9IF9yZWY0Lm5vbmNlSW5mbztcbiAgICAgIGlmIChfbm9uY2VJbmZvKSB7XG4gICAgICAgIHRoaXMubm9uY2VJbmZvID0gX25vbmNlSW5mbztcbiAgICAgIH1cbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gcmVjZW50QmxvY2toYXNoO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhUcmFuc2FjdGlvbiwgW3tcbiAgICBrZXk6IFwic2lnbmF0dXJlXCIsXG4gICAgZ2V0OlxuICAgIC8qKlxuICAgICAqIFRoZSBmaXJzdCAocGF5ZXIpIFRyYW5zYWN0aW9uIHNpZ25hdHVyZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0J1ZmZlciB8IG51bGx9IEJ1ZmZlciBvZiBwYXllcidzIHNpZ25hdHVyZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWduYXR1cmVzWzBdLnNpZ25hdHVyZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ0b0pTT05cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdG9KU09OKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCB8fCBudWxsLFxuICAgICAgICBmZWVQYXllcjogdGhpcy5mZWVQYXllciA/IHRoaXMuZmVlUGF5ZXIudG9KU09OKCkgOiBudWxsLFxuICAgICAgICBub25jZUluZm86IHRoaXMubm9uY2VJbmZvID8ge1xuICAgICAgICAgIG5vbmNlOiB0aGlzLm5vbmNlSW5mby5ub25jZSxcbiAgICAgICAgICBub25jZUluc3RydWN0aW9uOiB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLnRvSlNPTigpXG4gICAgICAgIH0gOiBudWxsLFxuICAgICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zLm1hcChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb24udG9KU09OKCk7XG4gICAgICAgIH0pLFxuICAgICAgICBzaWduZXJzOiB0aGlzLnNpZ25hdHVyZXMubWFwKGZ1bmN0aW9uIChfcmVmNSkge1xuICAgICAgICAgIHZhciBwdWJsaWNLZXkgPSBfcmVmNS5wdWJsaWNLZXk7XG4gICAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b0pTT04oKTtcbiAgICAgICAgfSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIG9uZSBvciBtb3JlIGluc3RydWN0aW9ucyB0byB0aGlzIFRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PCBUcmFuc2FjdGlvbiB8IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uQ3RvckZpZWxkcyA+fSBpdGVtcyAtIEluc3RydWN0aW9ucyB0byBhZGQgdG8gdGhlIFRyYW5zYWN0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZCgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgaXRlbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGl0ZW1zW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGluc3RydWN0aW9ucycpO1xuICAgICAgfVxuICAgICAgaXRlbXMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoJ2luc3RydWN0aW9ucycgaW4gaXRlbSkge1xuICAgICAgICAgIF90aGlzLmluc3RydWN0aW9ucyA9IF90aGlzLmluc3RydWN0aW9ucy5jb25jYXQoaXRlbS5pbnN0cnVjdGlvbnMpO1xuICAgICAgICB9IGVsc2UgaWYgKCdkYXRhJyBpbiBpdGVtICYmICdwcm9ncmFtSWQnIGluIGl0ZW0gJiYgJ2tleXMnIGluIGl0ZW0pIHtcbiAgICAgICAgICBfdGhpcy5pbnN0cnVjdGlvbnMucHVzaChpdGVtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBfdGhpcy5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpdGVtKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29tcGlsZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY29tcGlsZU1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZU1lc3NhZ2UoKSB7XG4gICAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbikpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lc3NhZ2U7XG4gICAgICB9XG4gICAgICB2YXIgcmVjZW50QmxvY2toYXNoO1xuICAgICAgdmFyIGluc3RydWN0aW9ucztcbiAgICAgIGlmICh0aGlzLm5vbmNlSW5mbykge1xuICAgICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLm5vbmNlSW5mby5ub25jZTtcbiAgICAgICAgaWYgKHRoaXMuaW5zdHJ1Y3Rpb25zWzBdICE9IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgICBpbnN0cnVjdGlvbnMgPSBbdGhpcy5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbl0uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheSh0aGlzLmluc3RydWN0aW9ucykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluc3RydWN0aW9ucyA9IHRoaXMuaW5zdHJ1Y3Rpb25zO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLnJlY2VudEJsb2NraGFzaDtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnM7XG4gICAgICB9XG4gICAgICBpZiAoIXJlY2VudEJsb2NraGFzaCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIHJlY2VudEJsb2NraGFzaCByZXF1aXJlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RydWN0aW9ucy5sZW5ndGggPCAxKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignTm8gaW5zdHJ1Y3Rpb25zIHByb3ZpZGVkJyk7XG4gICAgICB9XG4gICAgICB2YXIgZmVlUGF5ZXI7XG4gICAgICBpZiAodGhpcy5mZWVQYXllcikge1xuICAgICAgICBmZWVQYXllciA9IHRoaXMuZmVlUGF5ZXI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc2lnbmF0dXJlcy5sZW5ndGggPiAwICYmIHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXkpIHtcbiAgICAgICAgLy8gVXNlIGltcGxpY2l0IGZlZSBwYXllclxuICAgICAgICBmZWVQYXllciA9IHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zYWN0aW9uIGZlZSBwYXllciByZXF1aXJlZCcpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluc3RydWN0aW9uc1tpXS5wcm9ncmFtSWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIGluc3RydWN0aW9uIGluZGV4IFwiLmNvbmNhdChpLCBcIiBoYXMgdW5kZWZpbmVkIHByb2dyYW0gaWRcIikpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgcHJvZ3JhbUlkcyA9IFtdO1xuICAgICAgdmFyIGFjY291bnRNZXRhcyA9IFtdO1xuICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGluc3RydWN0aW9uLmtleXMuZm9yRWFjaChmdW5jdGlvbiAoYWNjb3VudE1ldGEpIHtcbiAgICAgICAgICBhY2NvdW50TWV0YXMucHVzaChfb2JqZWN0U3ByZWFkJDIoe30sIGFjY291bnRNZXRhKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJvZ3JhbUlkID0gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICghcHJvZ3JhbUlkcy5pbmNsdWRlcyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgcHJvZ3JhbUlkcy5wdXNoKHByb2dyYW1JZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBBcHBlbmQgcHJvZ3JhbUlEIGFjY291bnQgbWV0YXNcbiAgICAgIHByb2dyYW1JZHMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbUlkKSB7XG4gICAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgICBwdWJrZXk6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3VsbCBkdXBsaWNhdGUgYWNjb3VudCBtZXRhc1xuICAgICAgdmFyIHVuaXF1ZU1ldGFzID0gW107XG4gICAgICBhY2NvdW50TWV0YXMuZm9yRWFjaChmdW5jdGlvbiAoYWNjb3VudE1ldGEpIHtcbiAgICAgICAgdmFyIHB1YmtleVN0cmluZyA9IGFjY291bnRNZXRhLnB1YmtleS50b1N0cmluZygpO1xuICAgICAgICB2YXIgdW5pcXVlSW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgICByZXR1cm4geC5wdWJrZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5U3RyaW5nO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHVuaXF1ZUluZGV4ID4gLTEpIHtcbiAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlIHx8IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgICAgdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyID0gdW5pcXVlTWV0YXNbdW5pcXVlSW5kZXhdLmlzU2lnbmVyIHx8IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVuaXF1ZU1ldGFzLnB1c2goYWNjb3VudE1ldGEpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gU29ydC4gUHJpb3JpdGl6aW5nIGZpcnN0IGJ5IHNpZ25lciwgdGhlbiBieSB3cml0YWJsZVxuICAgICAgdW5pcXVlTWV0YXMuc29ydChmdW5jdGlvbiAoeCwgeSkge1xuICAgICAgICBpZiAoeC5pc1NpZ25lciAhPT0geS5pc1NpZ25lcikge1xuICAgICAgICAgIC8vIFNpZ25lcnMgYWx3YXlzIGNvbWUgYmVmb3JlIG5vbi1zaWduZXJzXG4gICAgICAgICAgcmV0dXJuIHguaXNTaWduZXIgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHguaXNXcml0YWJsZSAhPT0geS5pc1dyaXRhYmxlKSB7XG4gICAgICAgICAgLy8gV3JpdGFibGUgYWNjb3VudHMgYWx3YXlzIGNvbWUgYmVmb3JlIHJlYWQtb25seSBhY2NvdW50c1xuICAgICAgICAgIHJldHVybiB4LmlzV3JpdGFibGUgPyAtMSA6IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzb3J0IGJ5IHB1YmtleSwgc3RyaW5nd2lzZS5cbiAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgbG9jYWxlTWF0Y2hlcjogJ2Jlc3QgZml0JyxcbiAgICAgICAgICB1c2FnZTogJ3NvcnQnLFxuICAgICAgICAgIHNlbnNpdGl2aXR5OiAndmFyaWFudCcsXG4gICAgICAgICAgaWdub3JlUHVuY3R1YXRpb246IGZhbHNlLFxuICAgICAgICAgIG51bWVyaWM6IGZhbHNlLFxuICAgICAgICAgIGNhc2VGaXJzdDogJ2xvd2VyJ1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geC5wdWJrZXkudG9CYXNlNTgoKS5sb2NhbGVDb21wYXJlKHkucHVia2V5LnRvQmFzZTU4KCksICdlbicsIG9wdGlvbnMpO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIE1vdmUgZmVlIHBheWVyIHRvIHRoZSBmcm9udFxuICAgICAgdmFyIGZlZVBheWVySW5kZXggPSB1bmlxdWVNZXRhcy5maW5kSW5kZXgoZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgcmV0dXJuIHgucHVia2V5LmVxdWFscyhmZWVQYXllcik7XG4gICAgICB9KTtcbiAgICAgIGlmIChmZWVQYXllckluZGV4ID4gLTEpIHtcbiAgICAgICAgdmFyIF91bmlxdWVNZXRhcyRzcGxpY2UgPSB1bmlxdWVNZXRhcy5zcGxpY2UoZmVlUGF5ZXJJbmRleCwgMSksXG4gICAgICAgICAgX3VuaXF1ZU1ldGFzJHNwbGljZTIgPSBfc2xpY2VkVG9BcnJheShfdW5pcXVlTWV0YXMkc3BsaWNlLCAxKSxcbiAgICAgICAgICBwYXllck1ldGEgPSBfdW5pcXVlTWV0YXMkc3BsaWNlMlswXTtcbiAgICAgICAgcGF5ZXJNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgICAgcGF5ZXJNZXRhLmlzV3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHBheWVyTWV0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bmlxdWVNZXRhcy51bnNoaWZ0KHtcbiAgICAgICAgICBwdWJrZXk6IGZlZVBheWVyLFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIERpc2FsbG93IHVua25vd24gc2lnbmVyc1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDIodGhpcy5zaWduYXR1cmVzKSxcbiAgICAgICAgX3N0ZXA7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcCgpIHtcbiAgICAgICAgICB2YXIgc2lnbmF0dXJlID0gX3N0ZXAudmFsdWU7XG4gICAgICAgICAgdmFyIHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKHNpZ25hdHVyZS5wdWJsaWNLZXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICh1bmlxdWVJbmRleCA+IC0xKSB7XG4gICAgICAgICAgICBpZiAoIXVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lcikge1xuICAgICAgICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNTaWduZXIgPSB0cnVlO1xuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1RyYW5zYWN0aW9uIHJlZmVyZW5jZXMgYSBzaWduYXR1cmUgdGhhdCBpcyB1bm5lY2Vzc2FyeSwgJyArICdvbmx5IHRoZSBmZWUgcGF5ZXIgYW5kIGluc3RydWN0aW9uIHNpZ25lciBhY2NvdW50cyBzaG91bGQgc2lnbiBhIHRyYW5zYWN0aW9uLiAnICsgJ1RoaXMgYmVoYXZpb3IgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIHJlbGVhc2UuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gc2lnbmVyOiBcIi5jb25jYXQoc2lnbmF0dXJlLnB1YmxpY0tleS50b1N0cmluZygpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKF9pdGVyYXRvci5zKCk7ICEoX3N0ZXAgPSBfaXRlcmF0b3IubigpKS5kb25lOykge1xuICAgICAgICAgIF9sb29wKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHZhciBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSAwO1xuICAgICAgdmFyIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSAwO1xuICAgICAgdmFyIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IDA7XG5cbiAgICAgIC8vIFNwbGl0IG91dCBzaWduaW5nIGZyb20gbm9uLXNpZ25pbmcga2V5cyBhbmQgY291bnQgaGVhZGVyIHZhbHVlc1xuICAgICAgdmFyIHNpZ25lZEtleXMgPSBbXTtcbiAgICAgIHZhciB1bnNpZ25lZEtleXMgPSBbXTtcbiAgICAgIHVuaXF1ZU1ldGFzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY2KSB7XG4gICAgICAgIHZhciBwdWJrZXkgPSBfcmVmNi5wdWJrZXksXG4gICAgICAgICAgaXNTaWduZXIgPSBfcmVmNi5pc1NpZ25lcixcbiAgICAgICAgICBpc1dyaXRhYmxlID0gX3JlZjYuaXNXcml0YWJsZTtcbiAgICAgICAgaWYgKGlzU2lnbmVyKSB7XG4gICAgICAgICAgc2lnbmVkS2V5cy5wdXNoKHB1YmtleS50b1N0cmluZygpKTtcbiAgICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMgKz0gMTtcbiAgICAgICAgICBpZiAoIWlzV3JpdGFibGUpIHtcbiAgICAgICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdW5zaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBhY2NvdW50S2V5cyA9IHNpZ25lZEtleXMuY29uY2F0KHVuc2lnbmVkS2V5cyk7XG4gICAgICB2YXIgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnMubWFwKGZ1bmN0aW9uIChpbnN0cnVjdGlvbikge1xuICAgICAgICB2YXIgZGF0YSA9IGluc3RydWN0aW9uLmRhdGEsXG4gICAgICAgICAgcHJvZ3JhbUlkID0gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHByb2dyYW1JZEluZGV4OiBhY2NvdW50S2V5cy5pbmRleE9mKHByb2dyYW1JZC50b1N0cmluZygpKSxcbiAgICAgICAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAoZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAgICAgICAgIHJldHVybiBhY2NvdW50S2V5cy5pbmRleE9mKG1ldGEucHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICAgIH0pLFxuICAgICAgICAgIGRhdGE6IGJzNTguZW5jb2RlKGRhdGEpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmZvckVhY2goZnVuY3Rpb24gKGluc3RydWN0aW9uKSB7XG4gICAgICAgIGFzc2VydChpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCA+PSAwKTtcbiAgICAgICAgaW5zdHJ1Y3Rpb24uYWNjb3VudHMuZm9yRWFjaChmdW5jdGlvbiAoa2V5SW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gYXNzZXJ0KGtleUluZGV4ID49IDApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgICAgaGVhZGVyOiB7XG4gICAgICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgICAgICB9LFxuICAgICAgICBhY2NvdW50S2V5czogYWNjb3VudEtleXMsXG4gICAgICAgIHJlY2VudEJsb2NraGFzaDogcmVjZW50QmxvY2toYXNoLFxuICAgICAgICBpbnN0cnVjdGlvbnM6IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfY29tcGlsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfY29tcGlsZSgpIHtcbiAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5jb21waWxlTWVzc2FnZSgpO1xuICAgICAgdmFyIHNpZ25lZEtleXMgPSBtZXNzYWdlLmFjY291bnRLZXlzLnNsaWNlKDAsIG1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA9PT0gc2lnbmVkS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbGlkID0gdGhpcy5zaWduYXR1cmVzLmV2ZXJ5KGZ1bmN0aW9uIChwYWlyLCBpbmRleCkge1xuICAgICAgICAgIHJldHVybiBzaWduZWRLZXlzW2luZGV4XS5lcXVhbHMocGFpci5wdWJsaWNLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHZhbGlkKSByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lZEtleXMubWFwKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzaWduYXR1cmU6IG51bGwsXG4gICAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG1lc3NhZ2U7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGEgYnVmZmVyIG9mIHRoZSBUcmFuc2FjdGlvbiBkYXRhIHRoYXQgbmVlZCB0byBiZSBjb3ZlcmVkIGJ5IHNpZ25hdHVyZXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNlcmlhbGl6ZU1lc3NhZ2UoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fY29tcGlsZSgpLnNlcmlhbGl6ZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgZXN0aW1hdGVkIGZlZSBhc3NvY2lhdGVkIHdpdGggYSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uIENvbm5lY3Rpb24gdG8gUlBDIEVuZHBvaW50LlxuICAgICAqXG4gICAgICogQHJldHVybnMge1Byb21pc2U8bnVtYmVyIHwgbnVsbD59IFRoZSBlc3RpbWF0ZWQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFc3RpbWF0ZWRGZWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRFc3RpbWF0ZWRGZWUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkNCgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjb25uZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDQoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmdldEZlZUZvck1lc3NhZ2UodGhpcy5jb21waWxlTWVzc2FnZSgpKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dC5zZW50LnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0RXN0aW1hdGVkRmVlKF94KSB7XG4gICAgICAgIHJldHVybiBfZ2V0RXN0aW1hdGVkRmVlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RXN0aW1hdGVkRmVlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFNwZWNpZnkgdGhlIHB1YmxpYyBrZXlzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzaWduIHRoZSBUcmFuc2FjdGlvbi5cbiAgICAgKiBUaGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZCBhcyB0aGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyIGFjY291bnQuXG4gICAgICpcbiAgICAgKiBTaWduYXR1cmVzIGNhbiBiZSBhZGRlZCB3aXRoIGVpdGhlciBgcGFydGlhbFNpZ25gIG9yIGBhZGRTaWduYXR1cmVgXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIHYwLjg0LjAuIE9ubHkgdGhlIGZlZSBwYXllciBuZWVkcyB0byBiZVxuICAgICAqIHNwZWNpZmllZCBhbmQgaXQgY2FuIGJlIHNldCBpbiB0aGUgVHJhbnNhY3Rpb24gY29uc3RydWN0b3Igb3Igd2l0aCB0aGVcbiAgICAgKiBgZmVlUGF5ZXJgIHByb3BlcnR5LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldFNpZ25lcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0U2lnbmVycygpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgc2lnbmVycyA9IG5ldyBBcnJheShfbGVuMiksIF9rZXkyID0gMDsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBzaWduZXJzW19rZXkyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG4gICAgICBpZiAoc2lnbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgICB9XG4gICAgICB2YXIgc2VlbiA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25lcnMuZmlsdGVyKGZ1bmN0aW9uIChwdWJsaWNLZXkpIHtcbiAgICAgICAgdmFyIGtleSA9IHB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzZWVuLmFkZChrZXkpO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHB1YmxpY0tleSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2lnbiB0aGUgVHJhbnNhY3Rpb24gd2l0aCB0aGUgc3BlY2lmaWVkIHNpZ25lcnMuIE11bHRpcGxlIHNpZ25hdHVyZXMgbWF5XG4gICAgICogYmUgYXBwbGllZCB0byBhIFRyYW5zYWN0aW9uLiBUaGUgZmlyc3Qgc2lnbmF0dXJlIGlzIGNvbnNpZGVyZWQgXCJwcmltYXJ5XCJcbiAgICAgKiBhbmQgaXMgdXNlZCBpZGVudGlmeSBhbmQgY29uZmlybSB0cmFuc2FjdGlvbnMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgVHJhbnNhY3Rpb24gYGZlZVBheWVyYCBpcyBub3Qgc2V0LCB0aGUgZmlyc3Qgc2lnbmVyIHdpbGwgYmUgdXNlZFxuICAgICAqIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIFRyYW5zYWN0aW9uIGZpZWxkcyBzaG91bGQgbm90IGJlIG1vZGlmaWVkIGFmdGVyIHRoZSBmaXJzdCBjYWxsIHRvIGBzaWduYCxcbiAgICAgKiBhcyBkb2luZyBzbyBtYXkgaW52YWxpZGF0ZSB0aGUgc2lnbmF0dXJlIGFuZCBjYXVzZSB0aGUgVHJhbnNhY3Rpb24gdG8gYmVcbiAgICAgKiByZWplY3RlZC5cbiAgICAgKlxuICAgICAqIFRoZSBUcmFuc2FjdGlvbiBtdXN0IGJlIGFzc2lnbmVkIGEgdmFsaWQgYHJlY2VudEJsb2NraGFzaGAgYmVmb3JlIGludm9raW5nIHRoaXMgbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5PFNpZ25lcj59IHNpZ25lcnMgQXJyYXkgb2Ygc2lnbmVycyB0aGF0IHdpbGwgc2lnbiB0aGUgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNpZ24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMyA9IGFyZ3VtZW50cy5sZW5ndGgsIHNpZ25lcnMgPSBuZXcgQXJyYXkoX2xlbjMpLCBfa2V5MyA9IDA7IF9rZXkzIDwgX2xlbjM7IF9rZXkzKyspIHtcbiAgICAgICAgc2lnbmVyc1tfa2V5M10gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgICAgdmFyIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICB2YXIgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfc2lnbmVycyA9IHNpZ25lcnM7IF9pIDwgX3NpZ25lcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBzaWduZXIgPSBfc2lnbmVyc1tfaV07XG4gICAgICAgIHZhciBrZXkgPSBzaWduZXIucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgICB1bmlxdWVTaWduZXJzLnB1c2goc2lnbmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5zaWduYXR1cmVzID0gdW5pcXVlU2lnbmVycy5tYXAoZnVuY3Rpb24gKHNpZ25lcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgICAgICBwdWJsaWNLZXk6IHNpZ25lci5wdWJsaWNLZXlcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgdmFyIG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgICB0aGlzLl9wYXJ0aWFsU2lnbi5hcHBseSh0aGlzLCBbbWVzc2FnZV0uY29uY2F0KHVuaXF1ZVNpZ25lcnMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJ0aWFsbHkgc2lnbiBhIHRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBhY2NvdW50cy4gQWxsIGFjY291bnRzIG11c3RcbiAgICAgKiBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogaW5zdHJ1Y3Rpb25zLlxuICAgICAqXG4gICAgICogQWxsIHRoZSBjYXZlYXRzIGZyb20gdGhlIGBzaWduYCBtZXRob2QgYXBwbHkgdG8gYHBhcnRpYWxTaWduYFxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzIEFycmF5IG9mIHNpZ25lcnMgdGhhdCB3aWxsIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicGFydGlhbFNpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcGFydGlhbFNpZ24oKSB7XG4gICAgICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIHNpZ25lcnMgPSBuZXcgQXJyYXkoX2xlbjQpLCBfa2V5NCA9IDA7IF9rZXk0IDwgX2xlbjQ7IF9rZXk0KyspIHtcbiAgICAgICAgc2lnbmVyc1tfa2V5NF0gPSBhcmd1bWVudHNbX2tleTRdO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2lnbmVycycpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgICAgdmFyIHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgICB2YXIgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX3NpZ25lcnMyID0gc2lnbmVyczsgX2kyIDwgX3NpZ25lcnMyLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgICAgdmFyIHNpZ25lciA9IF9zaWduZXJzMltfaTJdO1xuICAgICAgICB2YXIga2V5ID0gc2lnbmVyLnB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgICAgdGhpcy5fcGFydGlhbFNpZ24uYXBwbHkodGhpcywgW21lc3NhZ2VdLmNvbmNhdCh1bmlxdWVTaWduZXJzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3BhcnRpYWxTaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXJ0aWFsU2lnbihtZXNzYWdlKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgICBmb3IgKHZhciBfbGVuNSA9IGFyZ3VtZW50cy5sZW5ndGgsIHNpZ25lcnMgPSBuZXcgQXJyYXkoX2xlbjUgPiAxID8gX2xlbjUgLSAxIDogMCksIF9rZXk1ID0gMTsgX2tleTUgPCBfbGVuNTsgX2tleTUrKykge1xuICAgICAgICBzaWduZXJzW19rZXk1IC0gMV0gPSBhcmd1bWVudHNbX2tleTVdO1xuICAgICAgfVxuICAgICAgc2lnbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChzaWduZXIpIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHNpZ24oc2lnbkRhdGEsIHNpZ25lci5zZWNyZXRLZXkpO1xuICAgICAgICBfdGhpczIuX2FkZFNpZ25hdHVyZShzaWduZXIucHVibGljS2V5LCB0b0J1ZmZlcihzaWduYXR1cmUpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCBhbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGEgdHJhbnNhY3Rpb24uIFRoZSBwdWJsaWMga2V5XG4gICAgICogbXVzdCBjb3JyZXNwb25kIHRvIGVpdGhlciB0aGUgZmVlIHBheWVyIG9yIGEgc2lnbmVyIGFjY291bnQgaW4gdGhlIHRyYW5zYWN0aW9uXG4gICAgICogaW5zdHJ1Y3Rpb25zLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtQdWJsaWNLZXl9IHB1YmtleSBQdWJsaWMga2V5IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZSBBbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGFkZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkU2lnbmF0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSkge1xuICAgICAgdGhpcy5fY29tcGlsZSgpOyAvLyBFbnN1cmUgc2lnbmF0dXJlcyBhcnJheSBpcyBwb3B1bGF0ZWRcbiAgICAgIHRoaXMuX2FkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2FkZFNpZ25hdHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5zaWduYXR1cmVzLmZpbmRJbmRleChmdW5jdGlvbiAoc2lncGFpcikge1xuICAgICAgICByZXR1cm4gcHVia2V5LmVxdWFscyhzaWdwYWlyLnB1YmxpY0tleSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBzaWduZXI6IFwiLmNvbmNhdChwdWJrZXkudG9TdHJpbmcoKSkpO1xuICAgICAgfVxuICAgICAgdGhpcy5zaWduYXR1cmVzW2luZGV4XS5zaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFZlcmlmeSBzaWduYXR1cmVzIG9mIGEgVHJhbnNhY3Rpb25cbiAgICAgKiBPcHRpb25hbCBwYXJhbWV0ZXIgc3BlY2lmaWVzIGlmIHdlJ3JlIGV4cGVjdGluZyBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBvciBhIHBhcnRpYWxseSBzaWduZWQgb25lLlxuICAgICAqIElmIG5vIGJvb2xlYW4gaXMgcHJvdmlkZWQsIHdlIGV4cGVjdCBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvbiBieSBkZWZhdWx0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmVxdWlyZUFsbFNpZ25hdHVyZXM9dHJ1ZV0gUmVxdWlyZSBhIGZ1bGx5IHNpZ25lZCBUcmFuc2FjdGlvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInZlcmlmeVNpZ25hdHVyZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmVyaWZ5U2lnbmF0dXJlcyhyZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgICAgcmV0dXJuIHRoaXMuX3ZlcmlmeVNpZ25hdHVyZXModGhpcy5zZXJpYWxpemVNZXNzYWdlKCksIHJlcXVpcmVBbGxTaWduYXR1cmVzID09PSB1bmRlZmluZWQgPyB0cnVlIDogcmVxdWlyZUFsbFNpZ25hdHVyZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl92ZXJpZnlTaWduYXR1cmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF92ZXJpZnlTaWduYXR1cmVzKHNpZ25EYXRhLCByZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgICAgdmFyIF9pdGVyYXRvcjIgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlciQyKHRoaXMuc2lnbmF0dXJlcyksXG4gICAgICAgIF9zdGVwMjtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yMi5zKCk7ICEoX3N0ZXAyID0gX2l0ZXJhdG9yMi5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIF9zdGVwMiR2YWx1ZSA9IF9zdGVwMi52YWx1ZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZSA9IF9zdGVwMiR2YWx1ZS5zaWduYXR1cmUsXG4gICAgICAgICAgICBwdWJsaWNLZXkgPSBfc3RlcDIkdmFsdWUucHVibGljS2V5O1xuICAgICAgICAgIGlmIChzaWduYXR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghdmVyaWZ5KHNpZ25hdHVyZSwgc2lnbkRhdGEsIHB1YmxpY0tleS50b0J5dGVzKCkpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIF9pdGVyYXRvcjIuZigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2VyaWFsaXplIHRoZSBUcmFuc2FjdGlvbiBpbiB0aGUgd2lyZSBmb3JtYXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gW2NvbmZpZ10gQ29uZmlnIG9mIHRyYW5zYWN0aW9uLlxuICAgICAqXG4gICAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlcmlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXJpYWxpemUoY29uZmlnKSB7XG4gICAgICB2YXIgX09iamVjdCRhc3NpZ24gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogdHJ1ZSxcbiAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiB0cnVlXG4gICAgICAgIH0sIGNvbmZpZyksXG4gICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzID0gX09iamVjdCRhc3NpZ24ucmVxdWlyZUFsbFNpZ25hdHVyZXMsXG4gICAgICAgIHZlcmlmeVNpZ25hdHVyZXMgPSBfT2JqZWN0JGFzc2lnbi52ZXJpZnlTaWduYXR1cmVzO1xuICAgICAgdmFyIHNpZ25EYXRhID0gdGhpcy5zZXJpYWxpemVNZXNzYWdlKCk7XG4gICAgICBpZiAodmVyaWZ5U2lnbmF0dXJlcyAmJiAhdGhpcy5fdmVyaWZ5U2lnbmF0dXJlcyhzaWduRGF0YSwgcmVxdWlyZUFsbFNpZ25hdHVyZXMpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignU2lnbmF0dXJlIHZlcmlmaWNhdGlvbiBmYWlsZWQnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9zZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3NlcmlhbGl6ZShzaWduRGF0YSkge1xuICAgICAgdmFyIHNpZ25hdHVyZXMgPSB0aGlzLnNpZ25hdHVyZXM7XG4gICAgICB2YXIgc2lnbmF0dXJlQ291bnQgPSBbXTtcbiAgICAgIGVuY29kZUxlbmd0aChzaWduYXR1cmVDb3VudCwgc2lnbmF0dXJlcy5sZW5ndGgpO1xuICAgICAgdmFyIHRyYW5zYWN0aW9uTGVuZ3RoID0gc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgc2lnbmF0dXJlcy5sZW5ndGggKiA2NCArIHNpZ25EYXRhLmxlbmd0aDtcbiAgICAgIHZhciB3aXJlVHJhbnNhY3Rpb24gPSBCdWZmZXIuYWxsb2ModHJhbnNhY3Rpb25MZW5ndGgpO1xuICAgICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoIDwgMjU2KTtcbiAgICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZUNvdW50KS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgMCk7XG4gICAgICBzaWduYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKF9yZWY3LCBpbmRleCkge1xuICAgICAgICB2YXIgc2lnbmF0dXJlID0gX3JlZjcuc2lnbmF0dXJlO1xuICAgICAgICBpZiAoc2lnbmF0dXJlICE9PSBudWxsKSB7XG4gICAgICAgICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCBcInNpZ25hdHVyZSBoYXMgaW52YWxpZCBsZW5ndGhcIik7XG4gICAgICAgICAgQnVmZmVyLmZyb20oc2lnbmF0dXJlKS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgc2lnbmF0dXJlQ291bnQubGVuZ3RoICsgaW5kZXggKiA2NCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2lnbkRhdGEuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQpO1xuICAgICAgYXNzZXJ0KHdpcmVUcmFuc2FjdGlvbi5sZW5ndGggPD0gUEFDS0VUX0RBVEFfU0laRSwgXCJUcmFuc2FjdGlvbiB0b28gbGFyZ2U6IFwiLmNvbmNhdCh3aXJlVHJhbnNhY3Rpb24ubGVuZ3RoLCBcIiA+IFwiKS5jb25jYXQoUEFDS0VUX0RBVEFfU0laRSkpO1xuICAgICAgcmV0dXJuIHdpcmVUcmFuc2FjdGlvbjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImtleXNcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIGFzc2VydCh0aGlzLmluc3RydWN0aW9ucy5sZW5ndGggPT09IDEpO1xuICAgICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmtleXMubWFwKGZ1bmN0aW9uIChrZXlPYmopIHtcbiAgICAgICAgcmV0dXJuIGtleU9iai5wdWJrZXk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXByZWNhdGVkIG1ldGhvZFxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInByb2dyYW1JZFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGF0YVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0uZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIHdpcmUgdHJhbnNhY3Rpb24gaW50byBhIFRyYW5zYWN0aW9uIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUcmFuc2FjdGlvbiBhc3NvY2lhdGVkIHdpdGggdGhlIHNpZ25hdHVyZVxuICAgICAqL1xuICB9XSwgW3tcbiAgICBrZXk6IFwiZnJvbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tKGJ1ZmZlcikge1xuICAgICAgLy8gU2xpY2UgdXAgd2lyZSBkYXRhXG4gICAgICB2YXIgYnl0ZUFycmF5ID0gX3RvQ29uc3VtYWJsZUFycmF5KGJ1ZmZlcik7XG4gICAgICB2YXIgc2lnbmF0dXJlQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIHZhciBzaWduYXR1cmVzID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ25hdHVyZUNvdW50OyBpKyspIHtcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IGJ5dGVBcnJheS5zbGljZSgwLCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKTtcbiAgICAgICAgYnl0ZUFycmF5ID0gYnl0ZUFycmF5LnNsaWNlKFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpO1xuICAgICAgICBzaWduYXR1cmVzLnB1c2goYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20oc2lnbmF0dXJlKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBvcHVsYXRlKE1lc3NhZ2UuZnJvbShieXRlQXJyYXkpLCBzaWduYXR1cmVzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZSBUcmFuc2FjdGlvbiBvYmplY3QgZnJvbSBtZXNzYWdlIGFuZCBzaWduYXR1cmVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01lc3NhZ2V9IG1lc3NhZ2UgTWVzc2FnZSBvZiB0cmFuc2FjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc2lnbmF0dXJlcyBMaXN0IG9mIHNpZ25hdHVyZXMgdG8gYXNzaWduIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMge1RyYW5zYWN0aW9ufSBUaGUgcG9wdWxhdGVkIFRyYW5zYWN0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicG9wdWxhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcG9wdWxhdGUobWVzc2FnZSkge1xuICAgICAgdmFyIHNpZ25hdHVyZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFtdO1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIGlmIChtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gbWVzc2FnZS5hY2NvdW50S2V5c1swXTtcbiAgICAgIH1cbiAgICAgIHNpZ25hdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAoc2lnbmF0dXJlLCBpbmRleCkge1xuICAgICAgICB2YXIgc2lnUHVia2V5UGFpciA9IHtcbiAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSA9PSBiczU4LmVuY29kZShERUZBVUxUX1NJR05BVFVSRSkgPyBudWxsIDogYnM1OC5kZWNvZGUoc2lnbmF0dXJlKSxcbiAgICAgICAgICBwdWJsaWNLZXk6IG1lc3NhZ2UuYWNjb3VudEtleXNbaW5kZXhdXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ25hdHVyZXMucHVzaChzaWdQdWJrZXlQYWlyKTtcbiAgICAgIH0pO1xuICAgICAgbWVzc2FnZS5pbnN0cnVjdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgICAgdmFyIGtleXMgPSBpbnN0cnVjdGlvbi5hY2NvdW50cy5tYXAoZnVuY3Rpb24gKGFjY291bnQpIHtcbiAgICAgICAgICB2YXIgcHVia2V5ID0gbWVzc2FnZS5hY2NvdW50S2V5c1thY2NvdW50XTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcHVia2V5OiBwdWJrZXksXG4gICAgICAgICAgICBpc1NpZ25lcjogdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5zb21lKGZ1bmN0aW9uIChrZXlPYmopIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGtleU9iai5wdWJsaWNLZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KSB8fCBtZXNzYWdlLmlzQWNjb3VudFNpZ25lcihhY2NvdW50KSxcbiAgICAgICAgICAgIGlzV3JpdGFibGU6IG1lc3NhZ2UuaXNBY2NvdW50V3JpdGFibGUoYWNjb3VudClcbiAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNhY3Rpb24uaW5zdHJ1Y3Rpb25zLnB1c2gobmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgICAgcHJvZ3JhbUlkOiBtZXNzYWdlLmFjY291bnRLZXlzW2luc3RydWN0aW9uLnByb2dyYW1JZEluZGV4XSxcbiAgICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKVxuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9uLl9tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgIHRyYW5zYWN0aW9uLl9qc29uID0gdHJhbnNhY3Rpb24udG9KU09OKCk7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBUcmFuc2FjdGlvbjtcbn0oKTtcblxuZnVuY3Rpb24gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkkMShvKSkgfHwgYWxsb3dBcnJheUxpa2UgJiYgbyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHsgaWYgKGl0KSBvID0gaXQ7IHZhciBpID0gMDsgdmFyIEYgPSBmdW5jdGlvbiBGKCkge307IHJldHVybiB7IHM6IEYsIG46IGZ1bmN0aW9uIG4oKSB7IGlmIChpID49IG8ubGVuZ3RoKSByZXR1cm4geyBkb25lOiB0cnVlIH07IHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogb1tpKytdIH07IH0sIGU6IGZ1bmN0aW9uIGUoX2UpIHsgdGhyb3cgX2U7IH0sIGY6IEYgfTsgfSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7IH0gdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLCBkaWRFcnIgPSBmYWxzZSwgZXJyOyByZXR1cm4geyBzOiBmdW5jdGlvbiBzKCkgeyBpdCA9IGl0LmNhbGwobyk7IH0sIG46IGZ1bmN0aW9uIG4oKSB7IHZhciBzdGVwID0gaXQubmV4dCgpOyBub3JtYWxDb21wbGV0aW9uID0gc3RlcC5kb25lOyByZXR1cm4gc3RlcDsgfSwgZTogZnVuY3Rpb24gZShfZTIpIHsgZGlkRXJyID0gdHJ1ZTsgZXJyID0gX2UyOyB9LCBmOiBmdW5jdGlvbiBmKCkgeyB0cnkgeyBpZiAoIW5vcm1hbENvbXBsZXRpb24gJiYgaXRbXCJyZXR1cm5cIl0gIT0gbnVsbCkgaXRbXCJyZXR1cm5cIl0oKTsgfSBmaW5hbGx5IHsgaWYgKGRpZEVycikgdGhyb3cgZXJyOyB9IH0gfTsgfVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5JDEobywgbWluTGVuKSB7IGlmICghbykgcmV0dXJuOyBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheSQxKG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkkMShvLCBtaW5MZW4pOyB9XG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheSQxKGFyciwgbGVuKSB7IGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoOyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07IHJldHVybiBhcnIyOyB9XG52YXIgVHJhbnNhY3Rpb25NZXNzYWdlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gVHJhbnNhY3Rpb25NZXNzYWdlKGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVHJhbnNhY3Rpb25NZXNzYWdlKTtcbiAgICB0aGlzLnBheWVyS2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMucGF5ZXJLZXkgPSBhcmdzLnBheWVyS2V5O1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSBhcmdzLnJlY2VudEJsb2NraGFzaDtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVHJhbnNhY3Rpb25NZXNzYWdlLCBbe1xuICAgIGtleTogXCJjb21waWxlVG9MZWdhY3lNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbXBpbGVUb0xlZ2FjeU1lc3NhZ2UoKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZS5jb21waWxlKHtcbiAgICAgICAgcGF5ZXJLZXk6IHRoaXMucGF5ZXJLZXksXG4gICAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb21waWxlVG9WME1lc3NhZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29tcGlsZVRvVjBNZXNzYWdlKGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZVYwLmNvbXBpbGUoe1xuICAgICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucyxcbiAgICAgICAgYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHM6IGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzXG4gICAgICB9KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJkZWNvbXBpbGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb21waWxlKG1lc3NhZ2UsIGFyZ3MpIHtcbiAgICAgIHZhciBoZWFkZXIgPSBtZXNzYWdlLmhlYWRlcixcbiAgICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBtZXNzYWdlLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgICByZWNlbnRCbG9ja2hhc2ggPSBtZXNzYWdlLnJlY2VudEJsb2NraGFzaDtcbiAgICAgIHZhciBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPSBoZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICBudW1SZWFkb25seVNpZ25lZEFjY291bnRzID0gaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyA9IGhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICB2YXIgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICBhc3NlcnQobnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA+IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgICB2YXIgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgLSBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICBhc3NlcnQobnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID49IDAsICdNZXNzYWdlIGhlYWRlciBpcyBpbnZhbGlkJyk7XG4gICAgICB2YXIgYWNjb3VudEtleXMgPSBtZXNzYWdlLmdldEFjY291bnRLZXlzKGFyZ3MpO1xuICAgICAgdmFyIHBheWVyS2V5ID0gYWNjb3VudEtleXMuZ2V0KDApO1xuICAgICAgaWYgKHBheWVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZGVjb21waWxlIG1lc3NhZ2UgYmVjYXVzZSBubyBhY2NvdW50IGtleXMgd2VyZSBmb3VuZCcpO1xuICAgICAgfVxuICAgICAgdmFyIGluc3RydWN0aW9ucyA9IFtdO1xuICAgICAgdmFyIF9pdGVyYXRvciA9IF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyJDEoY29tcGlsZWRJbnN0cnVjdGlvbnMpLFxuICAgICAgICBfc3RlcDtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgdmFyIGNvbXBpbGVkSXggPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgIHZhciBfaXRlcmF0b3IyID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIkMShjb21waWxlZEl4LmFjY291bnRLZXlJbmRleGVzKSxcbiAgICAgICAgICAgIF9zdGVwMjtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yIChfaXRlcmF0b3IyLnMoKTsgIShfc3RlcDIgPSBfaXRlcmF0b3IyLm4oKSkuZG9uZTspIHtcbiAgICAgICAgICAgICAgdmFyIGtleUluZGV4ID0gX3N0ZXAyLnZhbHVlO1xuICAgICAgICAgICAgICB2YXIgcHVia2V5ID0gYWNjb3VudEtleXMuZ2V0KGtleUluZGV4KTtcbiAgICAgICAgICAgICAgaWYgKHB1YmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmFpbGVkIHRvIGZpbmQga2V5IGZvciBhY2NvdW50IGtleSBpbmRleCBcIi5jb25jYXQoa2V5SW5kZXgpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2YXIgaXNTaWduZXIgPSBrZXlJbmRleCA8IG51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICAgICAgICAgICAgdmFyIGlzV3JpdGFibGUgPSB2b2lkIDA7XG4gICAgICAgICAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5SW5kZXggPCBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoIDxcbiAgICAgICAgICAgICAgICAvLyBhY2NvdW50S2V5c0Zyb21Mb29rdXBzIGNhbm5vdCBiZSB1bmRlZmluZWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGZvdW5kIGEgcHVia2V5IGZvciB0aGlzIGluZGV4IGFib3ZlXG4gICAgICAgICAgICAgICAgYWNjb3VudEtleXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBwdWJrZXk6IHB1YmtleSxcbiAgICAgICAgICAgICAgICBpc1NpZ25lcjoga2V5SW5kZXggPCBoZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgICAgICAgICAgIGlzV3JpdGFibGU6IGlzV3JpdGFibGVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfaXRlcmF0b3IyLmUoZXJyKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgX2l0ZXJhdG9yMi5mKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBwcm9ncmFtSWQgPSBhY2NvdW50S2V5cy5nZXQoY29tcGlsZWRJeC5wcm9ncmFtSWRJbmRleCk7XG4gICAgICAgICAgaWYgKHByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gZmluZCBwcm9ncmFtIGlkIGZvciBwcm9ncmFtIGlkIGluZGV4IFwiLmNvbmNhdChjb21waWxlZEl4LnByb2dyYW1JZEluZGV4KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgICAgIHByb2dyYW1JZDogcHJvZ3JhbUlkLFxuICAgICAgICAgICAgZGF0YTogdG9CdWZmZXIoY29tcGlsZWRJeC5kYXRhKSxcbiAgICAgICAgICAgIGtleXM6IGtleXNcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBfaXRlcmF0b3IuZShlcnIpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgX2l0ZXJhdG9yLmYoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25NZXNzYWdlKHtcbiAgICAgICAgcGF5ZXJLZXk6IHBheWVyS2V5LFxuICAgICAgICBpbnN0cnVjdGlvbnM6IGluc3RydWN0aW9ucyxcbiAgICAgICAgcmVjZW50QmxvY2toYXNoOiByZWNlbnRCbG9ja2hhc2hcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVHJhbnNhY3Rpb25NZXNzYWdlO1xufSgpO1xuXG5mdW5jdGlvbiBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihvLCBhbGxvd0FycmF5TGlrZSkgeyB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXSB8fCBvW1wiQEBpdGVyYXRvclwiXTsgaWYgKCFpdCkgeyBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSB7IGlmIChpdCkgbyA9IGl0OyB2YXIgaSA9IDA7IHZhciBGID0gZnVuY3Rpb24gRigpIHt9OyByZXR1cm4geyBzOiBGLCBuOiBmdW5jdGlvbiBuKCkgeyBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHsgZG9uZTogdHJ1ZSB9OyByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IG9baSsrXSB9OyB9LCBlOiBmdW5jdGlvbiBlKF9lKSB7IHRocm93IF9lOyB9LCBmOiBGIH07IH0gdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBpdGVyYXRlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpOyB9IHZhciBub3JtYWxDb21wbGV0aW9uID0gdHJ1ZSwgZGlkRXJyID0gZmFsc2UsIGVycjsgcmV0dXJuIHsgczogZnVuY3Rpb24gcygpIHsgaXQgPSBpdC5jYWxsKG8pOyB9LCBuOiBmdW5jdGlvbiBuKCkgeyB2YXIgc3RlcCA9IGl0Lm5leHQoKTsgbm9ybWFsQ29tcGxldGlvbiA9IHN0ZXAuZG9uZTsgcmV0dXJuIHN0ZXA7IH0sIGU6IGZ1bmN0aW9uIGUoX2UyKSB7IGRpZEVyciA9IHRydWU7IGVyciA9IF9lMjsgfSwgZjogZnVuY3Rpb24gZigpIHsgdHJ5IHsgaWYgKCFub3JtYWxDb21wbGV0aW9uICYmIGl0W1wicmV0dXJuXCJdICE9IG51bGwpIGl0W1wicmV0dXJuXCJdKCk7IH0gZmluYWxseSB7IGlmIChkaWRFcnIpIHRocm93IGVycjsgfSB9IH07IH1cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHsgaWYgKCFvKSByZXR1cm47IGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7IHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTsgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTsgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7IGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTsgfVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHsgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTsgcmV0dXJuIGFycjI7IH1cbi8qKlxuICogVmVyc2lvbmVkIHRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbnZhciBWZXJzaW9uZWRUcmFuc2FjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZlcnNpb25lZFRyYW5zYWN0aW9uKG1lc3NhZ2UsIHNpZ25hdHVyZXMpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVmVyc2lvbmVkVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHZvaWQgMDtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgaWYgKHNpZ25hdHVyZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgYXNzZXJ0KHNpZ25hdHVyZXMubGVuZ3RoID09PSBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMsICdFeHBlY3RlZCBzaWduYXR1cmVzIGxlbmd0aCB0byBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHJlcXVpcmVkIHNpZ25hdHVyZXMnKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IHNpZ25hdHVyZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBkZWZhdWx0U2lnbmF0dXJlcyA9IFtdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7IGkrKykge1xuICAgICAgICBkZWZhdWx0U2lnbmF0dXJlcy5wdXNoKG5ldyBVaW50OEFycmF5KFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IGRlZmF1bHRTaWduYXR1cmVzO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhWZXJzaW9uZWRUcmFuc2FjdGlvbiwgW3tcbiAgICBrZXk6IFwidmVyc2lvblwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZS52ZXJzaW9uO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2VyaWFsaXplKCkge1xuICAgICAgdmFyIHNlcmlhbGl6ZWRNZXNzYWdlID0gdGhpcy5tZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgICAgdmFyIGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCwgdGhpcy5zaWduYXR1cmVzLmxlbmd0aCk7XG4gICAgICB2YXIgdHJhbnNhY3Rpb25MYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aC5sZW5ndGgsICdlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKHNpZ25hdHVyZSgpLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoLCAnc2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihzZXJpYWxpemVkTWVzc2FnZS5sZW5ndGgsICdzZXJpYWxpemVkTWVzc2FnZScpXSk7XG4gICAgICB2YXIgc2VyaWFsaXplZFRyYW5zYWN0aW9uID0gbmV3IFVpbnQ4QXJyYXkoMjA0OCk7XG4gICAgICB2YXIgc2VyaWFsaXplZFRyYW5zYWN0aW9uTGVuZ3RoID0gdHJhbnNhY3Rpb25MYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoKSxcbiAgICAgICAgc2lnbmF0dXJlczogdGhpcy5zaWduYXR1cmVzLFxuICAgICAgICBzZXJpYWxpemVkTWVzc2FnZTogc2VyaWFsaXplZE1lc3NhZ2VcbiAgICAgIH0sIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZFRyYW5zYWN0aW9uLnNsaWNlKDAsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNpZ25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2lnbiQxKHNpZ25lcnMpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgbWVzc2FnZURhdGEgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgICB2YXIgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgICB2YXIgX2l0ZXJhdG9yID0gX2NyZWF0ZUZvck9mSXRlcmF0b3JIZWxwZXIoc2lnbmVycyksXG4gICAgICAgIF9zdGVwO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AoKSB7XG4gICAgICAgICAgdmFyIHNpZ25lciA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIHZhciBzaWduZXJJbmRleCA9IHNpZ25lclB1YmtleXMuZmluZEluZGV4KGZ1bmN0aW9uIChwdWJrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBwdWJrZXkuZXF1YWxzKHNpZ25lci5wdWJsaWNLZXkpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFzc2VydChzaWduZXJJbmRleCA+PSAwLCBcIkNhbm5vdCBzaWduIHdpdGggbm9uIHNpZ25lciBrZXkgXCIuY29uY2F0KHNpZ25lci5wdWJsaWNLZXkudG9CYXNlNTgoKSkpO1xuICAgICAgICAgIF90aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbihtZXNzYWdlRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgICAgIH07XG4gICAgICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XG4gICAgICAgICAgX2xvb3AoKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIF9pdGVyYXRvci5lKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBfaXRlcmF0b3IuZigpO1xuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRTaWduYXR1cmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkU2lnbmF0dXJlKHB1YmxpY0tleSwgc2lnbmF0dXJlKSB7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlLmJ5dGVMZW5ndGggPT09IDY0LCAnU2lnbmF0dXJlIG11c3QgYmUgNjQgYnl0ZXMgbG9uZycpO1xuICAgICAgdmFyIHNpZ25lclB1YmtleXMgPSB0aGlzLm1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMuc2xpY2UoMCwgdGhpcy5tZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgICAgdmFyIHNpZ25lckluZGV4ID0gc2lnbmVyUHVia2V5cy5maW5kSW5kZXgoZnVuY3Rpb24gKHB1YmtleSkge1xuICAgICAgICByZXR1cm4gcHVia2V5LmVxdWFscyhwdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgXCJDYW4gbm90IGFkZCBzaWduYXR1cmU7IGBcIi5jb25jYXQocHVibGljS2V5LnRvQmFzZTU4KCksIFwiYCBpcyBub3QgcmVxdWlyZWQgdG8gc2lnbiB0aGlzIHRyYW5zYWN0aW9uXCIpKTtcbiAgICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduYXR1cmU7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZGVzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZFRyYW5zYWN0aW9uKSB7XG4gICAgICB2YXIgYnl0ZUFycmF5ID0gX3RvQ29uc3VtYWJsZUFycmF5KHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgICB2YXIgc2lnbmF0dXJlcyA9IFtdO1xuICAgICAgdmFyIHNpZ25hdHVyZXNMZW5ndGggPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNpZ25hdHVyZXMucHVzaChuZXcgVWludDhBcnJheShieXRlQXJyYXkuc3BsaWNlKDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKSk7XG4gICAgICB9XG4gICAgICB2YXIgbWVzc2FnZSA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUobmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KSk7XG4gICAgICByZXR1cm4gbmV3IFZlcnNpb25lZFRyYW5zYWN0aW9uKG1lc3NhZ2UsIHNpZ25hdHVyZXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmVyc2lvbmVkVHJhbnNhY3Rpb247XG59KCk7XG5cbi8vIFRPRE86IFRoZXNlIGNvbnN0YW50cyBzaG91bGQgYmUgcmVtb3ZlZCBpbiBmYXZvciBvZiByZWFkaW5nIHRoZW0gb3V0IG9mIGFcbi8vIFN5c2NhbGwgYWNjb3VudFxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgTlVNX1RJQ0tTX1BFUl9TRUNPTkQgPSAxNjA7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UID0gNjQ7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBOVU1fU0xPVFNfUEVSX1NFQ09ORCA9IE5VTV9USUNLU19QRVJfU0VDT05EIC8gREVGQVVMVF9USUNLU19QRVJfU0xPVDtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIE1TX1BFUl9TTE9UID0gMTAwMCAvIE5VTV9TTE9UU19QRVJfU0VDT05EO1xuXG52YXIgU1lTVkFSX0NMT0NLX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbnZhciBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyRXBvY2hTY2hlZHUxZTExMTExMTExMTExMTExMTExMTExMTExMScpO1xudmFyIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyMW5zdHJ1Y3Rpb25zMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xudmFyIFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMScpO1xudmFyIFNZU1ZBUl9SRU5UX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclJlbnQxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbnZhciBTWVNWQVJfUkVXQVJEU19QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJSZXdhcmRzMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG52YXIgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbnZhciBTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbnZhciBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJTdGFrZUhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUkMygpIHsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lJDMgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG4vKipcbiAqIFNpZ24sIHNlbmQgYW5kIGNvbmZpcm0gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzXG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX3NlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCkge1xuICBfc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQzKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNvbm5lY3Rpb24sIHRyYW5zYWN0aW9uLCBzaWduZXJzLCBvcHRpb25zKSB7XG4gICAgdmFyIHNlbmRPcHRpb25zLCBzaWduYXR1cmUsIHN0YXR1cywgbm9uY2VJbnN0cnVjdGlvbiwgbm9uY2VBY2NvdW50UHVia2V5O1xuICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDMoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgc2VuZE9wdGlvbnMgPSBvcHRpb25zICYmIHtcbiAgICAgICAgICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICAgICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgICAgICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgICAgICAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICAgICAgICAgIH07XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBzaWduZXJzLCBzZW5kT3B0aW9ucyk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzaWduYXR1cmUgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgIGlmICghKHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ICE9IG51bGwpKSB7XG4gICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDc7XG4gICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgIGFib3J0U2lnbmFsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgICAgICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgc3RhdHVzID0gX2NvbnRleHQuc2VudC52YWx1ZTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgaWYgKCEodHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCAhPSBudWxsICYmIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyAhPSBudWxsKSkge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDE4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vbmNlSW5zdHJ1Y3Rpb24gPSB0cmFuc2FjdGlvbi5ub25jZUluZm8ubm9uY2VJbnN0cnVjdGlvbjtcbiAgICAgICAgICBub25jZUFjY291bnRQdWJrZXkgPSBub25jZUluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5O1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgYWJvcnRTaWduYWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIG1pbkNvbnRleHRTbG90OiB0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90LFxuICAgICAgICAgICAgbm9uY2VBY2NvdW50UHVia2V5OiBub25jZUFjY291bnRQdWJrZXksXG4gICAgICAgICAgICBub25jZVZhbHVlOiB0cmFuc2FjdGlvbi5ub25jZUluZm8ubm9uY2UsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KTtcbiAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICBzdGF0dXMgPSBfY29udGV4dC5zZW50LnZhbHVlO1xuICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hYm9ydFNpZ25hbCkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKCk6IEEgdHJhbnNhY3Rpb24gd2l0aCBhIGRlcHJlY2F0ZWQgY29uZmlybWF0aW9uIHN0cmF0ZWd5IHdhcyAnICsgJ3N1cHBsaWVkIGFsb25nIHdpdGggYW4gYGFib3J0U2lnbmFsYC4gT25seSB0cmFuc2FjdGlvbnMgaGF2aW5nIGBsYXN0VmFsaWRCbG9ja0hlaWdodGAgJyArICdvciBhIGNvbWJpbmF0aW9uIG9mIGBub25jZUluZm9gIGFuZCBgbWluTm9uY2VDb250ZXh0U2xvdGAgYXJlIGFib3J0YWJsZS4nKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIxO1xuICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KTtcbiAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICBzdGF0dXMgPSBfY29udGV4dC5zZW50LnZhbHVlO1xuICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgIGlmICghc3RhdHVzLmVycikge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI0O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRyYW5zYWN0aW9uIFwiLmNvbmNhdChzaWduYXR1cmUsIFwiIGZhaWxlZCAoXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShzdGF0dXMpLCBcIilcIikpO1xuICAgICAgICBjYXNlIDI0OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICB9XG4gICAgfSwgX2NhbGxlZSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9zZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbi8vIHp6elxuZnVuY3Rpb24gc2xlZXAobXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIFBvcHVsYXRlIGEgYnVmZmVyIG9mIGluc3RydWN0aW9uIGRhdGEgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5jb2RlRGF0YSh0eXBlLCBmaWVsZHMpIHtcbiAgdmFyIGFsbG9jTGVuZ3RoID0gdHlwZS5sYXlvdXQuc3BhbiA+PSAwID8gdHlwZS5sYXlvdXQuc3BhbiA6IGdldEFsbG9jKHR5cGUsIGZpZWxkcyk7XG4gIHZhciBkYXRhID0gQnVmZmVyLmFsbG9jKGFsbG9jTGVuZ3RoKTtcbiAgdmFyIGxheW91dEZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGluc3RydWN0aW9uOiB0eXBlLmluZGV4XG4gIH0sIGZpZWxkcyk7XG4gIHR5cGUubGF5b3V0LmVuY29kZShsYXlvdXRGaWVsZHMsIGRhdGEpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBEZWNvZGUgaW5zdHJ1Y3Rpb24gZGF0YSBidWZmZXIgdXNpbmcgYW4gSW5zdHJ1Y3Rpb25UeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSQxKHR5cGUsIGJ1ZmZlcikge1xuICB2YXIgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gdHlwZS5sYXlvdXQuZGVjb2RlKGJ1ZmZlcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRhdGEuaW5zdHJ1Y3Rpb24gIT09IHR5cGUuaW5kZXgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluc3RydWN0aW9uOyBpbnN0cnVjdGlvbiBpbmRleCBtaXNtYXRjaCBcIi5jb25jYXQoZGF0YS5pbnN0cnVjdGlvbiwgXCIgIT0gXCIpLmNvbmNhdCh0eXBlLmluZGV4KSk7XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzkwYmVkZDdlMDY3YjViOGYzZGRiYjQ1ZGEwMGE0ZTljYWJiMjJjNjIvc2RrL3NyYy9mZWVfY2FsY3VsYXRvci5ycyNMNy1MMTFcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIEZlZUNhbGN1bGF0b3JMYXlvdXQgPSBCdWZmZXJMYXlvdXQubnU2NCgnbGFtcG9ydHNQZXJTaWduYXR1cmUnKTtcblxuLyoqXG4gKiBDYWxjdWxhdG9yIGZvciB0cmFuc2FjdGlvbiBmZWVzLlxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC5cbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvMGVhMjg0M2VjOWNkYzUxNzU3MmI4ZTYyYzk1OWY0MWI1NWNmNDQ1My9zZGsvc3JjL25vbmNlX3N0YXRlLnJzI0wyOS1MMzJcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIE5vbmNlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3ZlcnNpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignc3RhdGUnKSwgcHVibGljS2V5KCdhdXRob3JpemVkUHVia2V5JyksIHB1YmxpY0tleSgnbm9uY2UnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbRmVlQ2FsY3VsYXRvckxheW91dF0sICdmZWVDYWxjdWxhdG9yJyldKTtcbnZhciBOT05DRV9BQ0NPVU5UX0xFTkdUSCA9IE5vbmNlQWNjb3VudExheW91dC5zcGFuO1xuXG4vKipcbiAqIEEgZHVyYWJsZSBub25jZSBpcyBhIDMyIGJ5dGUgdmFsdWUgZW5jb2RlZCBhcyBhIGJhc2U1OCBzdHJpbmcuXG4gKi9cblxuLyoqXG4gKiBOb25jZUFjY291bnQgY2xhc3NcbiAqL1xudmFyIE5vbmNlQWNjb3VudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIE5vbmNlQWNjb3VudChhcmdzKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vbmNlQWNjb3VudCk7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IGFyZ3MuYXV0aG9yaXplZFB1YmtleTtcbiAgICB0aGlzLm5vbmNlID0gYXJncy5ub25jZTtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSBhcmdzLmZlZUNhbGN1bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgTm9uY2VBY2NvdW50IGZyb20gdGhlIGFjY291bnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBOb25jZUFjY291bnRcbiAgICovXG4gIF9jcmVhdGVDbGFzcyhOb25jZUFjY291bnQsIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21BY2NvdW50RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgICB2YXIgbm9uY2VBY2NvdW50ID0gTm9uY2VBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCAwKTtcbiAgICAgIHJldHVybiBuZXcgTm9uY2VBY2NvdW50KHtcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShub25jZUFjY291bnQuYXV0aG9yaXplZFB1YmtleSksXG4gICAgICAgIG5vbmNlOiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5ub25jZSkudG9TdHJpbmcoKSxcbiAgICAgICAgZmVlQ2FsY3VsYXRvcjogbm9uY2VBY2NvdW50LmZlZUNhbGN1bGF0b3JcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTm9uY2VBY2NvdW50O1xufSgpO1xuXG52YXIgZW5jb2RlRGVjb2RlID0gZnVuY3Rpb24gZW5jb2RlRGVjb2RlKGxheW91dCkge1xuICB2YXIgZGVjb2RlID0gbGF5b3V0LmRlY29kZS5iaW5kKGxheW91dCk7XG4gIHZhciBlbmNvZGUgPSBsYXlvdXQuZW5jb2RlLmJpbmQobGF5b3V0KTtcbiAgcmV0dXJuIHtcbiAgICBkZWNvZGU6IGRlY29kZSxcbiAgICBlbmNvZGU6IGVuY29kZVxuICB9O1xufTtcbnZhciBiaWdJbnQgPSBmdW5jdGlvbiBiaWdJbnQobGVuZ3RoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocHJvcGVydHkpIHtcbiAgICB2YXIgbGF5b3V0ID0gYmxvYihsZW5ndGgsIHByb3BlcnR5KTtcbiAgICB2YXIgX2VuY29kZURlY29kZSA9IGVuY29kZURlY29kZShsYXlvdXQpLFxuICAgICAgZW5jb2RlID0gX2VuY29kZURlY29kZS5lbmNvZGUsXG4gICAgICBkZWNvZGUgPSBfZW5jb2RlRGVjb2RlLmRlY29kZTtcbiAgICB2YXIgYmlnSW50TGF5b3V0ID0gbGF5b3V0O1xuICAgIGJpZ0ludExheW91dC5kZWNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzcmMgPSBkZWNvZGUoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgcmV0dXJuIHRvQmlnSW50TEUoQnVmZmVyLmZyb20oc3JjKSk7XG4gICAgfTtcbiAgICBiaWdJbnRMYXlvdXQuZW5jb2RlID0gZnVuY3Rpb24gKGJpZ0ludCwgYnVmZmVyLCBvZmZzZXQpIHtcbiAgICAgIHZhciBzcmMgPSB0b0J1ZmZlckxFKGJpZ0ludCwgbGVuZ3RoKTtcbiAgICAgIHJldHVybiBlbmNvZGUoc3JjLCBidWZmZXIsIG9mZnNldCk7XG4gICAgfTtcbiAgICByZXR1cm4gYmlnSW50TGF5b3V0O1xuICB9O1xufTtcbnZhciB1NjQgPSBiaWdJbnQoOCk7XG5cbi8qKlxuICogQ3JlYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVHJhbnNmZXIgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXNzaWduIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgbm9uY2UgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZSBub25jZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFkdmFuY2Ugbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBXaXRoZHJhdyBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEF1dGhvcml6ZSBub25jZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQWxsb2NhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXNzaWduIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqIERlY29kZWQgdHJhbnNmZXIgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyV2l0aFNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uICovXG5cbi8qKlxuICogU3lzdGVtIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbnZhciBTeXN0ZW1JbnN0cnVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIFN5c3RlbUluc3RydWN0aW9uKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTeXN0ZW1JbnN0cnVjdGlvbik7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhTeXN0ZW1JbnN0cnVjdGlvbiwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdmFyIGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgICB2YXIgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX09iamVjdCRlbnRyaWVzW19pXSwgMiksXG4gICAgICAgICAgaXhUeXBlID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGxheW91dCA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcbiAgICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3lzdGVtSW5zdHJ1Y3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVDcmVhdGVBY2NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUNyZWF0ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgICB2YXIgX2RlY29kZURhdGEgPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlLCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgbGFtcG9ydHMgPSBfZGVjb2RlRGF0YS5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2UgPSBfZGVjb2RlRGF0YS5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkID0gX2RlY29kZURhdGEucHJvZ3JhbUlkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgICBsYW1wb3J0czogbGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBzcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgdHJhbnNmZXIgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVRyYW5zZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZVRyYW5zZmVyKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgICAgdmFyIF9kZWNvZGVEYXRhMiA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlciwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGxhbXBvcnRzID0gX2RlY29kZURhdGEyLmxhbXBvcnRzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGxhbXBvcnRzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHRyYW5zZmVyIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlVHJhbnNmZXJXaXRoU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgICAgdmFyIF9kZWNvZGVEYXRhMyA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgbGFtcG9ydHMgPSBfZGVjb2RlRGF0YTMubGFtcG9ydHMsXG4gICAgICAgIHNlZWQgPSBfZGVjb2RlRGF0YTMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkID0gX2RlY29kZURhdGEzLnByb2dyYW1JZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgICBsYW1wb3J0czogbGFtcG9ydHMsXG4gICAgICAgIHNlZWQ6IHNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhbiBhbGxvY2F0ZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlQWxsb2NhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlQWxsb2NhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgICB2YXIgX2RlY29kZURhdGE0ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgc3BhY2UgPSBfZGVjb2RlRGF0YTQuc3BhY2U7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgc3BhY2U6IHNwYWNlXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhbiBhbGxvY2F0ZSB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUFsbG9jYXRlV2l0aFNlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlQWxsb2NhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTUgPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGJhc2UgPSBfZGVjb2RlRGF0YTUuYmFzZSxcbiAgICAgICAgc2VlZCA9IF9kZWNvZGVEYXRhNS5zZWVkLFxuICAgICAgICBzcGFjZSA9IF9kZWNvZGVEYXRhNS5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkID0gX2RlY29kZURhdGE1LnByb2dyYW1JZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFjY291bnRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBuZXcgUHVibGljS2V5KGJhc2UpLFxuICAgICAgICBzZWVkOiBzZWVkLFxuICAgICAgICBzcGFjZTogc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhbiBhc3NpZ24gc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUFzc2lnblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBc3NpZ24oaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgICB2YXIgX2RlY29kZURhdGE2ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbiwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIHByb2dyYW1JZCA9IF9kZWNvZGVEYXRhNi5wcm9ncmFtSWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGFuIGFzc2lnbiB3aXRoIHNlZWQgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUFzc2lnbldpdGhTZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUFzc2lnbldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgICAgdmFyIF9kZWNvZGVEYXRhNyA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ25XaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGJhc2UgPSBfZGVjb2RlRGF0YTcuYmFzZSxcbiAgICAgICAgc2VlZCA9IF9kZWNvZGVEYXRhNy5zZWVkLFxuICAgICAgICBwcm9ncmFtSWQgPSBfZGVjb2RlRGF0YTcucHJvZ3JhbUlkO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICAgIHNlZWQ6IHNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlQ3JlYXRlV2l0aFNlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlQ3JlYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgICB2YXIgX2RlY29kZURhdGE4ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgYmFzZSA9IF9kZWNvZGVEYXRhOC5iYXNlLFxuICAgICAgICBzZWVkID0gX2RlY29kZURhdGE4LnNlZWQsXG4gICAgICAgIGxhbXBvcnRzID0gX2RlY29kZURhdGE4LmxhbXBvcnRzLFxuICAgICAgICBzcGFjZSA9IF9kZWNvZGVEYXRhOC5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkID0gX2RlY29kZURhdGE4LnByb2dyYW1JZDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZyb21QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgICAgYmFzZVB1YmtleTogbmV3IFB1YmxpY0tleShiYXNlKSxcbiAgICAgICAgc2VlZDogc2VlZCxcbiAgICAgICAgbGFtcG9ydHM6IGxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIG5vbmNlIGluaXRpYWxpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZU5vbmNlSW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVOb25jZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgICB2YXIgX2RlY29kZURhdGE5ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICBhdXRob3JpemVkID0gX2RlY29kZURhdGE5LmF1dGhvcml6ZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlTm9uY2VBZHZhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZU5vbmNlQWR2YW5jZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICAgIGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vbmNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgbm9uY2Ugd2l0aGRyYXcgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZU5vbmNlV2l0aGRyYXdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlTm9uY2VXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTEwID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgbGFtcG9ydHMgPSBfZGVjb2RlRGF0YTEwLmxhbXBvcnRzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbNF0ucHVia2V5LFxuICAgICAgICBsYW1wb3J0czogbGFtcG9ydHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgbm9uY2UgYXV0aG9yaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVOb25jZUF1dGhvcml6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVOb25jZUF1dGhvcml6ZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTExID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZU5vbmNlQWNjb3VudCwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGF1dGhvcml6ZWQgPSBfZGVjb2RlRGF0YTExLmF1dGhvcml6ZWQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWRQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrUHJvZ3JhbUlkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKFN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3lzdGVtUHJvZ3JhbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrS2V5TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCBcIi5jb25jYXQoa2V5cy5sZW5ndGgsIFwiIGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IFwiKS5jb25jYXQoZXhwZWN0ZWRMZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN5c3RlbUluc3RydWN0aW9uO1xufSgpO1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN5c3RlbUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBzeXN0ZW0gSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ246IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2Zlcjoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgQ3JlYXRlV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFkdmFuY2VOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBXaXRoZHJhd05vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA1LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBJbml0aWFsaXplTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDYsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWQnKV0pXG4gIH0sXG4gIEF1dGhvcml6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBbGxvY2F0ZToge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyldKVxuICB9LFxuICBBbGxvY2F0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDksXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnc3BhY2UnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIEFzc2lnbldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFRyYW5zZmVyV2l0aFNlZWQ6IHtcbiAgICBpbmRleDogMTEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ2xhbXBvcnRzJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgcHVibGljS2V5KCdwcm9ncmFtSWQnKV0pXG4gIH0sXG4gIFVwZ3JhZGVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogMTIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFN5c3RlbSBwcm9ncmFtXG4gKi9cbnZhciBTeXN0ZW1Qcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gU3lzdGVtUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU3lzdGVtUHJvZ3JhbSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN5c3RlbSBwcm9ncmFtXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU3lzdGVtUHJvZ3JhbSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY3JlYXRlQWNjb3VudFwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGU7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogcGFyYW1zLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHRyYW5zZmVycyBsYW1wb3J0cyBmcm9tIG9uZSBhY2NvdW50IHRvIGFub3RoZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ0cmFuc2ZlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB0cmFuc2ZlcihwYXJhbXMpIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgdmFyIGtleXM7XG4gICAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgICB2YXIgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyV2l0aFNlZWQ7XG4gICAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgICBsYW1wb3J0czogQmlnSW50KHBhcmFtcy5sYW1wb3J0cyksXG4gICAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICAgIH0pO1xuICAgICAgICBrZXlzID0gW3tcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBfdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyO1xuICAgICAgICBkYXRhID0gZW5jb2RlRGF0YShfdHlwZSwge1xuICAgICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKVxuICAgICAgICB9KTtcbiAgICAgICAga2V5cyA9IFt7XG4gICAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhc3NpZ25zIGFuIGFjY291bnQgdG8gYSBwcm9ncmFtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYXNzaWduXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFzc2lnbihwYXJhbXMpIHtcbiAgICAgIHZhciBkYXRhO1xuICAgICAgdmFyIGtleXM7XG4gICAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgICB2YXIgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkO1xuICAgICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICAgIH0pO1xuICAgICAgICBrZXlzID0gW3tcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF90eXBlMiA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbjtcbiAgICAgICAgZGF0YSA9IGVuY29kZURhdGEoX3R5cGUyLCB7XG4gICAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICAgIH0pO1xuICAgICAgICBrZXlzID0gW3tcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5hY2NvdW50UHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBhY2NvdW50IGF0XG4gICAgICogICBhbiBhZGRyZXNzIGdlbmVyYXRlZCB3aXRoIGBmcm9tYCwgYSBzZWVkLCBhbmQgcHJvZ3JhbUlkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY3JlYXRlQWNjb3VudFdpdGhTZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFjY291bnRXaXRoU2VlZChwYXJhbXMpIHtcbiAgICAgIHZhciB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlV2l0aFNlZWQ7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICB2YXIga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLm5ld0FjY291bnRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgICBpZiAocGFyYW1zLmJhc2VQdWJrZXkgIT0gcGFyYW1zLmZyb21QdWJrZXkpIHtcbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgTm9uY2UgYWNjb3VudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZU5vbmNlQWNjb3VudFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVOb25jZUFjY291bnQocGFyYW1zKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zICYmICdzZWVkJyBpbiBwYXJhbXMpIHtcbiAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudFdpdGhTZWVkKHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgICAgYmFzZVB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgICBzcGFjZTogTk9OQ0VfQUNDT1VOVF9MRU5HVEgsXG4gICAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB2YXIgaW5pdFBhcmFtcyA9IHtcbiAgICAgICAgbm9uY2VQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXlcbiAgICAgIH07XG4gICAgICB0cmFuc2FjdGlvbi5hZGQodGhpcy5ub25jZUluaXRpYWxpemUoaW5pdFBhcmFtcykpO1xuICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibm9uY2VJbml0aWFsaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vbmNlSW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICAgIHZhciB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5hdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIHZhciBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBhZHZhbmNlIHRoZSBub25jZSBpbiBhIE5vbmNlIGFjY291bnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJub25jZUFkdmFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm9uY2VBZHZhbmNlKHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BZHZhbmNlTm9uY2VBY2NvdW50O1xuICAgICAgdmFyIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgICAgdmFyIGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgd2l0aGRyYXdzIGxhbXBvcnRzIGZyb20gYSBOb25jZSBhY2NvdW50XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwibm9uY2VXaXRoZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBub25jZVdpdGhkcmF3KHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhd05vbmNlQWNjb3VudDtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHNcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV0sXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyB0aGUgYXV0aG9yaXR5XG4gICAgICogb24gYSBOb25jZSBhY2NvdW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm5vbmNlQXV0aG9yaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG5vbmNlQXV0aG9yaXplKHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQ7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBhdXRob3JpemVkOiB0b0J1ZmZlcihwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYWxsb2NhdGVzIHNwYWNlIGluIGFuIGFjY291bnQgd2l0aG91dCBmdW5kaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWxsb2NhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWxsb2NhdGUocGFyYW1zKSB7XG4gICAgICB2YXIgZGF0YTtcbiAgICAgIHZhciBrZXlzO1xuICAgICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkO1xuICAgICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgICAgYmFzZTogdG9CdWZmZXIocGFyYW1zLmJhc2VQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICAgICAgfSk7XG4gICAgICAgIGtleXMgPSBbe1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgX3R5cGUzID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQWxsb2NhdGU7XG4gICAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKF90eXBlMywge1xuICAgICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2VcbiAgICAgICAgfSk7XG4gICAgICAgIGtleXMgPSBbe1xuICAgICAgICAgIHB1YmtleTogcGFyYW1zLmFjY291bnRQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU3lzdGVtUHJvZ3JhbTtcbn0oKTtcblN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuZnVuY3Rpb24gX3JlZ2VuZXJhdG9yUnVudGltZSQyKCkgeyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUkMiA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7IHJldHVybiBleHBvcnRzOyB9OyB2YXIgZXhwb3J0cyA9IHt9LCBPcCA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093biA9IE9wLmhhc093blByb3BlcnR5LCBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXksIGRlc2MpIHsgb2JqW2tleV0gPSBkZXNjLnZhbHVlOyB9LCAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSwgaXRlcmF0b3JTeW1ib2wgPSAkU3ltYm9sLml0ZXJhdG9yIHx8IFwiQEBpdGVyYXRvclwiLCBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjsgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkgeyByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogITAsIGNvbmZpZ3VyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9KSwgb2JqW2tleV07IH0gdHJ5IHsgZGVmaW5lKHt9LCBcIlwiKTsgfSBjYXRjaCAoZXJyKSB7IGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIG9ialtrZXldID0gdmFsdWU7IH07IH0gZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkgeyB2YXIgcHJvdG9HZW5lcmF0b3IgPSBvdXRlckZuICYmIG91dGVyRm4ucHJvdG90eXBlIGluc3RhbmNlb2YgR2VuZXJhdG9yID8gb3V0ZXJGbiA6IEdlbmVyYXRvciwgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLCBjb250ZXh0ID0gbmV3IENvbnRleHQodHJ5TG9jc0xpc3QgfHwgW10pOyByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB9KSwgZ2VuZXJhdG9yOyB9IGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykgeyB0cnkgeyByZXR1cm4geyB0eXBlOiBcIm5vcm1hbFwiLCBhcmc6IGZuLmNhbGwob2JqLCBhcmcpIH07IH0gY2F0Y2ggKGVycikgeyByZXR1cm4geyB0eXBlOiBcInRocm93XCIsIGFyZzogZXJyIH07IH0gfSBleHBvcnRzLndyYXAgPSB3cmFwOyB2YXIgQ29udGludWVTZW50aW5lbCA9IHt9OyBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9IGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge30gdmFyIEl0ZXJhdG9yUHJvdG90eXBlID0ge307IGRlZmluZShJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pOyB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlID0gZ2V0UHJvdG8gJiYgZ2V0UHJvdG8oZ2V0UHJvdG8odmFsdWVzKFtdKSkpOyBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJiBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAhPT0gT3AgJiYgaGFzT3duLmNhbGwoTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sKSAmJiAoSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSk7IHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9IEdlbmVyYXRvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEl0ZXJhdG9yUHJvdG90eXBlKTsgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHByb3RvdHlwZSkgeyBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7IGRlZmluZShwcm90b3R5cGUsIG1ldGhvZCwgZnVuY3Rpb24gKGFyZykgeyByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTsgfSk7IH0pOyB9IGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkgeyBmdW5jdGlvbiBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCkgeyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTsgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHsgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsIHZhbHVlID0gcmVzdWx0LnZhbHVlOyByZXR1cm4gdmFsdWUgJiYgXCJvYmplY3RcIiA9PSBfdHlwZW9mKHZhbHVlKSAmJiBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpID8gUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZS5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyBpbnZva2UoXCJuZXh0XCIsIHZhbHVlLCByZXNvbHZlLCByZWplY3QpOyB9LCBmdW5jdGlvbiAoZXJyKSB7IGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTsgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHsgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkLCByZXNvbHZlKHJlc3VsdCk7IH0sIGZ1bmN0aW9uIChlcnJvcikgeyByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJlamVjdChyZWNvcmQuYXJnKTsgfSB2YXIgcHJldmlvdXNQcm9taXNlOyBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwgeyB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobWV0aG9kLCBhcmcpIHsgZnVuY3Rpb24gY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKSB7IHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkgeyBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7IH0pOyB9IHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTsgfSB9KTsgfSBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHsgdmFyIHN0YXRlID0gXCJzdXNwZW5kZWRTdGFydFwiOyByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJnKSB7IGlmIChcImV4ZWN1dGluZ1wiID09PSBzdGF0ZSkgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTsgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7IGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnOyByZXR1cm4gZG9uZVJlc3VsdCgpOyB9IGZvciAoY29udGV4dC5tZXRob2QgPSBtZXRob2QsIGNvbnRleHQuYXJnID0gYXJnOzspIHsgdmFyIGRlbGVnYXRlID0gY29udGV4dC5kZWxlZ2F0ZTsgaWYgKGRlbGVnYXRlKSB7IHZhciBkZWxlZ2F0ZVJlc3VsdCA9IG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpOyBpZiAoZGVsZWdhdGVSZXN1bHQpIHsgaWYgKGRlbGVnYXRlUmVzdWx0ID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIGRlbGVnYXRlUmVzdWx0OyB9IH0gaWYgKFwibmV4dFwiID09PSBjb250ZXh0Lm1ldGhvZCkgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gY29udGV4dC5tZXRob2QpIHsgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7IGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpOyB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gY29udGV4dC5tZXRob2QgJiYgY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgY29udGV4dC5hcmcpOyBzdGF0ZSA9IFwiZXhlY3V0aW5nXCI7IHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTsgaWYgKFwibm9ybWFsXCIgPT09IHJlY29yZC50eXBlKSB7IGlmIChzdGF0ZSA9IGNvbnRleHQuZG9uZSA/IFwiY29tcGxldGVkXCIgOiBcInN1c3BlbmRlZFlpZWxkXCIsIHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIGNvbnRpbnVlOyByZXR1cm4geyB2YWx1ZTogcmVjb3JkLmFyZywgZG9uZTogY29udGV4dC5kb25lIH07IH0gXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSAmJiAoc3RhdGUgPSBcImNvbXBsZXRlZFwiLCBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSByZWNvcmQuYXJnKTsgfSB9OyB9IGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpIHsgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCwgbWV0aG9kID0gZGVsZWdhdGUuaXRlcmF0b3JbbWV0aG9kTmFtZV07IGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7IHZhciByZWNvcmQgPSB0cnlDYXRjaChtZXRob2QsIGRlbGVnYXRlLml0ZXJhdG9yLCBjb250ZXh0LmFyZyk7IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSByZXR1cm4gY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZywgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWw7IHZhciBpbmZvID0gcmVjb3JkLmFyZzsgcmV0dXJuIGluZm8gPyBpbmZvLmRvbmUgPyAoY29udGV4dFtkZWxlZ2F0ZS5yZXN1bHROYW1lXSA9IGluZm8udmFsdWUsIGNvbnRleHQubmV4dCA9IGRlbGVnYXRlLm5leHRMb2MsIFwicmV0dXJuXCIgIT09IGNvbnRleHQubWV0aG9kICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKSA6IGluZm8gOiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIml0ZXJhdG9yIHJlc3VsdCBpcyBub3QgYW4gb2JqZWN0XCIpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCk7IH0gZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHsgdmFyIGVudHJ5ID0geyB0cnlMb2M6IGxvY3NbMF0gfTsgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7IH0gZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTsgcmVjb3JkLnR5cGUgPSBcIm5vcm1hbFwiLCBkZWxldGUgcmVjb3JkLmFyZywgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDsgfSBmdW5jdGlvbiBDb250ZXh0KHRyeUxvY3NMaXN0KSB7IHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7IH0gZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7IGlmIChpdGVyYWJsZSkgeyB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07IGlmIChpdGVyYXRvck1ldGhvZCkgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpOyBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBpdGVyYWJsZS5uZXh0KSByZXR1cm4gaXRlcmFibGU7IGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkgeyB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0OyByZXR1cm4gbmV4dC52YWx1ZSA9IHVuZGVmaW5lZCwgbmV4dC5kb25lID0gITAsIG5leHQ7IH07IHJldHVybiBuZXh0Lm5leHQgPSBuZXh0OyB9IH0gcmV0dXJuIHsgbmV4dDogZG9uZVJlc3VsdCB9OyB9IGZ1bmN0aW9uIGRvbmVSZXN1bHQoKSB7IHJldHVybiB7IHZhbHVlOiB1bmRlZmluZWQsIGRvbmU6ICEwIH07IH0gcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBkZWZpbmVQcm9wZXJ0eShHcCwgXCJjb25zdHJ1Y3RvclwiLCB7IHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgY29uZmlndXJhYmxlOiAhMCB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sIGNvbmZpZ3VyYWJsZTogITAgfSksIEdlbmVyYXRvckZ1bmN0aW9uLmRpc3BsYXlOYW1lID0gZGVmaW5lKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKSwgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24gKGdlbkZ1bikgeyB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjsgcmV0dXJuICEhY3RvciAmJiAoY3RvciA9PT0gR2VuZXJhdG9yRnVuY3Rpb24gfHwgXCJHZW5lcmF0b3JGdW5jdGlvblwiID09PSAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpKTsgfSwgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24gKGdlbkZ1bikgeyByZXR1cm4gT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKGdlbkZ1bi5fX3Byb3RvX18gPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lKGdlbkZ1biwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIikpLCBnZW5GdW4ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShHcCksIGdlbkZ1bjsgfSwgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHsgX19hd2FpdDogYXJnIH07IH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGV4cG9ydHMuQXN5bmNJdGVyYXRvciA9IEFzeW5jSXRlcmF0b3IsIGV4cG9ydHMuYXN5bmMgPSBmdW5jdGlvbiAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7IHZvaWQgMCA9PT0gUHJvbWlzZUltcGwgJiYgKFByb21pc2VJbXBsID0gUHJvbWlzZSk7IHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTsgcmV0dXJuIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbihvdXRlckZuKSA/IGl0ZXIgOiBpdGVyLm5leHQoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHsgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7IH0pOyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoR3ApLCBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKSwgZGVmaW5lKEdwLCBpdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSksIGRlZmluZShHcCwgXCJ0b1N0cmluZ1wiLCBmdW5jdGlvbiAoKSB7IHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiOyB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkgeyB2YXIgb2JqZWN0ID0gT2JqZWN0KHZhbCksIGtleXMgPSBbXTsgZm9yICh2YXIga2V5IGluIG9iamVjdCkga2V5cy5wdXNoKGtleSk7IHJldHVybiBrZXlzLnJldmVyc2UoKSwgZnVuY3Rpb24gbmV4dCgpIHsgZm9yICg7IGtleXMubGVuZ3RoOykgeyB2YXIga2V5ID0ga2V5cy5wb3AoKTsgaWYgKGtleSBpbiBvYmplY3QpIHJldHVybiBuZXh0LnZhbHVlID0ga2V5LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgfSByZXR1cm4gbmV4dC5kb25lID0gITAsIG5leHQ7IH07IH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHsgY29uc3RydWN0b3I6IENvbnRleHQsIHJlc2V0OiBmdW5jdGlvbiByZXNldChza2lwVGVtcFJlc2V0KSB7IGlmICh0aGlzLnByZXYgPSAwLCB0aGlzLm5leHQgPSAwLCB0aGlzLnNlbnQgPSB0aGlzLl9zZW50ID0gdW5kZWZpbmVkLCB0aGlzLmRvbmUgPSAhMSwgdGhpcy5kZWxlZ2F0ZSA9IG51bGwsIHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMuYXJnID0gdW5kZWZpbmVkLCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIXNraXBUZW1wUmVzZXQpIGZvciAodmFyIG5hbWUgaW4gdGhpcykgXCJ0XCIgPT09IG5hbWUuY2hhckF0KDApICYmIGhhc093bi5jYWxsKHRoaXMsIG5hbWUpICYmICFpc05hTigrbmFtZS5zbGljZSgxKSkgJiYgKHRoaXNbbmFtZV0gPSB1bmRlZmluZWQpOyB9LCBzdG9wOiBmdW5jdGlvbiBzdG9wKCkgeyB0aGlzLmRvbmUgPSAhMDsgdmFyIHJvb3RSZWNvcmQgPSB0aGlzLnRyeUVudHJpZXNbMF0uY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZzsgcmV0dXJuIHRoaXMucnZhbDsgfSwgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uIGRpc3BhdGNoRXhjZXB0aW9uKGV4Y2VwdGlvbikgeyBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247IHZhciBjb250ZXh0ID0gdGhpczsgZnVuY3Rpb24gaGFuZGxlKGxvYywgY2F1Z2h0KSB7IHJldHVybiByZWNvcmQudHlwZSA9IFwidGhyb3dcIiwgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbiwgY29udGV4dC5uZXh0ID0gbG9jLCBjYXVnaHQgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgISFjYXVnaHQ7IH0gZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV0sIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpOyBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikgeyB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKSwgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7IGlmIChoYXNDYXRjaCAmJiBoYXNGaW5hbGx5KSB7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApOyBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTsgfSBlbHNlIGlmIChoYXNDYXRjaCkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgfSBlbHNlIHsgaWYgKCFoYXNGaW5hbGx5KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gfSB9IH0sIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgaGFzT3duLmNhbGwoZW50cnksIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7IHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTsgYnJlYWs7IH0gfSBmaW5hbGx5RW50cnkgJiYgKFwiYnJlYWtcIiA9PT0gdHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHR5cGUpICYmIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmIGFyZyA8PSBmaW5hbGx5RW50cnkuZmluYWxseUxvYyAmJiAoZmluYWxseUVudHJ5ID0gbnVsbCk7IHZhciByZWNvcmQgPSBmaW5hbGx5RW50cnkgPyBmaW5hbGx5RW50cnkuY29tcGxldGlvbiA6IHt9OyByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpOyB9LCBjb21wbGV0ZTogZnVuY3Rpb24gY29tcGxldGUocmVjb3JkLCBhZnRlckxvYykgeyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgdGhyb3cgcmVjb3JkLmFyZzsgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsOyB9LCBmaW5pc2g6IGZ1bmN0aW9uIGZpbmlzaChmaW5hbGx5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkuZmluYWxseUxvYyA9PT0gZmluYWxseUxvYykgcmV0dXJuIHRoaXMuY29tcGxldGUoZW50cnkuY29tcGxldGlvbiwgZW50cnkuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KGVudHJ5KSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBcImNhdGNoXCI6IGZ1bmN0aW9uIF9jYXRjaCh0cnlMb2MpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPT09IHRyeUxvYykgeyB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHsgdmFyIHRocm93biA9IHJlY29yZC5hcmc7IHJlc2V0VHJ5RW50cnkoZW50cnkpOyB9IHJldHVybiB0aHJvd247IH0gfSB0aHJvdyBuZXcgRXJyb3IoXCJpbGxlZ2FsIGNhdGNoIGF0dGVtcHRcIik7IH0sIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHsgcmV0dXJuIHRoaXMuZGVsZWdhdGUgPSB7IGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLCByZXN1bHROYW1lOiByZXN1bHROYW1lLCBuZXh0TG9jOiBuZXh0TG9jIH0sIFwibmV4dFwiID09PSB0aGlzLm1ldGhvZCAmJiAodGhpcy5hcmcgPSB1bmRlZmluZWQpLCBDb250aW51ZVNlbnRpbmVsOyB9IH0sIGV4cG9ydHM7IH1cbi8vIEtlZXAgcHJvZ3JhbSBjaHVua3MgdW5kZXIgUEFDS0VUX0RBVEFfU0laRSwgbGVhdmluZyBlbm91Z2ggcm9vbSBmb3IgdGhlXG4vLyByZXN0IG9mIHRoZSBUcmFuc2FjdGlvbiBmaWVsZHNcbi8vXG4vLyBUT0RPOiByZXBsYWNlIDMwMCB3aXRoIGEgcHJvcGVyIGNvbnN0YW50IGZvciB0aGUgc2l6ZSBvZiB0aGUgb3RoZXJcbi8vIFRyYW5zYWN0aW9uIGZpZWxkc1xudmFyIENIVU5LX1NJWkUgPSBQQUNLRVRfREFUQV9TSVpFIC0gMzAwO1xuXG4vKipcbiAqIFByb2dyYW0gbG9hZGVyIGludGVyZmFjZVxuICovXG52YXIgTG9hZGVyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gTG9hZGVyKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBMb2FkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFtb3VudCBvZiBwcm9ncmFtIGRhdGEgcGxhY2VkIGluIGVhY2ggbG9hZCBUcmFuc2FjdGlvblxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKExvYWRlciwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0TWluTnVtU2lnbmF0dXJlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgICAqIHJldHJpZXNcbiAgICAgKlxuICAgICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMiAqIChcbiAgICAgIC8vIEV2ZXJ5IHRyYW5zYWN0aW9uIHJlcXVpcmVzIHR3byBzaWduYXR1cmVzIChwYXllciArIHByb2dyYW0pXG4gICAgICBNYXRoLmNlaWwoZGF0YUxlbmd0aCAvIExvYWRlci5jaHVua1NpemUpICsgMSArXG4gICAgICAvLyBBZGQgb25lIGZvciBDcmVhdGUgdHJhbnNhY3Rpb25cbiAgICAgIDEpIC8vIEFkZCBvbmUgZm9yIEZpbmFsaXplIHRyYW5zYWN0aW9uXG4gICAgICA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBnZW5lcmljIHByb2dyYW1cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uIFRoZSBjb25uZWN0aW9uIHRvIHVzZVxuICAgICAqIEBwYXJhbSBwYXllciBTeXN0ZW0gYWNjb3VudCB0aGF0IHBheXMgdG8gbG9hZCB0aGUgcHJvZ3JhbVxuICAgICAqIEBwYXJhbSBwcm9ncmFtIEFjY291bnQgdG8gbG9hZCB0aGUgcHJvZ3JhbSBpbnRvXG4gICAgICogQHBhcmFtIHByb2dyYW1JZCBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgbG9hZGVyXG4gICAgICogQHBhcmFtIGRhdGEgUHJvZ3JhbSBvY3RldHNcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbG9hZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQyKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBwcm9ncmFtSWQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGJhbGFuY2VOZWVkZWQsIHByb2dyYW1JbmZvLCB0cmFuc2FjdGlvbiwgZGF0YUxheW91dCwgY2h1bmtTaXplLCBvZmZzZXQsIGFycmF5LCB0cmFuc2FjdGlvbnMsIGJ5dGVzLCBfZGF0YSwgX3RyYW5zYWN0aW9uLCBSRVFVRVNUU19QRVJfU0VDT05ELCBfZGF0YUxheW91dCwgX2RhdGEyLCBfdHJhbnNhY3Rpb24yLCBkZXBsb3lDb21taXRtZW50LCBmaW5hbGl6ZVNpZ25hdHVyZSwgX3lpZWxkJGNvbm5lY3Rpb24kY29uLCBjb250ZXh0LCB2YWx1ZSwgY3VycmVudFNsb3Q7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDIoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbihkYXRhLmxlbmd0aCk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIGJhbGFuY2VOZWVkZWQgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wdWJsaWNLZXksICdjb25maXJtZWQnKTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgcHJvZ3JhbUluZm8gPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIGlmICghKHByb2dyYW1JbmZvICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXByb2dyYW1JbmZvLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUHJvZ3JhbSBsb2FkIGZhaWxlZCwgYWNjb3VudCBpcyBhbHJlYWR5IGV4ZWN1dGFibGUnKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCBmYWxzZSk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hc3NpZ24oe1xuICAgICAgICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICBwcm9ncmFtSWQ6IHByb2dyYW1JZFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJvZ3JhbUluZm8ubGFtcG9ydHMgPCBiYWxhbmNlTmVlZGVkKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS50cmFuc2Zlcih7XG4gICAgICAgICAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICB0b1B1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCAtIHByb2dyYW1JbmZvLmxhbXBvcnRzXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICAgICAgICAgIGZyb21QdWJrZXk6IHBheWVyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICBsYW1wb3J0czogYmFsYW5jZU5lZWRlZCA+IDAgPyBiYWxhbmNlTmVlZGVkIDogMSxcbiAgICAgICAgICAgICAgICBzcGFjZTogZGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWRcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgaWYgKCEodHJhbnNhY3Rpb24gIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyMDtcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgIGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdvZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXNMZW5ndGhQYWRkaW5nJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCdieXRlJyksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdieXRlcycpXSk7XG4gICAgICAgICAgICAgIGNodW5rU2l6ZSA9IExvYWRlci5jaHVua1NpemU7XG4gICAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgICAgICAgIGFycmF5ID0gZGF0YTtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zID0gW107XG4gICAgICAgICAgICBjYXNlIDI1OlxuICAgICAgICAgICAgICBpZiAoIShhcnJheS5sZW5ndGggPiAwKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBieXRlcyA9IGFycmF5LnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICAgICAgICAgIF9kYXRhID0gQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSArIDE2KTtcbiAgICAgICAgICAgICAgZGF0YUxheW91dC5lbmNvZGUoe1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uOiAwLFxuICAgICAgICAgICAgICAgIC8vIExvYWQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldCxcbiAgICAgICAgICAgICAgICBieXRlczogYnl0ZXMsXG4gICAgICAgICAgICAgICAgYnl0ZXNMZW5ndGg6IDAsXG4gICAgICAgICAgICAgICAgYnl0ZXNMZW5ndGhQYWRkaW5nOiAwXG4gICAgICAgICAgICAgIH0sIF9kYXRhKTtcbiAgICAgICAgICAgICAgX3RyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAgICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgICAgICAgICAgcHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICAgICAgICAgIH1dLFxuICAgICAgICAgICAgICAgIHByb2dyYW1JZDogcHJvZ3JhbUlkLFxuICAgICAgICAgICAgICAgIGRhdGE6IF9kYXRhXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnMucHVzaChzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uKGNvbm5lY3Rpb24sIF90cmFuc2FjdGlvbiwgW3BheWVyLCBwcm9ncmFtXSwge1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6ICdjb25maXJtZWQnXG4gICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAvLyBEZWxheSBiZXR3ZWVuIHNlbmRzIGluIGFuIGF0dGVtcHQgdG8gcmVkdWNlIHJhdGUgbGltaXQgZXJyb3JzXG4gICAgICAgICAgICAgIGlmICghY29ubmVjdGlvbi5fcnBjRW5kcG9pbnQuaW5jbHVkZXMoJ3NvbGFuYS5jb20nKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAzNTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBSRVFVRVNUU19QRVJfU0VDT05EID0gNDtcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDM1O1xuICAgICAgICAgICAgICByZXR1cm4gc2xlZXAoMTAwMCAvIFJFUVVFU1RTX1BFUl9TRUNPTkQpO1xuICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZTtcbiAgICAgICAgICAgICAgYXJyYXkgPSBhcnJheS5zbGljZShjaHVua1NpemUpO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDQxO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwodHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgIF9kYXRhTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pO1xuICAgICAgICAgICAgICBfZGF0YTIgPSBCdWZmZXIuYWxsb2MoX2RhdGFMYXlvdXQuc3Bhbik7XG4gICAgICAgICAgICAgIF9kYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb246IDEgLy8gRmluYWxpemUgaW5zdHJ1Y3Rpb25cbiAgICAgICAgICAgICAgfSwgX2RhdGEyKTtcbiAgICAgICAgICAgICAgX3RyYW5zYWN0aW9uMiA9IG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgICAgICAgICAga2V5czogW3tcbiAgICAgICAgICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRU5UX1BVQktFWSxcbiAgICAgICAgICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgfV0sXG4gICAgICAgICAgICAgICAgcHJvZ3JhbUlkOiBwcm9ncmFtSWQsXG4gICAgICAgICAgICAgICAgZGF0YTogX2RhdGEyXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBkZXBsb3lDb21taXRtZW50ID0gJ3Byb2Nlc3NlZCc7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA0ODtcbiAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb24uc2VuZFRyYW5zYWN0aW9uKF90cmFuc2FjdGlvbjIsIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICAgICAgICBwcmVmbGlnaHRDb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA0ODpcbiAgICAgICAgICAgICAgZmluYWxpemVTaWduYXR1cmUgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTE7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBmaW5hbGl6ZVNpZ25hdHVyZSxcbiAgICAgICAgICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogX3RyYW5zYWN0aW9uMi5sYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgICAgICAgICAgICBibG9ja2hhc2g6IF90cmFuc2FjdGlvbjIucmVjZW50QmxvY2toYXNoXG4gICAgICAgICAgICAgIH0sIGRlcGxveUNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgICAgX3lpZWxkJGNvbm5lY3Rpb24kY29uID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgY29udGV4dCA9IF95aWVsZCRjb25uZWN0aW9uJGNvbi5jb250ZXh0O1xuICAgICAgICAgICAgICB2YWx1ZSA9IF95aWVsZCRjb25uZWN0aW9uJGNvbi52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKCF2YWx1ZS5lcnIpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVHJhbnNhY3Rpb24gXCIuY29uY2F0KGZpbmFsaXplU2lnbmF0dXJlLCBcIiBmYWlsZWQgKFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkodmFsdWUpLCBcIilcIikpO1xuICAgICAgICAgICAgY2FzZSA1NjpcbiAgICAgICAgICAgICAgX2NvbnRleHQucHJldiA9IDU3O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNjA7XG4gICAgICAgICAgICAgIHJldHVybiBjb25uZWN0aW9uLmdldFNsb3Qoe1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGRlcGxveUNvbW1pdG1lbnRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDYwOlxuICAgICAgICAgICAgICBjdXJyZW50U2xvdCA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgICAgIGlmICghKGN1cnJlbnRTbG90ID4gY29udGV4dC5zbG90KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2MztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwiYnJlYWtcIiwgNzEpO1xuICAgICAgICAgICAgY2FzZSA2MzpcbiAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDY3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjU6XG4gICAgICAgICAgICAgIF9jb250ZXh0LnByZXYgPSA2NTtcbiAgICAgICAgICAgICAgX2NvbnRleHQudDAgPSBfY29udGV4dFtcImNhdGNoXCJdKDU3KTtcbiAgICAgICAgICAgIGNhc2UgNjc6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSA2OTtcbiAgICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQocmVzb2x2ZSwgTWF0aC5yb3VuZChNU19QRVJfU0xPVCAvIDIpKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDY5OlxuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA3MTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LmFicnVwdChcInJldHVyblwiLCB0cnVlKTtcbiAgICAgICAgICAgIGNhc2UgNzI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlLCBudWxsLCBbWzU3LCA2NV1dKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGxvYWQoX3gsIF94MiwgX3gzLCBfeDQsIF94NSkge1xuICAgICAgICByZXR1cm4gX2xvYWQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsb2FkO1xuICAgIH0oKVxuICB9XSk7XG4gIHJldHVybiBMb2FkZXI7XG59KCk7XG5Mb2FkZXIuY2h1bmtTaXplID0gQ0hVTktfU0laRTtcblxudmFyIEJQRl9MT0FERVJfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCBhIHByb2dyYW0gbG9hZGVyXG4gKi9cbnZhciBCcGZMb2FkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCcGZMb2FkZXIoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJwZkxvYWRlcik7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEJwZkxvYWRlciwgbnVsbCwgW3tcbiAgICBrZXk6IFwiZ2V0TWluTnVtU2lnbmF0dXJlc1wiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgICAqIHJldHJpZXNcbiAgICAgKlxuICAgICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gTG9hZGVyLmdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTG9hZCBhIFNCRiBwcm9ncmFtXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbiBUaGUgY29ubmVjdGlvbiB0byB1c2VcbiAgICAgKiBAcGFyYW0gcGF5ZXIgQWNjb3VudCB0aGF0IHdpbGwgcGF5IHByb2dyYW0gbG9hZGluZyBmZWVzXG4gICAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICAgKiBAcGFyYW0gZWxmIFRoZSBlbnRpcmUgRUxGIGNvbnRhaW5pbmcgdGhlIFNCRiBwcm9ncmFtXG4gICAgICogQHBhcmFtIGxvYWRlclByb2dyYW1JZCBUaGUgcHJvZ3JhbSBpZCBvZiB0aGUgQlBGIGxvYWRlciB0byB1c2VcbiAgICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJsb2FkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGVsZiwgbG9hZGVyUHJvZ3JhbUlkKSB7XG4gICAgICByZXR1cm4gTG9hZGVyLmxvYWQoY29ubmVjdGlvbiwgcGF5ZXIsIHByb2dyYW0sIGxvYWRlclByb2dyYW1JZCwgZWxmKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEJwZkxvYWRlcjtcbn0oKTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxudmFyIG9ialRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbnZhciBvYmpLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGtleXMgPSBbXTtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0a2V5cy5wdXNoKG5hbWUpO1xuXHRcdH1cblx0XHRyZXR1cm4ga2V5cztcblx0fTtcblxuZnVuY3Rpb24gc3RyaW5naWZ5KHZhbCwgaXNBcnJheVByb3ApIHtcblx0dmFyIGksIG1heCwgc3RyLCBrZXlzLCBrZXksIHByb3BWYWwsIHRvU3RyO1xuXHRpZiAodmFsID09PSB0cnVlKSB7XG5cdFx0cmV0dXJuIFwidHJ1ZVwiO1xuXHR9XG5cdGlmICh2YWwgPT09IGZhbHNlKSB7XG5cdFx0cmV0dXJuIFwiZmFsc2VcIjtcblx0fVxuXHRzd2l0Y2ggKHR5cGVvZiB2YWwpIHtcblx0XHRjYXNlIFwib2JqZWN0XCI6XG5cdFx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICh2YWwudG9KU09OICYmIHR5cGVvZiB2YWwudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcblx0XHRcdFx0cmV0dXJuIHN0cmluZ2lmeSh2YWwudG9KU09OKCksIGlzQXJyYXlQcm9wKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRvU3RyID0gb2JqVG9TdHJpbmcuY2FsbCh2YWwpO1xuXHRcdFx0XHRpZiAodG9TdHIgPT09IFwiW29iamVjdCBBcnJheV1cIikge1xuXHRcdFx0XHRcdHN0ciA9ICdbJztcblx0XHRcdFx0XHRtYXggPSB2YWwubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRmb3IoaSA9IDA7IGkgPCBtYXg7IGkrKykge1xuXHRcdFx0XHRcdFx0c3RyICs9IHN0cmluZ2lmeSh2YWxbaV0sIHRydWUpICsgJywnO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAobWF4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHN0ciArICddJztcblx0XHRcdFx0fSBlbHNlIGlmICh0b1N0ciA9PT0gXCJbb2JqZWN0IE9iamVjdF1cIikge1xuXHRcdFx0XHRcdC8vIG9ubHkgb2JqZWN0IGlzIGxlZnRcblx0XHRcdFx0XHRrZXlzID0gb2JqS2V5cyh2YWwpLnNvcnQoKTtcblx0XHRcdFx0XHRtYXggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRzdHIgPSBcIlwiO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0cHJvcFZhbCA9IHN0cmluZ2lmeSh2YWxba2V5XSwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKHByb3BWYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdFx0XHRpZiAoc3RyKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RyICs9ICcsJztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRzdHIgKz0gSlNPTi5zdHJpbmdpZnkoa2V5KSArICc6JyArIHByb3BWYWw7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpKys7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiAneycgKyBzdHIgKyAnfSc7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRjYXNlIFwiZnVuY3Rpb25cIjpcblx0XHRjYXNlIFwidW5kZWZpbmVkXCI6XG5cdFx0XHRyZXR1cm4gaXNBcnJheVByb3AgPyBudWxsIDogdW5kZWZpbmVkO1xuXHRcdGNhc2UgXCJzdHJpbmdcIjpcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdGRlZmF1bHQ6XG5cdFx0XHRyZXR1cm4gaXNGaW5pdGUodmFsKSA/IHZhbCA6IG51bGw7XG5cdH1cbn1cblxudmFyIGZhc3RTdGFibGVTdHJpbmdpZnkgPSBmdW5jdGlvbih2YWwpIHtcblx0dmFyIHJldHVyblZhbCA9IHN0cmluZ2lmeSh2YWwsIGZhbHNlKTtcblx0aWYgKHJldHVyblZhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuICcnKyByZXR1cm5WYWw7XG5cdH1cbn07XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5JDEgPSAvKkBfX1BVUkVfXyovZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMoZmFzdFN0YWJsZVN0cmluZ2lmeSk7XG5cbnZhciBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIID0gMzI7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHNlbGYuXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKG4pIHtcbiAgdmFyIHRyYWlsaW5nWmVyb3MgPSAwO1xuICB3aGlsZSAobiA+IDEpIHtcbiAgICBuIC89IDI7XG4gICAgdHJhaWxpbmdaZXJvcysrO1xuICB9XG4gIHJldHVybiB0cmFpbGluZ1plcm9zO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG5cbmZ1bmN0aW9uIG5leHRQb3dlck9mVHdvKG4pIHtcbiAgaWYgKG4gPT09IDApIHJldHVybiAxO1xuICBuLS07XG4gIG4gfD0gbiA+PiAxO1xuICBuIHw9IG4gPj4gMjtcbiAgbiB8PSBuID4+IDQ7XG4gIG4gfD0gbiA+PiA4O1xuICBuIHw9IG4gPj4gMTY7XG4gIG4gfD0gbiA+PiAzMjtcbiAgcmV0dXJuIG4gKyAxO1xufVxuXG4vKipcbiAqIEVwb2NoIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2Vwb2NoKVxuICogQ2FuIGJlIHJldHJpZXZlZCB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbi5nZXRFcG9jaFNjaGVkdWxlfSBtZXRob2RcbiAqL1xudmFyIEVwb2NoU2NoZWR1bGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFcG9jaFNjaGVkdWxlKHNsb3RzUGVyRXBvY2gsIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgd2FybXVwLCBmaXJzdE5vcm1hbEVwb2NoLCBmaXJzdE5vcm1hbFNsb3QpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRXBvY2hTY2hlZHVsZSk7XG4gICAgLyoqIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzbG90cyBpbiBlYWNoIGVwb2NoICovXG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgbnVtYmVyIG9mIHNsb3RzIGJlZm9yZSBiZWdpbm5pbmcgb2YgYW4gZXBvY2ggdG8gY2FsY3VsYXRlIGEgbGVhZGVyIHNjaGVkdWxlIGZvciB0aGF0IGVwb2NoICovXG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSB2b2lkIDA7XG4gICAgLyoqIEluZGljYXRlcyB3aGV0aGVyIGVwb2NocyBzdGFydCBzaG9ydCBhbmQgZ3JvdyAqL1xuICAgIHRoaXMud2FybXVwID0gdm9pZCAwO1xuICAgIC8qKiBUaGUgZmlyc3QgZXBvY2ggd2l0aCBgc2xvdHNQZXJFcG9jaGAgc2xvdHMgKi9cbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBzbG90IG9mIGBmaXJzdE5vcm1hbEVwb2NoYCAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gdm9pZCAwO1xuICAgIHRoaXMuc2xvdHNQZXJFcG9jaCA9IHNsb3RzUGVyRXBvY2g7XG4gICAgdGhpcy5sZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQgPSBsZWFkZXJTY2hlZHVsZVNsb3RPZmZzZXQ7XG4gICAgdGhpcy53YXJtdXAgPSB3YXJtdXA7XG4gICAgdGhpcy5maXJzdE5vcm1hbEVwb2NoID0gZmlyc3ROb3JtYWxFcG9jaDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsU2xvdCA9IGZpcnN0Tm9ybWFsU2xvdDtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRXBvY2hTY2hlZHVsZSwgW3tcbiAgICBrZXk6IFwiZ2V0RXBvY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RXBvY2goc2xvdCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RXBvY2hBbmRTbG90SW5kZXgoc2xvdClbMF07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEVwb2NoQW5kU2xvdEluZGV4XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEVwb2NoQW5kU2xvdEluZGV4KHNsb3QpIHtcbiAgICAgIGlmIChzbG90IDwgdGhpcy5maXJzdE5vcm1hbFNsb3QpIHtcbiAgICAgICAgdmFyIGVwb2NoID0gdHJhaWxpbmdaZXJvcyhuZXh0UG93ZXJPZlR3byhzbG90ICsgTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCArIDEpKSAtIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkgLSAxO1xuICAgICAgICB2YXIgZXBvY2hMZW4gPSB0aGlzLmdldFNsb3RzSW5FcG9jaChlcG9jaCk7XG4gICAgICAgIHZhciBzbG90SW5kZXggPSBzbG90IC0gKGVwb2NoTGVuIC0gTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCk7XG4gICAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbm9ybWFsU2xvdEluZGV4ID0gc2xvdCAtIHRoaXMuZmlyc3ROb3JtYWxTbG90O1xuICAgICAgICB2YXIgbm9ybWFsRXBvY2hJbmRleCA9IE1hdGguZmxvb3Iobm9ybWFsU2xvdEluZGV4IC8gdGhpcy5zbG90c1BlckVwb2NoKTtcbiAgICAgICAgdmFyIF9lcG9jaCA9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCArIG5vcm1hbEVwb2NoSW5kZXg7XG4gICAgICAgIHZhciBfc2xvdEluZGV4ID0gbm9ybWFsU2xvdEluZGV4ICUgdGhpcy5zbG90c1BlckVwb2NoO1xuICAgICAgICByZXR1cm4gW19lcG9jaCwgX3Nsb3RJbmRleF07XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldEZpcnN0U2xvdEluRXBvY2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Rmlyc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgICAgaWYgKGVwb2NoIDw9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgICByZXR1cm4gKE1hdGgucG93KDIsIGVwb2NoKSAtIDEpICogTUlOSU1VTV9TTE9UX1BFUl9FUE9DSDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAoZXBvY2ggLSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpICogdGhpcy5zbG90c1BlckVwb2NoICsgdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdldExhc3RTbG90SW5FcG9jaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRMYXN0U2xvdEluRXBvY2goZXBvY2gpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpICsgdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpIC0gMTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2xvdHNJbkVwb2NoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNsb3RzSW5FcG9jaChlcG9jaCkge1xuICAgICAgaWYgKGVwb2NoIDwgdGhpcy5maXJzdE5vcm1hbEVwb2NoKSB7XG4gICAgICAgIHJldHVybiBNYXRoLnBvdygyLCBlcG9jaCArIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2xvdHNQZXJFcG9jaDtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVwb2NoU2NoZWR1bGU7XG59KCk7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlciQxKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0JDEoKTsgcmV0dXJuIGZ1bmN0aW9uIF9jcmVhdGVTdXBlckludGVybmFsKCkgeyB2YXIgU3VwZXIgPSBfZ2V0UHJvdG90eXBlT2YoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9IF9nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgcmVzdWx0KTsgfTsgfVxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCQxKCkgeyBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwidW5kZWZpbmVkXCIgfHwgIVJlZmxlY3QuY29uc3RydWN0KSByZXR1cm4gZmFsc2U7IGlmIChSZWZsZWN0LmNvbnN0cnVjdC5zaGFtKSByZXR1cm4gZmFsc2U7IGlmICh0eXBlb2YgUHJveHkgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIHRydWU7IHRyeSB7IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTsgcmV0dXJuIHRydWU7IH0gY2F0Y2ggKGUpIHsgcmV0dXJuIGZhbHNlOyB9IH1cbnZhciBTZW5kVHJhbnNhY3Rpb25FcnJvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0Vycm9yKSB7XG4gIF9pbmhlcml0cyhTZW5kVHJhbnNhY3Rpb25FcnJvciwgX0Vycm9yKTtcbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlciQxKFNlbmRUcmFuc2FjdGlvbkVycm9yKTtcbiAgZnVuY3Rpb24gU2VuZFRyYW5zYWN0aW9uRXJyb3IobWVzc2FnZSwgbG9ncykge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VuZFRyYW5zYWN0aW9uRXJyb3IpO1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgX3RoaXMubG9ncyA9IHZvaWQgMDtcbiAgICBfdGhpcy5sb2dzID0gbG9ncztcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhTZW5kVHJhbnNhY3Rpb25FcnJvcik7XG59KCAvKiNfX1BVUkVfXyovX3dyYXBOYXRpdmVTdXBlcihFcnJvcikpO1xuXG4vLyBLZWVwIGluIHN5bmMgd2l0aCBjbGllbnQvc3JjL3JwY19jdXN0b21fZXJyb3JzLnJzXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG52YXIgU29sYW5hSlNPTlJQQ0Vycm9yQ29kZSA9IHtcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX0NMRUFORURfVVA6IC0zMjAwMSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NFTkRfVFJBTlNBQ1RJT05fUFJFRkxJR0hUX0ZBSUxVUkU6IC0zMjAwMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9WRVJJRklDQVRJT05fRkFJTFVSRTogLTMyMDAzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfTk9UX0FWQUlMQUJMRTogLTMyMDA0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9ERV9VTkhFQUxUSFk6IC0zMjAwNSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1BSRUNPTVBJTEVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwNixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1NMT1RfU0tJUFBFRDogLTMyMDA3LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTk9fU05BUFNIT1Q6IC0zMjAwOCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0xPTkdfVEVSTV9TVE9SQUdFX1NMT1RfU0tJUFBFRDogLTMyMDA5LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfS0VZX0VYQ0xVREVEX0ZST01fU0VDT05EQVJZX0lOREVYOiAtMzIwMTAsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9ISVNUT1JZX05PVF9BVkFJTEFCTEU6IC0zMjAxMSxcbiAgSlNPTl9SUENfU0NBTl9FUlJPUjogLTMyMDEyLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fU0lHTkFUVVJFX0xFTl9NSVNNQVRDSDogLTMyMDEzLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfQkxPQ0tfU1RBVFVTX05PVF9BVkFJTEFCTEVfWUVUOiAtMzIwMTQsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9VTlNVUFBPUlRFRF9UUkFOU0FDVElPTl9WRVJTSU9OOiAtMzIwMTUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9NSU5fQ09OVEVYVF9TTE9UX05PVF9SRUFDSEVEOiAtMzIwMTZcbn07XG52YXIgU29sYW5hSlNPTlJQQ0Vycm9yID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXJyb3IyKSB7XG4gIF9pbmhlcml0cyhTb2xhbmFKU09OUlBDRXJyb3IsIF9FcnJvcjIpO1xuICB2YXIgX3N1cGVyMiA9IF9jcmVhdGVTdXBlciQxKFNvbGFuYUpTT05SUENFcnJvcik7XG4gIGZ1bmN0aW9uIFNvbGFuYUpTT05SUENFcnJvcihfcmVmLCBjdXN0b21NZXNzYWdlKSB7XG4gICAgdmFyIF90aGlzMjtcbiAgICB2YXIgY29kZSA9IF9yZWYuY29kZSxcbiAgICAgIG1lc3NhZ2UgPSBfcmVmLm1lc3NhZ2UsXG4gICAgICBkYXRhID0gX3JlZi5kYXRhO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTb2xhbmFKU09OUlBDRXJyb3IpO1xuICAgIF90aGlzMiA9IF9zdXBlcjIuY2FsbCh0aGlzLCBjdXN0b21NZXNzYWdlICE9IG51bGwgPyBcIlwiLmNvbmNhdChjdXN0b21NZXNzYWdlLCBcIjogXCIpLmNvbmNhdChtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgIF90aGlzMi5jb2RlID0gdm9pZCAwO1xuICAgIF90aGlzMi5kYXRhID0gdm9pZCAwO1xuICAgIF90aGlzMi5jb2RlID0gY29kZTtcbiAgICBfdGhpczIuZGF0YSA9IGRhdGE7XG4gICAgX3RoaXMyLm5hbWUgPSAnU29sYW5hSlNPTlJQQ0Vycm9yJztcbiAgICByZXR1cm4gX3RoaXMyO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoU29sYW5hSlNPTlJQQ0Vycm9yKTtcbn0oIC8qI19fUFVSRV9fKi9fd3JhcE5hdGl2ZVN1cGVyKEVycm9yKSk7XG5cbnZhciBmZXRjaEltcGwgPSBnbG9iYWxUaGlzLmZldGNoO1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pKSwga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpICUgMiA/IG93bktleXMkMShPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gcmV0dXJuIHRhcmdldDsgfVxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gX2dldFByb3RvdHlwZU9mKERlcml2ZWQpLCByZXN1bHQ7IGlmIChoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KSB7IHZhciBOZXdUYXJnZXQgPSBfZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIHJlc3VsdCk7IH07IH1cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxudmFyIFJwY1dlYlNvY2tldENsaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX1JwY1dlYlNvY2tldENvbW1vbkNsKSB7XG4gIF9pbmhlcml0cyhScGNXZWJTb2NrZXRDbGllbnQsIF9ScGNXZWJTb2NrZXRDb21tb25DbCk7XG4gIHZhciBfc3VwZXIgPSBfY3JlYXRlU3VwZXIoUnBjV2ViU29ja2V0Q2xpZW50KTtcbiAgZnVuY3Rpb24gUnBjV2ViU29ja2V0Q2xpZW50KGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJwY1dlYlNvY2tldENsaWVudCk7XG4gICAgdmFyIHdlYlNvY2tldEZhY3RvcnkgPSBmdW5jdGlvbiB3ZWJTb2NrZXRGYWN0b3J5KHVybCkge1xuICAgICAgdmFyIHJwYyA9IGNyZWF0ZVJwYyh1cmwsIF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0cnVlLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogNSxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IDEwMDBcbiAgICAgIH0sIG9wdGlvbnMpKTtcbiAgICAgIGlmICgnc29ja2V0JyBpbiBycGMpIHtcbiAgICAgICAgX3RoaXMudW5kZXJseWluZ1NvY2tldCA9IHJwYy5zb2NrZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJwYztcbiAgICB9O1xuICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgd2ViU29ja2V0RmFjdG9yeSwgYWRkcmVzcywgb3B0aW9ucywgZ2VuZXJhdGVfcmVxdWVzdF9pZCk7XG4gICAgX3RoaXMudW5kZXJseWluZ1NvY2tldCA9IHZvaWQgMDtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKFJwY1dlYlNvY2tldENsaWVudCwgW3tcbiAgICBrZXk6IFwiY2FsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsKCkge1xuICAgICAgdmFyIF90aGlzJHVuZGVybHlpbmdTb2NrZTtcbiAgICAgIHZhciByZWFkeVN0YXRlID0gKF90aGlzJHVuZGVybHlpbmdTb2NrZSA9IHRoaXMudW5kZXJseWluZ1NvY2tldCkgPT09IG51bGwgfHwgX3RoaXMkdW5kZXJseWluZ1NvY2tlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyR1bmRlcmx5aW5nU29ja2UucmVhZHlTdGF0ZTtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgICAgdmFyIF9nZXQyO1xuICAgICAgICByZXR1cm4gKF9nZXQyID0gX2dldChfZ2V0UHJvdG90eXBlT2YoUnBjV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZSksIFwiY2FsbFwiLCB0aGlzKSkuY2FsbC5hcHBseShfZ2V0MiwgW3RoaXNdLmNvbmNhdChhcmdzKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKCdUcmllZCB0byBjYWxsIGEgSlNPTi1SUEMgbWV0aG9kIGAnICsgYXJnc1swXSArICdgIGJ1dCB0aGUgc29ja2V0IHdhcyBub3QgYENPTk5FQ1RJTkdgIG9yIGBPUEVOYCAoYHJlYWR5U3RhdGVgIHdhcyAnICsgcmVhZHlTdGF0ZSArICcpJykpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJub3RpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90aWZ5KCkge1xuICAgICAgdmFyIF90aGlzJHVuZGVybHlpbmdTb2NrZTI7XG4gICAgICB2YXIgcmVhZHlTdGF0ZSA9IChfdGhpcyR1bmRlcmx5aW5nU29ja2UyID0gdGhpcy51bmRlcmx5aW5nU29ja2V0KSA9PT0gbnVsbCB8fCBfdGhpcyR1bmRlcmx5aW5nU29ja2UyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyR1bmRlcmx5aW5nU29ja2UyLnJlYWR5U3RhdGU7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5Ml0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuICAgICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgICAgdmFyIF9nZXQzO1xuICAgICAgICByZXR1cm4gKF9nZXQzID0gX2dldChfZ2V0UHJvdG90eXBlT2YoUnBjV2ViU29ja2V0Q2xpZW50LnByb3RvdHlwZSksIFwibm90aWZ5XCIsIHRoaXMpKS5jYWxsLmFwcGx5KF9nZXQzLCBbdGhpc10uY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIHNlbmQgYSBKU09OLVJQQyBub3RpZmljYXRpb24gYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBScGNXZWJTb2NrZXRDbGllbnQ7XG59KFJwY1dlYlNvY2tldENvbW1vbkNsaWVudCk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBEZWNvZGUgYWNjb3VudCBkYXRhIGJ1ZmZlciB1c2luZyBhbiBBY2NvdW50VHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEodHlwZSwgZGF0YSkge1xuICB2YXIgZGVjb2RlZDtcbiAgdHJ5IHtcbiAgICBkZWNvZGVkID0gdHlwZS5sYXlvdXQuZGVjb2RlKGRhdGEpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkZWNvZGVkLnR5cGVJbmRleCAhPT0gdHlwZS5pbmRleCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYWNjb3VudCBkYXRhOyBhY2NvdW50IHR5cGUgbWlzbWF0Y2ggXCIuY29uY2F0KGRlY29kZWQudHlwZUluZGV4LCBcIiAhPSBcIikuY29uY2F0KHR5cGUuaW5kZXgpKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG52YXIgTE9PS1VQX1RBQkxFX01FVEFfU0laRSA9IDU2O1xudmFyIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50KGFyZ3MpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCk7XG4gICAgdGhpcy5rZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0ZSA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGFyZ3Mua2V5O1xuICAgIHRoaXMuc3RhdGUgPSBhcmdzLnN0YXRlO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50LCBbe1xuICAgIGtleTogXCJpc0FjdGl2ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBpc0FjdGl2ZSgpIHtcbiAgICAgIHZhciBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXRlLmRlYWN0aXZhdGlvblNsb3QgPT09IFU2NF9NQVg7XG4gICAgfVxuICB9XSwgW3tcbiAgICBrZXk6IFwiZGVzZXJpYWxpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzZXJpYWxpemUoYWNjb3VudERhdGEpIHtcbiAgICAgIHZhciBtZXRhID0gZGVjb2RlRGF0YShMb29rdXBUYWJsZU1ldGFMYXlvdXQsIGFjY291bnREYXRhKTtcbiAgICAgIHZhciBzZXJpYWxpemVkQWRkcmVzc2VzTGVuID0gYWNjb3VudERhdGEubGVuZ3RoIC0gTE9PS1VQX1RBQkxFX01FVEFfU0laRTtcbiAgICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuID49IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgICAgYXNzZXJ0KHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gJSAzMiA9PT0gMCwgJ2xvb2t1cCB0YWJsZSBpcyBpbnZhbGlkJyk7XG4gICAgICB2YXIgbnVtU2VyaWFsaXplZEFkZHJlc3NlcyA9IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gLyAzMjtcbiAgICAgIHZhciBfQnVmZmVyTGF5b3V0JHN0cnVjdCQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCBudW1TZXJpYWxpemVkQWRkcmVzc2VzLCAnYWRkcmVzc2VzJyldKS5kZWNvZGUoYWNjb3VudERhdGEuc2xpY2UoTE9PS1VQX1RBQkxFX01FVEFfU0laRSkpLFxuICAgICAgICBhZGRyZXNzZXMgPSBfQnVmZmVyTGF5b3V0JHN0cnVjdCQuYWRkcmVzc2VzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGVhY3RpdmF0aW9uU2xvdDogbWV0YS5kZWFjdGl2YXRpb25TbG90LFxuICAgICAgICBsYXN0RXh0ZW5kZWRTbG90OiBtZXRhLmxhc3RFeHRlbmRlZFNsb3QsXG4gICAgICAgIGxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4OiBtZXRhLmxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgsXG4gICAgICAgIGF1dGhvcml0eTogbWV0YS5hdXRob3JpdHkubGVuZ3RoICE9PSAwID8gbmV3IFB1YmxpY0tleShtZXRhLmF1dGhvcml0eVswXSkgOiB1bmRlZmluZWQsXG4gICAgICAgIGFkZHJlc3NlczogYWRkcmVzc2VzLm1hcChmdW5jdGlvbiAoYWRkcmVzcykge1xuICAgICAgICAgIHJldHVybiBuZXcgUHVibGljS2V5KGFkZHJlc3MpO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQ7XG59KCk7XG52YXIgTG9va3VwVGFibGVNZXRhTGF5b3V0ID0ge1xuICBpbmRleDogMSxcbiAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCd0eXBlSW5kZXgnKSwgdTY0KCdkZWFjdGl2YXRpb25TbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCdsYXN0RXh0ZW5kZWRTbG90JyksIEJ1ZmZlckxheW91dC51OCgnbGFzdEV4dGVuZGVkU3RhcnRJbmRleCcpLCBCdWZmZXJMYXlvdXQudTgoKSxcbiAgLy8gb3B0aW9uXG4gIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnU4KCksIC0xKSwgJ2F1dGhvcml0eScpXSlcbn07XG5cbnZhciBVUkxfUkUgPSAvXlteOl0rOlxcL1xcLyhbXjpbXSt8XFxbW15cXF1dK1xcXSkoOlxcZCspPyguKikvaTtcbmZ1bmN0aW9uIG1ha2VXZWJzb2NrZXRVcmwoZW5kcG9pbnQpIHtcbiAgdmFyIG1hdGNoZXMgPSBlbmRwb2ludC5tYXRjaChVUkxfUkUpO1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKFwiRmFpbGVkIHRvIHZhbGlkYXRlIGVuZHBvaW50IFVSTCBgXCIuY29uY2F0KGVuZHBvaW50LCBcImBcIikpO1xuICB9XG4gIHZhciBfbWF0Y2hlcyA9IF9zbGljZWRUb0FycmF5KG1hdGNoZXMsIDQpO1xuICAgIF9tYXRjaGVzWzBdO1xuICAgIHZhciAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGhvc3Rpc2ggPSBfbWF0Y2hlc1sxXSxcbiAgICBwb3J0V2l0aENvbG9uID0gX21hdGNoZXNbMl0sXG4gICAgcmVzdCA9IF9tYXRjaGVzWzNdO1xuICB2YXIgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICB2YXIgc3RhcnRQb3J0ID0gcG9ydFdpdGhDb2xvbiA9PSBudWxsID8gbnVsbCA6IHBhcnNlSW50KHBvcnRXaXRoQ29sb24uc2xpY2UoMSksIDEwKTtcbiAgdmFyIHdlYnNvY2tldFBvcnQgPVxuICAvLyBPbmx5IHNoaWZ0IHRoZSBwb3J0IGJ5ICsxIGFzIGEgY29udmVudGlvbiBmb3Igd3Mocykgb25seSBpZiBnaXZlbiBlbmRwb2ludFxuICAvLyBpcyBleHBsaWN0bHkgc3BlY2lmeWluZyB0aGUgZW5kcG9pbnQgcG9ydCAoSFRUUC1iYXNlZCBSUEMpLCBhc3N1bWluZ1xuICAvLyB3ZSdyZSBkaXJlY3RseSB0cnlpbmcgdG8gY29ubmVjdCB0byBzb2xhbmEtdmFsaWRhdG9yJ3Mgd3MgbGlzdGVuaW5nIHBvcnQuXG4gIC8vIFdoZW4gdGhlIGVuZHBvaW50IG9taXRzIHRoZSBwb3J0LCB3ZSdyZSBjb25uZWN0aW5nIHRvIHRoZSBwcm90b2NvbFxuICAvLyBkZWZhdWx0IHBvcnRzOiBodHRwKDgwKSBvciBodHRwcyg0NDMpIGFuZCBpdCdzIGFzc3VtZWQgd2UncmUgYmVoaW5kIGEgcmV2ZXJzZVxuICAvLyBwcm94eSB3aGljaCBtYW5hZ2VzIFdlYlNvY2tldCB1cGdyYWRlIGFuZCBiYWNrZW5kIHBvcnQgcmVkaXJlY3Rpb24uXG4gIHN0YXJ0UG9ydCA9PSBudWxsID8gJycgOiBcIjpcIi5jb25jYXQoc3RhcnRQb3J0ICsgMSk7XG4gIHJldHVybiBcIlwiLmNvbmNhdChwcm90b2NvbCwgXCIvL1wiKS5jb25jYXQoaG9zdGlzaCkuY29uY2F0KHdlYnNvY2tldFBvcnQpLmNvbmNhdChyZXN0KTtcbn1cblxudmFyIF9wcm9jZXNzJGVudiRucG1fcGFjaztcbnZhciBfZXhjbHVkZWQgPSBbXCJjb21taXRtZW50XCJdLFxuICBfZXhjbHVkZWQyID0gW1wiZW5jb2RpbmdcIl0sXG4gIF9leGNsdWRlZDMgPSBbXCJjb21taXRtZW50XCJdLFxuICBfZXhjbHVkZWQ0ID0gW1wiY29tbWl0bWVudFwiXTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpIHsgLyohIHJlZ2VuZXJhdG9yLXJ1bnRpbWUgLS0gQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuIC0tIGxpY2Vuc2UgKE1JVCk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9ibG9iL21haW4vTElDRU5TRSAqLyBfcmVnZW5lcmF0b3JSdW50aW1lJDEgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgZW51bWVyYWJsZU9ubHkgJiYgKHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IG51bGwgIT0gYXJndW1lbnRzW2ldID8gYXJndW1lbnRzW2ldIDoge307IGkgJSAyID8gb3duS2V5cyhPYmplY3Qoc291cmNlKSwgITApLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IHJldHVybiB0YXJnZXQ7IH1cbnZhciBQdWJsaWNLZXlGcm9tU3RyaW5nID0gY29lcmNlKGluc3RhbmNlKFB1YmxpY0tleSksIHN0cmluZygpLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodmFsdWUpO1xufSk7XG52YXIgUmF3QWNjb3VudERhdGFSZXN1bHQgPSB0dXBsZShbc3RyaW5nKCksIGxpdGVyYWwoJ2Jhc2U2NCcpXSk7XG52YXIgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhID0gY29lcmNlKGluc3RhbmNlKEJ1ZmZlciksIFJhd0FjY291bnREYXRhUmVzdWx0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlWzBdLCAnYmFzZTY0Jyk7XG59KTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHVzZSBhIHJlY2VudCBibG9ja2hhc2ggZm9yIHVwIHRvIDMwIHNlY29uZHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogSEFDSy5cbiAqIENvcGllZCBmcm9tIHJwYy13ZWJzb2NrZXRzL2Rpc3QvbGliL2NsaWVudC5cbiAqIE90aGVyd2lzZSwgYHlhcm4gYnVpbGRgIGZhaWxzIHdpdGg6XG4gKiBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9zdGV2ZWx1c2NoZXIvYzA1N2VjYTgxZDQ3OWVmNzA1Y2RiNTMxNjJmOTk3MWRcbiAqL1xuXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG4vKiogQGludGVybmFsICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKlxuICogQGludGVybmFsXG4gKiBFdmVyeSBzdWJzY3JpcHRpb24gY29udGFpbnMgdGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aFxuICogdGhlIHNlcnZlciwgYW5kIGEgbGlzdCBvZiBjYWxsZXJzIGludGVyZXN0ZWQgaW4gbm90aWZpY2F0aW9ucy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogQSBzdWJzY3JpcHRpb24gbWF5IGJlIGluIHZhcmlvdXMgc3RhdGVzIG9mIGNvbm5lY3RlZG5lc3MuIE9ubHkgd2hlbiBpdCBpc1xuICogZnVsbHkgY29ubmVjdGVkIHdpbGwgaXQgaGF2ZSBhIHNlcnZlciBzdWJzY3JpcHRpb24gaWQgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICogVGhpcyBpZCBjYW4gYmUgcmV0dXJuZWQgdG8gdGhlIHNlcnZlciB0byB1bnN1YnNjcmliZSB0aGUgY2xpZW50IGVudGlyZWx5LlxuICovXG5cbi8qKlxuICogQSB0eXBlIHRoYXQgZW5jYXBzdWxhdGVzIGEgc3Vic2NyaXB0aW9uJ3MgUlBDIG1ldGhvZFxuICogbmFtZXMgYW5kIG5vdGlmaWNhdGlvbiAoY2FsbGJhY2spIHNpZ25hdHVyZS5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVXRpbGl0eSB0eXBlIHRoYXQga2VlcHMgdGFnZ2VkIHVuaW9ucyBpbnRhY3Qgd2hpbGUgb21pdHRpbmcgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYSBzaW5nbGUgc3Vic2NyaWJhYmxlICd0b3BpYy4nIEl0J3MgbWFkZSB1cCBvZjpcbiAqXG4gKiAtIFRoZSBhcmdzIHVzZWQgdG8gb3BlbiB0aGUgc3Vic2NyaXB0aW9uIHdpdGggdGhlIHNlcnZlcixcbiAqIC0gVGhlIHN0YXRlIG9mIHRoZSBzdWJzY3JpcHRpb24sIGluIHRlcm1zIG9mIGl0cyBjb25uZWN0ZWRuZXNzLCBhbmRcbiAqIC0gVGhlIHNldCBvZiBjYWxsYmFja3MgdG8gY2FsbCB3aGVuIHRoZSBzZXJ2ZXIgcHVibGlzaGVzIG5vdGlmaWNhdGlvbnNcbiAqXG4gKiBUaGlzIHJlY29yZCBnZXRzIGluZGV4ZWQgYnkgYFN1YnNjcmlwdGlvbkNvbmZpZ0hhc2hgIGFuZCBpcyB1c2VkIHRvXG4gKiBzZXQgdXAgc3Vic2NyaXB0aW9ucywgZmFuIG91dCBub3RpZmljYXRpb25zLCBhbmQgdHJhY2sgc3Vic2NyaXB0aW9uIHN0YXRlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBFeHRyYSBjb250ZXh0dWFsIGluZm9ybWF0aW9uIGZvciBSUEMgcmVzcG9uc2VzXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBzZW5kaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlxuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFJQQyBSZXNwb25zZSB3aXRoIGV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb25cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgdHJhbnNhY3Rpb25zIHRoYXQgdXNlcyB0aGUgbGFzdCB2YWxpZFxuICogYmxvY2sgaGVpZ2h0IGZvciBhIGdpdmVuIGJsb2NraGFzaCB0byBjaGVjayBmb3IgdHJhbnNhY3Rpb24gZXhwaXJhdGlvbi5cbiAqL1xuXG4vKipcbiAqIEEgc3RyYXRlZ3kgZm9yIGNvbmZpcm1pbmcgZHVyYWJsZSBub25jZSB0cmFuc2FjdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBQcm9wZXJ0aWVzIHNoYXJlZCBieSBhbGwgdHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0cmF0ZWdpZXNcbiAqL1xuXG4vKipcbiAqIFRoaXMgdHlwZSByZXByZXNlbnRzIGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gYXNzZXJ0RW5kcG9pbnRVcmwocHV0YXRpdmVVcmwpIHtcbiAgaWYgKC9eaHR0cHM/Oi8udGVzdChwdXRhdGl2ZVVybCkgPT09IGZhbHNlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5kcG9pbnQgVVJMIG11c3Qgc3RhcnQgd2l0aCBgaHR0cDpgIG9yIGBodHRwczpgLicpO1xuICB9XG4gIHJldHVybiBwdXRhdGl2ZVVybDtcbn1cblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICB2YXIgY29tbWl0bWVudDtcbiAgdmFyIGNvbmZpZztcbiAgaWYgKHR5cGVvZiBjb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29tbWl0bWVudCA9IGNvbW1pdG1lbnRPckNvbmZpZztcbiAgfSBlbHNlIGlmIChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICB2YXIgc3BlY2lmaWVkQ29tbWl0bWVudCA9IGNvbW1pdG1lbnRPckNvbmZpZy5jb21taXRtZW50LFxuICAgICAgc3BlY2lmaWVkQ29uZmlnID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGNvbW1pdG1lbnRPckNvbmZpZywgX2V4Y2x1ZGVkKTtcbiAgICBjb21taXRtZW50ID0gc3BlY2lmaWVkQ29tbWl0bWVudDtcbiAgICBjb25maWcgPSBzcGVjaWZpZWRDb25maWc7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb21taXRtZW50OiBjb21taXRtZW50LFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJwY1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHVuaW9uKFt0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgcmVzdWx0OiByZXN1bHRcbiAgfSksIHR5cGUoe1xuICAgIGpzb25ycGM6IGxpdGVyYWwoJzIuMCcpLFxuICAgIGlkOiBzdHJpbmcoKSxcbiAgICBlcnJvcjogdHlwZSh7XG4gICAgICBjb2RlOiB1bmtub3duKCksXG4gICAgICBtZXNzYWdlOiBzdHJpbmcoKSxcbiAgICAgIGRhdGE6IG9wdGlvbmFsKGFueSgpKVxuICAgIH0pXG4gIH0pXSk7XG59XG52YXIgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0KHNjaGVtYSkge1xuICByZXR1cm4gY29lcmNlKGNyZWF0ZVJwY1Jlc3VsdChzY2hlbWEpLCBVbmtub3duUnBjUmVzdWx0LCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAoJ2Vycm9yJyBpbiB2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB2YWx1ZSksIHt9LCB7XG4gICAgICAgIHJlc3VsdDogY3JlYXRlKHZhbHVlLnJlc3VsdCwgc2NoZW1hKVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIGpzb25ScGNSZXN1bHQodHlwZSh7XG4gICAgY29udGV4dDogdHlwZSh7XG4gICAgICBzbG90OiBudW1iZXIoKVxuICAgIH0pLFxuICAgIHZhbHVlOiB2YWx1ZVxuICB9KSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGUoe1xuICAgIGNvbnRleHQ6IHR5cGUoe1xuICAgICAgc2xvdDogbnVtYmVyKClcbiAgICB9KSxcbiAgICB2YWx1ZTogdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiByZXNwb25zZS5hY2NvdW50S2V5cy5tYXAoZnVuY3Rpb24gKGFjY291bnRLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkoYWNjb3VudEtleSk7XG4gICAgICB9KSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogcmVzcG9uc2UucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IHJlc3BvbnNlLmluc3RydWN0aW9ucy5tYXAoZnVuY3Rpb24gKGl4KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgICAgIGFjY291bnRLZXlJbmRleGVzOiBpeC5hY2NvdW50cyxcbiAgICAgICAgICBkYXRhOiBiczU4LmRlY29kZShpeC5kYXRhKVxuICAgICAgICB9O1xuICAgICAgfSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgd2hlbiBxdWVyeWluZyBzdGF0ZVxuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcbi8qKlxuICogQSBzdWJzZXQgb2YgQ29tbWl0bWVudCBsZXZlbHMsIHdoaWNoIGFyZSBhdCBsZWFzdCBvcHRpbWlzdGljYWxseSBjb25maXJtZWRcbiAqIDxwcmU+XG4gKiAgICdjb25maXJtZWQnOiBRdWVyeSB0aGUgbW9zdCByZWNlbnQgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG4vKipcbiAqIEZpbHRlciBmb3IgbGFyZ2VzdCBhY2NvdW50cyBxdWVyeVxuICogPHByZT5cbiAqICAgJ2NpcmN1bGF0aW5nJzogICAgUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogICAnbm9uQ2lyY3VsYXRpbmcnOiBSZXR1cm4gdGhlIGxhcmdlc3QgYWNjb3VudHMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIGNpcmN1bGF0aW5nIHN1cHBseVxuICogPC9wcmU+XG4gKi9cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJhbGFuY2VgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrSGVpZ2h0YCBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0RXBvY2hJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0SW5mbGF0aW9uUmV3YXJkYCBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0TGF0ZXN0QmxvY2toYXNoYCBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgaXNCbG9ja2hhc2hWYWxpZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFNsb3RgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTbG90TGVhZGVyYCBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRUcmFuc2FjdGlvbmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhcmdlc3RBY2NvdW50c2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN1cHBseWAgcmVxdWVzdCBiZWhhdmlvclxuICovXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBxdWVyeSBiZWhhdmlvclxuICovXG4vKipcbiAqIEluZm9ybWF0aW9uIGRlc2NyaWJpbmcgYSBjbHVzdGVyIG5vZGVcbiAqL1xuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIGNsdXN0ZXIgdm90ZSBhY2NvdW50c1xuICovXG4vKipcbiAqIE5ldHdvcmsgSW5mbGF0aW9uXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL2ltcGxlbWVudGVkLXByb3Bvc2Fscy9lZF9vdmVydmlldylcbiAqL1xudmFyIEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0ID0gdHlwZSh7XG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBmb3VuZGF0aW9uVGVybTogbnVtYmVyKCksXG4gIGluaXRpYWw6IG51bWJlcigpLFxuICB0YXBlcjogbnVtYmVyKCksXG4gIHRlcm1pbmFsOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogVGhlIGluZmxhdGlvbiByZXdhcmQgZm9yIGFuIGVwb2NoXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmV3YXJkXCIgbWVzc2FnZVxuICovXG52YXIgR2V0SW5mbGF0aW9uUmV3YXJkUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBlZmZlY3RpdmVTbG90OiBudW1iZXIoKSxcbiAgYW1vdW50OiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bWJlcigpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpKTtcblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQgPSBhcnJheSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHByaW9yaXRpemF0aW9uRmVlOiBudW1iZXIoKVxufSkpO1xuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xudmFyIEdldEluZmxhdGlvblJhdGVSZXN1bHQgPSB0eXBlKHtcbiAgdG90YWw6IG51bWJlcigpLFxuICB2YWxpZGF0b3I6IG51bWJlcigpLFxuICBmb3VuZGF0aW9uOiBudW1iZXIoKSxcbiAgZXBvY2g6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlcG9jaFxuICovXG5cbnZhciBHZXRFcG9jaEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXBvY2g6IG51bWJlcigpLFxuICBzbG90SW5kZXg6IG51bWJlcigpLFxuICBzbG90c0luRXBvY2g6IG51bWJlcigpLFxuICBhYnNvbHV0ZVNsb3Q6IG51bWJlcigpLFxuICBibG9ja0hlaWdodDogb3B0aW9uYWwobnVtYmVyKCkpLFxuICB0cmFuc2FjdGlvbkNvdW50OiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xudmFyIEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogTGVhZGVyIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2xlYWRlci1zY2hlZHVsZSlcbiAqL1xuXG52YXIgR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQgPSByZWNvcmQoc3RyaW5nKCksIGFycmF5KG51bWJlcigpKSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3Igb3IgbnVsbFxuICovXG52YXIgVHJhbnNhY3Rpb25FcnJvclJlc3VsdCA9IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSk7XG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1cyBmb3IgYSB0cmFuc2FjdGlvblxuICovXG52YXIgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdFxufSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG52YXIgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHQgPSBsaXRlcmFsKCdyZWNlaXZlZFNpZ25hdHVyZScpO1xuXG4vKipcbiAqIFZlcnNpb24gaW5mbyBmb3IgYSBub2RlXG4gKi9cblxudmFyIFZlcnNpb25SZXN1bHQgPSB0eXBlKHtcbiAgJ3NvbGFuYS1jb3JlJzogc3RyaW5nKCksXG4gICdmZWF0dXJlLXNldCc6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG52YXIgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBlcnI6IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSksXG4gIGxvZ3M6IG51bGxhYmxlKGFycmF5KHN0cmluZygpKSksXG4gIGFjY291bnRzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IHN0cmluZygpLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBhcnJheShzdHJpbmcoKSksXG4gICAgcmVudEVwb2NoOiBvcHRpb25hbChudW1iZXIoKSlcbiAgfSkpKSkpLFxuICB1bml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIHJldHVybkRhdGE6IG9wdGlvbmFsKG51bGxhYmxlKHR5cGUoe1xuICAgIHByb2dyYW1JZDogc3RyaW5nKCksXG4gICAgZGF0YTogdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pXG4gIH0pKSlcbn0pKTtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWRkcmVzc2VzIGxvYWRlZCBieSBhIHRyYW5zYWN0aW9uIHVzaW5nIGFkZHJlc3MgdGFibGUgbG9va3Vwc1xuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnRpYWxseSBkZWNvZGVkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhZGRyZXNzIHRhYmxlIGxvb2t1cFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZVxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFuZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25XaXRoTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXIgd2l0aCBtZXRhXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBibG9jayBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBCbG9jayBvbiB0aGUgbGVkZ2VyIHdpdGggc2lnbmF0dXJlcyBvbmx5XG4gKi9cblxuLyoqXG4gKiByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrUHJvZHVjdGlvblwiIG1lc3NhZ2VcbiAqL1xudmFyIEJsb2NrUHJvZHVjdGlvblJlc3BvbnNlU3RydWN0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJ5SWRlbnRpdHk6IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKSxcbiAgcmFuZ2U6IHR5cGUoe1xuICAgIGZpcnN0U2xvdDogbnVtYmVyKCksXG4gICAgbGFzdFNsb3Q6IG51bWJlcigpXG4gIH0pXG59KSk7XG5cbi8qKlxuICogQSBwZXJmb3JtYW5jZSBzYW1wbGVcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVScGNDbGllbnQodXJsLCBodHRwSGVhZGVycywgY3VzdG9tRmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCkge1xuICB2YXIgZmV0Y2ggPSBjdXN0b21GZXRjaCA/IGN1c3RvbUZldGNoIDogZmV0Y2hJbXBsO1xuICB2YXIgYWdlbnQ7XG4gIHtcbiAgICBpZiAoaHR0cEFnZW50ICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2FybignWW91IGhhdmUgc3VwcGxpZWQgYW4gYGh0dHBBZ2VudGAgd2hlbiBjcmVhdGluZyBhIGBDb25uZWN0aW9uYCBpbiBhIGJyb3dzZXIgZW52aXJvbm1lbnQuJyArICdJdCBoYXMgYmVlbiBpZ25vcmVkOyBgaHR0cEFnZW50YCBpcyBvbmx5IHVzZWQgaW4gTm9kZSBlbnZpcm9ubWVudHMuJyk7XG4gICAgfVxuICB9XG4gIHZhciBmZXRjaFdpdGhNaWRkbGV3YXJlO1xuICBpZiAoZmV0Y2hNaWRkbGV3YXJlKSB7XG4gICAgZmV0Y2hXaXRoTWlkZGxld2FyZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlKGluZm8sIGluaXQpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVkRmV0Y2hBcmdzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlJChfY29udGV4dCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0LnByZXYgPSBfY29udGV4dC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBmZXRjaE1pZGRsZXdhcmUoaW5mbywgaW5pdCwgZnVuY3Rpb24gKG1vZGlmaWVkSW5mbywgbW9kaWZpZWRJbml0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKFttb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdF0pO1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbW9kaWZpZWRGZXRjaEFyZ3MgPSBfY29udGV4dC5zZW50O1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZldGNoLmFwcGx5KHZvaWQgMCwgX3RvQ29uc3VtYWJsZUFycmF5KG1vZGlmaWVkRmV0Y2hBcmdzKSk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQuc2VudCk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlKTtcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBmZXRjaFdpdGhNaWRkbGV3YXJlKF94LCBfeDIpIHtcbiAgICAgICAgcmV0dXJuIF9yZWYuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfSgpO1xuICB9XG4gIHZhciBjbGllbnRCcm93c2VyID0gbmV3IFJwY0NsaWVudCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICB2YXIgX3JlZjIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIocmVxdWVzdCwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBvcHRpb25zLCB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzLCByZXMsIHdhaXRUaW1lLCB0ZXh0O1xuICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIucHJldiA9IF9jb250ZXh0Mi5uZXh0KSB7XG4gICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICAgIGJvZHk6IHJlcXVlc3QsXG4gICAgICAgICAgICAgIGFnZW50OiBhZ2VudCxcbiAgICAgICAgICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgICAgICAgICAgICB9LCBodHRwSGVhZGVycyB8fCB7fSwgQ09NTU9OX0hUVFBfSEVBREVSUylcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfY29udGV4dDIucHJldiA9IDE7XG4gICAgICAgICAgICB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID0gNTtcbiAgICAgICAgICAgIHdhaXRUaW1lID0gNTAwO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmICghZmV0Y2hXaXRoTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNztcbiAgICAgICAgICAgIHJldHVybiBmZXRjaFdpdGhNaWRkbGV3YXJlKHVybCwgb3B0aW9ucyk7XG4gICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTI7XG4gICAgICAgICAgICByZXR1cm4gZmV0Y2godXJsLCBvcHRpb25zKTtcbiAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgcmVzID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGlmICghKHJlcy5zdGF0dXMgIT09IDQyOSAvKiBUb28gbWFueSByZXF1ZXN0cyAqLykpIHtcbiAgICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLmFicnVwdChcImJyZWFrXCIsIDI2KTtcbiAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgaWYgKCEoZGlzYWJsZVJldHJ5T25SYXRlTGltaXQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyNik7XG4gICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgIHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgLT0gMTtcbiAgICAgICAgICAgIGlmICghKHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPT09IDApKSB7XG4gICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJicmVha1wiLCAyNik7XG4gICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU2VydmVyIHJlc3BvbmRlZCB3aXRoIFwiLmNvbmNhdChyZXMuc3RhdHVzLCBcIiBcIikuY29uY2F0KHJlcy5zdGF0dXNUZXh0LCBcIi4gIFJldHJ5aW5nIGFmdGVyIFwiKS5jb25jYXQod2FpdFRpbWUsIFwibXMgZGVsYXkuLi5cIikpO1xuICAgICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAyMztcbiAgICAgICAgICAgIHJldHVybiBzbGVlcCh3YWl0VGltZSk7XG4gICAgICAgICAgY2FzZSAyMzpcbiAgICAgICAgICAgIHdhaXRUaW1lICo9IDI7XG4gICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDI4O1xuICAgICAgICAgICAgcmV0dXJuIHJlcy50ZXh0KCk7XG4gICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgIHRleHQgPSBfY29udGV4dDIuc2VudDtcbiAgICAgICAgICAgIGlmIChyZXMub2spIHtcbiAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgRXJyb3IoXCJcIi5jb25jYXQocmVzLnN0YXR1cywgXCIgXCIpLmNvbmNhdChyZXMuc3RhdHVzVGV4dCwgXCI6IFwiKS5jb25jYXQodGV4dCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMzU7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgX2NvbnRleHQyLnByZXYgPSAzMjtcbiAgICAgICAgICAgIF9jb250ZXh0Mi50MCA9IF9jb250ZXh0MltcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgaWYgKF9jb250ZXh0Mi50MCBpbnN0YW5jZW9mIEVycm9yKSBjYWxsYmFjayhfY29udGV4dDIudDApO1xuICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIF9jYWxsZWUyLCBudWxsLCBbWzEsIDMyXV0pO1xuICAgIH0pKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKF94MywgX3g0KSB7XG4gICAgICByZXR1cm4gX3JlZjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9KCksIHt9KTtcbiAgcmV0dXJuIGNsaWVudEJyb3dzZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVScGNSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgYXJncykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICBjbGllbnQucmVxdWVzdChtZXRob2QsIGFyZ3MsIGZ1bmN0aW9uIChlcnIsIHJlc3BvbnNlKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY0JhdGNoUmVxdWVzdChjbGllbnQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXF1ZXN0cykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHJlcXVlc3RzIGlzIGVtcHR5XG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgIHZhciBiYXRjaCA9IHJlcXVlc3RzLm1hcChmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBjbGllbnQucmVxdWVzdChwYXJhbXMubWV0aG9kTmFtZSwgcGFyYW1zLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBjbGllbnQucmVxdWVzdChiYXRjaCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25Hb3Zlcm5vclwiIG1lc3NhZ2VcbiAqL1xudmFyIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25Hb3Zlcm5vclJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEluZmxhdGlvblJhdGVcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRJbmZsYXRpb25SYXRlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG52YXIgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaEluZm9cIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRFcG9jaEluZm9ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEVwb2NoSW5mb1Jlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEVwb2NoU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRFcG9jaFNjaGVkdWxlUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRFcG9jaFNjaGVkdWxlUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGVhZGVyU2NoZWR1bGVcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJtaW5pbXVtTGVkZ2VyU2xvdFwiIGFuZCBcImdldEZpcnN0QXZhaWxhYmxlQmxvY2tcIiBtZXNzYWdlc1xuICovXG52YXIgU2xvdFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVtYmVyKCkpO1xuXG4vKipcbiAqIFN1cHBseVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFN1cHBseVwiIG1lc3NhZ2VcbiAqL1xudmFyIEdldFN1cHBseVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIGNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmc6IG51bWJlcigpLFxuICBub25DaXJjdWxhdGluZ0FjY291bnRzOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKVxufSkpO1xuXG4vKipcbiAqIFRva2VuIGFtb3VudCBvYmplY3Qgd2hpY2ggcmV0dXJucyBhIHRva2VuIGFtb3VudCBpbiBkaWZmZXJlbnQgZm9ybWF0c1xuICogZm9yIHZhcmlvdXMgY2xpZW50IHVzZSBjYXNlcy5cbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHN0cnVjdHVyZSBmb3IgdG9rZW4gYW1vdW50c1xuICovXG52YXIgVG9rZW5BbW91bnRSZXN1bHQgPSB0eXBlKHtcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBUb2tlbiBhZGRyZXNzIGFuZCBiYWxhbmNlLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG52YXIgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiIG1lc3NhZ2VcbiAqL1xudmFyIEdldFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcbnZhciBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCA9IHR5cGUoe1xuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHNwYWNlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZSB3aXRoIHBhcnNlZCBkYXRhXG4gKi9cbnZhciBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogUGFyc2VkQWNjb3VudERhdGFSZXN1bHQsXG4gICAgcmVudEVwb2NoOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBQYWlyIG9mIGFuIGFjY291bnQgYWRkcmVzcyBhbmQgaXRzIGJhbGFuY2VcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXJnZXN0QWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRMYXJnZXN0QWNjb3VudHNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheSh0eXBlKHtcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KSkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgS2V5ZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcbnZhciBQYXJzZWRPclJhd0FjY291bnREYXRhID0gY29lcmNlKHVuaW9uKFtpbnN0YW5jZShCdWZmZXIpLCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB1bmlvbihbUmF3QWNjb3VudERhdGFSZXN1bHQsIFBhcnNlZEFjY291bnREYXRhUmVzdWx0XSksIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBsYW1wb3J0czogbnVtYmVyKCksXG4gIGRhdGE6IFBhcnNlZE9yUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xudmFyIEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBTdGFrZUFjdGl2YXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3RhdGU6IHVuaW9uKFtsaXRlcmFsKCdhY3RpdmUnKSwgbGl0ZXJhbCgnaW5hY3RpdmUnKSwgbGl0ZXJhbCgnYWN0aXZhdGluZycpLCBsaXRlcmFsKCdkZWFjdGl2YXRpbmcnKV0pLFxuICBhY3RpdmU6IG51bWJlcigpLFxuICBpbmFjdGl2ZTogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcIiBtZXNzYWdlXG4gKi9cblxudmFyIEdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkodHlwZSh7XG4gIHNpZ25hdHVyZTogc3RyaW5nKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIG1lbW86IG51bGxhYmxlKHN0cmluZygpKSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1wiIG1lc3NhZ2VcbiAqL1xudmFyIEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJhY2NvdW50Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG52YXIgQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoQWNjb3VudEluZm9SZXN1bHQpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFByb2dyYW1BY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IEFjY291bnRJbmZvUmVzdWx0XG59KTtcblxuLyoqKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInByb2dyYW1Ob3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbnZhciBQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBTbG90SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgcm9vdDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzbG90Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG52YXIgU2xvdE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RJbmZvUmVzdWx0XG59KTtcblxuLyoqXG4gKiBTbG90IHVwZGF0ZXMgd2hpY2ggY2FuIGJlIHVzZWQgZm9yIHRyYWNraW5nIHRoZSBsaXZlIHByb2dyZXNzIG9mIGEgY2x1c3Rlci5cbiAqIC0gYFwiZmlyc3RTaHJlZFJlY2VpdmVkXCJgOiBjb25uZWN0ZWQgbm9kZSByZWNlaXZlZCB0aGUgZmlyc3Qgc2hyZWQgb2YgYSBibG9jay5cbiAqIEluZGljYXRlcyB0aGF0IGEgbmV3IGJsb2NrIHRoYXQgaXMgYmVpbmcgcHJvZHVjZWQuXG4gKiAtIGBcImNvbXBsZXRlZFwiYDogY29ubmVjdGVkIG5vZGUgaGFzIHJlY2VpdmVkIGFsbCBzaHJlZHMgb2YgYSBibG9jay4gSW5kaWNhdGVzXG4gKiBhIGJsb2NrIHdhcyByZWNlbnRseSBwcm9kdWNlZC5cbiAqIC0gYFwib3B0aW1pc3RpY0NvbmZpcm1hdGlvblwiYDogYmxvY2sgd2FzIG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZCBieSB0aGVcbiAqIGNsdXN0ZXIuIEl0IGlzIG5vdCBndWFyYW50ZWVkIHRoYXQgYW4gb3B0aW1pc3RpYyBjb25maXJtYXRpb24gbm90aWZpY2F0aW9uXG4gKiB3aWxsIGJlIHNlbnQgZm9yIGV2ZXJ5IGZpbmFsaXplZCBibG9ja3MuXG4gKiAtIGBcInJvb3RcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSByb290ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiY3JlYXRlZEJhbmtcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgc3RhcnRlZCB2YWxpZGF0aW5nIHRoaXMgYmxvY2suXG4gKiAtIGBcImZyb3plblwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGhhcyB2YWxpZGF0ZWQgdGhpcyBibG9jay5cbiAqIC0gYFwiZGVhZFwiYDogdGhlIGNvbm5lY3RlZCBub2RlIGZhaWxlZCB0byB2YWxpZGF0ZSB0aGlzIGJsb2NrLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbnZhciBTbG90VXBkYXRlUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICB0eXBlOiB1bmlvbihbbGl0ZXJhbCgnZmlyc3RTaHJlZFJlY2VpdmVkJyksIGxpdGVyYWwoJ2NvbXBsZXRlZCcpLCBsaXRlcmFsKCdvcHRpbWlzdGljQ29uZmlybWF0aW9uJyksIGxpdGVyYWwoJ3Jvb3QnKV0pLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdjcmVhdGVkQmFuaycpLFxuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdmcm96ZW4nKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIHN0YXRzOiB0eXBlKHtcbiAgICBudW1UcmFuc2FjdGlvbkVudHJpZXM6IG51bWJlcigpLFxuICAgIG51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG51bUZhaWxlZFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbWF4VHJhbnNhY3Rpb25zUGVyRW50cnk6IG51bWJlcigpXG4gIH0pXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2RlYWQnKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIGVycjogc3RyaW5nKClcbn0pXSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3RzVXBkYXRlc05vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xudmFyIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90VXBkYXRlUmVzdWx0XG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2lnbmF0dXJlTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG52YXIgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dCh1bmlvbihbU2lnbmF0dXJlU3RhdHVzUmVzdWx0LCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdF0pKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJvb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbnZhciBSb290Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbnVtYmVyKClcbn0pO1xudmFyIENvbnRhY3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGdvc3NpcDogbnVsbGFibGUoc3RyaW5nKCkpLFxuICB0cHU6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgcnBjOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHZlcnNpb246IG51bGxhYmxlKHN0cmluZygpKVxufSk7XG52YXIgVm90ZUFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHZvdGVQdWJrZXk6IHN0cmluZygpLFxuICBub2RlUHVia2V5OiBzdHJpbmcoKSxcbiAgYWN0aXZhdGVkU3Rha2U6IG51bWJlcigpLFxuICBlcG9jaFZvdGVBY2NvdW50OiBib29sZWFuKCksXG4gIGVwb2NoQ3JlZGl0czogYXJyYXkodHVwbGUoW251bWJlcigpLCBudW1iZXIoKSwgbnVtYmVyKCldKSksXG4gIGNvbW1pc3Npb246IG51bWJlcigpLFxuICBsYXN0Vm90ZTogbnVtYmVyKCksXG4gIHJvb3RTbG90OiBudWxsYWJsZShudW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRWb3RlQWNjb3VudHNcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRWb3RlQWNjb3VudHMgPSBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICBjdXJyZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpLFxuICBkZWxpbnF1ZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpXG59KSk7XG52YXIgQ29uZmlybWF0aW9uU3RhdHVzID0gdW5pb24oW2xpdGVyYWwoJ3Byb2Nlc3NlZCcpLCBsaXRlcmFsKCdjb25maXJtZWQnKSwgbGl0ZXJhbCgnZmluYWxpemVkJyldKTtcbnZhciBTaWduYXR1cmVTdGF0dXNSZXNwb25zZSA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgY29uZmlybWF0aW9uczogbnVsbGFibGUobnVtYmVyKCkpLFxuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGNvbmZpcm1hdGlvblN0YXR1czogb3B0aW9uYWwoQ29uZmlybWF0aW9uU3RhdHVzKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIgbWVzc2FnZVxuICovXG52YXIgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShTaWduYXR1cmVTdGF0dXNSZXNwb25zZSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uXCIgbWVzc2FnZVxuICovXG52YXIgR2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG52YXIgQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0ID0gdHlwZSh7XG4gIGFjY291bnRLZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIHdyaXRhYmxlSW5kZXhlczogYXJyYXkobnVtYmVyKCkpLFxuICByZWFkb25seUluZGV4ZXM6IGFycmF5KG51bWJlcigpKVxufSk7XG52YXIgQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoc3RyaW5nKCkpLFxuICAgIGhlYWRlcjogdHlwZSh7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IG51bWJlcigpXG4gICAgfSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICAgIGFjY291bnRzOiBhcnJheShudW1iZXIoKSksXG4gICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXIoKVxuICAgIH0pKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpXG4gIH0pXG59KTtcbnZhciBBbm5vdGF0ZWRBY2NvdW50S2V5ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgc2lnbmVyOiBib29sZWFuKCksXG4gIHdyaXRhYmxlOiBib29sZWFuKCksXG4gIHNvdXJjZTogb3B0aW9uYWwodW5pb24oW2xpdGVyYWwoJ3RyYW5zYWN0aW9uJyksIGxpdGVyYWwoJ2xvb2t1cFRhYmxlJyldKSlcbn0pO1xudmFyIENvbmZpcm1lZFRyYW5zYWN0aW9uQWNjb3VudHNNb2RlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpXG59KTtcbnZhciBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG52YXIgUmF3SW5zdHJ1Y3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgYWNjb3VudHM6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBQdWJsaWNLZXlGcm9tU3RyaW5nXG59KTtcbnZhciBJbnN0cnVjdGlvblJlc3VsdCA9IHVuaW9uKFtSYXdJbnN0cnVjdGlvblJlc3VsdCwgUGFyc2VkSW5zdHJ1Y3Rpb25SZXN1bHRdKTtcbnZhciBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSksIHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoc3RyaW5nKCkpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSldKTtcbnZhciBQYXJzZWRPclJhd0luc3RydWN0aW9uID0gY29lcmNlKEluc3RydWN0aW9uUmVzdWx0LCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoJ2FjY291bnRzJyBpbiB2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFJhd0luc3RydWN0aW9uUmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpKVxuICB9KVxufSk7XG52YXIgVG9rZW5CYWxhbmNlUmVzdWx0ID0gdHlwZSh7XG4gIGFjY291bnRJbmRleDogbnVtYmVyKCksXG4gIG1pbnQ6IHN0cmluZygpLFxuICBvd25lcjogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICB1aVRva2VuQW1vdW50OiBUb2tlbkFtb3VudFJlc3VsdFxufSk7XG52YXIgTG9hZGVkQWRkcmVzc2VzUmVzdWx0ID0gdHlwZSh7XG4gIHdyaXRhYmxlOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgcmVhZG9ubHk6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICAgIGFjY291bnRzOiBhcnJheShudW1iZXIoKSksXG4gICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXIoKVxuICAgIH0pKVxuICB9KSkpKSxcbiAgcHJlQmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcG9zdEJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIGxvZ01lc3NhZ2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShzdHJpbmcoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IG9wdGlvbmFsKExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG52YXIgVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0ID0gdW5pb24oW2xpdGVyYWwoMCksIGxpdGVyYWwoJ2xlZ2FjeScpXSk7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBSZXdhcmRzUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogc3RyaW5nKCksXG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgcG9zdEJhbGFuY2U6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgcmV3YXJkVHlwZTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBjb21taXNzaW9uOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uczogYXJyYXkodHlwZSh7XG4gICAgdHJhbnNhY3Rpb246IENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICAgIG1ldGE6IG51bGxhYmxlKENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCksXG4gICAgdmVyc2lvbjogb3B0aW9uYWwoVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBub25lYFxuICovXG52YXIgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xudmFyIEdldEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG52YXIgR2V0UGFyc2VkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlICB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xudmFyIEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xudmFyIEdldFBhcnNlZE5vbmVNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRDb25maXJtZWRCbG9ja1wiIG1lc3NhZ2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIEdldEJsb2NrUnBjUmVzdWx0fSBpbnN0ZWFkLlxuICovXG52YXIgR2V0Q29uZmlybWVkQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xudmFyIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIG1ldGE6IENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xudmFyIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRyYW5zYWN0aW9uOiBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRSZWNlbnRCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHR9IGluc3RlYWQuXG4gKi9cbnZhciBHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRMYXRlc3RCbG9ja2hhc2hcIiBtZXNzYWdlXG4gKi9cbnZhciBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcigpXG59KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbnZhciBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYm9vbGVhbigpKTtcbnZhciBQZXJmU2FtcGxlUmVzdWx0ID0gdHlwZSh7XG4gIHNsb3Q6IG51bWJlcigpLFxuICBudW1UcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICBudW1TbG90czogbnVtYmVyKCksXG4gIHNhbXBsZVBlcmlvZFNlY3M6IG51bWJlcigpXG59KTtcblxuLypcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciBcImdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1wiIG1lc3NhZ2VcbiAqL1xudmFyIEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkoUGVyZlNhbXBsZVJlc3VsdCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG52YXIgR2V0RmVlQ2FsY3VsYXRvclJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKHR5cGUoe1xuICBmZWVDYWxjdWxhdG9yOiB0eXBlKHtcbiAgICBsYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInJlcXVlc3RBaXJkcm9wXCIgbWVzc2FnZVxuICovXG52YXIgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KHN0cmluZygpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwic2VuZFRyYW5zYWN0aW9uXCIgbWVzc2FnZVxuICovXG52YXIgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBzbG90IGJlaW5nIHByb2Nlc3NlZCBieSBhIG5vZGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlZCBhY2NvdW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFN0YWtlIEFjdGl2YXRpb24gZGF0YVxuICovXG5cbi8qKlxuICogRGF0YSBzbGljZSBhcmd1bWVudCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogRGF0YSBzaXplIGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIEEgZmlsdGVyIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0TXVsdGlwbGVBY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZWBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VBbmRDb250ZXh0YFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBY2NvdW50IGluZm9ybWF0aW9uIGlkZW50aWZpZWQgYnkgcHVia2V5XG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IHVwZGF0ZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbiB3aXRoIHRyYW5zYWN0aW9uIHJlc3VsdFxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciByb290IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIExvZ3NSZXN1bHQgPSB0eXBlKHtcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBsb2dzOiBhcnJheShzdHJpbmcoKSksXG4gIHNpZ25hdHVyZTogc3RyaW5nKClcbn0pO1xuXG4vKipcbiAqIExvZ3MgcmVzdWx0LlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImxvZ3NOb3RpZmljYXRpb25cIiBtZXNzYWdlLlxuICovXG52YXIgTG9nc05vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoTG9nc1Jlc3VsdCksXG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEZpbHRlciBmb3IgbG9nIHN1YnNjcmlwdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgbG9nIG5vdGlmaWNhdGlvbnMuXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgcmVzdWx0XG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvclxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gY29uZmlybWF0aW9uIHN0YXR1c1xuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjb25uZWN0ZWQgbm9kZVxuICogICAnY29uZmlybWVkJzogVHJhbnNhY3Rpb24gbGFuZGVkIGluIGEgYmxvY2sgd2hpY2ggaGFzIHJlYWNoZWQgMSBjb25maXJtYXRpb24gYnkgdGhlIGNsdXN0ZXJcbiAqICAgJ2ZpbmFsaXplZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBzaWduYXR1cmUgd2l0aCBpdHMgc3RhdHVzXG4gKi9cblxuLyoqXG4gKiBBbiBvYmplY3QgZGVmaW5pbmcgaGVhZGVycyB0byBiZSBwYXNzZWQgdG8gdGhlIFJQQyBzZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIFRoZSB0eXBlIG9mIHRoZSBKYXZhU2NyaXB0IGBmZXRjaCgpYCBBUElcbiAqL1xuXG4vKipcbiAqIEEgY2FsbGJhY2sgdXNlZCB0byBhdWdtZW50IHRoZSBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGluc3RhbnRpYXRpbmcgYSBDb25uZWN0aW9uXG4gKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xudmFyIENPTU1PTl9IVFRQX0hFQURFUlMgPSB7XG4gICdzb2xhbmEtY2xpZW50JzogXCJqcy9cIi5jb25jYXQoKF9wcm9jZXNzJGVudiRucG1fcGFjayA9IFwiMC4wLjAtZGV2ZWxvcG1lbnRcIikgIT09IG51bGwgJiYgX3Byb2Nlc3MkZW52JG5wbV9wYWNrICE9PSB2b2lkIDAgPyBfcHJvY2VzcyRlbnYkbnBtX3BhY2sgOiAnVU5LTk9XTicpXG59O1xuXG4vKipcbiAqIEEgY29ubmVjdGlvbiB0byBhIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gKi9cbnZhciBDb25uZWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEVzdGFibGlzaCBhIEpTT04gUlBDIGNvbm5lY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIGVuZHBvaW50IFVSTCB0byB0aGUgZnVsbG5vZGUgSlNPTiBSUEMgZW5kcG9pbnRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnRPckNvbmZpZyBvcHRpb25hbCBkZWZhdWx0IGNvbW1pdG1lbnQgbGV2ZWwgb3Igb3B0aW9uYWwgQ29ubmVjdGlvbkNvbmZpZyBjb25maWd1cmF0aW9uIG9iamVjdFxuICAgKi9cbiAgZnVuY3Rpb24gQ29ubmVjdGlvbihlbmRwb2ludCwgX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIENvbm5lY3Rpb24pO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb21taXRtZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dzRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0NsaWVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbFxuICAgICAqIEEgbnVtYmVyIHRoYXQgd2UgaW5jcmVtZW50IGV2ZXJ5IHRpbWUgYW4gYWN0aXZlIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNhbWUgc29ja2V0IGNvbm5lY3Rpb24gdGhhdCB3YXMgb3BlblxuICAgICAqIHdoZW4gYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgaXMgdGhlIHNhbWUgb25lIHRoYXQncyBhY3RpdmUgd2hlblxuICAgICAqIGl0cyBjb250aW51YXRpb24gZmlyZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmcgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgbGF0ZXN0QmxvY2toYXNoOiBudWxsLFxuICAgICAgbGFzdEZldGNoOiAwLFxuICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2ggPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoID0ge307XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICogc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gV2UgbmVlZCB0byB0cmFjayB3aGljaCBvZiB0aGVzZVxuICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHRlYXIgZG93biB0aGUgc2VydmVyIHN1YnNjcmlwdGlvbikgb3IgYW5cbiAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMgPSBuZXcgU2V0KCk7XG4gICAgLypcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJsb2NrIGhlaWdodCBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QmxvY2tIZWlnaHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgcmVxdWVzdFByb21pc2VzID0ge307XG4gICAgICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9yZWYzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgICAgIHZhciBfcmVxdWVzdFByb21pc2VzJHJlcXU7XG4gICAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybywgY29tbWl0bWVudCwgY29uZmlnLCBhcmdzLCByZXF1ZXN0SGFzaDtcbiAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQucHJldiA9IF9jb250ZXh0NC5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfZXh0cmFjdENvbW1pdG1lbnRGcm8gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZyby5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8uY29uZmlnO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBfdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEhhc2ggPSBmYXN0U3RhYmxlU3RyaW5naWZ5JDEoYXJncyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9IChfcmVxdWVzdFByb21pc2VzJHJlcXUgPSByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdKSAhPT0gbnVsbCAmJiBfcmVxdWVzdFByb21pc2VzJHJlcXUgIT09IHZvaWQgMCA/IF9yZXF1ZXN0UHJvbWlzZXMkcmVxdSA6IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMygpIHtcbiAgICAgICAgICAgICAgICAgIHZhciB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzLnByZXYgPSBfY29udGV4dDMubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDMuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIGhlaWdodCBpbmZvcm1hdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0My5wcmV2ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0UHJvbWlzZXNbcmVxdWVzdEhhc2hdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5maW5pc2goOCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTMsIG51bGwsIFtbMCwsIDgsIDExXV0pO1xuICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0NC5zZW50KTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NC5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgX2NhbGxlZTQpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoX3g1KSB7XG4gICAgICAgICAgcmV0dXJuIF9yZWYzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KCk7XG4gICAgfSgpO1xuICAgIHZhciB3c0VuZHBvaW50O1xuICAgIHZhciBodHRwSGVhZGVycztcbiAgICB2YXIgZmV0Y2g7XG4gICAgdmFyIGZldGNoTWlkZGxld2FyZTtcbiAgICB2YXIgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgdmFyIGh0dHBBZ2VudDtcbiAgICBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZyAmJiB0eXBlb2YgX2NvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIH0gZWxzZSBpZiAoX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgdGhpcy5fY29tbWl0bWVudCA9IF9jb21taXRtZW50T3JDb25maWcuY29tbWl0bWVudDtcbiAgICAgIHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dDtcbiAgICAgIHdzRW5kcG9pbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLndzRW5kcG9pbnQ7XG4gICAgICBodHRwSGVhZGVycyA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEhlYWRlcnM7XG4gICAgICBmZXRjaCA9IF9jb21taXRtZW50T3JDb25maWcuZmV0Y2g7XG4gICAgICBmZXRjaE1pZGRsZXdhcmUgPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoTWlkZGxld2FyZTtcbiAgICAgIGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0ID0gX2NvbW1pdG1lbnRPckNvbmZpZy5kaXNhYmxlUmV0cnlPblJhdGVMaW1pdDtcbiAgICAgIGh0dHBBZ2VudCA9IF9jb21taXRtZW50T3JDb25maWcuaHR0cEFnZW50O1xuICAgIH1cbiAgICB0aGlzLl9ycGNFbmRwb2ludCA9IGFzc2VydEVuZHBvaW50VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNXc0VuZHBvaW50ID0gd3NFbmRwb2ludCB8fCBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KTtcbiAgICB0aGlzLl9ycGNDbGllbnQgPSBjcmVhdGVScGNDbGllbnQoZW5kcG9pbnQsIGh0dHBIZWFkZXJzLCBmZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KTtcbiAgICB0aGlzLl9ycGNSZXF1ZXN0ID0gY3JlYXRlUnBjUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY0JhdGNoUmVxdWVzdCA9IGNyZWF0ZVJwY0JhdGNoUmVxdWVzdCh0aGlzLl9ycGNDbGllbnQpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldCA9IG5ldyBScGNXZWJTb2NrZXRDbGllbnQodGhpcy5fcnBjV3NFbmRwb2ludCwge1xuICAgICAgYXV0b2Nvbm5lY3Q6IGZhbHNlLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IEluZmluaXR5XG4gICAgfSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdvcGVuJywgdGhpcy5fd3NPbk9wZW4uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdlcnJvcicsIHRoaXMuX3dzT25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2Nsb3NlJywgdGhpcy5fd3NPbkNsb3NlLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignYWNjb3VudE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncHJvZ3JhbU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3ROb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Nsb3RzVXBkYXRlc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3NpZ25hdHVyZU5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25TaWduYXR1cmVOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdyb290Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblJvb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdsb2dzTm90aWZpY2F0aW9uJywgdGhpcy5fd3NPbkxvZ3NOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGRlZmF1bHQgY29tbWl0bWVudCB1c2VkIGZvciByZXF1ZXN0c1xuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKENvbm5lY3Rpb24sIFt7XG4gICAga2V5OiBcImNvbW1pdG1lbnRcIixcbiAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb21taXRtZW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBSUEMgZW5kcG9pbnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJycGNFbmRwb2ludFwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3JwY0VuZHBvaW50O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXksIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYWxhbmNlQW5kQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEJhbGFuY2VBbmRDb250ZXh0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm8yLCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNSQoX2NvbnRleHQ1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1LnByZXYgPSBfY29udGV4dDUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAvKiogQGludGVybmFsICovXG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzIgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzIuY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvMi5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCYWxhbmNlJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NS5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIFwiZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciBcIi5jb25jYXQocHVibGljS2V5LnRvQmFzZTU4KCkpKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0QmFsYW5jZUFuZENvbnRleHQoX3g2LCBfeDcpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRCYWxhbmNlQW5kQ29udGV4dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEJhbGFuY2VBbmRDb250ZXh0O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBiYWxhbmNlIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRCYWxhbmNlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0QmFsYW5jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNihwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNiQoX2NvbnRleHQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2LnByZXYgPSBfY29udGV4dDYubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDYubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEJhbGFuY2VBbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKS50aGVuKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgudmFsdWU7XG4gICAgICAgICAgICAgIH0pW1wiY2F0Y2hcIl0oZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgYmFsYW5jZSBvZiBhY2NvdW50ICcgKyBwdWJsaWNLZXkudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYuYWJydXB0KFwicmV0dXJuXCIsIF9jb250ZXh0Ni5zZW50KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ni5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNiwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRCYWxhbmNlKF94OCwgX3g5KSB7XG4gICAgICAgIHJldHVybiBfZ2V0QmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEJhbGFuY2U7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGVzdGltYXRlZCBwcm9kdWN0aW9uIHRpbWUgb2YgYSBibG9ja1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJsb2NrVGltZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEJsb2NrVGltZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNyhzbG90KSB7XG4gICAgICAgIHZhciB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTckKF9jb250ZXh0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0Ny5wcmV2ID0gX2NvbnRleHQ3Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tUaW1lJywgW3Nsb3RdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ3LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0Ny5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgXCJmYWlsZWQgdG8gZ2V0IGJsb2NrIHRpbWUgZm9yIHNsb3QgXCIuY29uY2F0KHNsb3QpKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0QmxvY2tUaW1lKF94MTApIHtcbiAgICAgICAgcmV0dXJuIF9nZXRCbG9ja1RpbWUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRCbG9ja1RpbWU7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGxvd2VzdCBzbG90IHRoYXQgdGhlIG5vZGUgaGFzIGluZm9ybWF0aW9uIGFib3V0IGluIGl0cyBsZWRnZXIuXG4gICAgICogVGhpcyB2YWx1ZSBtYXkgaW5jcmVhc2Ugb3ZlciB0aW1lIGlmIHRoZSBub2RlIGlzIGNvbmZpZ3VyZWQgdG8gcHVyZ2Ugb2xkZXIgbGVkZ2VyIGRhdGFcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRNaW5pbXVtTGVkZ2VyU2xvdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1pbmltdW1MZWRnZXJTbG90ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4KCkge1xuICAgICAgICB2YXIgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4JChfY29udGV4dDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDgucHJldiA9IF9jb250ZXh0OC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0OC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ21pbmltdW1MZWRnZXJTbG90JywgW10pO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDguc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChudW1iZXIoKSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IG1pbmltdW0gbGVkZ2VyIHNsb3QnKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0TWluaW11bUxlZGdlclNsb3QoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0TWluaW11bUxlZGdlclNsb3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRNaW5pbXVtTGVkZ2VyU2xvdDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgc2xvdCBvZiB0aGUgbG93ZXN0IGNvbmZpcm1lZCBibG9jayB0aGF0IGhhcyBub3QgYmVlbiBwdXJnZWQgZnJvbSB0aGUgbGVkZ2VyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Rmlyc3RBdmFpbGFibGVCbG9ja1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEZpcnN0QXZhaWxhYmxlQmxvY2sgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkoKSB7XG4gICAgICAgIHZhciB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkkKF9jb250ZXh0OSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0OS5wcmV2ID0gX2NvbnRleHQ5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaycsIFtdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ5LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIFNsb3RScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDkubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZpcnN0IGF2YWlsYWJsZSBibG9jaycpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCkge1xuICAgICAgICByZXR1cm4gX2dldEZpcnN0QXZhaWxhYmxlQmxvY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRGaXJzdEF2YWlsYWJsZUJsb2NrO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IHN1cHBseVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFN1cHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFN1cHBseSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTAoY29uZmlnKSB7XG4gICAgICAgIHZhciBjb25maWdBcmcsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAkKF9jb250ZXh0MTApIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDEwLnByZXYgPSBfY29udGV4dDEwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY29uZmlnQXJnID0ge307XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbmZpZ1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnQXJnID0gX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBjb25maWcpLCB7fSwge1xuICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQxMC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN1cHBseScsIFtjb25maWdBcmddKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQxMC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTdXBwbHlScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEwLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzdXBwbHknKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0U3VwcGx5KF94MTEpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRTdXBwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTdXBwbHk7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3VwcGx5IG9mIGEgdG9rZW4gbWludFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRva2VuU3VwcGx5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0VG9rZW5TdXBwbHkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTExKHRva2VuTWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTEkKF9jb250ZXh0MTEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDExLnByZXYgPSBfY29udGV4dDExLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5NaW50QWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDExLnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTEubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIHN1cHBseScpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDExLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRUb2tlblN1cHBseShfeDEyLCBfeDEzKSB7XG4gICAgICAgIHJldHVybiBfZ2V0VG9rZW5TdXBwbHkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRUb2tlblN1cHBseTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgY3VycmVudCBiYWxhbmNlIG9mIGEgdG9rZW4gYWNjb3VudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRva2VuQWNjb3VudEJhbGFuY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRUb2tlbkFjY291bnRCYWxhbmNlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMih0b2tlbkFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTIkKF9jb250ZXh0MTIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDEyLnByZXYgPSBfY29udGV4dDEyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdG9rZW5BZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxMi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudEJhbGFuY2UnLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQxMi5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChUb2tlbkFtb3VudFJlc3VsdCkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDEyLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50IGJhbGFuY2UnKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTIuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0VG9rZW5BY2NvdW50QmFsYW5jZShfeDE0LCBfeDE1KSB7XG4gICAgICAgIHJldHVybiBfZ2V0VG9rZW5BY2NvdW50QmFsYW5jZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFRva2VuQWNjb3VudEJhbGFuY2U7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIHRoZSB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb2tlbkFjY291bnRzQnlPd25lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRva2VuQWNjb3VudHNCeU93bmVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMyhvd25lckFkZHJlc3MsIGZpbHRlciwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm8zLCBjb21taXRtZW50LCBjb25maWcsIF9hcmdzLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEzJChfY29udGV4dDEzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxMy5wcmV2ID0gX2NvbnRleHQxMy5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzMgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzMuY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvMy5jb25maWc7XG4gICAgICAgICAgICAgIF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICAgICAgICAgICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgICAgICAgICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTMubmV4dCA9IDY7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlbkFjY291bnRzQnlPd25lcicsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDEzLnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRva2VuQWNjb3VudHNCeU93bmVyKTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMy5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIFwiZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50IFwiLmNvbmNhdChvd25lckFkZHJlc3MudG9CYXNlNTgoKSkpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEzLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFRva2VuQWNjb3VudHNCeU93bmVyKF94MTYsIF94MTcsIF94MTgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRUb2tlbkFjY291bnRzQnlPd25lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFRva2VuQWNjb3VudHNCeU93bmVyO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHBhcnNlZCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIGFjY291bnRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNChvd25lckFkZHJlc3MsIGZpbHRlciwgY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgX2FyZ3MsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTQkKF9jb250ZXh0MTQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDE0LnByZXYgPSBfY29udGV4dDE0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2FyZ3MgPSBbb3duZXJBZGRyZXNzLnRvQmFzZTU4KCldO1xuICAgICAgICAgICAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgICAgICAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgbWludDogZmlsdGVyLm1pbnQudG9CYXNlNTgoKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgICAgICAgICAgICBfY29udGV4dDE0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQxNC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTQubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIFwiZmFpbGVkIHRvIGdldCB0b2tlbiBhY2NvdW50cyBvd25lZCBieSBhY2NvdW50IFwiLmNvbmNhdChvd25lckFkZHJlc3MudG9CYXNlNTgoKSkpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTQsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIoX3gxOSwgX3gyMCwgX3gyMSkge1xuICAgICAgICByZXR1cm4gX2dldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFyZ2VzdEFjY291bnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0TGFyZ2VzdEFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxNShjb25maWcpIHtcbiAgICAgICAgdmFyIGFyZywgYXJncywgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxNSQoX2NvbnRleHQxNSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTUucHJldiA9IF9jb250ZXh0MTUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmcgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZyksIHt9LCB7XG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXJncyA9IGFyZy5maWx0ZXIgfHwgYXJnLmNvbW1pdG1lbnQgPyBbYXJnXSA6IFtdO1xuICAgICAgICAgICAgICBfY29udGV4dDE1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0MTUuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxNS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxNS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE1LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxNSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRMYXJnZXN0QWNjb3VudHMoX3gyMikge1xuICAgICAgICByZXR1cm4gX2dldExhcmdlc3RBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldExhcmdlc3RBY2NvdW50cztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCB0b2tlbiBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICAgKiBmb3IgYSBnaXZlbiBtaW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0VG9rZW5MYXJnZXN0QWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE2KG1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgICAgIHZhciBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE2JChfY29udGV4dDE2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxNi5wcmV2ID0gX2NvbnRleHQxNi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW21pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0MTYuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE2Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0b2tlbiBsYXJnZXN0IGFjY291bnRzJyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE2LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE2LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFRva2VuTGFyZ2VzdEFjY291bnRzKF94MjMsIF94MjQpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRUb2tlbkxhcmdlc3RBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFRva2VuTGFyZ2VzdEFjY291bnRzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXksIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRBY2NvdW50SW5mb0FuZENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRBY2NvdW50SW5mb0FuZENvbnRleHQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE3KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm80LCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTckKF9jb250ZXh0MTcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDE3LnByZXYgPSBfY29udGV4dDE3Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvNCA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpLCBjb21taXRtZW50ID0gX2V4dHJhY3RDb21taXRtZW50RnJvNC5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm80LmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQxNy5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0MTcuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MTcubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIFwiZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgXCIuY29uY2F0KHB1YmxpY0tleS50b0Jhc2U1OCgpKSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE3LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE3LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldEFjY291bnRJbmZvQW5kQ29udGV4dChfeDI1LCBfeDI2KSB7XG4gICAgICAgIHJldHVybiBfZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHBhcnNlZCBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBhcnNlZEFjY291bnRJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0UGFyc2VkQWNjb3VudEluZm8gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTE4KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm81LCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTgkKF9jb250ZXh0MTgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDE4LnByZXYgPSBfY29udGV4dDE4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvNSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpLCBjb21taXRtZW50ID0gX2V4dHJhY3RDb21taXRtZW50RnJvNS5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm81LmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRBY2NvdW50SW5mbycsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDE4LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KG51bGxhYmxlKFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDE4Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBcImZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50IFwiLmNvbmNhdChwdWJsaWNLZXkudG9CYXNlNTgoKSkpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxOC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDE4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxOCwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRQYXJzZWRBY2NvdW50SW5mbyhfeDI3LCBfeDI4KSB7XG4gICAgICAgIHJldHVybiBfZ2V0UGFyc2VkQWNjb3VudEluZm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQYXJzZWRBY2NvdW50SW5mbztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QWNjb3VudEluZm9cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRBY2NvdW50SW5mbyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMTkocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTE5JChfY29udGV4dDE5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxOS5wcmV2ID0gX2NvbnRleHQxOS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTkucHJldiA9IDA7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTkubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChwdWJsaWNLZXksIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHJlcyA9IF9jb250ZXh0MTkuc2VudDtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuYWJydXB0KFwicmV0dXJuXCIsIHJlcy52YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTkucHJldiA9IDc7XG4gICAgICAgICAgICAgIF9jb250ZXh0MTkudDAgPSBfY29udGV4dDE5W1wiY2F0Y2hcIl0oMCk7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBpbmZvIGFib3V0IGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIF9jb250ZXh0MTkudDApO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTE5LCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRBY2NvdW50SW5mbyhfeDI5LCBfeDMwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0QWNjb3VudEluZm8uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRBY2NvdW50SW5mbztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50c1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE11bHRpcGxlUGFyc2VkQWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIwKHB1YmxpY0tleXMsIHJhd0NvbmZpZykge1xuICAgICAgICB2YXIgX2V4dHJhY3RDb21taXRtZW50RnJvNiwgY29tbWl0bWVudCwgY29uZmlnLCBrZXlzLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIwJChfY29udGV4dDIwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyMC5wcmV2ID0gX2NvbnRleHQyMC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzYgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzYuY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvNi5jb25maWc7XG4gICAgICAgICAgICAgIGtleXMgPSBwdWJsaWNLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleS50b0Jhc2U1OCgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhba2V5c10sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQyMC5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQyMC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjAubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIFwiZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyBcIi5jb25jYXQoa2V5cykpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjAsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cyhfeDMxLCBfeDMyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0TXVsdGlwbGVQYXJzZWRBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldE11bHRpcGxlUGFyc2VkQWNjb3VudHM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIG11bHRpcGxlIGFjY291bnRzIHNwZWNpZmllZCBieSBhbiBhcnJheSBvZiBwdWJsaWMga2V5cywgcmV0dXJuIHdpdGggY29udGV4dFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjEocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm83LCBjb21taXRtZW50LCBjb25maWcsIGtleXMsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMjEkKF9jb250ZXh0MjEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDIxLnByZXYgPSBfY29udGV4dDIxLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvNyA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpLCBjb21taXRtZW50ID0gX2V4dHJhY3RDb21taXRtZW50RnJvNy5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm83LmNvbmZpZztcbiAgICAgICAgICAgICAga2V5cyA9IHB1YmxpY0tleXMubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnRvQmFzZTU4KCk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MjEubmV4dCA9IDU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNdWx0aXBsZUFjY291bnRzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0MjEuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIxLm5leHQgPSA5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBcImZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgXCIuY29uY2F0KGtleXMpKTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjEuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIxLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChfeDMzLCBfeDM0KSB7XG4gICAgICAgIHJldHVybiBfZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRNdWx0aXBsZUFjY291bnRzSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE11bHRpcGxlQWNjb3VudHNJbmZvID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyMihwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIyJChfY29udGV4dDIyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyMi5wcmV2ID0gX2NvbnRleHQyMi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE11bHRpcGxlQWNjb3VudHNJbmZvQW5kQ29udGV4dChwdWJsaWNLZXlzLCBjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDIyLnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIyLmFicnVwdChcInJldHVyblwiLCByZXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0TXVsdGlwbGVBY2NvdW50c0luZm8oX3gzNSwgX3gzNikge1xuICAgICAgICByZXR1cm4gX2dldE11bHRpcGxlQWNjb3VudHNJbmZvLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0TXVsdGlwbGVBY2NvdW50c0luZm87XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJucyBlcG9jaCBhY3RpdmF0aW9uIGluZm9ybWF0aW9uIGZvciBhIHN0YWtlIGFjY291bnQgdGhhdCBoYXMgYmVlbiBkZWxlZ2F0ZWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGFrZUFjdGl2YXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTdGFrZUFjdGl2YXRpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIzKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnLCBlcG9jaCkge1xuICAgICAgICB2YXIgX2V4dHJhY3RDb21taXRtZW50RnJvOCwgY29tbWl0bWVudCwgY29uZmlnLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIzJChfY29udGV4dDIzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyMy5wcmV2ID0gX2NvbnRleHQyMy5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzggPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzguY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvOC5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIGNvbmZpZyksIHt9LCB7XG4gICAgICAgICAgICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy5lcG9jaFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0MjMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZUFjdGl2YXRpb24nLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQyMy5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFN0YWtlQWN0aXZhdGlvblJlc3VsdCkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDIzLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBcImZhaWxlZCB0byBnZXQgU3Rha2UgQWN0aXZhdGlvbiBcIi5jb25jYXQocHVibGljS2V5LnRvQmFzZTU4KCkpKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjMuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyMy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjMsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0U3Rha2VBY3RpdmF0aW9uKF94MzcsIF94MzgsIF94MzkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRTdGFrZUFjdGl2YXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTdGFrZUFjdGl2YXRpb247XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50cyBvd25lZCBieSB0aGUgc3BlY2lmaWVkIHByb2dyYW0gaWRcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXI+fT4+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFByb2dyYW1BY2NvdW50c1wiLFxuICAgIHZhbHVlOiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQcm9ncmFtQWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI0KHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm85LCBjb21taXRtZW50LCBjb25maWcsIF9yZWY1LCBlbmNvZGluZywgY29uZmlnV2l0aG91dEVuY29kaW5nLCBhcmdzLCB1bnNhZmVSZXMsIGJhc2VTY2hlbWEsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI0JChfY29udGV4dDI0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyNC5wcmV2ID0gX2NvbnRleHQyNC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzkgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzkuY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvOS5jb25maWc7XG4gICAgICAgICAgICAgIF9yZWY1ID0gY29uZmlnIHx8IHt9LCBlbmNvZGluZyA9IF9yZWY1LmVuY29kaW5nLCBjb25maWdXaXRob3V0RW5jb2RpbmcgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3JlZjUsIF9leGNsdWRlZDIpO1xuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIGVuY29kaW5nIHx8ICdiYXNlNjQnLCBjb25maWdXaXRob3V0RW5jb2RpbmcpO1xuICAgICAgICAgICAgICBfY29udGV4dDI0Lm5leHQgPSA1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0MjQuc2VudDtcbiAgICAgICAgICAgICAgYmFzZVNjaGVtYSA9IGFycmF5KEtleWVkQWNjb3VudEluZm9SZXN1bHQpO1xuICAgICAgICAgICAgICByZXMgPSBjb25maWdXaXRob3V0RW5jb2Rpbmcud2l0aENvbnRleHQgPT09IHRydWUgPyBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChiYXNlU2NoZW1hKSkgOiBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGJhc2VTY2hlbWEpKTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIFwiZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtIFwiLmNvbmNhdChwcm9ncmFtSWQudG9CYXNlNTgoKSkpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI0LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFByb2dyYW1BY2NvdW50cyhfeDQwLCBfeDQxKSB7XG4gICAgICAgIHJldHVybiBfZ2V0UHJvZ3JhbUFjY291bnRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UHJvZ3JhbUFjY291bnRzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGFuZCBwYXJzZSBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgICAqXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxBcnJheTx7cHVia2V5OiBQdWJsaWNLZXksIGFjY291bnQ6IEFjY291bnRJbmZvPEJ1ZmZlciB8IFBhcnNlZEFjY291bnREYXRhPn0+Pn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI1KHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm8xMCwgY29tbWl0bWVudCwgY29uZmlnLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI1JChfY29udGV4dDI1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyNS5wcmV2ID0gX2NvbnRleHQyNS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzEwID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbmZpZ09yQ29tbWl0bWVudCksIGNvbW1pdG1lbnQgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xMC5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xMC5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UHJvZ3JhbUFjY291bnRzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0MjUuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShLZXllZFBhcnNlZEFjY291bnRJbmZvUmVzdWx0KSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI1Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBcImZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSBcIi5jb25jYXQocHJvZ3JhbUlkLnRvQmFzZTU4KCkpKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjUuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMjUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzKF94NDIsIF94NDMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQYXJzZWRQcm9ncmFtQWNjb3VudHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQYXJzZWRQcm9ncmFtQWNjb3VudHM7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlybVRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2NvbmZpcm1UcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMjYoc3RyYXRlZ3ksIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIHJhd1NpZ25hdHVyZSwgX2NvbmZpZyRhYm9ydFNpZ25hbCwgX2NvbmZpZywgZGVjb2RlZFNpZ25hdHVyZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTI2JChfY29udGV4dDI2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyNi5wcmV2ID0gX2NvbnRleHQyNi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghKHR5cGVvZiBzdHJhdGVneSA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDI2Lm5leHQgPSA0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJhd1NpZ25hdHVyZSA9IHN0cmF0ZWd5O1xuICAgICAgICAgICAgICBfY29udGV4dDI2Lm5leHQgPSA4O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbmZpZyA9IHN0cmF0ZWd5O1xuICAgICAgICAgICAgICBpZiAoISgoX2NvbmZpZyRhYm9ydFNpZ25hbCA9IF9jb25maWcuYWJvcnRTaWduYWwpICE9PSBudWxsICYmIF9jb25maWckYWJvcnRTaWduYWwgIT09IHZvaWQgMCAmJiBfY29uZmlnJGFib3J0U2lnbmFsLmFib3J0ZWQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwgUHJvbWlzZS5yZWplY3QoX2NvbmZpZy5hYm9ydFNpZ25hbC5yZWFzb24pKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmF3U2lnbmF0dXJlID0gX2NvbmZpZy5zaWduYXR1cmU7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9jb250ZXh0MjYucHJldiA9IDg7XG4gICAgICAgICAgICAgIGRlY29kZWRTaWduYXR1cmUgPSBiczU4LmRlY29kZShyYXdTaWduYXR1cmUpO1xuICAgICAgICAgICAgICBfY29udGV4dDI2Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfY29udGV4dDI2LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgX2NvbnRleHQyNi50MCA9IF9jb250ZXh0MjZbXCJjYXRjaFwiXSg4KTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBiYXNlNTggZW5jb2RlZDogJyArIHJhd1NpZ25hdHVyZSk7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBhc3NlcnQoZGVjb2RlZFNpZ25hdHVyZS5sZW5ndGggPT09IDY0LCAnc2lnbmF0dXJlIGhhcyBpbnZhbGlkIGxlbmd0aCcpO1xuICAgICAgICAgICAgICBpZiAoISh0eXBlb2Ygc3RyYXRlZ3kgPT09ICdzdHJpbmcnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDIyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9jb250ZXh0MjYubmV4dCA9IDE5O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiByYXdTaWduYXR1cmVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyNi5zZW50KTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIGlmICghKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gMjg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMjU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDI2LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgX2NvbnRleHQyNi5uZXh0ID0gMzA7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50LFxuICAgICAgICAgICAgICAgIHN0cmF0ZWd5OiBzdHJhdGVneVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgMzA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI2LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDI2LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAzMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTI2LCB0aGlzLCBbWzgsIDEyXV0pO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gY29uZmlybVRyYW5zYWN0aW9uKF94NDQsIF94NDUpIHtcbiAgICAgICAgcmV0dXJuIF9jb25maXJtVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maXJtVHJhbnNhY3Rpb247XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRDYW5jZWxsYXRpb25Qcm9taXNlKHNpZ25hbCkge1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChfLCByZWplY3QpIHtcbiAgICAgICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgIHJlamVjdChzaWduYWwucmVhc29uKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKF9yZWY2KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcbiAgICAgIHZhciBjb21taXRtZW50ID0gX3JlZjYuY29tbWl0bWVudCxcbiAgICAgICAgc2lnbmF0dXJlID0gX3JlZjYuc2lnbmF0dXJlO1xuICAgICAgdmFyIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkO1xuICAgICAgdmFyIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyO1xuICAgICAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgICAgIHZhciBjb25maXJtYXRpb25Qcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gX3RoaXMyLm9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgZnVuY3Rpb24gKHJlc3VsdCwgY29udGV4dCkge1xuICAgICAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgIHZhbHVlOiByZXN1bHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgX190eXBlOiBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQsXG4gICAgICAgICAgICAgIHJlc3BvbnNlOiByZXNwb25zZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSwgY29tbWl0bWVudCk7XG4gICAgICAgICAgdmFyIHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlU3Vic2NyaXB0aW9uU2V0dXApIHtcbiAgICAgICAgICAgIGlmIChzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIgPSBfdGhpczIuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2Uoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQsIGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV4dFN0YXRlID09PSAnc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyNygpIHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSwgY29udGV4dCwgdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMjckKF9jb250ZXh0MjcpIHtcbiAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyNy5wcmV2ID0gX2NvbnRleHQyNy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNy5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb25TZXR1cFByb21pc2U7XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjcubmV4dCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjcuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjcubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMyLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2NvbnRleHQyNy5zZW50O1xuICAgICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjcubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjcuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgICAgIGlmICghKHJlc3BvbnNlID09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjcubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI3LmFicnVwdChcInJldHVyblwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICAgICAgY29udGV4dCA9IHJlc3BvbnNlLmNvbnRleHQsIHZhbHVlID0gcmVzcG9uc2UudmFsdWU7XG4gICAgICAgICAgICAgICAgICBpZiAoISh2YWx1ZSA9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI3Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNy5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB2b2lkIDAgJiYgdmFsdWUuZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI3Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICByZWplY3QodmFsdWUuZXJyKTtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjcubmV4dCA9IDI5O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjcudDAgPSBjb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNy5uZXh0ID0gX2NvbnRleHQyNy50MCA9PT0gJ2NvbmZpcm1lZCcgPyAyMSA6IF9jb250ZXh0MjcudDAgPT09ICdzaW5nbGUnID8gMjEgOiBfY29udGV4dDI3LnQwID09PSAnc2luZ2xlR29zc2lwJyA/IDIxIDogX2NvbnRleHQyNy50MCA9PT0gJ2ZpbmFsaXplZCcgPyAyNCA6IF9jb250ZXh0MjcudDAgPT09ICdtYXgnID8gMjQgOiBfY29udGV4dDI3LnQwID09PSAncm9vdCcgPyAyNCA6IF9jb250ZXh0MjcudDAgPT09ICdwcm9jZXNzZWQnID8gMjcgOiBfY29udGV4dDI3LnQwID09PSAncmVjZW50JyA/IDI3IDogMjc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDIxOlxuICAgICAgICAgICAgICAgICAgaWYgKCEodmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAncHJvY2Vzc2VkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNy5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjcuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNy5hYnJ1cHQoXCJicmVha1wiLCAyNyk7XG4gICAgICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgICAgIGlmICghKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcgfHwgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyNy5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjcuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgIGNhc2UgMjY6XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyNy5hYnJ1cHQoXCJicmVha1wiLCAyNyk7XG4gICAgICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjcuc3RvcCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBfY2FsbGVlMjcpO1xuICAgICAgICAgIH0pKSgpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2YXIgYWJvcnRDb25maXJtYXRpb24gPSBmdW5jdGlvbiBhYm9ydENvbmZpcm1hdGlvbigpIHtcbiAgICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgICAgZGlzcG9zZVNpZ25hdHVyZVN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlT2JzZXJ2ZXIoKTtcbiAgICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgIT0gbnVsbCkge1xuICAgICAgICAgIF90aGlzMi5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhYm9ydENvbmZpcm1hdGlvbjogYWJvcnRDb25maXJtYXRpb24sXG4gICAgICAgIGNvbmZpcm1hdGlvblByb21pc2U6IGNvbmZpcm1hdGlvblByb21pc2VcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMChfcmVmOCkge1xuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgICAgdmFyIGNvbW1pdG1lbnQsIF9yZWY4JHN0cmF0ZWd5LCBhYm9ydFNpZ25hbCwgbGFzdFZhbGlkQmxvY2tIZWlnaHQsIHNpZ25hdHVyZSwgZG9uZSwgZXhwaXJ5UHJvbWlzZSwgX3RoaXMkZ2V0VHJhbnNhY3Rpb25DLCBhYm9ydENvbmZpcm1hdGlvbiwgY29uZmlybWF0aW9uUHJvbWlzZSwgY2FuY2VsbGF0aW9uUHJvbWlzZSwgcmVzdWx0LCBvdXRjb21lO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMzAkKF9jb250ZXh0MzApIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMwLnByZXYgPSBfY29udGV4dDMwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY29tbWl0bWVudCA9IF9yZWY4LmNvbW1pdG1lbnQsIF9yZWY4JHN0cmF0ZWd5ID0gX3JlZjguc3RyYXRlZ3ksIGFib3J0U2lnbmFsID0gX3JlZjgkc3RyYXRlZ3kuYWJvcnRTaWduYWwsIGxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gX3JlZjgkc3RyYXRlZ3kubGFzdFZhbGlkQmxvY2tIZWlnaHQsIHNpZ25hdHVyZSA9IF9yZWY4JHN0cmF0ZWd5LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hlY2tCbG9ja0hlaWdodCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjkgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTI4KCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYmxvY2tIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUyOCQoX2NvbnRleHQyOCkge1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MjgucHJldiA9IF9jb250ZXh0MjgubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI4LnByZXYgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI4Lm5leHQgPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMzLmdldEJsb2NrSGVpZ2h0KGNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0hlaWdodCA9IF9jb250ZXh0Mjguc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjguYWJydXB0KFwicmV0dXJuXCIsIGJsb2NrSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC5wcmV2ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOC50MCA9IF9jb250ZXh0MjhbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjguYWJydXB0KFwicmV0dXJuXCIsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDI4LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUyOCwgbnVsbCwgW1swLCA3XV0pO1xuICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIGNoZWNrQmxvY2tIZWlnaHQoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVmOS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUyOSgpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50QmxvY2tIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMjkkKF9jb250ZXh0MjkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyOS5wcmV2ID0gX2NvbnRleHQyOS5uZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEJsb2NrSGVpZ2h0ID0gX2NvbnRleHQyOS5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjkuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnRCbG9ja0hlaWdodCA8PSBsYXN0VmFsaWRCbG9ja0hlaWdodCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOS5uZXh0ID0gMTc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzbGVlcCgxMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQyOS5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MjkuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI5Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IF9jb250ZXh0Mjkuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDI5Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQyOS5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MjkubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERURcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mjkuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMjkpO1xuICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX3RoaXMkZ2V0VHJhbnNhY3Rpb25DID0gdGhpcy5nZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmVcbiAgICAgICAgICAgICAgfSksIGFib3J0Q29uZmlybWF0aW9uID0gX3RoaXMkZ2V0VHJhbnNhY3Rpb25DLmFib3J0Q29uZmlybWF0aW9uLCBjb25maXJtYXRpb25Qcm9taXNlID0gX3RoaXMkZ2V0VHJhbnNhY3Rpb25DLmNvbmZpcm1hdGlvblByb21pc2U7XG4gICAgICAgICAgICAgIGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgICBfY29udGV4dDMwLnByZXYgPSA1O1xuICAgICAgICAgICAgICBfY29udGV4dDMwLm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG91dGNvbWUgPSBfY29udGV4dDMwLnNlbnQ7XG4gICAgICAgICAgICAgIGlmICghKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzMC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzMC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQzMC5wcmV2ID0gMTQ7XG4gICAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMC5maW5pc2goMTQpO1xuICAgICAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzAuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMzAsIHRoaXMsIFtbNSwsIDE0LCAxOF1dKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koX3g0Nikge1xuICAgICAgICByZXR1cm4gX2NvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3kuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0Jsb2NrSGVpZ2h0RXhjZWVkYW5jZVN0cmF0ZWd5O1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMyhfcmVmMTEpIHtcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICAgIHZhciBjb21taXRtZW50LCBfcmVmMTEkc3RyYXRlZ3ksIGFib3J0U2lnbmFsLCBtaW5Db250ZXh0U2xvdCwgbm9uY2VBY2NvdW50UHVia2V5LCBub25jZVZhbHVlLCBzaWduYXR1cmUsIGRvbmUsIGV4cGlyeVByb21pc2UsIF90aGlzJGdldFRyYW5zYWN0aW9uQzIsIGFib3J0Q29uZmlybWF0aW9uLCBjb25maXJtYXRpb25Qcm9taXNlLCBjYW5jZWxsYXRpb25Qcm9taXNlLCByZXN1bHQsIG91dGNvbWUsIF9zaWduYXR1cmVTdGF0dXMsIHNpZ25hdHVyZVN0YXR1cywgX291dGNvbWUkc2xvdEluV2hpY2hOLCBzdGF0dXMsIGNvbW1pdG1lbnRGb3JTdGF0dXMsIGNvbmZpcm1hdGlvblN0YXR1cztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTMzJChfY29udGV4dDM0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzNC5wcmV2ID0gX2NvbnRleHQzNC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGNvbW1pdG1lbnQgPSBfcmVmMTEuY29tbWl0bWVudCwgX3JlZjExJHN0cmF0ZWd5ID0gX3JlZjExLnN0cmF0ZWd5LCBhYm9ydFNpZ25hbCA9IF9yZWYxMSRzdHJhdGVneS5hYm9ydFNpZ25hbCwgbWluQ29udGV4dFNsb3QgPSBfcmVmMTEkc3RyYXRlZ3kubWluQ29udGV4dFNsb3QsIG5vbmNlQWNjb3VudFB1YmtleSA9IF9yZWYxMSRzdHJhdGVneS5ub25jZUFjY291bnRQdWJrZXksIG5vbmNlVmFsdWUgPSBfcmVmMTEkc3RyYXRlZ3kubm9uY2VWYWx1ZSwgc2lnbmF0dXJlID0gX3JlZjExJHN0cmF0ZWd5LnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudE5vbmNlVmFsdWUgPSBub25jZVZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hlY2tlZFNsb3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIHZhciBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgX3JlZjEyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMSgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF95aWVsZCRfdGhpczQkZ2V0Tm9uYywgX2NvbnRleHQzMSwgbm9uY2VBY2NvdW50O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMzEkKF9jb250ZXh0MzIpIHtcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMyLnByZXYgPSBfY29udGV4dDMyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMi5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzNC5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50UHVia2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtaW5Db250ZXh0U2xvdDogbWluQ29udGV4dFNsb3RcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF95aWVsZCRfdGhpczQkZ2V0Tm9uYyA9IF9jb250ZXh0MzIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMSA9IF95aWVsZCRfdGhpczQkZ2V0Tm9uYy5jb250ZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBub25jZUFjY291bnQgPSBfeWllbGQkX3RoaXM0JGdldE5vbmMudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RDaGVja2VkU2xvdCA9IF9jb250ZXh0MzEuc2xvdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzIuYWJydXB0KFwicmV0dXJuXCIsIG5vbmNlQWNjb3VudCA9PT0gbnVsbCB8fCBub25jZUFjY291bnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vbmNlQWNjb3VudC5ub25jZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMyLnByZXYgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMi50MCA9IF9jb250ZXh0MzJbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzIuYWJydXB0KFwicmV0dXJuXCIsIGN1cnJlbnROb25jZVZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMyLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWUzMSwgbnVsbCwgW1swLCAxMF1dKTtcbiAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYxMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICAgICAgX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzMigpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzMiQoX2NvbnRleHQzMykge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDMzLnByZXYgPSBfY29udGV4dDMzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMzLm5leHQgPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBfY29udGV4dDMzLnNlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMy5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEobm9uY2VWYWx1ZSAhPT0gY3VycmVudE5vbmNlVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzMubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuTk9OQ0VfSU5WQUxJRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc2xvdEluV2hpY2hOb25jZURpZEFkdmFuY2U6IGxhc3RDaGVja2VkU2xvdFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMy5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2xlZXAoMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDMzLm5leHQgPSAxMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzMy5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzMubmV4dCA9IDE1O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEN1cnJlbnROb25jZVZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gX2NvbnRleHQzMy5zZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0MzMubmV4dCA9IDE4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDMzLmFicnVwdChcInJldHVyblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQzMy5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjA6XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzMuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LCBfY2FsbGVlMzIpO1xuICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX3RoaXMkZ2V0VHJhbnNhY3Rpb25DMiA9IHRoaXMuZ2V0VHJhbnNhY3Rpb25Db25maXJtYXRpb25Qcm9taXNlKHtcbiAgICAgICAgICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50LFxuICAgICAgICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlXG4gICAgICAgICAgICAgIH0pLCBhYm9ydENvbmZpcm1hdGlvbiA9IF90aGlzJGdldFRyYW5zYWN0aW9uQzIuYWJvcnRDb25maXJtYXRpb24sIGNvbmZpcm1hdGlvblByb21pc2UgPSBfdGhpcyRnZXRUcmFuc2FjdGlvbkMyLmNvbmZpcm1hdGlvblByb21pc2U7XG4gICAgICAgICAgICAgIGNhbmNlbGxhdGlvblByb21pc2UgPSB0aGlzLmdldENhbmNlbGxhdGlvblByb21pc2UoYWJvcnRTaWduYWwpO1xuICAgICAgICAgICAgICBfY29udGV4dDM0LnByZXYgPSA1O1xuICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSA4O1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtjYW5jZWxsYXRpb25Qcm9taXNlLCBjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIG91dGNvbWUgPSBfY29udGV4dDM0LnNlbnQ7XG4gICAgICAgICAgICAgIGlmICghKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gMTY7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNpZ25hdHVyZVN0YXR1cyhzaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgICAgc3RhdHVzID0gX2NvbnRleHQzNC5zZW50O1xuICAgICAgICAgICAgICBpZiAoIShzdGF0dXMgPT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAxOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNC5hYnJ1cHQoXCJicmVha1wiLCAyNyk7XG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBpZiAoIShzdGF0dXMuY29udGV4dC5zbG90IDwgKChfb3V0Y29tZSRzbG90SW5XaGljaE4gPSBvdXRjb21lLnNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlKSAhPT0gbnVsbCAmJiBfb3V0Y29tZSRzbG90SW5XaGljaE4gIT09IHZvaWQgMCA/IF9vdXRjb21lJHNsb3RJbldoaWNoTiA6IG1pbkNvbnRleHRTbG90KSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAyMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHNsZWVwKDQwMCk7XG4gICAgICAgICAgICBjYXNlIDIyOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNC5hYnJ1cHQoXCJjb250aW51ZVwiLCAxMyk7XG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBzaWduYXR1cmVTdGF0dXMgPSBzdGF0dXM7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LmFicnVwdChcImJyZWFrXCIsIDI3KTtcbiAgICAgICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgICAgIGlmICghKChfc2lnbmF0dXJlU3RhdHVzID0gc2lnbmF0dXJlU3RhdHVzKSAhPT0gbnVsbCAmJiBfc2lnbmF0dXJlU3RhdHVzICE9PSB2b2lkIDAgJiYgX3NpZ25hdHVyZVN0YXR1cy52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSA0NjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb21taXRtZW50Rm9yU3RhdHVzID0gY29tbWl0bWVudCB8fCAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzID0gc2lnbmF0dXJlU3RhdHVzLnZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cztcbiAgICAgICAgICAgICAgX2NvbnRleHQzNC50MCA9IGNvbW1pdG1lbnRGb3JTdGF0dXM7XG4gICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IF9jb250ZXh0MzQudDAgPT09ICdwcm9jZXNzZWQnID8gMzMgOiBfY29udGV4dDM0LnQwID09PSAncmVjZW50JyA/IDMzIDogX2NvbnRleHQzNC50MCA9PT0gJ2NvbmZpcm1lZCcgPyAzNiA6IF9jb250ZXh0MzQudDAgPT09ICdzaW5nbGUnID8gMzYgOiBfY29udGV4dDM0LnQwID09PSAnc2luZ2xlR29zc2lwJyA/IDM2IDogX2NvbnRleHQzNC50MCA9PT0gJ2ZpbmFsaXplZCcgPyAzOSA6IF9jb250ZXh0MzQudDAgPT09ICdtYXgnID8gMzkgOiBfY29udGV4dDM0LnQwID09PSAncm9vdCcgPyAzOSA6IDQyO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzM6XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ3Byb2Nlc3NlZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDM1O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAzNTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzQuYWJydXB0KFwiYnJlYWtcIiwgNDMpO1xuICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgICAgaWYgKCEoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnY29uZmlybWVkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdmaW5hbGl6ZWQnKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0MzQubmV4dCA9IDM4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgY2FzZSAzODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzQuYWJydXB0KFwiYnJlYWtcIiwgNDMpO1xuICAgICAgICAgICAgY2FzZSAzOTpcbiAgICAgICAgICAgICAgaWYgKCEoY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM0Lm5leHQgPSA0MTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIGNhc2UgNDE6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LmFicnVwdChcImJyZWFrXCIsIDQzKTtcbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICBjYXNlIDQzOlxuICAgICAgICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogc2lnbmF0dXJlU3RhdHVzLmNvbnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICAgIGVycjogc2lnbmF0dXJlU3RhdHVzLnZhbHVlLmVyclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzNC5uZXh0ID0gNDc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NjpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICBjYXNlIDQ3OlxuICAgICAgICAgICAgICBfY29udGV4dDM0LnByZXYgPSA0NztcbiAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LmZpbmlzaCg0Nyk7XG4gICAgICAgICAgICBjYXNlIDUxOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgNTI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzMywgdGhpcywgW1s1LCwgNDcsIDUxXV0pO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneShfeDQ3KSB7XG4gICAgICAgIHJldHVybiBfY29uZmlybVRyYW5zYWN0aW9uVXNpbmdEdXJhYmxlTm9uY2VTdHJhdGVneS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3k7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3lcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMzQoX3JlZjE0KSB7XG4gICAgICAgIHZhciBfdGhpczUgPSB0aGlzO1xuICAgICAgICB2YXIgY29tbWl0bWVudCwgc2lnbmF0dXJlLCB0aW1lb3V0SWQsIGV4cGlyeVByb21pc2UsIF90aGlzJGdldFRyYW5zYWN0aW9uQzMsIGFib3J0Q29uZmlybWF0aW9uLCBjb25maXJtYXRpb25Qcm9taXNlLCByZXN1bHQsIG91dGNvbWU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzNCQoX2NvbnRleHQzNSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MzUucHJldiA9IF9jb250ZXh0MzUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBjb21taXRtZW50ID0gX3JlZjE0LmNvbW1pdG1lbnQsIHNpZ25hdHVyZSA9IF9yZWYxNC5zaWduYXR1cmU7XG4gICAgICAgICAgICAgIGV4cGlyeVByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgICAgIHZhciB0aW1lb3V0TXMgPSBfdGhpczUuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnQpIHtcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICAgICAgY2FzZSAnc2luZ2xlJzpcbiAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgdGltZW91dE1zID0gX3RoaXM1Ll9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCB8fCAzMCAqIDEwMDA7XG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuVElNRURfT1VULFxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0TXM6IHRpbWVvdXRNc1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgdGltZW91dE1zKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF90aGlzJGdldFRyYW5zYWN0aW9uQzMgPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZVxuICAgICAgICAgICAgICB9KSwgYWJvcnRDb25maXJtYXRpb24gPSBfdGhpcyRnZXRUcmFuc2FjdGlvbkMzLmFib3J0Q29uZmlybWF0aW9uLCBjb25maXJtYXRpb25Qcm9taXNlID0gX3RoaXMkZ2V0VHJhbnNhY3Rpb25DMy5jb25maXJtYXRpb25Qcm9taXNlO1xuICAgICAgICAgICAgICBfY29udGV4dDM1LnByZXYgPSAzO1xuICAgICAgICAgICAgICBfY29udGV4dDM1Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtjb25maXJtYXRpb25Qcm9taXNlLCBleHBpcnlQcm9taXNlXSk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIG91dGNvbWUgPSBfY29udGV4dDM1LnNlbnQ7XG4gICAgICAgICAgICAgIGlmICghKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNS5uZXh0ID0gMTE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgX2NvbnRleHQzNS5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvcihzaWduYXR1cmUsIG91dGNvbWUudGltZW91dE1zIC8gMTAwMCk7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfY29udGV4dDM1LnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM1LmZpbmlzaCgxMik7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM1LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNCwgdGhpcywgW1szLCwgMTIsIDE2XV0pO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3koX3g0OCkge1xuICAgICAgICByZXR1cm4gX2NvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29uZmlybVRyYW5zYWN0aW9uVXNpbmdMZWdhY3lUaW1lb3V0U3RyYXRlZ3k7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2x1c3Rlck5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0Q2x1c3Rlck5vZGVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNSgpIHtcbiAgICAgICAgdmFyIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMzUkKF9jb250ZXh0MzYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDM2LnByZXYgPSBfY29udGV4dDM2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQzNi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldENsdXN0ZXJOb2RlcycsIFtdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQzNi5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KENvbnRhY3RJbmZvUmVzdWx0KSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDM2Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjbHVzdGVyIG5vZGVzJyk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM2LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTM1LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldENsdXN0ZXJOb2RlcygpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRDbHVzdGVyTm9kZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRDbHVzdGVyTm9kZXM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Vm90ZUFjY291bnRzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0Vm90ZUFjY291bnRzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNihjb21taXRtZW50KSB7XG4gICAgICAgIHZhciBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTM2JChfY29udGV4dDM3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQzNy5wcmV2ID0gX2NvbnRleHQzNy5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICBfY29udGV4dDM3Lm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Vm90ZUFjY291bnRzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0Mzcuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Vm90ZUFjY291bnRzKTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzNy5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdm90ZSBhY2NvdW50cycpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzNy5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM3LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNiwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRWb3RlQWNjb3VudHMoX3g0OSkge1xuICAgICAgICByZXR1cm4gX2dldFZvdGVBY2NvdW50cy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFZvdGVBY2NvdW50cztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IHRoYXQgdGhlIG5vZGUgaXMgcHJvY2Vzc2luZ1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNsb3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTbG90ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzNyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzExLCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMzckKF9jb250ZXh0MzgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDM4LnByZXYgPSBfY29udGV4dDM4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvMTEgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzExLmNvbW1pdG1lbnQsIGNvbmZpZyA9IF9leHRyYWN0Q29tbWl0bWVudEZybzExLmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDM4Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdCcsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDM4LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCcpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzOC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDM4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzNywgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRTbG90KF94NTApIHtcbiAgICAgICAgcmV0dXJuIF9nZXRTbG90LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2xvdDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IGxlYWRlciBvZiB0aGUgY2x1c3RlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNsb3RMZWFkZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTbG90TGVhZGVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUzOChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzEyLCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMzgkKF9jb250ZXh0MzkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDM5LnByZXYgPSBfY29udGV4dDM5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvMTIgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzEyLmNvbW1pdG1lbnQsIGNvbmZpZyA9IF9leHRyYWN0Q29tbWl0bWVudEZybzEyLmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDM5Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcicsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDM5LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpKTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzOS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXInKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MzkuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzOS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMzgsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0U2xvdExlYWRlcihfeDUxKSB7XG4gICAgICAgIHJldHVybiBfZ2V0U2xvdExlYWRlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFNsb3RMZWFkZXI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYGxpbWl0YCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gYHN0YXJ0U2xvdGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAgICogQHBhcmFtIGxpbWl0IG51bWJlciBvZiBzbG90IGxlYWRlcnMgdG8gcmV0dXJuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2xvdExlYWRlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTbG90TGVhZGVycyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMzkoc3RhcnRTbG90LCBsaW1pdCkge1xuICAgICAgICB2YXIgYXJncywgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzOSQoX2NvbnRleHQ0MCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NDAucHJldiA9IF9jb250ZXh0NDAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmdzID0gW3N0YXJ0U2xvdCwgbGltaXRdO1xuICAgICAgICAgICAgICBfY29udGV4dDQwLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcnMnLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ0MC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVycycpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0MC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzOSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRTbG90TGVhZGVycyhfeDUyLCBfeDUzKSB7XG4gICAgICAgIHJldHVybiBfZ2V0U2xvdExlYWRlcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRTbG90TGVhZGVycztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgY3VycmVudCBzdGF0dXMgb2YgYSBzaWduYXR1cmVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTaWduYXR1cmVTdGF0dXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTaWduYXR1cmVTdGF0dXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQwKHNpZ25hdHVyZSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRnZXRTaWduYXQsIGNvbnRleHQsIHZhbHVlcywgdmFsdWU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0MCQoX2NvbnRleHQ0MSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NDEucHJldiA9IF9jb250ZXh0NDEubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDQxLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhbc2lnbmF0dXJlXSwgY29uZmlnKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgX3lpZWxkJHRoaXMkZ2V0U2lnbmF0ID0gX2NvbnRleHQ0MS5zZW50O1xuICAgICAgICAgICAgICBjb250ZXh0ID0gX3lpZWxkJHRoaXMkZ2V0U2lnbmF0LmNvbnRleHQ7XG4gICAgICAgICAgICAgIHZhbHVlcyA9IF95aWVsZCR0aGlzJGdldFNpZ25hdC52YWx1ZTtcbiAgICAgICAgICAgICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPT09IDEpO1xuICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlc1swXTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDEuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDEuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQwLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFNpZ25hdHVyZVN0YXR1cyhfeDU0LCBfeDU1KSB7XG4gICAgICAgIHJldHVybiBfZ2V0U2lnbmF0dXJlU3RhdHVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2lnbmF0dXJlU3RhdHVzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1c2VzIG9mIGEgYmF0Y2ggb2Ygc2lnbmF0dXJlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNpZ25hdHVyZVN0YXR1c2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0U2lnbmF0dXJlU3RhdHVzZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQxKHNpZ25hdHVyZXMsIGNvbmZpZykge1xuICAgICAgICB2YXIgcGFyYW1zLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQxJChfY29udGV4dDQyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ0Mi5wcmV2ID0gX2NvbnRleHQ0Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHBhcmFtcyA9IFtzaWduYXR1cmVzXTtcbiAgICAgICAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHBhcmFtcy5wdXNoKGNvbmZpZyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQ0Mi5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZVN0YXR1c2VzJywgcGFyYW1zKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ0Mi5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRTaWduYXR1cmVTdGF0dXNlc1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDIubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZSBzdGF0dXMnKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDIuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDEsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0U2lnbmF0dXJlU3RhdHVzZXMoX3g1NiwgX3g1Nykge1xuICAgICAgICByZXR1cm4gX2dldFNpZ25hdHVyZVN0YXR1c2VzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0U2lnbmF0dXJlU3RhdHVzZXM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdHJhbnNhY3Rpb24gY291bnQgb2YgdGhlIGNsdXN0ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0VHJhbnNhY3Rpb25Db3VudCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNDIoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm8xMywgY29tbWl0bWVudCwgY29uZmlnLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQyJChfY29udGV4dDQzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ0My5wcmV2ID0gX2NvbnRleHQ0My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzEzID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyksIGNvbW1pdG1lbnQgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xMy5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xMy5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0My5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ0My5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDMubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uIGNvdW50Jyk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQzLmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQyLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uQ291bnQoX3g1OCkge1xuICAgICAgICByZXR1cm4gX2dldFRyYW5zYWN0aW9uQ291bnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRUcmFuc2FjdGlvbkNvdW50O1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBjdXJyZW50IHRvdGFsIGN1cnJlbmN5IHN1cHBseSBvZiB0aGUgY2x1c3RlciBpbiBsYW1wb3J0c1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4yLjguIFBsZWFzZSB1c2Uge0BsaW5rIGdldFN1cHBseX0gaW5zdGVhZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUb3RhbFN1cHBseVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRvdGFsU3VwcGx5ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0Myhjb21taXRtZW50KSB7XG4gICAgICAgIHZhciByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0MyQoX2NvbnRleHQ0NCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NDQucHJldiA9IF9jb250ZXh0NDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDQ0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRTdXBwbHkoe1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgZXhjbHVkZU5vbkNpcmN1bGF0aW5nQWNjb3VudHNMaXN0OiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDQ0LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQ0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQudmFsdWUudG90YWwpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDMsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0VG90YWxTdXBwbHkoX3g1OSkge1xuICAgICAgICByZXR1cm4gX2dldFRvdGFsU3VwcGx5LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0VG90YWxTdXBwbHk7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGNsdXN0ZXIgSW5mbGF0aW9uR292ZXJub3IgcGFyYW1ldGVyc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEluZmxhdGlvbkdvdmVybm9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0SW5mbGF0aW9uR292ZXJub3IgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQ0KGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNDQkKF9jb250ZXh0NDUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQ1LnByZXYgPSBfY29udGV4dDQ1Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NDUubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25Hb3Zlcm5vcicsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDQ1LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvbkdvdmVybm9yUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0NS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uJyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQ1LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQ0LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldEluZmxhdGlvbkdvdmVybm9yKF94NjApIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbmZsYXRpb25Hb3Zlcm5vci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEluZmxhdGlvbkdvdmVybm9yO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBpbmZsYXRpb24gcmV3YXJkIGZvciBhIGxpc3Qgb2YgYWRkcmVzc2VzIGZvciBhbiBlcG9jaFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEluZmxhdGlvblJld2FyZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEluZmxhdGlvblJld2FyZCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNDUoYWRkcmVzc2VzLCBlcG9jaCwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm8xNCwgY29tbWl0bWVudCwgY29uZmlnLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTQ1JChfY29udGV4dDQ2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ0Ni5wcmV2ID0gX2NvbnRleHQ0Ni5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzE0ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyksIGNvbW1pdG1lbnQgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xNC5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xNC5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2FkZHJlc3Nlcy5tYXAoZnVuY3Rpb24gKHB1YmtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwdWJrZXkudG9CYXNlNTgoKTtcbiAgICAgICAgICAgICAgfSldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgY29uZmlnKSwge30sIHtcbiAgICAgICAgICAgICAgICBlcG9jaDogZXBvY2ggIT0gbnVsbCA/IGVwb2NoIDogY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29uZmlnLmVwb2NoXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ0Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJld2FyZCcsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDQ2LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEluZmxhdGlvblJld2FyZFJlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDYubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByZXdhcmQnKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDYuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0Ni5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0SW5mbGF0aW9uUmV3YXJkKF94NjEsIF94NjIsIF94NjMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbmZsYXRpb25SZXdhcmQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRJbmZsYXRpb25SZXdhcmQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIHNwZWNpZmljIGluZmxhdGlvbiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0SW5mbGF0aW9uUmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEluZmxhdGlvblJhdGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQ2KCkge1xuICAgICAgICB2YXIgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0NiQoX2NvbnRleHQ0Nykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NDcucHJldiA9IF9jb250ZXh0NDcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDQ3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0SW5mbGF0aW9uUmF0ZScsIFtdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ0Ny5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SYXRlUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0Ny5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJhdGUnKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDcuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDYsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0SW5mbGF0aW9uUmF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRJbmZsYXRpb25SYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0SW5mbGF0aW9uUmF0ZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgRXBvY2ggSW5mbyBwYXJhbWV0ZXJzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RXBvY2hJbmZvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0RXBvY2hJbmZvID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0Nyhjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzE1LCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNDckKF9jb250ZXh0NDgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQ4LnByZXYgPSBfY29udGV4dDQ4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvMTUgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzE1LmNvbW1pdG1lbnQsIGNvbmZpZyA9IF9leHRyYWN0Q29tbWl0bWVudEZybzE1LmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDQ4Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0RXBvY2hJbmZvJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NDguc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hJbmZvUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ0OC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggaW5mbycpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0OC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQ4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU0NywgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRFcG9jaEluZm8oX3g2NCkge1xuICAgICAgICByZXR1cm4gX2dldEVwb2NoSW5mby5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEVwb2NoSW5mbztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgRXBvY2ggU2NoZWR1bGUgcGFyYW1ldGVyc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVwb2NoU2NoZWR1bGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRFcG9jaFNjaGVkdWxlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU0OCgpIHtcbiAgICAgICAgdmFyIHVuc2FmZVJlcywgcmVzLCBlcG9jaFNjaGVkdWxlO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNDgkKF9jb250ZXh0NDkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDQ5LnByZXYgPSBfY29udGV4dDQ5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ0OS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoU2NoZWR1bGUnLCBbXSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NDkuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NDkubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIHNjaGVkdWxlJyk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIGVwb2NoU2NoZWR1bGUgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0OS5hYnJ1cHQoXCJyZXR1cm5cIiwgbmV3IEVwb2NoU2NoZWR1bGUoZXBvY2hTY2hlZHVsZS5zbG90c1BlckVwb2NoLCBlcG9jaFNjaGVkdWxlLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgZXBvY2hTY2hlZHVsZS53YXJtdXAsIGVwb2NoU2NoZWR1bGUuZmlyc3ROb3JtYWxFcG9jaCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbFNsb3QpKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NDkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQ4LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldEVwb2NoU2NoZWR1bGUoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0RXBvY2hTY2hlZHVsZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEVwb2NoU2NoZWR1bGU7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPFJwY1Jlc3BvbnNlQW5kQ29udGV4dDxMZWFkZXJTY2hlZHVsZT4+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExlYWRlclNjaGVkdWxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0TGVhZGVyU2NoZWR1bGUgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQ5KCkge1xuICAgICAgICB2YXIgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU0OSQoX2NvbnRleHQ1MCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NTAucHJldiA9IF9jb250ZXh0NTAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDUwLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGVhZGVyU2NoZWR1bGUnLCBbXSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NTAuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGVhZGVyU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUwLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsZWFkZXIgc2NoZWR1bGUnKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTAuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1MC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNDksIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0TGVhZGVyU2NoZWR1bGUoKSB7XG4gICAgICAgIHJldHVybiBfZ2V0TGVhZGVyU2NoZWR1bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRMZWFkZXJTY2hlZHVsZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgbWluaW11bSBiYWxhbmNlIG5lZWRlZCB0byBleGVtcHQgYW4gYWNjb3VudCBvZiBgZGF0YUxlbmd0aGBcbiAgICAgKiBzaXplIGZyb20gcmVudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNTAoZGF0YUxlbmd0aCwgY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgYXJncywgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1MCQoX2NvbnRleHQ1MSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NTEucHJldiA9IF9jb250ZXh0NTEubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtkYXRhTGVuZ3RoXSwgY29tbWl0bWVudCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24nLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ1MS5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDUxLm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZldGNoIG1pbmltdW0gYmFsYW5jZSBmb3IgcmVudCBleGVtcHRpb24nKTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTEuYWJydXB0KFwicmV0dXJuXCIsIDApO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1MS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDUxLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1MCwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oX3g2NSwgX3g2Nikge1xuICAgICAgICByZXR1cm4gX2dldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldE1pbmltdW1CYWxhbmNlRm9yUmVudEV4ZW1wdGlvbjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+Pn1cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1MShjb21taXRtZW50KSB7XG4gICAgICAgIHZhciBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUxJChfY29udGV4dDUyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1Mi5wcmV2ID0gX2NvbnRleHQ1Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICBfY29udGV4dDUyLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50QmxvY2toYXNoJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NTIuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dFJwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTIubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2gnKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTIuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTEsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChfeDY3KSB7XG4gICAgICAgIHJldHVybiBfZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PFBlcmZTYW1wbGU+Pn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTUyKGxpbWl0KSB7XG4gICAgICAgIHZhciB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTUyJChfY29udGV4dDUzKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1My5wcmV2ID0gX2NvbnRleHQ1My5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NTMubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMnLCBsaW1pdCA/IFtsaW1pdF0gOiBbXSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NTMuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1My5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXMnKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTMuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1My5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTIsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzKF94NjgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGZlZSBjYWxjdWxhdG9yIGZvciBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRGZWVGb3JNZXNzYWdlfSBpbnN0ZWFkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1MyhibG9ja2hhc2gsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzLCBfcmVzJHJlc3VsdCwgY29udGV4dCwgdmFsdWU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU1MyQoX2NvbnRleHQ1NCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NTQucHJldiA9IF9jb250ZXh0NTQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ1NC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1NC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGNhbGN1bGF0b3InKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX3JlcyRyZXN1bHQgPSByZXMucmVzdWx0LCBjb250ZXh0ID0gX3JlcyRyZXN1bHQuY29udGV4dCwgdmFsdWUgPSBfcmVzJHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTQuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlLmZlZUNhbGN1bGF0b3IgOiBudWxsXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTMsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaChfeDY5LCBfeDcwKSB7XG4gICAgICAgIHJldHVybiBfZ2V0RmVlQ2FsY3VsYXRvckZvckJsb2NraGFzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2g7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGZlZSBmb3IgYSBtZXNzYWdlIGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRGZWVGb3JNZXNzYWdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0RmVlRm9yTWVzc2FnZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNTQobWVzc2FnZSwgY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgd2lyZU1lc3NhZ2UsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNTQkKF9jb250ZXh0NTUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDU1LnByZXYgPSBfY29udGV4dDU1Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgd2lyZU1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3dpcmVNZXNzYWdlXSwgY29tbWl0bWVudCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NTUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVGb3JNZXNzYWdlJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NTUuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGZlZSBmb3IgbWVzc2FnZScpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICBpZiAoIShyZXMucmVzdWx0ID09PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTUubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBibG9ja2hhc2gnKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU1LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU1LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1NCwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRGZWVGb3JNZXNzYWdlKF94NzEsIF94NzIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRGZWVGb3JNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0RmVlRm9yTWVzc2FnZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgcHJpb3JpdGl6YXRpb24gZmVlcyBmcm9tIHJlY2VudCBibG9ja3MuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1NShjb25maWcpIHtcbiAgICAgICAgdmFyIF9jb25maWckbG9ja2VkV3JpdGFibDtcbiAgICAgICAgdmFyIGFjY291bnRzLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTU1JChfY29udGV4dDU2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ1Ni5wcmV2ID0gX2NvbnRleHQ1Ni5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFjY291bnRzID0gY29uZmlnID09PSBudWxsIHx8IGNvbmZpZyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9jb25maWckbG9ja2VkV3JpdGFibCA9IGNvbmZpZy5sb2NrZWRXcml0YWJsZUFjY291bnRzKSA9PT0gbnVsbCB8fCBfY29uZmlnJGxvY2tlZFdyaXRhYmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jb25maWckbG9ja2VkV3JpdGFibC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBrZXkudG9CYXNlNTgoKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGFyZ3MgPSBhY2NvdW50cyAhPT0gbnVsbCAmJiBhY2NvdW50cyAhPT0gdm9pZCAwICYmIGFjY291bnRzLmxlbmd0aCA/IFthY2NvdW50c10gOiBbXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcycsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDU2LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NTYubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHJlY2VudCBwcmlvcml0aXphdGlvbiBmZWVzJyk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU2LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTU1LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyhfeDczKSB7XG4gICAgICAgIHJldHVybiBfZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZTx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pn1cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0TGF0ZXN0QmxvY2toYXNofSBpbnN0ZWFkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFJlY2VudEJsb2NraGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFJlY2VudEJsb2NraGFzaCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNTYoY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNTYkKF9jb250ZXh0NTcpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDU3LnByZXYgPSBfY29udGV4dDU3Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Ny5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50KTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmVzID0gX2NvbnRleHQ1Ny5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Ny5wcmV2ID0gNztcbiAgICAgICAgICAgICAgX2NvbnRleHQ1Ny50MCA9IF9jb250ZXh0NTdbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBfY29udGV4dDU3LnQwKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU3LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1NiwgdGhpcywgW1swLCA3XV0pO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0UmVjZW50QmxvY2toYXNoKF94NzQpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRSZWNlbnRCbG9ja2hhc2guYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRSZWNlbnRCbG9ja2hhc2g7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgICAqIEByZXR1cm4ge1Byb21pc2U8QmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0Pn1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRMYXRlc3RCbG9ja2hhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRMYXRlc3RCbG9ja2hhc2ggPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTU3KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgICB2YXIgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNTckKF9jb250ZXh0NTgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDU4LnByZXYgPSBfY29udGV4dDU4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ1OC5wcmV2ID0gMDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ1OC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dChjb21taXRtZW50T3JDb25maWcpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICByZXMgPSBfY29udGV4dDU4LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU4LmFicnVwdChcInJldHVyblwiLCByZXMudmFsdWUpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBfY29udGV4dDU4LnByZXYgPSA3O1xuICAgICAgICAgICAgICBfY29udGV4dDU4LnQwID0gX2NvbnRleHQ1OFtcImNhdGNoXCJdKDApO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZhaWxlZCB0byBnZXQgcmVjZW50IGJsb2NraGFzaDogJyArIF9jb250ZXh0NTgudDApO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NTguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTU3LCB0aGlzLCBbWzAsIDddXSk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRMYXRlc3RCbG9ja2hhc2goX3g3NSkge1xuICAgICAgICByZXR1cm4gX2dldExhdGVzdEJsb2NraGFzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldExhdGVzdEJsb2NraGFzaDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgbGF0ZXN0IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0ID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU1OChjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzE2LCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNTgkKF9jb250ZXh0NTkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDU5LnByZXYgPSBfY29udGV4dDU5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvMTYgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzE2LmNvbW1pdG1lbnQsIGNvbmZpZyA9IF9leHRyYWN0Q29tbWl0bWVudEZybzE2LmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDU5Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TGF0ZXN0QmxvY2toYXNoJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NTkuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0TGF0ZXN0QmxvY2toYXNoUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ1OS5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGF0ZXN0IGJsb2NraGFzaCcpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ1OS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDU5LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU1OCwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KF94NzYpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0TGF0ZXN0QmxvY2toYXNoQW5kQ29udGV4dDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBibG9ja2hhc2ggaXMgc3RpbGwgdmFsaWQgb3Igbm90XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaXNCbG9ja2hhc2hWYWxpZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2lzQmxvY2toYXNoVmFsaWQgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTU5KGJsb2NraGFzaCwgcmF3Q29uZmlnKSB7XG4gICAgICAgIHZhciBfZXh0cmFjdENvbW1pdG1lbnRGcm8xNywgY29tbWl0bWVudCwgY29uZmlnLCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTU5JChfY29udGV4dDYwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2MC5wcmV2ID0gX2NvbnRleHQ2MC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzE3ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyksIGNvbW1pdG1lbnQgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xNy5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8xNy5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2MC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2lzQmxvY2toYXNoVmFsaWQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ2MC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBJc0Jsb2NraGFzaFZhbGlkUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2MC5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBkZXRlcm1pbmUgaWYgdGhlIGJsb2NraGFzaCBgJyArIGJsb2NraGFzaCArICdgaXMgdmFsaWQnKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjAuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2MC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNTksIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gaXNCbG9ja2hhc2hWYWxpZChfeDc3LCBfeDc4KSB7XG4gICAgICAgIHJldHVybiBfaXNCbG9ja2hhc2hWYWxpZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzQmxvY2toYXNoVmFsaWQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIG5vZGUgdmVyc2lvblxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZlcnNpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRWZXJzaW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2MCgpIHtcbiAgICAgICAgdmFyIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNjAkKF9jb250ZXh0NjEpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDYxLnByZXYgPSBfY29udGV4dDYxLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ2MS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFZlcnNpb24nLCBbXSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NjEuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChWZXJzaW9uUmVzdWx0KSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjEubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHZlcnNpb24nKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjEuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2MS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNjAsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRWZXJzaW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0VmVyc2lvbjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0aGUgZ2VuZXNpcyBoYXNoXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0R2VuZXNpc0hhc2hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRHZW5lc2lzSGFzaCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNjEoKSB7XG4gICAgICAgIHZhciB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTYxJChfY29udGV4dDYyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2Mi5wcmV2ID0gX2NvbnRleHQ2Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0NjIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRHZW5lc2lzSGFzaCcsIFtdKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ2Mi5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KHN0cmluZygpKSk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGdlbmVzaXMgaGFzaCcpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYyLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2MSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRHZW5lc2lzSGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRHZW5lc2lzSGFzaC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldEdlbmVzaXNIYXNoO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRCbG9ja2AgdXNpbmcgYSBgR2V0VmVyc2lvbmVkQmxvY2tDb25maWdgIGJ5XG4gICAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmxvY2tcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIHByb2Nlc3NlZCBibG9jayBmcm9tIHRoZSBjbHVzdGVyLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEJsb2NrID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2MihzbG90LCByYXdDb25maWcpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzE4LCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzLCBfcmVzLCBfcmVzMiwgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNjIkKF9jb250ZXh0NjMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDYzLnByZXYgPSBfY29udGV4dDYzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvMTggPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzE4LmNvbW1pdG1lbnQsIGNvbmZpZyA9IF9leHRyYWN0Q29tbWl0bWVudEZybzE4LmNvbmZpZztcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjMubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDYzLnNlbnQ7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjMucHJldiA9IDU7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjMudDAgPSBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcudHJhbnNhY3Rpb25EZXRhaWxzO1xuICAgICAgICAgICAgICBfY29udGV4dDYzLm5leHQgPSBfY29udGV4dDYzLnQwID09PSAnYWNjb3VudHMnID8gOSA6IF9jb250ZXh0NjMudDAgPT09ICdub25lJyA/IDEzIDogMTc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjMubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYzLmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIF9yZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiBfcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjMubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IF9yZXMuZXJyb3I7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2My5hYnJ1cHQoXCJyZXR1cm5cIiwgX3Jlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgX3JlczIgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gX3JlczIpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2My5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgX3JlczIuZXJyb3I7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICByZXN1bHQgPSBfcmVzMi5yZXN1bHQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDYzLmFicnVwdChcInJldHVyblwiLCByZXN1bHQgPyBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAoX3JlZjE1KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBfcmVmMTUudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG1ldGEgPSBfcmVmMTUubWV0YSxcbiAgICAgICAgICAgICAgICAgICAgdmVyc2lvbiA9IF9yZWYxNS52ZXJzaW9uO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogbWV0YSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdHJhbnNhY3Rpb24pLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgdHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIHZlcnNpb246IHZlcnNpb25cbiAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSkgOiBudWxsKTtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIF9jb250ZXh0NjMubmV4dCA9IDI3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0NjMucHJldiA9IDI0O1xuICAgICAgICAgICAgICBfY29udGV4dDYzLnQxID0gX2NvbnRleHQ2M1tcImNhdGNoXCJdKDUpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKF9jb250ZXh0NjMudDEsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgICAgICAgICAgY2FzZSAyNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTYyLCB0aGlzLCBbWzUsIDI0XV0pO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0QmxvY2soX3g3OSwgX3g4MCkge1xuICAgICAgICByZXR1cm4gX2dldEJsb2NrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0QmxvY2s7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCBibG9ja1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFBhcnNlZEJsb2NrXCIsXG4gICAgdmFsdWU6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFBhcnNlZEJsb2NrID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2MyhzbG90LCByYXdDb25maWcpIHtcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzE5LCBjb21taXRtZW50LCBjb25maWcsIGFyZ3MsIHVuc2FmZVJlcywgcmVzLCBfcmVzMywgX3JlczQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2MyQoX2NvbnRleHQ2NCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NjQucHJldiA9IF9jb250ZXh0NjQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfZXh0cmFjdENvbW1pdG1lbnRGcm8xOSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpLCBjb21taXRtZW50ID0gX2V4dHJhY3RDb21taXRtZW50RnJvMTkuY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvMTkuY29uZmlnO1xuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2NC5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NjQuc2VudDtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2NC5wcmV2ID0gNTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2NC50MCA9IGNvbmZpZyA9PT0gbnVsbCB8fCBjb25maWcgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvbmZpZy50cmFuc2FjdGlvbkRldGFpbHM7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjQubmV4dCA9IF9jb250ZXh0NjQudDAgPT09ICdhY2NvdW50cycgPyA5IDogX2NvbnRleHQ2NC50MCA9PT0gJ25vbmUnID8gMTMgOiAxNztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2NC5uZXh0ID0gMTI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjQuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgICAgX3JlczMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiBfcmVzMykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDY0Lm5leHQgPSAxNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBfcmVzMy5lcnJvcjtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDY0LmFicnVwdChcInJldHVyblwiLCBfcmVzMy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxNzpcbiAgICAgICAgICAgICAgX3JlczQgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gX3JlczQpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2NC5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgX3JlczQuZXJyb3I7XG4gICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2NC5hYnJ1cHQoXCJyZXR1cm5cIiwgX3JlczQucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMjE6XG4gICAgICAgICAgICAgIF9jb250ZXh0NjQubmV4dCA9IDI2O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjM6XG4gICAgICAgICAgICAgIF9jb250ZXh0NjQucHJldiA9IDIzO1xuICAgICAgICAgICAgICBfY29udGV4dDY0LnQxID0gX2NvbnRleHQ2NFtcImNhdGNoXCJdKDUpO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKF9jb250ZXh0NjQudDEsICdmYWlsZWQgdG8gZ2V0IGJsb2NrJyk7XG4gICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2NC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNjMsIHRoaXMsIFtbNSwgMjNdXSk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRQYXJzZWRCbG9jayhfeDgxLCBfeDgyKSB7XG4gICAgICAgIHJldHVybiBfZ2V0UGFyc2VkQmxvY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRQYXJzZWRCbG9jaztcbiAgICB9KClcbiAgfSwge1xuICAgIGtleTogXCJnZXRCbG9ja1Byb2R1Y3Rpb25cIixcbiAgICB2YWx1ZTpcbiAgICAvKlxuICAgICAqIFJldHVybnMgcmVjZW50IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24gZnJvbSB0aGUgY3VycmVudCBvciBwcmV2aW91cyBlcG9jaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0QmxvY2tQcm9kdWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2NChjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGV4dHJhLCBjb21taXRtZW50LCBjLCByZXN0LCBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTY0JChfY29udGV4dDY1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2NS5wcmV2ID0gX2NvbnRleHQ2NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgY29uZmlnT3JDb21taXRtZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQgPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgYyA9IGNvbmZpZ09yQ29tbWl0bWVudC5jb21taXRtZW50LCByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKGNvbmZpZ09yQ29tbWl0bWVudCwgX2V4Y2x1ZGVkMyk7XG4gICAgICAgICAgICAgICAgY29tbWl0bWVudCA9IGM7XG4gICAgICAgICAgICAgICAgZXh0cmEgPSByZXN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBleHRyYSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjUubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1Byb2R1Y3Rpb24nLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ2NS5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjUubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrIHByb2R1Y3Rpb24gaW5mb3JtYXRpb24nKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjUuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2NS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNjQsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0QmxvY2tQcm9kdWN0aW9uKF94ODMpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRCbG9ja1Byb2R1Y3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRCbG9ja1Byb2R1Y3Rpb247XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBjb25maXJtZWQgb3IgZmluYWxpemVkIHRyYW5zYWN0aW9uIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbmAgdXNpbmcgYVxuICAgICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2NShzaWduYXR1cmUsIHJhd0NvbmZpZykge1xuICAgICAgICB2YXIgX2V4dHJhY3RDb21taXRtZW50RnJvMjAsIGNvbW1pdG1lbnQsIGNvbmZpZywgYXJncywgdW5zYWZlUmVzLCByZXMsIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTY1JChfY29udGV4dDY2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2Ni5wcmV2ID0gX2NvbnRleHQ2Ni5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzIwID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyksIGNvbW1pdG1lbnQgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8yMC5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8yMC5jb25maWc7XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjYubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDY2LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ2Ni5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjYubmV4dCA9IDExO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDY2LmFicnVwdChcInJldHVyblwiLCByZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjYuYWJydXB0KFwicmV0dXJuXCIsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCByZXN1bHQudHJhbnNhY3Rpb24pLCB7fSwge1xuICAgICAgICAgICAgICAgICAgbWVzc2FnZTogdmVyc2lvbmVkTWVzc2FnZUZyb21SZXNwb25zZShyZXN1bHQudmVyc2lvbiwgcmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjYuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTY1LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFRyYW5zYWN0aW9uKF94ODQsIF94ODUpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJzZWRUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFBhcnNlZFRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU2NihzaWduYXR1cmUsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgICB2YXIgX2V4dHJhY3RDb21taXRtZW50RnJvMjEsIGNvbW1pdG1lbnQsIGNvbmZpZywgYXJncywgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2NiQoX2NvbnRleHQ2Nykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NjcucHJldiA9IF9jb250ZXh0NjcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfZXh0cmFjdENvbW1pdG1lbnRGcm8yMSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpLCBjb21taXRtZW50ID0gX2V4dHJhY3RDb21taXRtZW50RnJvMjEuY29tbWl0bWVudCwgY29uZmlnID0gX2V4dHJhY3RDb21taXRtZW50RnJvMjEuY29uZmlnO1xuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgICAgICAgICAgICBfY29udGV4dDY3Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ2Ny5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NjcubmV4dCA9IDg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDY3LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Njcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTY2LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFBhcnNlZFRyYW5zYWN0aW9uKF94ODYsIF94ODcpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRQYXJzZWRUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFBhcnNlZFRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJzZWRUcmFuc2FjdGlvbnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRQYXJzZWRUcmFuc2FjdGlvbnMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTY3KHNpZ25hdHVyZXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgICAgdmFyIF9leHRyYWN0Q29tbWl0bWVudEZybzIyLCBjb21taXRtZW50LCBjb25maWcsIGJhdGNoLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTY3JChfY29udGV4dDY4KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ2OC5wcmV2ID0gX2NvbnRleHQ2OC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9leHRyYWN0Q29tbWl0bWVudEZybzIyID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyksIGNvbW1pdG1lbnQgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8yMi5jb21taXRtZW50LCBjb25maWcgPSBfZXh0cmFjdENvbW1pdG1lbnRGcm8yMi5jb25maWc7XG4gICAgICAgICAgICAgIGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoZnVuY3Rpb24gKHNpZ25hdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gX3RoaXM2Ll9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6ICdnZXRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NjgubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDY4LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IHVuc2FmZVJlcy5tYXAoZnVuY3Rpb24gKHVuc2FmZVJlcykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NjguYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDY4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU2NywgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRQYXJzZWRUcmFuc2FjdGlvbnMoX3g4OCwgX3g4OSkge1xuICAgICAgICByZXR1cm4gX2dldFBhcnNlZFRyYW5zYWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFBhcnNlZFRyYW5zYWN0aW9ucztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGluayBUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldFRyYW5zYWN0aW9uc2AgdXNpbmcgYVxuICAgICAqIGBHZXRWZXJzaW9uZWRUcmFuc2FjdGlvbkNvbmZpZ2AgYnkgc2V0dGluZyB0aGVcbiAgICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRUcmFuc2FjdGlvbnNcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBGZXRjaCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnMuXG4gICAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgICAqL1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFRyYW5zYWN0aW9ucyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNjgoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgICB2YXIgX2V4dHJhY3RDb21taXRtZW50RnJvMjMsIGNvbW1pdG1lbnQsIGNvbmZpZywgYmF0Y2gsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNjgkKF9jb250ZXh0NjkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDY5LnByZXYgPSBfY29udGV4dDY5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2V4dHJhY3RDb21taXRtZW50RnJvMjMgPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSwgY29tbWl0bWVudCA9IF9leHRyYWN0Q29tbWl0bWVudEZybzIzLmNvbW1pdG1lbnQsIGNvbmZpZyA9IF9leHRyYWN0Q29tbWl0bWVudEZybzIzLmNvbmZpZztcbiAgICAgICAgICAgICAgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfdGhpczcuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ2OS5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0Njkuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gdW5zYWZlUmVzLm1hcChmdW5jdGlvbiAodW5zYWZlUmVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgcmVzdWx0KSwge30sIHtcbiAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdC50cmFuc2FjdGlvbiksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDY5LmFicnVwdChcInJldHVyblwiLCByZXMpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ2OS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNjgsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0VHJhbnNhY3Rpb25zKF94OTAsIF94OTEpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRUcmFuc2FjdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRUcmFuc2FjdGlvbnM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIFRyYW5zYWN0aW9ucyBhbmQgdHJhbnNhY3Rpb24gc3RhdHVzZXMgZnJvbSB0aGUgY2x1c3RlclxuICAgICAqIGZvciBhIGNvbmZpcm1lZCBibG9jay5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMTMuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2t9IGluc3RlYWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29uZmlybWVkQmxvY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRDb25maXJtZWRCbG9jayA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNjkoc2xvdCwgY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgYXJncywgdW5zYWZlUmVzLCByZXMsIHJlc3VsdCwgYmxvY2s7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU2OSQoX2NvbnRleHQ3MCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NzAucHJldiA9IF9jb250ZXh0NzAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICBfY29udGV4dDcwLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkQmxvY2snLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ3MC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgIGlmICghKCdlcnJvcicgaW4gcmVzKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NzAubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3MC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgYmxvY2sgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25zOiByZXN1bHQudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAoX3JlZjE2KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBfcmVmMTYudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG1ldGEgPSBfcmVmMTYubWV0YTtcbiAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbmV3IE1lc3NhZ2UodHJhbnNhY3Rpb24ubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBtZXRhOiBtZXRhLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCB0cmFuc2FjdGlvbiksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NzAuYWJydXB0KFwicmV0dXJuXCIsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgYmxvY2spLCB7fSwge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uczogYmxvY2sudHJhbnNhY3Rpb25zLm1hcChmdW5jdGlvbiAoX3JlZjE3KSB7XG4gICAgICAgICAgICAgICAgICB2YXIgdHJhbnNhY3Rpb24gPSBfcmVmMTcudHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIG1ldGEgPSBfcmVmMTcubWV0YTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGE6IG1ldGEsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbi5tZXNzYWdlLCB0cmFuc2FjdGlvbi5zaWduYXR1cmVzKVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3MC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNjksIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0Q29uZmlybWVkQmxvY2soX3g5MiwgX3g5Mykge1xuICAgICAgICByZXR1cm4gX2dldENvbmZpcm1lZEJsb2NrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0Q29uZmlybWVkQmxvY2s7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggY29uZmlybWVkIGJsb2NrcyBiZXR3ZWVuIHR3byBzbG90c1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJsb2Nrc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEJsb2NrcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNzAoc3RhcnRTbG90LCBlbmRTbG90LCBjb21taXRtZW50KSB7XG4gICAgICAgIHZhciBhcmdzLCB1bnNhZmVSZXMsIHJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTcwJChfY29udGV4dDcxKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ3MS5wcmV2ID0gX2NvbnRleHQ3MS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGVuZFNsb3QgIT09IHVuZGVmaW5lZCA/IFtzdGFydFNsb3QsIGVuZFNsb3RdIDogW3N0YXJ0U2xvdF0sIGNvbW1pdG1lbnQpO1xuICAgICAgICAgICAgICBfY29udGV4dDcxLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NzEuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChhcnJheShudW1iZXIoKSkpKTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3MS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2tzJyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDcxLmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NzEuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcwLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldEJsb2NrcyhfeDk0LCBfeDk1LCBfeDk2KSB7XG4gICAgICAgIHJldHVybiBfZ2V0QmxvY2tzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0QmxvY2tzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIGEgbGlzdCBvZiBTaWduYXR1cmVzIGZyb20gdGhlIGNsdXN0ZXIgZm9yIGEgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QmxvY2tTaWduYXR1cmVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0QmxvY2tTaWduYXR1cmVzID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3MShzbG90LCBjb21taXRtZW50KSB7XG4gICAgICAgIHZhciBhcmdzLCB1bnNhZmVSZXMsIHJlcywgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNzEkKF9jb250ZXh0NzIpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDcyLnByZXYgPSBfY29udGV4dDcyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCB1bmRlZmluZWQsIHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgICAgICAgICAgICByZXdhcmRzOiBmYWxzZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Mi5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NzIuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Mi5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2snKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NzIubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgICAgICAgICAgY2FzZSAxMDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NzIuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNzEsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0QmxvY2tTaWduYXR1cmVzKF94OTcsIF94OTgpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRCbG9ja1NpZ25hdHVyZXMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXRCbG9ja1NpZ25hdHVyZXM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggYSBsaXN0IG9mIFNpZ25hdHVyZXMgZnJvbSB0aGUgY2x1c3RlciBmb3IgYSBjb25maXJtZWQgYmxvY2ssIGV4Y2x1ZGluZyByZXdhcmRzXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEJsb2NrU2lnbmF0dXJlc30gaW5zdGVhZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTcyKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzLCByZXN1bHQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3MiQoX2NvbnRleHQ3Mykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NzMucHJldiA9IF9jb250ZXh0NzMubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uRGV0YWlsczogJ3NpZ25hdHVyZXMnLFxuICAgICAgICAgICAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBfY29udGV4dDczLm5leHQgPSAzO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkQmxvY2snLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ3My5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDczLm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NzMubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlybWVkIGJsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDczLmFicnVwdChcInJldHVyblwiLCByZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NzMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTcyLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhfeDk5LCBfeDEwMCkge1xuICAgICAgICByZXR1cm4gX2dldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldENvbmZpcm1lZFRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTczKHNpZ25hdHVyZSwgY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgYXJncywgdW5zYWZlUmVzLCByZXMsIHJlc3VsdCwgbWVzc2FnZSwgc2lnbmF0dXJlcztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTczJChfY29udGV4dDc0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ3NC5wcmV2ID0gX2NvbnRleHQ3NC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50KTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0NzQuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDc0Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbicpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3NC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NzQuYWJydXB0KFwicmV0dXJuXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBtZXNzYWdlID0gbmV3IE1lc3NhZ2UocmVzdWx0LnRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICBzaWduYXR1cmVzID0gcmVzdWx0LnRyYW5zYWN0aW9uLnNpZ25hdHVyZXM7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc0LmFicnVwdChcInJldHVyblwiLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHJlc3VsdCksIHt9LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uLnBvcHVsYXRlKG1lc3NhZ2UsIHNpZ25hdHVyZXMpXG4gICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3MywgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRDb25maXJtZWRUcmFuc2FjdGlvbihfeDEwMSwgX3gxMDIpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRDb25maXJtZWRUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldENvbmZpcm1lZFRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbn0gaW5zdGVhZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3NChzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNzQkKF9jb250ZXh0NzUpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDc1LnByZXYgPSBfY29udGV4dDc1Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NzUubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDc1LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3NS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9uJyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc1LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0NzUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTc0LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uKF94MTAzLCBfeDEwNCkge1xuICAgICAgICByZXR1cm4gX2dldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb247XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGluc3RlYWQuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU3NShzaWduYXR1cmVzLCBjb21taXRtZW50KSB7XG4gICAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgICB2YXIgYmF0Y2gsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNzUkKF9jb250ZXh0NzYpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDc2LnByZXYgPSBfY29udGV4dDc2Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChmdW5jdGlvbiAoc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBfdGhpczguX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIG1ldGhvZE5hbWU6ICdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsXG4gICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NzYubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICB1bnNhZmVSZXMgPSBfY29udGV4dDc2LnNlbnQ7XG4gICAgICAgICAgICAgIHJlcyA9IHVuc2FmZVJlcy5tYXAoZnVuY3Rpb24gKHVuc2FmZVJlcykge1xuICAgICAgICAgICAgICAgIHZhciByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRQYXJzZWRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIHRyYW5zYWN0aW9ucycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc2LmFicnVwdChcInJldHVyblwiLCByZXMpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3Ni5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlNzUsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0UGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25zKF94MTA1LCBfeDEwNikge1xuICAgICAgICByZXR1cm4gX2dldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucztcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaCBhIGxpc3Qgb2YgYWxsIHRoZSBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgdHJhbnNhY3Rpb25zIGludm9sdmluZyBhbiBhZGRyZXNzXG4gICAgICogd2l0aGluIGEgc3BlY2lmaWVkIHNsb3QgcmFuZ2UuIE1heCByYW5nZSBhbGxvd2VkIGlzIDEwLDAwMCBzbG90cy5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMy4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyfSBpbnN0ZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAgICogQHBhcmFtIHN0YXJ0U2xvdCBzdGFydCBzbG90LCBpbmNsdXNpdmVcbiAgICAgKiBAcGFyYW0gZW5kU2xvdCBlbmQgc2xvdCwgaW5jbHVzaXZlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNzYoYWRkcmVzcywgc3RhcnRTbG90LCBlbmRTbG90KSB7XG4gICAgICAgIHZhciBvcHRpb25zLCBmaXJzdEF2YWlsYWJsZUJsb2NrLCBibG9jaywgaGlnaGVzdENvbmZpcm1lZFJvb3QsIF9ibG9jaywgY29uZmlybWVkU2lnbmF0dXJlSW5mbztcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTc2JChfY29udGV4dDc3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ3Ny5wcmV2ID0gX2NvbnRleHQ3Ny5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Ny5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaygpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBmaXJzdEF2YWlsYWJsZUJsb2NrID0gX2NvbnRleHQ3Ny5zZW50O1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICBpZiAoJ3VudGlsJyBpbiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Ny5uZXh0ID0gMjQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgc3RhcnRTbG90LS07XG4gICAgICAgICAgICAgIGlmICghKHN0YXJ0U2xvdCA8PSAwIHx8IHN0YXJ0U2xvdCA8IGZpcnN0QXZhaWxhYmxlQmxvY2spKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ3Ny5uZXh0ID0gODtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3Ny5hYnJ1cHQoXCJicmVha1wiLCAyNCk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICAgIF9jb250ZXh0NzcucHJldiA9IDg7XG4gICAgICAgICAgICAgIF9jb250ZXh0NzcubmV4dCA9IDExO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc3RhcnRTbG90LCAnZmluYWxpemVkJyk7XG4gICAgICAgICAgICBjYXNlIDExOlxuICAgICAgICAgICAgICBibG9jayA9IF9jb250ZXh0Nzcuc2VudDtcbiAgICAgICAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMudW50aWwgPSBibG9jay5zaWduYXR1cmVzW2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDc3Lm5leHQgPSAyMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICBfY29udGV4dDc3LnByZXYgPSAxNTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Ny50MCA9IF9jb250ZXh0NzdbXCJjYXRjaFwiXSg4KTtcbiAgICAgICAgICAgICAgaWYgKCEoX2NvbnRleHQ3Ny50MCBpbnN0YW5jZW9mIEVycm9yICYmIF9jb250ZXh0NzcudDAubWVzc2FnZS5pbmNsdWRlcygnc2tpcHBlZCcpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NzcubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc3LmFicnVwdChcImNvbnRpbnVlXCIsIDQpO1xuICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgdGhyb3cgX2NvbnRleHQ3Ny50MDtcbiAgICAgICAgICAgIGNhc2UgMjI6XG4gICAgICAgICAgICAgIF9jb250ZXh0NzcubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Ny5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFNsb3QoJ2ZpbmFsaXplZCcpO1xuICAgICAgICAgICAgY2FzZSAyNjpcbiAgICAgICAgICAgICAgaGlnaGVzdENvbmZpcm1lZFJvb3QgPSBfY29udGV4dDc3LnNlbnQ7XG4gICAgICAgICAgICBjYXNlIDI3OlxuICAgICAgICAgICAgICBpZiAoJ2JlZm9yZScgaW4gb3B0aW9ucykge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NzcubmV4dCA9IDQ3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGVuZFNsb3QrKztcbiAgICAgICAgICAgICAgaWYgKCEoZW5kU2xvdCA+IGhpZ2hlc3RDb25maXJtZWRSb290KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NzcubmV4dCA9IDMxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc3LmFicnVwdChcImJyZWFrXCIsIDQ3KTtcbiAgICAgICAgICAgIGNhc2UgMzE6XG4gICAgICAgICAgICAgIF9jb250ZXh0NzcucHJldiA9IDMxO1xuICAgICAgICAgICAgICBfY29udGV4dDc3Lm5leHQgPSAzNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29uZmlybWVkQmxvY2tTaWduYXR1cmVzKGVuZFNsb3QpO1xuICAgICAgICAgICAgY2FzZSAzNDpcbiAgICAgICAgICAgICAgX2Jsb2NrID0gX2NvbnRleHQ3Ny5zZW50O1xuICAgICAgICAgICAgICBpZiAoX2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuYmVmb3JlID0gX2Jsb2NrLnNpZ25hdHVyZXNbX2Jsb2NrLnNpZ25hdHVyZXMubGVuZ3RoIC0gMV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDc3Lm5leHQgPSA0NTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICBfY29udGV4dDc3LnByZXYgPSAzODtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Ny50MSA9IF9jb250ZXh0NzdbXCJjYXRjaFwiXSgzMSk7XG4gICAgICAgICAgICAgIGlmICghKF9jb250ZXh0NzcudDEgaW5zdGFuY2VvZiBFcnJvciAmJiBfY29udGV4dDc3LnQxLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDc3Lm5leHQgPSA0NDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3Ny5hYnJ1cHQoXCJjb250aW51ZVwiLCAyNyk7XG4gICAgICAgICAgICBjYXNlIDQ0OlxuICAgICAgICAgICAgICB0aHJvdyBfY29udGV4dDc3LnQxO1xuICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Ny5uZXh0ID0gMjc7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ3Ny5uZXh0ID0gNDk7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMihhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgNDk6XG4gICAgICAgICAgICAgIGNvbmZpcm1lZFNpZ25hdHVyZUluZm8gPSBfY29udGV4dDc3LnNlbnQ7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc3LmFicnVwdChcInJldHVyblwiLCBjb25maXJtZWRTaWduYXR1cmVJbmZvLm1hcChmdW5jdGlvbiAoaW5mbykge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmZvLnNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY2FzZSA1MTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Nzcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTc2LCB0aGlzLCBbWzgsIDE1XSwgWzMxLCAzOF1dKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzKF94MTA3LCBfeDEwOCwgX3gxMDkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICAgKiBhZGRyZXNzIGJhY2t3YXJkcyBpbiB0aW1lIGZyb20gdGhlIHByb3ZpZGVkIHNpZ25hdHVyZSBvciBtb3N0IHJlY2VudCBjb25maXJtZWQgYmxvY2tcbiAgICAgKlxuICAgICAqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgcXVlcmllZCBhZGRyZXNzXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTc3KGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MsIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlNzckKF9jb250ZXh0NzgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDc4LnByZXYgPSBfY29udGV4dDc4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW2FkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0NzgubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczInLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ3OC5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDc4Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgc2lnbmF0dXJlcyBmb3IgYWRkcmVzcycpO1xuICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ3OC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc4LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3NywgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoX3gxMTAsIF94MTExLCBfeDExMikge1xuICAgICAgICByZXR1cm4gX2dldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuXG4gICAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXRTaWduYXR1cmVzRm9yQWRkcmVzcyA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNzgoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgICAgICB2YXIgYXJncywgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU3OCQoX2NvbnRleHQ3OSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0NzkucHJldiA9IF9jb250ZXh0NzkubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ3OS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZXNGb3JBZGRyZXNzJywgYXJncyk7XG4gICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0Nzkuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDc5Lm5leHQgPSA3O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDc5LmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Nzkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTc4LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzKF94MTEzLCBfeDExNCwgX3gxMTUpIHtcbiAgICAgICAgcmV0dXJuIF9nZXRTaWduYXR1cmVzRm9yQWRkcmVzcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFNpZ25hdHVyZXNGb3JBZGRyZXNzO1xuICAgIH0oKVxuICB9LCB7XG4gICAga2V5OiBcImdldEFkZHJlc3NMb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldEFkZHJlc3NMb29rdXBUYWJsZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlNzkoYWNjb3VudEtleSwgY29uZmlnKSB7XG4gICAgICAgIHZhciBfeWllbGQkdGhpcyRnZXRBY2NvdW4sIGNvbnRleHQsIGFjY291bnRJbmZvLCB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTc5JChfY29udGV4dDgwKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4MC5wcmV2ID0gX2NvbnRleHQ4MC5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0ODAubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChhY2NvdW50S2V5LCBjb25maWcpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICBfeWllbGQkdGhpcyRnZXRBY2NvdW4gPSBfY29udGV4dDgwLnNlbnQ7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSBfeWllbGQkdGhpcyRnZXRBY2NvdW4uY29udGV4dDtcbiAgICAgICAgICAgICAgYWNjb3VudEluZm8gPSBfeWllbGQkdGhpcyRnZXRBY2NvdW4udmFsdWU7XG4gICAgICAgICAgICAgIHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCh7XG4gICAgICAgICAgICAgICAgICBrZXk6IGFjY291bnRLZXksXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudC5kZXNlcmlhbGl6ZShhY2NvdW50SW5mby5kYXRhKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDgwLmFicnVwdChcInJldHVyblwiLCB7XG4gICAgICAgICAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDgwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU3OSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRBZGRyZXNzTG9va3VwVGFibGUoX3gxMTYsIF94MTE3KSB7XG4gICAgICAgIHJldHVybiBfZ2V0QWRkcmVzc0xvb2t1cFRhYmxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0QWRkcmVzc0xvb2t1cFRhYmxlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vbmNlQW5kQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldE5vbmNlQW5kQ29udGV4dCA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlODAobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgdmFyIF95aWVsZCR0aGlzJGdldEFjY291bjIsIGNvbnRleHQsIGFjY291bnRJbmZvLCB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgwJChfY29udGV4dDgxKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4MS5wcmV2ID0gX2NvbnRleHQ4MS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0ODEubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFjY291bnRJbmZvQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIF95aWVsZCR0aGlzJGdldEFjY291bjIgPSBfY29udGV4dDgxLnNlbnQ7XG4gICAgICAgICAgICAgIGNvbnRleHQgPSBfeWllbGQkdGhpcyRnZXRBY2NvdW4yLmNvbnRleHQ7XG4gICAgICAgICAgICAgIGFjY291bnRJbmZvID0gX3lpZWxkJHRoaXMkZ2V0QWNjb3VuMi52YWx1ZTtcbiAgICAgICAgICAgICAgdmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAoYWNjb3VudEluZm8gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IE5vbmNlQWNjb3VudC5mcm9tQWNjb3VudERhdGEoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODEuYWJydXB0KFwicmV0dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgODpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODEuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgwLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIGdldE5vbmNlQW5kQ29udGV4dChfeDExOCwgX3gxMTkpIHtcbiAgICAgICAgcmV0dXJuIF9nZXROb25jZUFuZENvbnRleHQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXROb25jZUFuZENvbnRleHQ7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogRmV0Y2ggdGhlIGNvbnRlbnRzIG9mIGEgTm9uY2UgYWNjb3VudCBmcm9tIHRoZSBjbHVzdGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9uY2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9nZXROb25jZSA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlODEobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTgxJChfY29udGV4dDgyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4Mi5wcmV2ID0gX2NvbnRleHQ4Mi5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0ODIubmV4dCA9IDI7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykudGhlbihmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB4LnZhbHVlO1xuICAgICAgICAgICAgICB9KVtcImNhdGNoXCJdKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IG5vbmNlIGZvciBhY2NvdW50ICcgKyBub25jZUFjY291bnQudG9CYXNlNTgoKSArICc6ICcgKyBlKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDgyLmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDgyLnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4Mi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlODEsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gZ2V0Tm9uY2UoX3gxMjAsIF94MTIxKSB7XG4gICAgICAgIHJldHVybiBfZ2V0Tm9uY2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBnZXROb25jZTtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBSZXF1ZXN0IGFuIGFsbG9jYXRpb24gb2YgbGFtcG9ydHMgdG8gdGhlIHNwZWNpZmllZCBhZGRyZXNzXG4gICAgICpcbiAgICAgKiBgYGB0eXBlc2NyaXB0XG4gICAgICogaW1wb3J0IHsgQ29ubmVjdGlvbiwgUHVibGljS2V5LCBMQU1QT1JUU19QRVJfU09MIH0gZnJvbSBcIkBzb2xhbmEvd2ViMy5qc1wiO1xuICAgICAqXG4gICAgICogKGFzeW5jICgpID0+IHtcbiAgICAgKiAgIGNvbnN0IGNvbm5lY3Rpb24gPSBuZXcgQ29ubmVjdGlvbihcImh0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbVwiLCBcImNvbmZpcm1lZFwiKTtcbiAgICAgKiAgIGNvbnN0IG15QWRkcmVzcyA9IG5ldyBQdWJsaWNLZXkoXCIybnIxYkhGVDg2Vzl0R255dm1ZVzR2Y0hLc1FCM3NWUWZuZGRhc3o0a0V4TVwiKTtcbiAgICAgKiAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdEFpcmRyb3AobXlBZGRyZXNzLCBMQU1QT1JUU19QRVJfU09MKTtcbiAgICAgKiAgIGF3YWl0IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSk7XG4gICAgICogfSkoKTtcbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXF1ZXN0QWlyZHJvcFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlcXVlc3RBaXJkcm9wID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4Mih0bywgbGFtcG9ydHMpIHtcbiAgICAgICAgdmFyIHVuc2FmZVJlcywgcmVzO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlODIkKF9jb250ZXh0ODMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDgzLnByZXYgPSBfY29udGV4dDgzLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4My5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ3JlcXVlc3RBaXJkcm9wJywgW3RvLnRvQmFzZTU4KCksIGxhbXBvcnRzXSk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0ODMuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDgzLm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBcImFpcmRyb3AgdG8gXCIuY29uY2F0KHRvLnRvQmFzZTU4KCksIFwiIGZhaWxlZFwiKSk7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDgzLmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODMuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgyLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIHJlcXVlc3RBaXJkcm9wKF94MTIyLCBfeDEyMykge1xuICAgICAgICByZXR1cm4gX3JlcXVlc3RBaXJkcm9wLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVxdWVzdEFpcmRyb3A7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodDIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTgzKGRpc2FibGVDYWNoZSkge1xuICAgICAgICB2YXIgdGltZVNpbmNlRmV0Y2gsIGV4cGlyZWQ7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4MyQoX2NvbnRleHQ4NCkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0ODQucHJldiA9IF9jb250ZXh0ODQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoZGlzYWJsZUNhY2hlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4NC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLl9wb2xsaW5nQmxvY2toYXNoKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4NC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBfY29udGV4dDg0Lm5leHQgPSA0O1xuICAgICAgICAgICAgICByZXR1cm4gc2xlZXAoMTAwKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4NC5uZXh0ID0gMTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgIHRpbWVTaW5jZUZldGNoID0gRGF0ZS5ub3coKSAtIHRoaXMuX2Jsb2NraGFzaEluZm8ubGFzdEZldGNoO1xuICAgICAgICAgICAgICBleHBpcmVkID0gdGltZVNpbmNlRmV0Y2ggPj0gQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVM7XG4gICAgICAgICAgICAgIGlmICghKHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoICE9PSBudWxsICYmICFleHBpcmVkKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0ODQubmV4dCA9IDEwO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDg0LmFicnVwdChcInJldHVyblwiLCB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaCk7XG4gICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICBfY29udGV4dDg0Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BvbGxOZXdCbG9ja2hhc2goKTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDg0LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDg0LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTgzLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIF9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoX3gxMjQpIHtcbiAgICAgICAgcmV0dXJuIF9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodDtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfcG9sbE5ld0Jsb2NraGFzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3BvbGxOZXdCbG9ja2hhc2gyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4NCgpIHtcbiAgICAgICAgdmFyIHN0YXJ0VGltZSwgY2FjaGVkTGF0ZXN0QmxvY2toYXNoLCBjYWNoZWRCbG9ja2hhc2gsIGksIGxhdGVzdEJsb2NraGFzaDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTg0JChfY29udGV4dDg1KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4NS5wcmV2ID0gX2NvbnRleHQ4NS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIHRoaXMuX3BvbGxpbmdCbG9ja2hhc2ggPSB0cnVlO1xuICAgICAgICAgICAgICBfY29udGV4dDg1LnByZXYgPSAxO1xuICAgICAgICAgICAgICBzdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICBjYWNoZWRMYXRlc3RCbG9ja2hhc2ggPSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaDtcbiAgICAgICAgICAgICAgY2FjaGVkQmxvY2toYXNoID0gY2FjaGVkTGF0ZXN0QmxvY2toYXNoID8gY2FjaGVkTGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCA6IG51bGw7XG4gICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBpZiAoIShpIDwgNTApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4NS5uZXh0ID0gMTg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQ4NS5uZXh0ID0gOTtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF0ZXN0QmxvY2toYXNoKCdmaW5hbGl6ZWQnKTtcbiAgICAgICAgICAgIGNhc2UgOTpcbiAgICAgICAgICAgICAgbGF0ZXN0QmxvY2toYXNoID0gX2NvbnRleHQ4NS5zZW50O1xuICAgICAgICAgICAgICBpZiAoIShjYWNoZWRCbG9ja2hhc2ggIT09IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2gpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4NS5uZXh0ID0gMTM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mbyA9IHtcbiAgICAgICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2g6IGxhdGVzdEJsb2NraGFzaCxcbiAgICAgICAgICAgICAgICBsYXN0RmV0Y2g6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgICAgICAgICAgICBzaW11bGF0ZWRTaWduYXR1cmVzOiBbXVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4NS5hYnJ1cHQoXCJyZXR1cm5cIiwgbGF0ZXN0QmxvY2toYXNoKTtcbiAgICAgICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgICAgIF9jb250ZXh0ODUubmV4dCA9IDE1O1xuICAgICAgICAgICAgICByZXR1cm4gc2xlZXAoTVNfUEVSX1NMT1QgLyAyKTtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgX2NvbnRleHQ4NS5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE4OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmFibGUgdG8gb2J0YWluIGEgbmV3IGJsb2NraGFzaCBhZnRlciBcIi5jb25jYXQoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSwgXCJtc1wiKSk7XG4gICAgICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgICAgICBfY29udGV4dDg1LnByZXYgPSAxOTtcbiAgICAgICAgICAgICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4NS5maW5pc2goMTkpO1xuICAgICAgICAgICAgY2FzZSAyMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTg0LCB0aGlzLCBbWzEsLCAxOSwgMjJdXSk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBfcG9sbE5ld0Jsb2NraGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9wb2xsTmV3QmxvY2toYXNoMi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9wb2xsTmV3QmxvY2toYXNoO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIGdldCB0aGUgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2dldFN0YWtlTWluaW11bURlbGVnYXRpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTg1KGNvbmZpZykge1xuICAgICAgICB2YXIgX2V4dHJhY3RDb21taXRtZW50RnJvMjQsIGNvbW1pdG1lbnQsIGNvbmZpZ0FyZywgYXJncywgdW5zYWZlUmVzLCByZXM7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU4NSQoX2NvbnRleHQ4Nikge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0ODYucHJldiA9IF9jb250ZXh0ODYubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfZXh0cmFjdENvbW1pdG1lbnRGcm8yNCA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWcpLCBjb21taXRtZW50ID0gX2V4dHJhY3RDb21taXRtZW50RnJvMjQuY29tbWl0bWVudCwgY29uZmlnQXJnID0gX2V4dHJhY3RDb21taXRtZW50RnJvMjQuY29uZmlnO1xuICAgICAgICAgICAgICBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnQXJnKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Ni5uZXh0ID0gNDtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ2dldFN0YWtlTWluaW11bURlbGVnYXRpb24nLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ4Ni5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChudW1iZXIoKSkpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIHJlcykpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg2Lm5leHQgPSA4O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBcImZhaWxlZCB0byBnZXQgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uXCIpO1xuICAgICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4Ni5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzLnJlc3VsdCk7XG4gICAgICAgICAgICBjYXNlIDk6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDg2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4NSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uKF94MTI1KSB7XG4gICAgICAgIHJldHVybiBfZ2V0U3Rha2VNaW5pbXVtRGVsZWdhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGdldFN0YWtlTWluaW11bURlbGVnYXRpb247XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2ltdWxhdGVUcmFuc2FjdGlvbn0gd2l0aCB7QGxpbmtcbiAgICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn0gYW5kIHtAbGluayBTaW11bGF0ZVRyYW5zYWN0aW9uQ29uZmlnfSBwYXJhbWV0ZXJzXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2ltdWxhdGVUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICAgKi9cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gICAgZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zaW11bGF0ZVRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4Nih0cmFuc2FjdGlvbk9yTWVzc2FnZSwgY29uZmlnT3JTaWduZXJzLCBpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgICAgdmFyIHZlcnNpb25lZFR4LCBfd2lyZVRyYW5zYWN0aW9uLCBfZW5jb2RlZFRyYW5zYWN0aW9uLCBfY29uZmlnMiwgX2FyZ3M4NywgX3Vuc2FmZVJlcywgX3JlczUsIHRyYW5zYWN0aW9uLCBvcmlnaW5hbFR4LCBzaWduZXJzLCBfdHJhbnNhY3Rpb24sIGRpc2FibGVDYWNoZSwgX3RyYW5zYWN0aW9uMiwgbGF0ZXN0QmxvY2toYXNoLCBfc2lnbmF0dXJlLCBtZXNzYWdlLCBzaWduRGF0YSwgd2lyZVRyYW5zYWN0aW9uLCBlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZywgYWRkcmVzc2VzLCBhcmdzLCB1bnNhZmVSZXMsIHJlcywgX2xvZ3MsIHRyYWNlSW5kZW50LCBsb2dUcmFjZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTg2JChfY29udGV4dDg3KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4Ny5wcmV2ID0gX2NvbnRleHQ4Ny5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGlmICghKCdtZXNzYWdlJyBpbiB0cmFuc2FjdGlvbk9yTWVzc2FnZSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB2ZXJzaW9uZWRUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgICAgICAgICBfd2lyZVRyYW5zYWN0aW9uID0gdmVyc2lvbmVkVHguc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgIF9lbmNvZGVkVHJhbnNhY3Rpb24gPSBCdWZmZXIuZnJvbShfd2lyZVRyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSB8fCBpbmNsdWRlQWNjb3VudHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSA2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudHMnKTtcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgX2NvbmZpZzIgPSBjb25maWdPclNpZ25lcnMgfHwge307XG4gICAgICAgICAgICAgIF9jb25maWcyLmVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgIGlmICghKCdjb21taXRtZW50JyBpbiBfY29uZmlnMikpIHtcbiAgICAgICAgICAgICAgICBfY29uZmlnMi5jb21taXRtZW50ID0gdGhpcy5jb21taXRtZW50O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF9hcmdzODcgPSBbX2VuY29kZWRUcmFuc2FjdGlvbiwgX2NvbmZpZzJdO1xuICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSAxMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JwY1JlcXVlc3QoJ3NpbXVsYXRlVHJhbnNhY3Rpb24nLCBfYXJnczg3KTtcbiAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgIF91bnNhZmVSZXMgPSBfY29udGV4dDg3LnNlbnQ7XG4gICAgICAgICAgICAgIF9yZXM1ID0gY3JlYXRlKF91bnNhZmVSZXMsIFNpbXVsYXRlZFRyYW5zYWN0aW9uUmVzcG9uc2VTdHJ1Y3QpO1xuICAgICAgICAgICAgICBpZiAoISgnZXJyb3InIGluIF9yZXM1KSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0ODcubmV4dCA9IDE2O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIHNpbXVsYXRlIHRyYW5zYWN0aW9uOiAnICsgX3JlczUuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICBjYXNlIDE2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4Ny5hYnJ1cHQoXCJyZXR1cm5cIiwgX3JlczUucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMTc6XG4gICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbk9yTWVzc2FnZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24uZmVlUGF5ZXIgPSBvcmlnaW5hbFR4LmZlZVBheWVyO1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlLmluc3RydWN0aW9ucztcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5ub25jZUluZm8gPSBvcmlnaW5hbFR4Lm5vbmNlSW5mbztcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzID0gb3JpZ2luYWxUeC5zaWduYXR1cmVzO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gVHJhbnNhY3Rpb24ucG9wdWxhdGUodHJhbnNhY3Rpb25Pck1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8vIEhBQ0s6IHRoaXMgZnVuY3Rpb24gcmVsaWVzIG9uIG11dGF0aW5nIHRoZSBwb3B1bGF0ZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9qc29uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmICghKGNvbmZpZ09yU2lnbmVycyAhPT0gdW5kZWZpbmVkICYmICFBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Ny5uZXh0ID0gMjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgc2lnbmVycyA9IGNvbmZpZ09yU2lnbmVycztcbiAgICAgICAgICAgICAgaWYgKCEodHJhbnNhY3Rpb24ubm9uY2VJbmZvICYmIHNpZ25lcnMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Ny5uZXh0ID0gMjU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgKF90cmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uKS5zaWduLmFwcGx5KF90cmFuc2FjdGlvbiwgX3RvQ29uc3VtYWJsZUFycmF5KHNpZ25lcnMpKTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Ny5uZXh0ID0gNDU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAyNTpcbiAgICAgICAgICAgICAgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICAgICAgICBjYXNlIDI2OlxuICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSAyODtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICAgICAgY2FzZSAyODpcbiAgICAgICAgICAgICAgbGF0ZXN0QmxvY2toYXNoID0gX2NvbnRleHQ4Ny5zZW50O1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgICAgICAgaWYgKHNpZ25lcnMpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSAzMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4Ny5hYnJ1cHQoXCJicmVha1wiLCA0NSk7XG4gICAgICAgICAgICBjYXNlIDMzOlxuICAgICAgICAgICAgICAoX3RyYW5zYWN0aW9uMiA9IHRyYW5zYWN0aW9uKS5zaWduLmFwcGx5KF90cmFuc2FjdGlvbjIsIF90b0NvbnN1bWFibGVBcnJheShzaWduZXJzKSk7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSAzNjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTtcbiAgICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAgIF9zaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICAgICAgICBpZiAoISghdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLmluY2x1ZGVzKF9zaWduYXR1cmUpICYmICF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhfc2lnbmF0dXJlKSkpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg3Lm5leHQgPSA0MjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby5zaW11bGF0ZWRTaWduYXR1cmVzLnB1c2goX3NpZ25hdHVyZSk7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDg3LmFicnVwdChcImJyZWFrXCIsIDQ1KTtcbiAgICAgICAgICAgIGNhc2UgNDI6XG4gICAgICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgY2FzZSA0MzpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4Ny5uZXh0ID0gMjY7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9jb21waWxlKCk7XG4gICAgICAgICAgICAgIHNpZ25EYXRhID0gbWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uX3NlcmlhbGl6ZShzaWduRGF0YSk7XG4gICAgICAgICAgICAgIGVuY29kZWRUcmFuc2FjdGlvbiA9IHdpcmVUcmFuc2FjdGlvbi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgICAgICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIGlmIChpbmNsdWRlQWNjb3VudHMpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMgPSAoQXJyYXkuaXNBcnJheShpbmNsdWRlQWNjb3VudHMpID8gaW5jbHVkZUFjY291bnRzIDogbWVzc2FnZS5ub25Qcm9ncmFtSWRzKCkpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4ga2V5LnRvQmFzZTU4KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uZmlnWydhY2NvdW50cyddID0ge1xuICAgICAgICAgICAgICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzaWduZXJzKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLnNpZ1ZlcmlmeSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYXJncyA9IFtlbmNvZGVkVHJhbnNhY3Rpb24sIGNvbmZpZ107XG4gICAgICAgICAgICAgIF9jb250ZXh0ODcubmV4dCA9IDU1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgICAgICAgY2FzZSA1NTpcbiAgICAgICAgICAgICAgdW5zYWZlUmVzID0gX2NvbnRleHQ4Ny5zZW50O1xuICAgICAgICAgICAgICByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTaW11bGF0ZWRUcmFuc2FjdGlvblJlc3BvbnNlU3RydWN0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4Ny5uZXh0ID0gNjA7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfbG9ncyA9IHJlcy5lcnJvci5kYXRhLmxvZ3M7XG4gICAgICAgICAgICAgICAgaWYgKF9sb2dzICYmIEFycmF5LmlzQXJyYXkoX2xvZ3MpKSB7XG4gICAgICAgICAgICAgICAgICB0cmFjZUluZGVudCA9ICdcXG4gICAgJztcbiAgICAgICAgICAgICAgICAgIGxvZ1RyYWNlID0gdHJhY2VJbmRlbnQgKyBfbG9ncy5qb2luKHRyYWNlSW5kZW50KTtcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IocmVzLmVycm9yLm1lc3NhZ2UsIGxvZ1RyYWNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFNlbmRUcmFuc2FjdGlvbkVycm9yKCdmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSwgX2xvZ3MpO1xuICAgICAgICAgICAgY2FzZSA2MDpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODcuYWJydXB0KFwicmV0dXJuXCIsIHJlcy5yZXN1bHQpO1xuICAgICAgICAgICAgY2FzZSA2MTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODcuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTg2LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIHNpbXVsYXRlVHJhbnNhY3Rpb24oX3gxMjYsIF94MTI3LCBfeDEyOCkge1xuICAgICAgICByZXR1cm4gX3NpbXVsYXRlVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzaW11bGF0ZVRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFNpZ24gYW5kIHNlbmQgYSB0cmFuc2FjdGlvblxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2VuZFRyYW5zYWN0aW9ufSB3aXRoIGEge0BsaW5rXG4gICAgICogVmVyc2lvbmVkVHJhbnNhY3Rpb259XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZFRyYW5zYWN0aW9uXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfc2VuZFRyYW5zYWN0aW9uID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU4Nyh0cmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3dpcmVUcmFuc2FjdGlvbjIsIHNpZ25lcnMsIGRpc2FibGVDYWNoZSwgbGF0ZXN0QmxvY2toYXNoLCBfc2lnbmF0dXJlMiwgd2lyZVRyYW5zYWN0aW9uO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlODckKF9jb250ZXh0ODgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDg4LnByZXYgPSBfY29udGV4dDg4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCEoJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0ODgubmV4dCA9IDc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCEoc2lnbmVyc09yT3B0aW9ucyAmJiBBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0ODgubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICBfd2lyZVRyYW5zYWN0aW9uMiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICBfY29udGV4dDg4Lm5leHQgPSA2O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24oX3dpcmVUcmFuc2FjdGlvbjIsIHNpZ25lcnNPck9wdGlvbnMpO1xuICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4OC5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQ4OC5zZW50KTtcbiAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgaWYgKCEoc2lnbmVyc09yT3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8ICFBcnJheS5pc0FycmF5KHNpZ25lcnNPck9wdGlvbnMpKSkge1xuICAgICAgICAgICAgICAgIF9jb250ZXh0ODgubmV4dCA9IDk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgICAgICBzaWduZXJzID0gc2lnbmVyc09yT3B0aW9ucztcbiAgICAgICAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5ub25jZUluZm8pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg4Lm5leHQgPSAxNDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zaWduLmFwcGx5KHRyYW5zYWN0aW9uLCBfdG9Db25zdW1hYmxlQXJyYXkoc2lnbmVycykpO1xuICAgICAgICAgICAgICBfY29udGV4dDg4Lm5leHQgPSAzMjtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0aGlzLl9kaXNhYmxlQmxvY2toYXNoQ2FjaGluZztcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIF9jb250ZXh0ODgubmV4dCA9IDE3O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2toYXNoV2l0aEV4cGlyeUJsb2NrSGVpZ2h0KGRpc2FibGVDYWNoZSk7XG4gICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICBsYXRlc3RCbG9ja2hhc2ggPSBfY29udGV4dDg4LnNlbnQ7XG4gICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0ID0gbGF0ZXN0QmxvY2toYXNoLmxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoO1xuICAgICAgICAgICAgICB0cmFuc2FjdGlvbi5zaWduLmFwcGx5KHRyYW5zYWN0aW9uLCBfdG9Db25zdW1hYmxlQXJyYXkoc2lnbmVycykpO1xuICAgICAgICAgICAgICBpZiAodHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ4OC5uZXh0ID0gMjM7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7XG4gICAgICAgICAgICBjYXNlIDIzOlxuICAgICAgICAgICAgICBfc2lnbmF0dXJlMiA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhfc2lnbmF0dXJlMikpIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dDg4Lm5leHQgPSAyOTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUaGUgc2lnbmF0dXJlIG9mIHRoaXMgdHJhbnNhY3Rpb24gaGFzIG5vdCBiZWVuIHNlZW4gYmVmb3JlIHdpdGggdGhlXG4gICAgICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMucHVzaChfc2lnbmF0dXJlMik7XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDg4LmFicnVwdChcImJyZWFrXCIsIDMyKTtcbiAgICAgICAgICAgIGNhc2UgMjk6XG4gICAgICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgICAgICAvLyBtYXRjaGVkIHRvIG9uZSBvZiBhbHJlYWR5IHJlY29yZGVkIHNpZ25hdHVyZXMpLlxuICAgICAgICAgICAgICAvLyBTbywgd2UgbXVzdCBmZXRjaCBhIG5ldyBibG9ja2hhc2ggZm9yIGEgZGlmZmVyZW50IHNpZ25hdHVyZSBieSBkaXNhYmxpbmdcbiAgICAgICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgICAgICBkaXNhYmxlQ2FjaGUgPSB0cnVlO1xuICAgICAgICAgICAgY2FzZSAzMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ4OC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzMjpcbiAgICAgICAgICAgICAgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0ODgubmV4dCA9IDM1O1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgMzU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDg4LmFicnVwdChcInJldHVyblwiLCBfY29udGV4dDg4LnNlbnQpO1xuICAgICAgICAgICAgY2FzZSAzNjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODguc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTg3LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIHNlbmRUcmFuc2FjdGlvbihfeDEyOSwgX3gxMzAsIF94MTMxKSB7XG4gICAgICAgIHJldHVybiBfc2VuZFRyYW5zYWN0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2VuZFRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSB0cmFuc2FjdGlvbiB0aGF0IGhhcyBhbHJlYWR5IGJlZW4gc2lnbmVkIGFuZCBzZXJpYWxpemVkIGludG8gdGhlXG4gICAgICogd2lyZSBmb3JtYXRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZW5kUmF3VHJhbnNhY3Rpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9zZW5kUmF3VHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTg4KHJhd1RyYW5zYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBlbmNvZGVkVHJhbnNhY3Rpb24sIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTg4JChfY29udGV4dDg5KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ4OS5wcmV2ID0gX2NvbnRleHQ4OS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGVuY29kZWRUcmFuc2FjdGlvbiA9IHRvQnVmZmVyKHJhd1RyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgICAgICAgIF9jb250ZXh0ODkubmV4dCA9IDM7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbmRFbmNvZGVkVHJhbnNhY3Rpb24oZW5jb2RlZFRyYW5zYWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgcmVzdWx0ID0gX2NvbnRleHQ4OS5zZW50O1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ4OS5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0ODkuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTg4LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIHNlbmRSYXdUcmFuc2FjdGlvbihfeDEzMiwgX3gxMzMpIHtcbiAgICAgICAgcmV0dXJuIF9zZW5kUmF3VHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kUmF3VHJhbnNhY3Rpb247XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQsIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICAgKiB3aXJlIGZvcm1hdCwgYW5kIGVuY29kZWQgYXMgYSBiYXNlNjQgc3RyaW5nXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2VuZEVuY29kZWRUcmFuc2FjdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3NlbmRFbmNvZGVkVHJhbnNhY3Rpb24gPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTg5KGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB2YXIgY29uZmlnLCBza2lwUHJlZmxpZ2h0LCBwcmVmbGlnaHRDb21taXRtZW50LCBhcmdzLCB1bnNhZmVSZXMsIHJlcywgX2xvZ3MyO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlODkkKF9jb250ZXh0OTApIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDkwLnByZXYgPSBfY29udGV4dDkwLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nOiAnYmFzZTY0J1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBza2lwUHJlZmxpZ2h0ID0gb3B0aW9ucyAmJiBvcHRpb25zLnNraXBQcmVmbGlnaHQ7XG4gICAgICAgICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQgPSBvcHRpb25zICYmIG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm1heFJldHJpZXMgPSBvcHRpb25zLm1heFJldHJpZXM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5Db250ZXh0U2xvdCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uZmlnLm1pbkNvbnRleHRTbG90ID0gb3B0aW9ucy5taW5Db250ZXh0U2xvdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoc2tpcFByZWZsaWdodCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5za2lwUHJlZmxpZ2h0ID0gc2tpcFByZWZsaWdodDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocHJlZmxpZ2h0Q29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5wcmVmbGlnaHRDb21taXRtZW50ID0gcHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICAgICAgICAgICAgX2NvbnRleHQ5MC5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ycGNSZXF1ZXN0KCdzZW5kVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgIHVuc2FmZVJlcyA9IF9jb250ZXh0OTAuc2VudDtcbiAgICAgICAgICAgICAgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgICAgICAgICAgaWYgKCEoJ2Vycm9yJyBpbiByZXMpKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5MC5uZXh0ID0gMTU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKCdkYXRhJyBpbiByZXMuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBfbG9nczIgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcignZmFpbGVkIHRvIHNlbmQgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSwgX2xvZ3MyKTtcbiAgICAgICAgICAgIGNhc2UgMTU6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkwLmFicnVwdChcInJldHVyblwiLCByZXMucmVzdWx0KTtcbiAgICAgICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU4OSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiBzZW5kRW5jb2RlZFRyYW5zYWN0aW9uKF94MTM0LCBfeDEzNSkge1xuICAgICAgICByZXR1cm4gX3NlbmRFbmNvZGVkVHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZW5kRW5jb2RlZFRyYW5zYWN0aW9uO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uT3BlblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd3NPbk9wZW4oKSB7XG4gICAgICB2YXIgX3RoaXM5ID0gdGhpcztcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBpbmcgc2VydmVyIGV2ZXJ5IDVzIHRvIHByZXZlbnQgaWRsZSB0aW1lb3V0c1xuICAgICAgICBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkwKCkge1xuICAgICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5MCQoX2NvbnRleHQ5MSkge1xuICAgICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ5MS5wcmV2ID0gX2NvbnRleHQ5MS5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBfY29udGV4dDkxLnByZXYgPSAwO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0OTEubmV4dCA9IDM7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzOS5fcnBjV2ViU29ja2V0Lm5vdGlmeSgncGluZycpO1xuICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5MS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIF9jb250ZXh0OTEucHJldiA9IDU7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5MS50MCA9IF9jb250ZXh0OTFbXCJjYXRjaFwiXSgwKTtcbiAgICAgICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OTEuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIF9jYWxsZWU5MCwgbnVsbCwgW1swLCA1XV0pO1xuICAgICAgICB9KSkoKTtcbiAgICAgIH0sIDUwMDApO1xuICAgICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uRXJyb3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dzT25FcnJvcihlcnIpIHtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgY29uc29sZS5lcnJvcignd3MgZXJyb3I6JywgZXJyLm1lc3NhZ2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uQ2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dzT25DbG9zZShjb2RlKSB7XG4gICAgICB2YXIgX3RoaXMxMCA9IHRoaXM7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAodGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiArIDEpICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCkge1xuICAgICAgICBjbGVhckludGVydmFsKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCk7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgICAvLyBleHBsaWNpdCBjbG9zZSwgY2hlY2sgaWYgYW55IHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIG1hZGUgc2luY2UgY2xvc2VcbiAgICAgICAgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGltcGxpY2l0IGNsb3NlLCBwcmVwYXJlIHN1YnNjcmlwdGlvbnMgZm9yIGF1dG8tcmVjb25uZWN0XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgICBPYmplY3QuZW50cmllcyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmMTkpIHtcbiAgICAgICAgdmFyIF9yZWYyMCA9IF9zbGljZWRUb0FycmF5KF9yZWYxOSwgMiksXG4gICAgICAgICAgaGFzaCA9IF9yZWYyMFswXSxcbiAgICAgICAgICBzdWJzY3JpcHRpb24gPSBfcmVmMjBbMV07XG4gICAgICAgIF90aGlzMTAuX3NldFN1YnNjcmlwdGlvbihoYXNoLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN1YnNjcmlwdGlvbiksIHt9LCB7XG4gICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICB9KSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfc2V0U3Vic2NyaXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTdWJzY3JpcHRpb24oaGFzaCwgbmV4dFN1YnNjcmlwdGlvbikge1xuICAgICAgdmFyIF90aGlzJF9zdWJzY3JpcHRpb25zQjtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSAoX3RoaXMkX3N1YnNjcmlwdGlvbnNCID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSkgPT09IG51bGwgfHwgX3RoaXMkX3N1YnNjcmlwdGlvbnNCID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRfc3Vic2NyaXB0aW9uc0Iuc3RhdGU7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0gbmV4dFN1YnNjcmlwdGlvbjtcbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG5leHRTdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgICAgdmFyIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF07XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZUNhbGxiYWNrcykge1xuICAgICAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjYihuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICB9IGNhdGNoIChfdW51c2VkMikge31cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9vblN1YnNjcmlwdGlvblN0YXRlQ2hhbmdlKGNsaWVudFN1YnNjcmlwdGlvbklkLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzJF9zdWJzY3JpcHRpb25TdCxcbiAgICAgICAgX3RoaXMxMSA9IHRoaXM7XG4gICAgICB2YXIgaGFzaCA9IHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGlmIChoYXNoID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gKF90aGlzJF9zdWJzY3JpcHRpb25TdCA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoKVtoYXNoXSB8fCAoX3RoaXMkX3N1YnNjcmlwdGlvblN0W2hhc2hdID0gbmV3IFNldCgpKTtcbiAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrc1tcImRlbGV0ZVwiXShjYWxsYmFjayk7XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZUNhbGxiYWNrcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgZGVsZXRlIF90aGlzMTEuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl91cGRhdGVTdWJzY3JpcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdXBkYXRlU3Vic2NyaXB0aW9uczIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTk0KCkge1xuICAgICAgICB2YXIgX3RoaXMxMiA9IHRoaXM7XG4gICAgICAgIHZhciBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uLCBpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmU7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5NCQoX2NvbnRleHQ5NSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0OTUucHJldiA9IF9jb250ZXh0OTUubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBpZiAoIShPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5NS5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgIF90aGlzMTIuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzMTIuX3JwY1dlYlNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHN3YWxsb3cgZXJyb3IgaWYgc29ja2V0IGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkVycm9yIHdoZW4gY2xvc2luZyBzb2NrZXQgY29ubmVjdGlvbjogXCIuY29uY2F0KGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDk1LmFicnVwdChcInJldHVyblwiKTtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQ5NS5uZXh0ID0gNztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXQuY29ubmVjdCgpO1xuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5NS5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgICAgICAgICAgICBpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUgPSBmdW5jdGlvbiBpc0N1cnJlbnRDb25uZWN0aW9uU3RpbGxBY3RpdmUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPT09IF90aGlzMTIuX3JwY1dlYlNvY2tldEdlbmVyYXRpb247XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIF9jb250ZXh0OTUubmV4dCA9IDExO1xuICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICAgIC8vIERvbid0IGJlIHRlbXB0ZWQgdG8gY2hhbmdlIHRoaXMgdG8gYE9iamVjdC5lbnRyaWVzYC4gV2UgY2FsbFxuICAgICAgICAgICAgICAvLyBgX3VwZGF0ZVN1YnNjcmlwdGlvbnNgIHJlY3Vyc2l2ZWx5IHdoZW4gcHJvY2Vzc2luZyB0aGUgc3RhdGUsXG4gICAgICAgICAgICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAgICAgICAgICAgLy8gZWFjaCBzdWJzY3JpcHRpb24sIGV2ZXJ5IHRpbWUgd2UgcHJvY2VzcyBhIGhhc2guXG4gICAgICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3N1YnNjcmlwdGlvbnNCeUhhc2gpLm1hcCggLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgX3JlZjIxID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5MyhoYXNoKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTkzJChfY29udGV4dDk0KSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0OTQucHJldiA9IF9jb250ZXh0OTQubmV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzMTIuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5NC5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5NC50MCA9IHN1YnNjcmlwdGlvbi5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTQubmV4dCA9IF9jb250ZXh0OTQudDAgPT09ICdwZW5kaW5nJyA/IDYgOiBfY29udGV4dDk0LnQwID09PSAndW5zdWJzY3JpYmVkJyA/IDYgOiBfY29udGV4dDk0LnQwID09PSAnc3Vic2NyaWJlZCcgPyAxNSA6IF9jb250ZXh0OTQudDAgPT09ICdzdWJzY3JpYmluZycgPyAxOSA6IF9jb250ZXh0OTQudDAgPT09ICd1bnN1YnNjcmliaW5nJyA/IDE5IDogMjA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTQubmV4dCA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogWW91IGNhbiBlbmQgdXAgaGVyZSB3aGVuOlxuICAgICAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIC0gYSBzdWJzY3JpcHRpb24gaGFzIHJlY2VudGx5IHVuc3Vic2NyaWJlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICogICB3aXRob3V0IGhhdmluZyBuZXcgY2FsbGJhY2tzIGFkZGVkIHRvIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiAgIHdoaWxlIHRoZSB1bnN1YnNjcmliZSB3YXMgaW4gZmxpZ2h0LCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICogLSB3aGVuIGEgcGVuZGluZyBzdWJzY3JpcHRpb24gaGFzIGl0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICogICBsaXN0ZW5lcnMgcmVtb3ZlZCBiZWZvcmUgYSByZXF1ZXN0IHdhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICogICBzZW50IHRvIHRoZSBzZXJ2ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogQmVpbmcgdGhhdCBub2JvZHkgaXMgaW50ZXJlc3RlZCBpbiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzdWJzY3JpcHRpb24gYW55IGxvbmdlciwgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMxMi5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uc3RhdGUgPT09ICd1bnN1YnNjcmliZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczEyLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3N1YnNjcmlwdGlvbi5zZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDk0Lm5leHQgPSAxMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczEyLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDk0LmFicnVwdChcInJldHVyblwiKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5NC5uZXh0ID0gMTQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5MSgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MsIG1ldGhvZCwgX3NlcnZlclN1YnNjcmlwdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOTEkKF9jb250ZXh0OTIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDkyLnByZXYgPSBfY29udGV4dDkyLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncyA9IHN1YnNjcmlwdGlvbi5hcmdzLCBtZXRob2QgPSBzdWJzY3JpcHRpb24ubWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkyLnByZXYgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczEyLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBzdWJzY3JpcHRpb24pLCB7fSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5Mi5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTIuX3JwY1dlYlNvY2tldC5jYWxsKG1ldGhvZCwgYXJncyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9zZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IF9jb250ZXh0OTIuc2VudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMi5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3Vic2NyaXB0aW9uKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJ2ZXJTdWJzY3JpcHRpb25JZDogX3NlcnZlclN1YnNjcmlwdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiAnc3Vic2NyaWJlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpczEyLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW19zZXJ2ZXJTdWJzY3JpcHRpb25JZF0gPSBzdWJzY3JpcHRpb24uY2FsbGJhY2tzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkyLm5leHQgPSAxMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTIuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTIubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTIucHJldiA9IDEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkyLnQwID0gX2NvbnRleHQ5MltcImNhdGNoXCJdKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2NvbnRleHQ5Mi50MCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlwiLmNvbmNhdChtZXRob2QsIFwiIGVycm9yIGZvciBhcmd1bWVudFwiKSwgYXJncywgX2NvbnRleHQ5Mi50MC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkyLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5Mi5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYXliZSBhZGQgYW4gJ2Vycm9yZWQnIHN0YXRlIG9yIGEgcmV0cnkgbGltaXQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTIuX3NldFN1YnNjcmlwdGlvbihoYXNoLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN1YnNjcmlwdGlvbiksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTIubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMi5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OTIuc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTkxLCBudWxsLCBbWzEsIDEyXV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxNDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDk0LmFicnVwdChcImJyZWFrXCIsIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoc3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5zaXplID09PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDk0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDk0Lm5leHQgPSAxODtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTkyKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VydmVyU3Vic2NyaXB0aW9uSWQsIHVuc3Vic2NyaWJlTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOTIkKF9jb250ZXh0OTMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDkzLnByZXYgPSBfY29udGV4dDkzLm5leHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQgPSBzdWJzY3JpcHRpb24uc2VydmVyU3Vic2NyaXB0aW9uSWQsIHVuc3Vic2NyaWJlTWV0aG9kID0gc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzMTIuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5oYXMoc2VydmVyU3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5My5uZXh0ID0gNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBJZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBzdWJzY3JpcHRpb24gdGhhdCBoYXMgYmVlbiBhdXRvLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBkaXNwb3NlZCBieSB0aGUgUlBDLCB0aGVuIHdlIGNhbiBza2lwIHRoZSBSUEMgY2FsbCB0b1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTIuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwY1tcImRlbGV0ZVwiXShzZXJ2ZXJTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTMubmV4dCA9IDIxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMi5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3Vic2NyaXB0aW9uKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMi5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3Vic2NyaXB0aW9uKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5My5wcmV2ID0gNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5My5uZXh0ID0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczEyLl9ycGNXZWJTb2NrZXQuY2FsbCh1bnN1YnNjcmliZU1ldGhvZCwgW3NlcnZlclN1YnNjcmlwdGlvbklkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkzLm5leHQgPSAyMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkzLnByZXYgPSAxMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NvbnRleHQ5My50MCA9IF9jb250ZXh0OTNbXCJjYXRjaFwiXSg3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9jb250ZXh0OTMudDAgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJcIi5jb25jYXQodW5zdWJzY3JpYmVNZXRob2QsIFwiIGVycm9yOlwiKSwgX2NvbnRleHQ5My50MC5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50Q29ubmVjdGlvblN0aWxsQWN0aXZlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkzLm5leHQgPSAxNztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5My5hYnJ1cHQoXCJyZXR1cm5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE3OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBNYXliZSBhZGQgYW4gJ2Vycm9yZWQnIHN0YXRlIG9yIGEgcmV0cnkgbGltaXQ/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzMTIuX3NldFN1YnNjcmlwdGlvbihoYXNoLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHN1YnNjcmlwdGlvbiksIHt9LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jb250ZXh0OTMubmV4dCA9IDIwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMxMi5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OTMuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyMTpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMxMi5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3Vic2NyaXB0aW9uKSwge30sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJlZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY29udGV4dDkzLm5leHQgPSAyNDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzMTIuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDkzLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sIF9jYWxsZWU5MiwgbnVsbCwgW1s3LCAxMl1dKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpO1xuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTg6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5NC5hYnJ1cHQoXCJicmVha1wiLCAyMCk7XG4gICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOTpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDk0LmFicnVwdChcImJyZWFrXCIsIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgICBjYXNlIDIwOlxuICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDk0LnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSwgX2NhbGxlZTkzKTtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChfeDEzNikge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZWYyMS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0oKSkpO1xuICAgICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0OTUuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTk0LCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIF91cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgICAgICByZXR1cm4gX3VwZGF0ZVN1YnNjcmlwdGlvbnMyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gX3VwZGF0ZVN1YnNjcmlwdGlvbnM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHNlcnZlclN1YnNjcmlwdGlvbklkLCBjYWxsYmFja0FyZ3MpIHtcbiAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkW3NlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGlmIChjYWxsYmFja3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYi5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShjYWxsYmFja0FyZ3MpKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uQWNjb3VudE5vdGlmaWNhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd3NPbkFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICB2YXIgX2NyZWF0ZSA9IGNyZWF0ZShub3RpZmljYXRpb24sIEFjY291bnROb3RpZmljYXRpb25SZXN1bHQpLFxuICAgICAgICByZXN1bHQgPSBfY3JlYXRlLnJlc3VsdCxcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gX2NyZWF0ZS5zdWJzY3JpcHRpb247XG4gICAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9tYWtlU3Vic2NyaXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9tYWtlU3Vic2NyaXB0aW9uKHN1YnNjcmlwdGlvbkNvbmZpZyxcbiAgICAvKipcbiAgICAgKiBXaGVuIHByZXBhcmluZyBgYXJnc2AgZm9yIGEgY2FsbCB0byBgX21ha2VTdWJzY3JpcHRpb25gLCBiZSBzdXJlXG4gICAgICogdG8gY2FyZWZ1bGx5IGFwcGx5IGEgZGVmYXVsdCBgY29tbWl0bWVudGAgcHJvcGVydHksIGlmIG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIC0gSWYgdGhlIHVzZXIgc3VwcGxpZWQgYSBgY29tbWl0bWVudGAgdXNlIHRoYXQuXG4gICAgICogLSBPdGhlcndpc2UsIGlmIHRoZSBgQ29ubmVjdGlvbjo6Y29tbWl0bWVudGAgaXMgc2V0LCB1c2UgdGhhdC5cbiAgICAgKiAtIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBSUEMgc2VydmVyIGRlZmF1bHQ6IGBmaW5hbGl6ZWRgLlxuICAgICAqXG4gICAgICogVGhpcyBpcyBleHRyZW1lbHkgaW1wb3J0YW50IHRvIGVuc3VyZSB0aGF0IHRoZXNlIHR3byBmdW5kYW1lbnRhbGx5XG4gICAgICogaWRlbnRpY2FsIHN1YnNjcmlwdGlvbnMgcHJvZHVjZSB0aGUgc2FtZSBpZGVudGlmeWluZyBoYXNoOlxuICAgICAqXG4gICAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdpdGhvdXQgc3BlY2lmeWluZyBhIGNvbW1pdG1lbnQuXG4gICAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdoZXJlIHRoZSBjb21taXRtZW50IHNwZWNpZmllZCBpcyB0aGUgc2FtZVxuICAgICAqICAgYXMgdGhlIGRlZmF1bHQgYXBwbGllZCB0byB0aGUgc3Vic2NyaXB0aW9uIGFib3ZlLlxuICAgICAqXG4gICAgICogRXhhbXBsZTsgdGhlc2UgdHdvIHN1YnNjcmlwdGlvbnMgbXVzdCBwcm9kdWNlIHRoZSBzYW1lIGhhc2g6XG4gICAgICpcbiAgICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2BcbiAgICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2Agd2l0aCBjb21taXRtZW50XG4gICAgICogICBgJ2ZpbmFsaXplZCdgLlxuICAgICAqXG4gICAgICogU2VlIHRoZSAnbWFraW5nIGEgc3Vic2NyaXB0aW9uIHdpdGggZGVmYXVsdGVkIHBhcmFtcyBvbWl0dGVkJyB0ZXN0XG4gICAgICogaW4gYGNvbm5lY3Rpb24tc3Vic2NyaXB0aW9ucy50c2AgZm9yIG1vcmUuXG4gICAgICovXG4gICAgYXJncykge1xuICAgICAgdmFyIF90aGlzMTMgPSB0aGlzO1xuICAgICAgdmFyIGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkKys7XG4gICAgICB2YXIgaGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkkMShbc3Vic2NyaXB0aW9uQ29uZmlnLm1ldGhvZCwgYXJnc10sIHRydWUgLyogaXNBcnJheVByb3AgKi8pO1xuXG4gICAgICB2YXIgZXhpc3RpbmdTdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKGV4aXN0aW5nU3Vic2NyaXB0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgc3Vic2NyaXB0aW9uQ29uZmlnKSwge30sIHtcbiAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgIGNhbGxiYWNrczogbmV3IFNldChbc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrXSksXG4gICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nU3Vic2NyaXB0aW9uLmNhbGxiYWNrcy5hZGQoc3Vic2NyaXB0aW9uQ29uZmlnLmNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGhhc2g7XG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF0gPSAvKiNfX1BVUkVfXyovX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5NSgpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbjtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTk1JChfY29udGV4dDk2KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQ5Ni5wcmV2ID0gX2NvbnRleHQ5Ni5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczEzLl9zdWJzY3JpcHRpb25EaXNwb3NlRnVuY3Rpb25zQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczEzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICAgICAgICAgIHN1YnNjcmlwdGlvbiA9IF90aGlzMTMuX3N1YnNjcmlwdGlvbnNCeUhhc2hbaGFzaF07XG4gICAgICAgICAgICAgIGFzc2VydChzdWJzY3JpcHRpb24gIT09IHVuZGVmaW5lZCwgXCJDb3VsZCBub3QgZmluZCBhIGBTdWJzY3JpcHRpb25gIHdoZW4gdGVhcmluZyBkb3duIGNsaWVudCBzdWJzY3JpcHRpb24gI1wiLmNvbmNhdChjbGllbnRTdWJzY3JpcHRpb25JZCkpO1xuICAgICAgICAgICAgICBzdWJzY3JpcHRpb24uY2FsbGJhY2tzW1wiZGVsZXRlXCJdKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgICAgICAgICAgIF9jb250ZXh0OTYubmV4dCA9IDc7XG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczEzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDk2LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5NSk7XG4gICAgICB9KSk7XG4gICAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHdoZW5ldmVyIHRoZSBzcGVjaWZpZWQgYWNjb3VudCBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbW9uaXRvclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSBjb21taXRtZW50IFNwZWNpZnkgdGhlIGNvbW1pdG1lbnQgbGV2ZWwgYWNjb3VudCBjaGFuZ2VzIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwib25BY2NvdW50Q2hhbmdlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uQWNjb3VudENoYW5nZShwdWJsaWNLZXksIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgICB2YXIgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgICAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICAgJ2Jhc2U2NCcpO1xuICAgICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIG1ldGhvZDogJ2FjY291bnRTdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2FjY291bnRVbnN1YnNjcmliZSdcbiAgICAgIH0sIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmVBY2NvdW50Q2hhbmdlTGlzdGVuZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTk2KGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5NiQoX2NvbnRleHQ5Nykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0OTcucHJldiA9IF9jb250ZXh0OTcubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDk3Lm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdhY2NvdW50IGNoYW5nZScpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5Ny5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOTYsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyKF94MTM3KSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlQWNjb3VudENoYW5nZUxpc3RlbmVyO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dzT25Qcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICAgIHZhciBfY3JlYXRlMiA9IGNyZWF0ZShub3RpZmljYXRpb24sIFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KSxcbiAgICAgICAgcmVzdWx0ID0gX2NyZWF0ZTIucmVzdWx0LFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBfY3JlYXRlMi5zdWJzY3JpcHRpb247XG4gICAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbe1xuICAgICAgICBhY2NvdW50SWQ6IHJlc3VsdC52YWx1ZS5wdWJrZXksXG4gICAgICAgIGFjY291bnRJbmZvOiByZXN1bHQudmFsdWUuYWNjb3VudFxuICAgICAgfSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgYWNjb3VudHMgb3duZWQgYnkgdGhlXG4gICAgICogc3BlY2lmaWVkIHByb2dyYW0gY2hhbmdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gbW9uaXRvclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIGFjY291bnQgaXMgY2hhbmdlZFxuICAgICAqIEBwYXJhbSBjb21taXRtZW50IFNwZWNpZnkgdGhlIGNvbW1pdG1lbnQgbGV2ZWwgYWNjb3VudCBjaGFuZ2VzIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgICAqIEBwYXJhbSBmaWx0ZXJzIFRoZSBwcm9ncmFtIGFjY291bnQgZmlsdGVycyB0byBwYXNzIGludG8gdGhlIFJQQyBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uUHJvZ3JhbUFjY291bnRDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Qcm9ncmFtQWNjb3VudENoYW5nZShwcm9ncmFtSWQsIGNhbGxiYWNrLCBjb21taXRtZW50LCBmaWx0ZXJzKSB7XG4gICAgICB2YXIgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHJvZ3JhbUlkLnRvQmFzZTU4KCldLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcsXG4gICAgICAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICAgJ2Jhc2U2NCcgLyogZW5jb2RpbmcgKi8sIGZpbHRlcnMgPyB7XG4gICAgICAgIGZpbHRlcnM6IGZpbHRlcnNcbiAgICAgIH0gOiB1bmRlZmluZWQgLyogZXh0cmEgKi8pO1xuXG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kOiAncHJvZ3JhbVN1YnNjcmliZScsXG4gICAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJ1xuICAgICAgfSwgYXJncyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVyZWdpc3RlciBhbiBhY2NvdW50IG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIGlkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVByb2dyYW1BY2NvdW50Q2hhbmdlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5NyhjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOTckKF9jb250ZXh0OTgpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDk4LnByZXYgPSBfY29udGV4dDk4Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5OC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5OC5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOTcsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihfeDEzOCkge1xuICAgICAgICByZXR1cm4gX3JlbW92ZVByb2dyYW1BY2NvdW50Q2hhbmdlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVQcm9ncmFtQWNjb3VudENoYW5nZUxpc3RlbmVyO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgbG9ncyBhcmUgZW1pdHRlZC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvbkxvZ3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Mb2dzKGZpbHRlciwgY2FsbGJhY2ssIGNvbW1pdG1lbnQpIHtcbiAgICAgIHZhciBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtfdHlwZW9mKGZpbHRlcikgPT09ICdvYmplY3QnID8ge1xuICAgICAgICBtZW50aW9uczogW2ZpbHRlci50b1N0cmluZygpXVxuICAgICAgfSA6IGZpbHRlcl0sIGNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICAgKTtcblxuICAgICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIG1ldGhvZDogJ2xvZ3NTdWJzY3JpYmUnLFxuICAgICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZSdcbiAgICAgIH0sIGFyZ3MpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcmVnaXN0ZXIgYSBsb2dzIGNhbGxiYWNrLlxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3Rlci5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVPbkxvZ3NMaXN0ZW5lclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlbW92ZU9uTG9nc0xpc3RlbmVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWU5OChjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlOTgkKF9jb250ZXh0OTkpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDk5LnByZXYgPSBfY29udGV4dDk5Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgX2NvbnRleHQ5OS5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnbG9ncycpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ5OS5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlOTgsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlT25Mb2dzTGlzdGVuZXIoX3gxMzkpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmVPbkxvZ3NMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlbW92ZU9uTG9nc0xpc3RlbmVyO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uTG9nc05vdGlmaWNhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd3NPbkxvZ3NOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICB2YXIgX2NyZWF0ZTMgPSBjcmVhdGUobm90aWZpY2F0aW9uLCBMb2dzTm90aWZpY2F0aW9uUmVzdWx0KSxcbiAgICAgICAgcmVzdWx0ID0gX2NyZWF0ZTMucmVzdWx0LFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBfY3JlYXRlMy5zdWJzY3JpcHRpb247XG4gICAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uU2xvdE5vdGlmaWNhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd3NPblNsb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgICB2YXIgX2NyZWF0ZTQgPSBjcmVhdGUobm90aWZpY2F0aW9uLCBTbG90Tm90aWZpY2F0aW9uUmVzdWx0KSxcbiAgICAgICAgcmVzdWx0ID0gX2NyZWF0ZTQucmVzdWx0LFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBfY3JlYXRlNC5zdWJzY3JpcHRpb247XG4gICAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0XSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBjYWxsYmFjayB0byBiZSBpbnZva2VkIHVwb24gc2xvdCBjaGFuZ2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBzbG90IGNoYW5nZXNcbiAgICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uU2xvdENoYW5nZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvblNsb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBtZXRob2Q6ICdzbG90U3Vic2NyaWJlJyxcbiAgICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90VW5zdWJzY3JpYmUnXG4gICAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTk5KGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWU5OSQoX2NvbnRleHQxMDApIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDEwMC5wcmV2ID0gX2NvbnRleHQxMDAubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDEwMC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCBjaGFuZ2UnKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTAwLnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWU5OSwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiByZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIoX3gxNDApIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVTbG90Q2hhbmdlTGlzdGVuZXI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3dzT25TbG90VXBkYXRlc05vdGlmaWNhdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfd3NPblNsb3RVcGRhdGVzTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgdmFyIF9jcmVhdGU1ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCksXG4gICAgICAgIHJlc3VsdCA9IF9jcmVhdGU1LnJlc3VsdCxcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gX2NyZWF0ZTUuc3Vic2NyaXB0aW9uO1xuICAgICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNsb3QgdXBkYXRlcy4ge0BsaW5rIFNsb3RVcGRhdGV9J3NcbiAgICAgKiBtYXkgYmUgdXNlZnVsIHRvIHRyYWNrIGxpdmUgcHJvZ3Jlc3Mgb2YgYSBjbHVzdGVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCB1cGRhdGVzXG4gICAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblNsb3RVcGRhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25TbG90VXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kOiAnc2xvdHNVcGRhdGVzU3Vic2NyaWJlJyxcbiAgICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90c1VwZGF0ZXNVbnN1YnNjcmliZSdcbiAgICAgIH0sIFtdIC8qIGFyZ3MgKi8pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlcmVnaXN0ZXIgYSBzbG90IHVwZGF0ZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW1vdmVTbG90VXBkYXRlTGlzdGVuZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIF9yZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwMChjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAwJChfY29udGV4dDEwMSkge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTAxLnByZXYgPSBfY29udGV4dDEwMS5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAxLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzbG90IHVwZGF0ZScpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQxMDEuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTEwMCwgdGhpcyk7XG4gICAgICB9KSk7XG4gICAgICBmdW5jdGlvbiByZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIoX3gxNDEpIHtcbiAgICAgICAgcmV0dXJuIF9yZW1vdmVTbG90VXBkYXRlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVTbG90VXBkYXRlTGlzdGVuZXI7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24yID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMDEoY2xpZW50U3Vic2NyaXB0aW9uSWQsIHN1YnNjcmlwdGlvbk5hbWUpIHtcbiAgICAgICAgdmFyIGRpc3Bvc2U7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JSdW50aW1lJDEoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUxMDEkKF9jb250ZXh0MTAyKSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQxMDIucHJldiA9IF9jb250ZXh0MTAyLm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgZGlzcG9zZSA9IHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgICAgICAgaWYgKCFkaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgX2NvbnRleHQxMDIubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgX2NvbnRleHQxMDIubmV4dCA9IDQ7XG4gICAgICAgICAgICAgIHJldHVybiBkaXNwb3NlKCk7XG4gICAgICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAyLm5leHQgPSA3O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdJZ25vcmVkIHVuc3Vic2NyaWJlIHJlcXVlc3QgYmVjYXVzZSBhbiBhY3RpdmUgc3Vic2NyaXB0aW9uIHdpdGggaWQgJyArIFwiYFwiLmNvbmNhdChjbGllbnRTdWJzY3JpcHRpb25JZCwgXCJgIGZvciAnXCIpLmNvbmNhdChzdWJzY3JpcHRpb25OYW1lLCBcIicgZXZlbnRzIFwiKSArICdjb3VsZCBub3QgYmUgZm91bmQuJyk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwMi5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAxLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIF91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihfeDE0MiwgX3gxNDMpIHtcbiAgICAgICAgcmV0dXJuIF91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbjIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb247XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiX2J1aWxkQXJnc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICAgIHZhciBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICAgIGlmIChjb21taXRtZW50IHx8IGVuY29kaW5nIHx8IGV4dHJhKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgICAgICBfb3B0aW9ucy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21taXRtZW50KSB7XG4gICAgICAgICAgX29wdGlvbnMuY29tbWl0bWVudCA9IGNvbW1pdG1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgICAgX29wdGlvbnMgPSBPYmplY3QuYXNzaWduKF9vcHRpb25zLCBleHRyYSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy5wdXNoKF9vcHRpb25zKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICAgIHZhciBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICAgIGlmIChjb21taXRtZW50ICYmICFbJ2NvbmZpcm1lZCcsICdmaW5hbGl6ZWQnXS5pbmNsdWRlcyhjb21taXRtZW50KSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICsgdGhpcy5fY29tbWl0bWVudCArICdgLCBidXQgbWV0aG9kIHJlcXVpcmVzIGF0IGxlYXN0IGBjb25maXJtZWRgJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgdmFyIF9jcmVhdGU2ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0KSxcbiAgICAgICAgcmVzdWx0ID0gX2NyZWF0ZTYucmVzdWx0LFxuICAgICAgICBzdWJzY3JpcHRpb24gPSBfY3JlYXRlNi5zdWJzY3JpcHRpb247XG4gICAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAncmVjZWl2ZWRTaWduYXR1cmUnKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTcGVjaWFsIGNhc2UuXG4gICAgICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICAgICAqIHN1YnNjcmlwdGlvbiBvbiB0aGUgc2VydmVyIHNpZGUuIFdlIG5lZWQgdG8gdHJhY2sgd2hpY2ggb2YgdGhlc2VcbiAgICAgICAgICogc3Vic2NyaXB0aW9ucyBoYXZlIGJlZW4gZGlzcG9zZWQgaW4gc3VjaCBhIHdheSwgc28gdGhhdCB3ZSBrbm93XG4gICAgICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgICAgICogKGluIHdoaWNoIGNhc2Ugd2UgbXVzdCB0ZWFyIGRvd24gdGhlIHNlcnZlciBzdWJzY3JpcHRpb24pIG9yIGFuXG4gICAgICAgICAqIGFscmVhZHktcHJvY2Vzc2VkIHNpZ25hdHVyZSAoaW4gd2hpY2ggY2FzZSB0aGUgY2xpZW50IGNhbiBzaW1wbHlcbiAgICAgICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFRoZXJlIGlzIGEgcHJvcG9zYWwgdG8gZWxpbWluYXRlIHRoaXMgc3BlY2lhbCBjYXNlLCBoZXJlOlxuICAgICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0F1dG9EaXNwb3NlZEJ5UnBjLmFkZChzdWJzY3JpcHRpb24pO1xuICAgICAgfVxuICAgICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgcmVzdWx0LnZhbHVlID09PSAncmVjZWl2ZWRTaWduYXR1cmUnID8gW3tcbiAgICAgICAgdHlwZTogJ3JlY2VpdmVkJ1xuICAgICAgfSwgcmVzdWx0LmNvbnRleHRdIDogW3tcbiAgICAgICAgdHlwZTogJ3N0YXR1cycsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0LnZhbHVlXG4gICAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNpZ25hdHVyZSB1cGRhdGVzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2lnbmF0dXJlIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBzdHJpbmcgaW4gYmFzZSA1OFxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICAgKiBAcGFyYW0gY29tbWl0bWVudCBTcGVjaWZ5IHRoZSBjb21taXRtZW50IGxldmVsIHNpZ25hdHVyZSBtdXN0IHJlYWNoIGJlZm9yZSBub3RpZmljYXRpb25cbiAgICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIm9uU2lnbmF0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2lnbmF0dXJlKHNpZ25hdHVyZSwgX2NhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgICB2YXIgX3RoaXMxNCA9IHRoaXM7XG4gICAgICB2YXIgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgICApO1xuXG4gICAgICB2YXIgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG5vdGlmaWNhdGlvbiwgY29udGV4dCkge1xuICAgICAgICAgIGlmIChub3RpZmljYXRpb24udHlwZSA9PT0gJ3N0YXR1cycpIHtcbiAgICAgICAgICAgIF9jYWxsYmFjayhub3RpZmljYXRpb24ucmVzdWx0LCBjb250ZXh0KTtcbiAgICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgICAgLy8gc28gbm8gbmVlZCB0byBleHBsaWNpdGx5IHNlbmQgYW4gdW5zdWJzY3JpYmUgbWVzc2FnZS5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIF90aGlzMTQucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbWV0aG9kOiAnc2lnbmF0dXJlU3Vic2NyaWJlJyxcbiAgICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICAgIH0sIGFyZ3MpO1xuICAgICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGEgdHJhbnNhY3Rpb24gaXNcbiAgICAgKiByZWNlaXZlZCBhbmQvb3IgcHJvY2Vzc2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNpZ25hdHVyZSBUcmFuc2FjdGlvbiBzaWduYXR1cmUgc3RyaW5nIGluIGJhc2UgNThcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIG9uIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gICAgICogQHBhcmFtIG9wdGlvbnMgRW5hYmxlIHJlY2VpdmVkIG5vdGlmaWNhdGlvbnMgYW5kIHNldCB0aGUgY29tbWl0bWVudFxuICAgICAqICAgbGV2ZWwgdGhhdCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblNpZ25hdHVyZVdpdGhPcHRpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9uU2lnbmF0dXJlV2l0aE9wdGlvbnMoc2lnbmF0dXJlLCBfY2FsbGJhY2syLCBvcHRpb25zKSB7XG4gICAgICB2YXIgX3RoaXMxNSA9IHRoaXM7XG4gICAgICB2YXIgX29wdGlvbnMkY29tbWl0bWVudCA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICAgICAgY29tbWl0bWVudDogb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQgfHwgdGhpcy5fY29tbWl0bWVudCB8fCAnZmluYWxpemVkJyAvLyBBcHBseSBjb25uZWN0aW9uL3NlcnZlciBkZWZhdWx0LlxuICAgICAgICB9KSxcbiAgICAgICAgY29tbWl0bWVudCA9IF9vcHRpb25zJGNvbW1pdG1lbnQuY29tbWl0bWVudCxcbiAgICAgICAgZXh0cmEgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX29wdGlvbnMkY29tbWl0bWVudCwgX2V4Y2x1ZGVkNCk7XG4gICAgICB2YXIgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBleHRyYSk7XG4gICAgICB2YXIgY2xpZW50U3Vic2NyaXB0aW9uSWQgPSB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIGNhbGxiYWNrKG5vdGlmaWNhdGlvbiwgY29udGV4dCkge1xuICAgICAgICAgIF9jYWxsYmFjazIobm90aWZpY2F0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICAvLyBTaWduYXR1cmVzIHN1YnNjcmlwdGlvbnMgYXJlIGF1dG8tcmVtb3ZlZCBieSB0aGUgUlBDIHNlcnZpY2VcbiAgICAgICAgICAvLyBzbyBubyBuZWVkIHRvIGV4cGxpY2l0bHkgc2VuZCBhbiB1bnN1YnNjcmliZSBtZXNzYWdlLlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBfdGhpczE1LnJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZC5cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAnc2lnbmF0dXJlVW5zdWJzY3JpYmUnXG4gICAgICB9LCBhcmdzKTtcbiAgICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZXJlZ2lzdGVyIGEgc2lnbmF0dXJlIG5vdGlmaWNhdGlvbiBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHBhcmFtIGlkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTEwMihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSQxKCkud3JhcChmdW5jdGlvbiBfY2FsbGVlMTAyJChfY29udGV4dDEwMykge1xuICAgICAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0MTAzLnByZXYgPSBfY29udGV4dDEwMy5uZXh0KSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgIF9jb250ZXh0MTAzLm5leHQgPSAyO1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdzaWduYXR1cmUgcmVzdWx0Jyk7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDEwMy5zdG9wKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9LCBfY2FsbGVlMTAyLCB0aGlzKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIHJlbW92ZVNpZ25hdHVyZUxpc3RlbmVyKF94MTQ0KSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZW1vdmVTaWduYXR1cmVMaXN0ZW5lcjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJfd3NPblJvb3ROb3RpZmljYXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX3dzT25Sb290Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgICAgdmFyIF9jcmVhdGU3ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCksXG4gICAgICAgIHJlc3VsdCA9IF9jcmVhdGU3LnJlc3VsdCxcbiAgICAgICAgc3Vic2NyaXB0aW9uID0gX2NyZWF0ZTcuc3Vic2NyaXB0aW9uO1xuICAgICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHJvb3QgY2hhbmdlc1xuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgcm9vdCBjaGFuZ2VzXG4gICAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJvblJvb3RDaGFuZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gb25Sb290Q2hhbmdlKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kOiAncm9vdFN1YnNjcmliZScsXG4gICAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncm9vdFVuc3Vic2NyaWJlJ1xuICAgICAgfSwgW10gLyogYXJncyAqLyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVyZWdpc3RlciBhIHJvb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaWQgY2xpZW50IHN1YnNjcmlwdGlvbiBpZCB0byBkZXJlZ2lzdGVyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lJDEoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUxMDMoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUkMSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTEwMyQoX2NvbnRleHQxMDQpIHtcbiAgICAgICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dDEwNC5wcmV2ID0gX2NvbnRleHQxMDQubmV4dCkge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICBfY29udGV4dDEwNC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncm9vdCBjaGFuZ2UnKTtcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0MTA0LnN0b3AoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUxMDMsIHRoaXMpO1xuICAgICAgfSkpO1xuICAgICAgZnVuY3Rpb24gcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyKF94MTQ1KSB7XG4gICAgICAgIHJldHVybiBfcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyO1xuICAgIH0oKVxuICB9XSk7XG4gIHJldHVybiBDb25uZWN0aW9uO1xufSgpO1xuXG4vKipcbiAqIEtleXBhaXIgc2lnbmVyIGludGVyZmFjZVxuICovXG5cbi8qKlxuICogQW4gYWNjb3VudCBrZXlwYWlyIHVzZWQgZm9yIHNpZ25pbmcgdHJhbnNhY3Rpb25zLlxuICovXG52YXIgS2V5cGFpciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcga2V5cGFpciBpbnN0YW5jZS5cbiAgICogR2VuZXJhdGUgcmFuZG9tIGtleXBhaXIgaWYgbm8ge0BsaW5rIEVkMjU1MTlLZXlwYWlyfSBpcyBwcm92aWRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFZDI1NTE5S2V5cGFpcn0ga2V5cGFpciBlZDI1NTE5IGtleXBhaXJcbiAgICovXG4gIGZ1bmN0aW9uIEtleXBhaXIoa2V5cGFpcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBLZXlwYWlyKTtcbiAgICB0aGlzLl9rZXlwYWlyID0gdm9pZCAwO1xuICAgIHRoaXMuX2tleXBhaXIgPSBrZXlwYWlyICE9PSBudWxsICYmIGtleXBhaXIgIT09IHZvaWQgMCA/IGtleXBhaXIgOiBnZW5lcmF0ZUtleXBhaXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKEtleXBhaXIsIFt7XG4gICAga2V5OiBcInB1YmxpY0tleVwiLFxuICAgIGdldDpcbiAgICAvKipcbiAgICAgKiBUaGUgcHVibGljIGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7UHVibGljS2V5fSBQdWJsaWNLZXlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9rZXlwYWlyLnB1YmxpY0tleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIHJhdyBzZWNyZXQga2V5IGZvciB0aGlzIGtleXBhaXJcbiAgICAgKiBAcmV0dXJucyB7VWludDhBcnJheX0gU2VjcmV0IGtleSBpbiBhbiBhcnJheSBvZiBVaW50OCBieXRlc1xuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNlY3JldEtleVwiLFxuICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuX2tleXBhaXIuc2VjcmV0S2V5KTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJnZW5lcmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgS2V5cGFpcihnZW5lcmF0ZUtleXBhaXIoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcmF3IHNlY3JldCBrZXkgYnl0ZSBhcnJheS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIHNob3VsZCBvbmx5IGJlIHVzZWQgdG8gcmVjcmVhdGUgYSBrZXlwYWlyIGZyb20gYSBwcmV2aW91c2x5XG4gICAgICogZ2VuZXJhdGVkIHNlY3JldCBrZXkuIEdlbmVyYXRpbmcga2V5cGFpcnMgZnJvbSBhIHJhbmRvbSBzZWVkIHNob3VsZCBiZSBkb25lXG4gICAgICogd2l0aCB0aGUge0BsaW5rIEtleXBhaXIuZnJvbVNlZWR9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHByb3ZpZGVkIHNlY3JldCBrZXkgaXMgaW52YWxpZCBhbmQgdmFsaWRhdGlvbiBpcyBub3Qgc2tpcHBlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWNyZXRLZXkgc2VjcmV0IGtleSBieXRlIGFycmF5XG4gICAgICogQHBhcmFtIG9wdGlvbnMgc2tpcCBzZWNyZXQga2V5IHZhbGlkYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtLZXlwYWlyfSBLZXlwYWlyXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZnJvbVNlY3JldEtleVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2VjcmV0S2V5KHNlY3JldEtleSwgb3B0aW9ucykge1xuICAgICAgaWYgKHNlY3JldEtleS5ieXRlTGVuZ3RoICE9PSA2NCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBzZWNyZXQga2V5IHNpemUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBwdWJsaWNLZXkgPSBzZWNyZXRLZXkuc2xpY2UoMzIsIDY0KTtcbiAgICAgIGlmICghb3B0aW9ucyB8fCAhb3B0aW9ucy5za2lwVmFsaWRhdGlvbikge1xuICAgICAgICB2YXIgcHJpdmF0ZVNjYWxhciA9IHNlY3JldEtleS5zbGljZSgwLCAzMik7XG4gICAgICAgIHZhciBjb21wdXRlZFB1YmxpY0tleSA9IGdldFB1YmxpY0tleShwcml2YXRlU2NhbGFyKTtcbiAgICAgICAgZm9yICh2YXIgaWkgPSAwOyBpaSA8IDMyOyBpaSsrKSB7XG4gICAgICAgICAgaWYgKHB1YmxpY0tleVtpaV0gIT09IGNvbXB1dGVkUHVibGljS2V5W2lpXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm92aWRlZCBzZWNyZXRLZXkgaXMgaW52YWxpZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBLZXlwYWlyKHtcbiAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgICAgIHNlY3JldEtleTogc2VjcmV0S2V5XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIGtleXBhaXIgZnJvbSBhIDMyIGJ5dGUgc2VlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZWVkIHNlZWQgYnl0ZSBhcnJheVxuICAgICAqXG4gICAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJmcm9tU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tU2VlZChzZWVkKSB7XG4gICAgICB2YXIgcHVibGljS2V5ID0gZ2V0UHVibGljS2V5KHNlZWQpO1xuICAgICAgdmFyIHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgICAgIHNlY3JldEtleS5zZXQoc2VlZCk7XG4gICAgICBzZWNyZXRLZXkuc2V0KHB1YmxpY0tleSwgMzIpO1xuICAgICAgcmV0dXJuIG5ldyBLZXlwYWlyKHtcbiAgICAgICAgcHVibGljS2V5OiBwdWJsaWNLZXksXG4gICAgICAgIHNlY3JldEtleTogc2VjcmV0S2V5XG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEtleXBhaXI7XG59KCk7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgTG9va3VwVGFibGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgYWRkcmVzcyBsb29rdXAgdGFibGUgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgQ3JlYXRlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgncmVjZW50U2xvdCcpLCBCdWZmZXJMYXlvdXQudTgoJ2J1bXBTZWVkJyldKVxuICB9LFxuICBGcmVlemVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEV4dGVuZExvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDIsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoKSwgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2FkZHJlc3NlcycpXSlcbiAgfSxcbiAgRGVhY3RpdmF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgQ2xvc2VMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xudmFyIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIG51bGwsIFt7XG4gICAga2V5OiBcImRlY29kZUluc3RydWN0aW9uVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHZhciBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgICAgdmFyIGluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICAgIHZhciB0eXBlO1xuICAgICAgZm9yICh2YXIgX2kgPSAwLCBfT2JqZWN0JGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX09iamVjdCRlbnRyaWVzW19pXSwgMiksXG4gICAgICAgICAgbGF5b3V0VHlwZSA9IF9PYmplY3QkZW50cmllcyRfaVswXSxcbiAgICAgICAgICBsYXlvdXQgPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07XG4gICAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gaW5kZXgpIHtcbiAgICAgICAgICB0eXBlID0gbGF5b3V0VHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBJbnN0cnVjdGlvbi4gU2hvdWxkIGJlIGEgTG9va3VwVGFibGUgSW5zdHJ1Y3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVDcmVhdGVMb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleXNMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNCk7XG4gICAgICB2YXIgX2RlY29kZURhdGEgPSBkZWNvZGVEYXRhJDEoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGUsIGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICByZWNlbnRTbG90ID0gX2RlY29kZURhdGEucmVjZW50U2xvdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgICAgcmVjZW50U2xvdDogTnVtYmVyKHJlY2VudFNsb3QpXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVFeHRlbmRMb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVFeHRlbmRMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCBcIi5jb25jYXQoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGgsIFwiIGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IDJcIikpO1xuICAgICAgfVxuICAgICAgdmFyIF9kZWNvZGVEYXRhMiA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGFkZHJlc3NlcyA9IF9kZWNvZGVEYXRhMi5hZGRyZXNzZXM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICAgIHBheWVyOiBpbnN0cnVjdGlvbi5rZXlzLmxlbmd0aCA+IDIgPyBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSA6IHVuZGVmaW5lZCxcbiAgICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFB1YmxpY0tleShidWZmZXIpO1xuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlQ2xvc2VMb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVDbG9zZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgICAgcmVjaXBpZW50OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlRnJlZXplTG9va3VwVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlRnJlZXplTG9va3VwVGFibGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbG9va3VwVGFibGU6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVEZWFjdGl2YXRlTG9va3VwVGFibGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXR5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1Byb2dyYW1JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IEFkZHJlc3NMb29rdXBUYWJsZSBQcm9ncmFtJyk7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrS2V5c0xlbmd0aFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja0tleXNMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kIFwiLmNvbmNhdChrZXlzLmxlbmd0aCwgXCIga2V5cywgZXhwZWN0ZWQgYXQgbGVhc3QgXCIpLmNvbmNhdChleHBlY3RlZExlbmd0aCkpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb247XG59KCk7XG52YXIgQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0pO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLCBudWxsLCBbe1xuICAgIGtleTogXCJjcmVhdGVMb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICAgIHZhciBfUHVibGljS2V5JGZpbmRQcm9ncmEgPSBQdWJsaWNLZXkuZmluZFByb2dyYW1BZGRyZXNzU3luYyhbcGFyYW1zLmF1dGhvcml0eS50b0J1ZmZlcigpLCB0b0J1ZmZlckxFKEJpZ0ludChwYXJhbXMucmVjZW50U2xvdCksIDgpXSwgdGhpcy5wcm9ncmFtSWQpLFxuICAgICAgICBfUHVibGljS2V5JGZpbmRQcm9ncmEyID0gX3NsaWNlZFRvQXJyYXkoX1B1YmxpY0tleSRmaW5kUHJvZ3JhLCAyKSxcbiAgICAgICAgbG9va3VwVGFibGVBZGRyZXNzID0gX1B1YmxpY0tleSRmaW5kUHJvZ3JhMlswXSxcbiAgICAgICAgYnVtcFNlZWQgPSBfUHVibGljS2V5JGZpbmRQcm9ncmEyWzFdO1xuICAgICAgdmFyIHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZTtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHJlY2VudFNsb3Q6IEJpZ0ludChwYXJhbXMucmVjZW50U2xvdCksXG4gICAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgICAgfSk7XG4gICAgICB2YXIga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogbG9va3VwVGFibGVBZGRyZXNzLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pLCBsb29rdXBUYWJsZUFkZHJlc3NdO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmcmVlemVMb29rdXBUYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcmVlemVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICAgIHZhciB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRnJlZXplTG9va3VwVGFibGU7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImV4dGVuZExvb2t1cFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGV4dGVuZExvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZTtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoZnVuY3Rpb24gKGFkZHIpIHtcbiAgICAgICAgICByZXR1cm4gYWRkci50b0J5dGVzKCk7XG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIHZhciBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5OiBwYXJhbXMucGF5ZXIsXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhY3RpdmF0ZUxvb2t1cFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlYWN0aXZhdGVMb29rdXBUYWJsZShwYXJhbXMpIHtcbiAgICAgIHZhciB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZUxvb2t1cFRhYmxlO1xuICAgICAgdmFyIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjbG9zZUxvb2t1cFRhYmxlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsb3NlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgICB2YXIgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkNsb3NlTG9va3VwVGFibGU7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgICB2YXIga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMucmVjaXBpZW50LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtO1xufSgpO1xuQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdBZGRyZXNzTG9va3VwVGFiMWUxMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogQ29tcHV0ZSBCdWRnZXQgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xudmFyIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uLCBudWxsLCBbe1xuICAgIGtleTogXCJkZWNvZGVJbnN0cnVjdGlvblR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB2YXIgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpO1xuICAgICAgdmFyIHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyk7IF9pIDwgX09iamVjdCRlbnRyaWVzLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgX09iamVjdCRlbnRyaWVzJF9pID0gX3NsaWNlZFRvQXJyYXkoX09iamVjdCRlbnRyaWVzW19pXSwgMiksXG4gICAgICAgICAgaXhUeXBlID0gX09iamVjdCRlbnRyaWVzJF9pWzBdLFxuICAgICAgICAgIGxheW91dCA9IF9PYmplY3QkZW50cmllcyRfaVsxXTtcbiAgICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgICB0eXBlID0gaXhUeXBlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgQ29tcHV0ZUJ1ZGdldEluc3RydWN0aW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVSZXF1ZXN0VW5pdHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlUmVxdWVzdFVuaXRzKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB2YXIgX2RlY29kZURhdGEgPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHMsIGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICB1bml0cyA9IF9kZWNvZGVEYXRhLnVuaXRzLFxuICAgICAgICBhZGRpdGlvbmFsRmVlID0gX2RlY29kZURhdGEuYWRkaXRpb25hbEZlZTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVuaXRzOiB1bml0cyxcbiAgICAgICAgYWRkaXRpb25hbEZlZTogYWRkaXRpb25hbEZlZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgcmVxdWVzdCBoZWFwIGZyYW1lIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZVJlcXVlc3RIZWFwRnJhbWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlUmVxdWVzdEhlYXBGcmFtZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdmFyIF9kZWNvZGVEYXRhMiA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICBieXRlcyA9IF9kZWNvZGVEYXRhMi5ieXRlcztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVzOiBieXRlc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgc2V0IGNvbXB1dGUgdW5pdCBsaW1pdCBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVTZXRDb21wdXRlVW5pdExpbWl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZVNldENvbXB1dGVVbml0TGltaXQoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTMgPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgdW5pdHMgPSBfZGVjb2RlRGF0YTMudW5pdHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB1bml0czogdW5pdHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgcHJpY2UgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlU2V0Q29tcHV0ZVVuaXRQcmljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVTZXRDb21wdXRlVW5pdFByaWNlKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB2YXIgX2RlY29kZURhdGE0ID0gZGVjb2RlRGF0YSQxKENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuU2V0Q29tcHV0ZVVuaXRQcmljZSwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIG1pY3JvTGFtcG9ydHMgPSBfZGVjb2RlRGF0YTQubWljcm9MYW1wb3J0cztcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1pY3JvTGFtcG9ydHM6IG1pY3JvTGFtcG9ydHNcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tQcm9ncmFtSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQ29tcHV0ZUJ1ZGdldFByb2dyYW0nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbjtcbn0oKTtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgdW5pdHMgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBSZXF1ZXN0IGhlYXAgZnJhbWUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IGxpbWl0IGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogU2V0IGNvbXB1dGUgdW5pdCBwcmljZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXQgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBSZXF1ZXN0VW5pdHM6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKSwgQnVmZmVyTGF5b3V0LnUzMignYWRkaXRpb25hbEZlZScpXSlcbiAgfSxcbiAgUmVxdWVzdEhlYXBGcmFtZToge1xuICAgIGluZGV4OiAxLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlcycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRMaW1pdDoge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQudTMyKCd1bml0cycpXSlcbiAgfSxcbiAgU2V0Q29tcHV0ZVVuaXRQcmljZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdpbnN0cnVjdGlvbicpLCB1NjQoJ21pY3JvTGFtcG9ydHMnKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9uIGluc3RydWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBDb21wdXRlIEJ1ZGdldCBwcm9ncmFtXG4gKi9cbnZhciBDb21wdXRlQnVkZ2V0UHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIENvbXB1dGVCdWRnZXRQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDb21wdXRlQnVkZ2V0UHJvZ3JhbSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDb21wdXRlQnVkZ2V0UHJvZ3JhbSwgbnVsbCwgW3tcbiAgICBrZXk6IFwicmVxdWVzdFVuaXRzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRMaW1pdH0gYW5kL29yIHtAbGluayBzZXRDb21wdXRlVW5pdFByaWNlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcXVlc3RVbml0cyhwYXJhbXMpIHtcbiAgICAgIHZhciB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0VW5pdHM7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVxdWVzdEhlYXBGcmFtZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXF1ZXN0SGVhcEZyYW1lKHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWU7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29tcHV0ZVVuaXRMaW1pdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21wdXRlVW5pdExpbWl0KHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0TGltaXQ7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwgcGFyYW1zKTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q29tcHV0ZVVuaXRQcmljZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDb21wdXRlVW5pdFByaWNlKHBhcmFtcykge1xuICAgICAgdmFyIHR5cGUgPSBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlNldENvbXB1dGVVbml0UHJpY2U7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBtaWNyb0xhbXBvcnRzOiBCaWdJbnQocGFyYW1zLm1pY3JvTGFtcG9ydHMpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENvbXB1dGVCdWRnZXRQcm9ncmFtO1xufSgpO1xuQ29tcHV0ZUJ1ZGdldFByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQ29tcHV0ZUJ1ZGdldDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG52YXIgUFJJVkFURV9LRVlfQllURVMkMSA9IDY0O1xudmFyIFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xudmFyIFNJR05BVFVSRV9CWVRFUyA9IDY0O1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB1c2luZyBhIHByaXZhdGUga2V5XG4gKi9cblxudmFyIEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51OCgncGFkZGluZycpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdwdWJsaWNLZXlPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5SW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZUluc3RydWN0aW9uSW5kZXgnKV0pO1xudmFyIEVkMjU1MTlQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gRWQyNTUxOVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEVkMjU1MTlQcm9ncmFtKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgZWQyNTUxOSBwcm9ncmFtXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoRWQyNTUxOVByb2dyYW0sIG51bGwsIFt7XG4gICAga2V5OiBcImNyZWF0ZUluc3RydWN0aW9uV2l0aFB1YmxpY0tleVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5IGFuZCBzaWduYXR1cmUuIFRoZVxuICAgICAqIHB1YmxpYyBrZXkgbXVzdCBiZSBhIGJ1ZmZlciB0aGF0IGlzIDMyIGJ5dGVzIGxvbmcsIGFuZCB0aGUgc2lnbmF0dXJlXG4gICAgICogbXVzdCBiZSBhIGJ1ZmZlciBvZiA2NCBieXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgICB2YXIgcHVibGljS2V5ID0gcGFyYW1zLnB1YmxpY0tleSxcbiAgICAgICAgbWVzc2FnZSA9IHBhcmFtcy5tZXNzYWdlLFxuICAgICAgICBzaWduYXR1cmUgPSBwYXJhbXMuc2lnbmF0dXJlLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4ID0gcGFyYW1zLmluc3RydWN0aW9uSW5kZXg7XG4gICAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUyQxLCBcIlB1YmxpYyBLZXkgbXVzdCBiZSBcIi5jb25jYXQoUFVCTElDX0tFWV9CWVRFUyQxLCBcIiBieXRlcyBidXQgcmVjZWl2ZWQgXCIpLmNvbmNhdChwdWJsaWNLZXkubGVuZ3RoLCBcIiBieXRlc1wiKSk7XG4gICAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gU0lHTkFUVVJFX0JZVEVTLCBcIlNpZ25hdHVyZSBtdXN0IGJlIFwiLmNvbmNhdChTSUdOQVRVUkVfQllURVMsIFwiIGJ5dGVzIGJ1dCByZWNlaXZlZCBcIikuY29uY2F0KHNpZ25hdHVyZS5sZW5ndGgsIFwiIGJ5dGVzXCIpKTtcbiAgICAgIHZhciBwdWJsaWNLZXlPZmZzZXQgPSBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuO1xuICAgICAgdmFyIHNpZ25hdHVyZU9mZnNldCA9IHB1YmxpY0tleU9mZnNldCArIHB1YmxpY0tleS5sZW5ndGg7XG4gICAgICB2YXIgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoO1xuICAgICAgdmFyIG51bVNpZ25hdHVyZXMgPSAxO1xuICAgICAgdmFyIGluc3RydWN0aW9uRGF0YSA9IEJ1ZmZlci5hbGxvYyhtZXNzYWdlRGF0YU9mZnNldCArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgIHZhciBpbmRleCA9IGluc3RydWN0aW9uSW5kZXggPT0gbnVsbCA/IDB4ZmZmZiAvLyBBbiBpbmRleCBvZiBgdTE2OjpNQVhgIG1ha2VzIGl0IGRlZmF1bHQgdG8gdGhlIGN1cnJlbnQgaW5zdHJ1Y3Rpb24uXG4gICAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgICBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgICBudW1TaWduYXR1cmVzOiBudW1TaWduYXR1cmVzLFxuICAgICAgICBwYWRkaW5nOiAwLFxuICAgICAgICBzaWduYXR1cmVPZmZzZXQ6IHNpZ25hdHVyZU9mZnNldCxcbiAgICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICAgIHB1YmxpY0tleU9mZnNldDogcHVibGljS2V5T2Zmc2V0LFxuICAgICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgICAgbWVzc2FnZURhdGFPZmZzZXQ6IG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgICBtZXNzYWdlRGF0YVNpemU6IG1lc3NhZ2UubGVuZ3RoLFxuICAgICAgICBtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXhcbiAgICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChwdWJsaWNLZXksIHB1YmxpY0tleU9mZnNldCk7XG4gICAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChzaWduYXR1cmUsIHNpZ25hdHVyZU9mZnNldCk7XG4gICAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uRGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIGVkMjU1MTkgaW5zdHJ1Y3Rpb24gd2l0aCBhIHByaXZhdGUga2V5LiBUaGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgICB2YXIgcHJpdmF0ZUtleSA9IHBhcmFtcy5wcml2YXRlS2V5LFxuICAgICAgICBtZXNzYWdlID0gcGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXggPSBwYXJhbXMuaW5zdHJ1Y3Rpb25JbmRleDtcbiAgICAgIGFzc2VydChwcml2YXRlS2V5Lmxlbmd0aCA9PT0gUFJJVkFURV9LRVlfQllURVMkMSwgXCJQcml2YXRlIGtleSBtdXN0IGJlIFwiLmNvbmNhdChQUklWQVRFX0tFWV9CWVRFUyQxLCBcIiBieXRlcyBidXQgcmVjZWl2ZWQgXCIpLmNvbmNhdChwcml2YXRlS2V5Lmxlbmd0aCwgXCIgYnl0ZXNcIikpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGtleXBhaXIgPSBLZXlwYWlyLmZyb21TZWNyZXRLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgIHZhciBwdWJsaWNLZXkgPSBrZXlwYWlyLnB1YmxpY0tleS50b0J5dGVzKCk7XG4gICAgICAgIHZhciBzaWduYXR1cmUgPSBzaWduKG1lc3NhZ2UsIGtleXBhaXIuc2VjcmV0S2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHtcbiAgICAgICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgICAgIHNpZ25hdHVyZTogc2lnbmF0dXJlLFxuICAgICAgICAgIGluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjcmVhdGluZyBpbnN0cnVjdGlvbjsgXCIuY29uY2F0KGVycm9yKSk7XG4gICAgICB9XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFZDI1NTE5UHJvZ3JhbTtcbn0oKTtcbkVkMjU1MTlQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0VkMjU1MTlTaWdWZXJpZnkxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIGVjZHNhU2lnbiA9IGZ1bmN0aW9uIGVjZHNhU2lnbihtc2dIYXNoLCBwcml2S2V5KSB7XG4gIHZhciBzaWduYXR1cmUgPSBzZWNwMjU2azEuc2lnbihtc2dIYXNoLCBwcml2S2V5KTtcbiAgcmV0dXJuIFtzaWduYXR1cmUudG9Db21wYWN0UmF3Qnl0ZXMoKSwgc2lnbmF0dXJlLnJlY292ZXJ5XTtcbn07XG5zZWNwMjU2azEudXRpbHMuaXNWYWxpZFByaXZhdGVLZXk7XG52YXIgcHVibGljS2V5Q3JlYXRlID0gc2VjcDI1NmsxLmdldFB1YmxpY0tleTtcblxudmFyIFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG52YXIgRVRIRVJFVU1fQUREUkVTU19CWVRFUyA9IDIwO1xudmFyIFBVQkxJQ19LRVlfQllURVMgPSA2NDtcbnZhciBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG52YXIgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTE2KCdzaWduYXR1cmVPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnU4KCdzaWduYXR1cmVJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ2V0aEFkZHJlc3NPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnU4KCdldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTE2KCdtZXNzYWdlRGF0YVNpemUnKSwgQnVmZmVyTGF5b3V0LnU4KCdtZXNzYWdlSW5zdHJ1Y3Rpb25JbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYigyMCwgJ2V0aEFkZHJlc3MnKSwgQnVmZmVyTGF5b3V0LmJsb2IoNjQsICdzaWduYXR1cmUnKSwgQnVmZmVyTGF5b3V0LnU4KCdyZWNvdmVyeUlkJyldKTtcbnZhciBTZWNwMjU2azFQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gU2VjcDI1NmsxUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2VjcDI1NmsxUHJvZ3JhbSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU2VjcDI1NmsxUHJvZ3JhbSwgbnVsbCwgW3tcbiAgICBrZXk6IFwicHVibGljS2V5VG9FdGhBZGRyZXNzXCIsXG4gICAgdmFsdWU6XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0IGFuIEV0aGVyZXVtIGFkZHJlc3MgZnJvbSBhIHNlY3AyNTZrMSBwdWJsaWMga2V5IGJ1ZmZlci5cbiAgICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgICBhc3NlcnQocHVibGljS2V5Lmxlbmd0aCA9PT0gUFVCTElDX0tFWV9CWVRFUywgXCJQdWJsaWMga2V5IG11c3QgYmUgXCIuY29uY2F0KFBVQkxJQ19LRVlfQllURVMsIFwiIGJ5dGVzIGJ1dCByZWNlaXZlZCBcIikuY29uY2F0KHB1YmxpY0tleS5sZW5ndGgsIFwiIGJ5dGVzXCIpKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKHB1YmxpY0tleSkpKS5zbGljZSgtRVRIRVJFVU1fQUREUkVTU19CWVRFUyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBjb25zdHJ1Y3RpbmcgRXRoZXJldW0gYWRkcmVzczogXCIuY29uY2F0KGVycm9yKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleS4gVGhlIHB1YmxpYyBrZXlcbiAgICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlSW5zdHJ1Y3Rpb25XaXRoUHVibGljS2V5KHBhcmFtcykge1xuICAgICAgdmFyIHB1YmxpY0tleSA9IHBhcmFtcy5wdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UgPSBwYXJhbXMubWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlID0gcGFyYW1zLnNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCA9IHBhcmFtcy5yZWNvdmVyeUlkLFxuICAgICAgICBpbnN0cnVjdGlvbkluZGV4ID0gcGFyYW1zLmluc3RydWN0aW9uSW5kZXg7XG4gICAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgICAgZXRoQWRkcmVzczogU2VjcDI1NmsxUHJvZ3JhbS5wdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSxcbiAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgIHJlY292ZXJ5SWQ6IHJlY292ZXJ5SWQsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhbiBFdGhlcmV1bSBhZGRyZXNzLiBUaGUgYWRkcmVzc1xuICAgICAqIG11c3QgYmUgYSBoZXggc3RyaW5nIG9yIGEgYnVmZmVyIHRoYXQgaXMgMjAgYnl0ZXMgbG9uZy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgICB2YXIgcmF3QWRkcmVzcyA9IHBhcmFtcy5ldGhBZGRyZXNzLFxuICAgICAgICBtZXNzYWdlID0gcGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSA9IHBhcmFtcy5zaWduYXR1cmUsXG4gICAgICAgIHJlY292ZXJ5SWQgPSBwYXJhbXMucmVjb3ZlcnlJZCxcbiAgICAgICAgX3BhcmFtcyRpbnN0cnVjdGlvbkluID0gcGFyYW1zLmluc3RydWN0aW9uSW5kZXgsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXggPSBfcGFyYW1zJGluc3RydWN0aW9uSW4gPT09IHZvaWQgMCA/IDAgOiBfcGFyYW1zJGluc3RydWN0aW9uSW47XG4gICAgICB2YXIgZXRoQWRkcmVzcztcbiAgICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHJhd0FkZHJlc3Muc3RhcnRzV2l0aCgnMHgnKSkge1xuICAgICAgICAgIGV0aEFkZHJlc3MgPSBCdWZmZXIuZnJvbShyYXdBZGRyZXNzLnN1YnN0cigyKSwgJ2hleCcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV0aEFkZHJlc3MgPSBCdWZmZXIuZnJvbShyYXdBZGRyZXNzLCAnaGV4Jyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV0aEFkZHJlc3MgPSByYXdBZGRyZXNzO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGV0aEFkZHJlc3MubGVuZ3RoID09PSBFVEhFUkVVTV9BRERSRVNTX0JZVEVTLCBcIkFkZHJlc3MgbXVzdCBiZSBcIi5jb25jYXQoRVRIRVJFVU1fQUREUkVTU19CWVRFUywgXCIgYnl0ZXMgYnV0IHJlY2VpdmVkIFwiKS5jb25jYXQoZXRoQWRkcmVzcy5sZW5ndGgsIFwiIGJ5dGVzXCIpKTtcbiAgICAgIHZhciBkYXRhU3RhcnQgPSAxICsgU0lHTkFUVVJFX09GRlNFVFNfU0VSSUFMSVpFRF9TSVpFO1xuICAgICAgdmFyIGV0aEFkZHJlc3NPZmZzZXQgPSBkYXRhU3RhcnQ7XG4gICAgICB2YXIgc2lnbmF0dXJlT2Zmc2V0ID0gZGF0YVN0YXJ0ICsgZXRoQWRkcmVzcy5sZW5ndGg7XG4gICAgICB2YXIgbWVzc2FnZURhdGFPZmZzZXQgPSBzaWduYXR1cmVPZmZzZXQgKyBzaWduYXR1cmUubGVuZ3RoICsgMTtcbiAgICAgIHZhciBudW1TaWduYXR1cmVzID0gMTtcbiAgICAgIHZhciBpbnN0cnVjdGlvbkRhdGEgPSBCdWZmZXIuYWxsb2MoU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgICAgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5lbmNvZGUoe1xuICAgICAgICBudW1TaWduYXR1cmVzOiBudW1TaWduYXR1cmVzLFxuICAgICAgICBzaWduYXR1cmVPZmZzZXQ6IHNpZ25hdHVyZU9mZnNldCxcbiAgICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgICAgZXRoQWRkcmVzc09mZnNldDogZXRoQWRkcmVzc09mZnNldCxcbiAgICAgICAgZXRoQWRkcmVzc0luc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0OiBtZXNzYWdlRGF0YU9mZnNldCxcbiAgICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgICAgbWVzc2FnZUluc3RydWN0aW9uSW5kZXg6IGluc3RydWN0aW9uSW5kZXgsXG4gICAgICAgIHNpZ25hdHVyZTogdG9CdWZmZXIoc2lnbmF0dXJlKSxcbiAgICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICAgIHJlY292ZXJ5SWQ6IHJlY292ZXJ5SWRcbiAgICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIGtleXM6IFtdLFxuICAgICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhbiBzZWNwMjU2azEgaW5zdHJ1Y3Rpb24gd2l0aCBhIHByaXZhdGUga2V5LiBUaGUgcHJpdmF0ZSBrZXlcbiAgICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUluc3RydWN0aW9uV2l0aFByaXZhdGVLZXkocGFyYW1zKSB7XG4gICAgICB2YXIgcGtleSA9IHBhcmFtcy5wcml2YXRlS2V5LFxuICAgICAgICBtZXNzYWdlID0gcGFyYW1zLm1lc3NhZ2UsXG4gICAgICAgIGluc3RydWN0aW9uSW5kZXggPSBwYXJhbXMuaW5zdHJ1Y3Rpb25JbmRleDtcbiAgICAgIGFzc2VydChwa2V5Lmxlbmd0aCA9PT0gUFJJVkFURV9LRVlfQllURVMsIFwiUHJpdmF0ZSBrZXkgbXVzdCBiZSBcIi5jb25jYXQoUFJJVkFURV9LRVlfQllURVMsIFwiIGJ5dGVzIGJ1dCByZWNlaXZlZCBcIikuY29uY2F0KHBrZXkubGVuZ3RoLCBcIiBieXRlc1wiKSk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJpdmF0ZUtleSA9IHRvQnVmZmVyKHBrZXkpO1xuICAgICAgICB2YXIgcHVibGljS2V5ID0gcHVibGljS2V5Q3JlYXRlKHByaXZhdGVLZXksIGZhbHNlIC8qIGlzQ29tcHJlc3NlZCAqLykuc2xpY2UoMSk7IC8vIHRocm93IGF3YXkgbGVhZGluZyBieXRlXG4gICAgICAgIHZhciBtZXNzYWdlSGFzaCA9IEJ1ZmZlci5mcm9tKGtlY2Nha18yNTYodG9CdWZmZXIobWVzc2FnZSkpKTtcbiAgICAgICAgdmFyIF9lY2RzYVNpZ24gPSBlY2RzYVNpZ24obWVzc2FnZUhhc2gsIHByaXZhdGVLZXkpLFxuICAgICAgICAgIF9lY2RzYVNpZ24yID0gX3NsaWNlZFRvQXJyYXkoX2VjZHNhU2lnbiwgMiksXG4gICAgICAgICAgc2lnbmF0dXJlID0gX2VjZHNhU2lnbjJbMF0sXG4gICAgICAgICAgcmVjb3ZlcnlJZCA9IF9lY2RzYVNpZ24yWzFdO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICAgIHB1YmxpY0tleTogcHVibGljS2V5LFxuICAgICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUsXG4gICAgICAgICAgcmVjb3ZlcnlJZDogcmVjb3ZlcnlJZCxcbiAgICAgICAgICBpbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247IFwiLmNvbmNhdChlcnJvcikpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbTtcbn0oKTtcblNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnS2VjY2FrU2VjcDI1NmsxMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEFkZHJlc3Mgb2YgdGhlIHN0YWtlIGNvbmZpZyBhY2NvdW50IHdoaWNoIGNvbmZpZ3VyZXMgdGhlIHJhdGVcbiAqIG9mIHN0YWtlIHdhcm11cCBhbmQgY29vbGRvd24gYXMgd2VsbCBhcyB0aGUgc2xhc2hpbmcgcGVuYWx0eS5cbiAqL1xudmFyIFNUQUtFX0NPTkZJR19JRCA9IG5ldyBQdWJsaWNLZXkoJ1N0YWtlQ29uZmlnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGF1dGhvcml0eSBpbmZvXG4gKi9cbnZhciBBdXRob3JpemVkID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhcbi8qKlxuICogQ3JlYXRlIGEgbmV3IEF1dGhvcml6ZWQgb2JqZWN0XG4gKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAqIEBwYXJhbSB3aXRoZHJhd2VyIHRoZSB3aXRoZHJhdyBhdXRob3JpdHlcbiAqL1xuZnVuY3Rpb24gQXV0aG9yaXplZChzdGFrZXIsIHdpdGhkcmF3ZXIpIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEF1dGhvcml6ZWQpO1xuICAvKiogc3Rha2UgYXV0aG9yaXR5ICovXG4gIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAvKiogd2l0aGRyYXcgYXV0aG9yaXR5ICovXG4gIHRoaXMud2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gIHRoaXMud2l0aGRyYXdlciA9IHdpdGhkcmF3ZXI7XG59KTtcbi8qKlxuICogU3Rha2UgYWNjb3VudCBsb2NrdXAgaW5mb1xuICovXG52YXIgTG9ja3VwID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhcbi8qKlxuICogQ3JlYXRlIGEgbmV3IExvY2t1cCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gTG9ja3VwKHVuaXhUaW1lc3RhbXAsIGVwb2NoLCBjdXN0b2RpYW4pIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExvY2t1cCk7XG4gIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICB0aGlzLnVuaXhUaW1lc3RhbXAgPSB2b2lkIDA7XG4gIC8qKiBFcG9jaCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAvKiogTG9ja3VwIGN1c3RvZGlhbiBhdXRob3JpdHkgKi9cbiAgdGhpcy5jdXN0b2RpYW4gPSB2b2lkIDA7XG4gIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gIHRoaXMuZXBvY2ggPSBlcG9jaDtcbiAgdGhpcy5jdXN0b2RpYW4gPSBjdXN0b2RpYW47XG59XG5cbi8qKlxuICogRGVmYXVsdCwgaW5hY3RpdmUgTG9ja3VwIHZhbHVlXG4gKi8pO1xuTG9ja3VwW1wiZGVmYXVsdFwiXSA9IG5ldyBMb2NrdXAoMCwgMCwgUHVibGljS2V5W1wiZGVmYXVsdFwiXSk7XG4vKipcbiAqIENyZWF0ZSBzdGFrZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIENyZWF0ZSBzdGFrZSBhY2NvdW50IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBJbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIERlbGVnYXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBBdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zIHVzaW5nIGEgZGVyaXZlZCBrZXlcbiAqL1xuLyoqXG4gKiBTcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBTcGxpdCB3aXRoIHNlZWQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogV2l0aGRyYXcgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVhY3RpdmF0ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBNZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBTdGFrZSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG52YXIgU3Rha2VJbnN0cnVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIFN0YWtlSW5zdHJ1Y3Rpb24oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YWtlSW5zdHJ1Y3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhTdGFrZUluc3RydWN0aW9uLCBudWxsLCBbe1xuICAgIGtleTogXCJkZWNvZGVJbnN0cnVjdGlvblR5cGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB2YXIgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICAgIHZhciB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgICAgdmFyIHR5cGU7XG4gICAgICBmb3IgKHZhciBfaSA9IDAsIF9PYmplY3QkZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMpOyBfaSA8IF9PYmplY3QkZW50cmllcy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIF9PYmplY3QkZW50cmllcyRfaSA9IF9zbGljZWRUb0FycmF5KF9PYmplY3QkZW50cmllc1tfaV0sIDIpLFxuICAgICAgICAgIGl4VHlwZSA9IF9PYmplY3QkZW50cmllcyRfaVswXSxcbiAgICAgICAgICBsYXlvdXQgPSBfT2JqZWN0JGVudHJpZXMkX2lbMV07XG4gICAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN0YWtlSW5zdHJ1Y3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIGluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlSW5pdGlhbGl6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVJbml0aWFsaXplKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgICAgdmFyIF9kZWNvZGVEYXRhID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGF1dGhvcml6ZWQgPSBfZGVjb2RlRGF0YS5hdXRob3JpemVkLFxuICAgICAgICBsb2NrdXAgPSBfZGVjb2RlRGF0YS5sb2NrdXA7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWQ6IG5ldyBBdXRob3JpemVkKG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZC5zdGFrZXIpLCBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQud2l0aGRyYXdlcikpLFxuICAgICAgICBsb2NrdXA6IG5ldyBMb2NrdXAobG9ja3VwLnVuaXhUaW1lc3RhbXAsIGxvY2t1cC5lcG9jaCwgbmV3IFB1YmxpY0tleShsb2NrdXAuY3VzdG9kaWFuKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgZGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlRGVsZWdhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlRGVsZWdhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNik7XG4gICAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzVdLnB1YmtleVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUF1dGhvcml6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgICB2YXIgX2RlY29kZURhdGEyID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgbmV3QXV0aG9yaXplZCA9IF9kZWNvZGVEYXRhMi5uZXdBdXRob3JpemVkLFxuICAgICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlID0gX2RlY29kZURhdGEyLnN0YWtlQXV0aG9yaXphdGlvblR5cGU7XG4gICAgICB2YXIgbyA9IHtcbiAgICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplLXdpdGgtc2VlZCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVBdXRob3JpemVXaXRoU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBdXRob3JpemVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTMgPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIG5ld0F1dGhvcml6ZWQgPSBfZGVjb2RlRGF0YTMubmV3QXV0aG9yaXplZCxcbiAgICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSA9IF9kZWNvZGVEYXRhMy5zdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgICBhdXRob3JpdHlTZWVkID0gX2RlY29kZURhdGEzLmF1dGhvcml0eVNlZWQsXG4gICAgICAgIGF1dGhvcml0eU93bmVyID0gX2RlY29kZURhdGEzLmF1dGhvcml0eU93bmVyO1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXR5QmFzZTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICAgIG8uY3VzdG9kaWFuUHVia2V5ID0gaW5zdHJ1Y3Rpb24ua2V5c1szXS5wdWJrZXk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBzcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVTcGxpdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVTcGxpdChpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTQgPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdCwgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGxhbXBvcnRzID0gX2RlY29kZURhdGE0LmxhbXBvcnRzO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBzcGxpdFN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiBsYW1wb3J0c1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBtZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVNZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVNZXJnZShpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgc291cmNlU3Rha2VQdWJLZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSB3aXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVXaXRoZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTUgPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSksXG4gICAgICAgIGxhbXBvcnRzID0gX2RlY29kZURhdGE1LmxhbXBvcnRzO1xuICAgICAgdmFyIG8gPSB7XG4gICAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGxhbXBvcnRzXG4gICAgICB9O1xuICAgICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gNSkge1xuICAgICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG87XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRGVjb2RlIGEgZGVhY3RpdmF0ZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVEZWFjdGl2YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZURlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2hlY2tQcm9ncmFtSWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3Rha2VQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrS2V5TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCBcIi5jb25jYXQoa2V5cy5sZW5ndGgsIFwiIGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IFwiKS5jb25jYXQoZXhwZWN0ZWRMZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFN0YWtlSW5zdHJ1Y3Rpb247XG59KCk7XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUyA9IE9iamVjdC5mcmVlemUoe1xuICBJbml0aWFsaXplOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBhdXRob3JpemVkKCksIGxvY2t1cCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpXSlcbiAgfSxcbiAgRGVsZWdhdGU6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBTcGxpdDoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBEZWFjdGl2YXRlOiB7XG4gICAgaW5kZXg6IDUsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgTWVyZ2U6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBBdXRob3JpemVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA4LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCduZXdBdXRob3JpemVkJyksIEJ1ZmZlckxheW91dC51MzIoJ3N0YWtlQXV0aG9yaXphdGlvblR5cGUnKSwgcnVzdFN0cmluZygnYXV0aG9yaXR5U2VlZCcpLCBwdWJsaWNLZXkoJ2F1dGhvcml0eU93bmVyJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBTdGFrZSBhdXRob3JpemF0aW9uIHR5cGVcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCdzXG4gKi9cbnZhciBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgU3Rha2VyOiB7XG4gICAgaW5kZXg6IDBcbiAgfSxcbiAgV2l0aGRyYXdlcjoge1xuICAgIGluZGV4OiAxXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTdGFrZSBwcm9ncmFtXG4gKi9cbnZhciBTdGFrZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBTdGFrZVByb2dyYW0oKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFN0YWtlUHJvZ3JhbSk7XG4gIH1cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIFN0YWtlIHByb2dyYW1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhTdGFrZVByb2dyYW0sIG51bGwsIFt7XG4gICAga2V5OiBcImluaXRpYWxpemVcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgICB2YXIgc3Rha2VQdWJrZXkgPSBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWQgPSBwYXJhbXMuYXV0aG9yaXplZCxcbiAgICAgICAgbWF5YmVMb2NrdXAgPSBwYXJhbXMubG9ja3VwO1xuICAgICAgdmFyIGxvY2t1cCA9IG1heWJlTG9ja3VwIHx8IExvY2t1cFtcImRlZmF1bHRcIl07XG4gICAgICB2YXIgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGF1dGhvcml6ZWQ6IHtcbiAgICAgICAgICBzdGFrZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQuc3Rha2VyLnRvQnVmZmVyKCkpLFxuICAgICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgICB9LFxuICAgICAgICBsb2NrdXA6IHtcbiAgICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgICBlcG9jaDogbG9ja3VwLmVwb2NoLFxuICAgICAgICAgIGN1c3RvZGlhbjogdG9CdWZmZXIobG9ja3VwLmN1c3RvZGlhbi50b0J1ZmZlcigpKVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHZhciBpbnN0cnVjdGlvbkRhdGEgPSB7XG4gICAgICAgIGtleXM6IFt7XG4gICAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgU3Rha2UgYWNjb3VudCBhdFxuICAgICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVBY2NvdW50V2l0aFNlZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQWNjb3VudFdpdGhTZWVkKHBhcmFtcykge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgICB2YXIgc3Rha2VQdWJrZXkgPSBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWQgPSBwYXJhbXMuYXV0aG9yaXplZCxcbiAgICAgICAgbG9ja3VwID0gcGFyYW1zLmxvY2t1cDtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgICAgc3Rha2VQdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBhdXRob3JpemVkOiBhdXRob3JpemVkLFxuICAgICAgICBsb2NrdXA6IGxvY2t1cFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IFN0YWtlIGFjY291bnRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjcmVhdGVBY2NvdW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgICAgdmFyIHN0YWtlUHVia2V5ID0gcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBhdXRob3JpemVkID0gcGFyYW1zLmF1dGhvcml6ZWQsXG4gICAgICAgIGxvY2t1cCA9IHBhcmFtcy5sb2NrdXA7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuaW5pdGlhbGl6ZSh7XG4gICAgICAgIHN0YWtlUHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZDogYXV0aG9yaXplZCxcbiAgICAgICAgbG9ja3VwOiBsb2NrdXBcbiAgICAgIH0pKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgZGVsZWdhdGVzIFN0YWtlIHRva2VucyB0byBhIHZhbGlkYXRvclxuICAgICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgICAqIHRvIGEgbmV3IHZhbGlkYXRvciBWb3RlIFB1YmxpY0tleS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWxlZ2F0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICAgIHZhciBzdGFrZVB1YmtleSA9IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleSA9IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICB2b3RlUHVia2V5ID0gcGFyYW1zLnZvdGVQdWJrZXk7XG4gICAgICB2YXIgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1RBS0VfQ09ORklHX0lELFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgU3Rha2VyXG4gICAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdXRob3JpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0aG9yaXplKHBhcmFtcykge1xuICAgICAgdmFyIHN0YWtlUHVia2V5ID0gcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5ID0gcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXkgPSBwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSA9IHBhcmFtcy5zdGFrZUF1dGhvcml6YXRpb25UeXBlLFxuICAgICAgICBjdXN0b2RpYW5QdWJrZXkgPSBwYXJhbXMuY3VzdG9kaWFuUHVia2V5O1xuICAgICAgdmFyIHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICAgIH0pO1xuICAgICAgdmFyIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBQdWJsaWNLZXkgYXMgU3Rha2VyXG4gICAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdXRob3JpemVXaXRoU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICAgIHZhciBzdGFrZVB1YmtleSA9IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXR5QmFzZSA9IHBhcmFtcy5hdXRob3JpdHlCYXNlLFxuICAgICAgICBhdXRob3JpdHlTZWVkID0gcGFyYW1zLmF1dGhvcml0eVNlZWQsXG4gICAgICAgIGF1dGhvcml0eU93bmVyID0gcGFyYW1zLmF1dGhvcml0eU93bmVyLFxuICAgICAgICBuZXdBdXRob3JpemVkUHVia2V5ID0gcGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUgPSBwYXJhbXMuc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgICAgY3VzdG9kaWFuUHVia2V5ID0gcGFyYW1zLmN1c3RvZGlhblB1YmtleTtcbiAgICAgIHZhciB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZDtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIG5ld0F1dGhvcml6ZWQ6IHRvQnVmZmVyKG5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSksXG4gICAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICAgIGF1dGhvcml0eVNlZWQ6IGF1dGhvcml0eVNlZWQsXG4gICAgICAgIGF1dGhvcml0eU93bmVyOiB0b0J1ZmZlcihhdXRob3JpdHlPd25lci50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICB2YXIga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml0eUJhc2UsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dO1xuICAgICAgaWYgKGN1c3RvZGlhblB1YmtleSkge1xuICAgICAgICBrZXlzLnB1c2goe1xuICAgICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBrZXlzLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzcGxpdEluc3RydWN0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgc3Rha2VQdWJrZXkgPSBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICAgIGF1dGhvcml6ZWRQdWJrZXkgPSBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgc3BsaXRTdGFrZVB1YmtleSA9IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBsYW1wb3J0cyA9IHBhcmFtcy5sYW1wb3J0cztcbiAgICAgIHZhciB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBsYW1wb3J0c1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNwbGl0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNwbGl0KHBhcmFtcykge1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBsYW1wb3J0czogMCxcbiAgICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAgICogZGVyaXZlZCBmcm9tIGEgYmFzZSBwdWJsaWMga2V5IGFuZCBzZWVkXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic3BsaXRXaXRoU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzcGxpdFdpdGhTZWVkKHBhcmFtcykge1xuICAgICAgdmFyIHN0YWtlUHVia2V5ID0gcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5ID0gcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIHNwbGl0U3Rha2VQdWJrZXkgPSBwYXJhbXMuc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgYmFzZVB1YmtleSA9IHBhcmFtcy5iYXNlUHVia2V5LFxuICAgICAgICBzZWVkID0gcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzID0gcGFyYW1zLmxhbXBvcnRzO1xuICAgICAgdmFyIHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgIGFjY291bnRQdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGJhc2VQdWJrZXk6IGJhc2VQdWJrZXksXG4gICAgICAgIHNlZWQ6IHNlZWQsXG4gICAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICAgIHN0YWtlUHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgc3BsaXRTdGFrZVB1YmtleTogc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IGxhbXBvcnRzXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJtZXJnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBtZXJnZShwYXJhbXMpIHtcbiAgICAgIHZhciBzdGFrZVB1YmtleSA9IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgICAgc291cmNlU3Rha2VQdWJLZXkgPSBwYXJhbXMuc291cmNlU3Rha2VQdWJLZXksXG4gICAgICAgIGF1dGhvcml6ZWRQdWJrZXkgPSBwYXJhbXMuYXV0aG9yaXplZFB1YmtleTtcbiAgICAgIHZhciB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5NZXJnZTtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogc291cmNlU3Rha2VQdWJLZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgd2l0aGRyYXdzIGRlYWN0aXZhdGVkIFN0YWtlIHRva2Vucy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ3aXRoZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB3aXRoZHJhdyhwYXJhbXMpIHtcbiAgICAgIHZhciBzdGFrZVB1YmtleSA9IHBhcmFtcy5zdGFrZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleSA9IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICB0b1B1YmtleSA9IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgbGFtcG9ydHMgPSBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIGN1c3RvZGlhblB1YmtleSA9IHBhcmFtcy5jdXN0b2RpYW5QdWJrZXk7XG4gICAgICB2YXIgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBsYW1wb3J0czogbGFtcG9ydHNcbiAgICAgIH0pO1xuICAgICAgdmFyIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgICBpZiAoY3VzdG9kaWFuUHVia2V5KSB7XG4gICAgICAgIGtleXMucHVzaCh7XG4gICAgICAgICAgcHVia2V5OiBjdXN0b2RpYW5QdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICAgIGtleXM6IGtleXMsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICAgIGRhdGE6IGRhdGFcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVhY3RpdmF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWFjdGl2YXRlKHBhcmFtcykge1xuICAgICAgdmFyIHN0YWtlUHVia2V5ID0gcGFyYW1zLnN0YWtlUHVia2V5LFxuICAgICAgICBhdXRob3JpemVkUHVia2V5ID0gcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXk7XG4gICAgICB2YXIgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVhY3RpdmF0ZTtcbiAgICAgIHZhciBkYXRhID0gZW5jb2RlRGF0YSh0eXBlKTtcbiAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogc3Rha2VQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBTdGFrZVByb2dyYW07XG59KCk7XG5TdGFrZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnU3Rha2UxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBTdGFrZSBhY2NvdW50XG4gKlxuICogVGhpcyBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgc29sYW5hLXN0YWtlLXByb2dyYW0gU3Rha2VTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBTdGFrZVN0YXRlOjpzaXplX29mKClgOlxuICogaHR0cHM6Ly9kb2NzLnJzL3NvbGFuYS1zdGFrZS1wcm9ncmFtL2xhdGVzdC9zb2xhbmFfc3Rha2VfcHJvZ3JhbS9zdGFrZV9zdGF0ZS9lbnVtLlN0YWtlU3RhdGUuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xudmFyIFZvdGVJbml0ID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyggLyoqIFswLCAxMDBdICovXG5cbmZ1bmN0aW9uIFZvdGVJbml0KG5vZGVQdWJrZXksIGF1dGhvcml6ZWRWb3RlciwgYXV0aG9yaXplZFdpdGhkcmF3ZXIsIGNvbW1pc3Npb24pIHtcbiAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFZvdGVJbml0KTtcbiAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IHZvaWQgMDtcbiAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IHZvaWQgMDtcbiAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICB0aGlzLm5vZGVQdWJrZXkgPSBub2RlUHVia2V5O1xuICB0aGlzLmF1dGhvcml6ZWRWb3RlciA9IGF1dGhvcml6ZWRWb3RlcjtcbiAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICB0aGlzLmNvbW1pc3Npb24gPSBjb21taXNzaW9uO1xufSk7XG5cbi8qKlxuICogQ3JlYXRlIHZvdGUgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemVBY2NvdW50IGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQXV0aG9yaXplV2l0aFNlZWQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBXaXRoZHJhdyBmcm9tIHZvdGUgYWNjb3VudCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFZvdGUgSW5zdHJ1Y3Rpb24gY2xhc3NcbiAqL1xudmFyIFZvdGVJbnN0cnVjdGlvbiA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZ1bmN0aW9uIFZvdGVJbnN0cnVjdGlvbigpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVm90ZUluc3RydWN0aW9uKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSB2b3RlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhWb3RlSW5zdHJ1Y3Rpb24sIG51bGwsIFt7XG4gICAga2V5OiBcImRlY29kZUluc3RydWN0aW9uVHlwZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHZhciBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpO1xuICAgICAgdmFyIHR5cGVJbmRleCA9IGluc3RydWN0aW9uVHlwZUxheW91dC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgICB2YXIgdHlwZTtcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX09iamVjdCRlbnRyaWVzID0gT2JqZWN0LmVudHJpZXMoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTKTsgX2kgPCBfT2JqZWN0JGVudHJpZXMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBfT2JqZWN0JGVudHJpZXMkX2kgPSBfc2xpY2VkVG9BcnJheShfT2JqZWN0JGVudHJpZXNbX2ldLCAyKSxcbiAgICAgICAgICBpeFR5cGUgPSBfT2JqZWN0JGVudHJpZXMkX2lbMF0sXG4gICAgICAgICAgbGF5b3V0ID0gX09iamVjdCRlbnRyaWVzJF9pWzFdO1xuICAgICAgICBpZiAobGF5b3V0LmluZGV4ID09IHR5cGVJbmRleCkge1xuICAgICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luc3RydWN0aW9uIHR5cGUgaW5jb3JyZWN0OyBub3QgYSBWb3RlSW5zdHJ1Y3Rpb24nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlY29kZSBhbiBpbml0aWFsaXplIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGVjb2RlSW5pdGlhbGl6ZUFjY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNCk7XG4gICAgICB2YXIgX2RlY29kZURhdGEgPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgdm90ZUluaXQgPSBfZGVjb2RlRGF0YS52b3RlSW5pdDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgICBub2RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleSxcbiAgICAgICAgdm90ZUluaXQ6IG5ldyBWb3RlSW5pdChuZXcgUHVibGljS2V5KHZvdGVJbml0Lm5vZGVQdWJrZXkpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRWb3RlciksIG5ldyBQdWJsaWNLZXkodm90ZUluaXQuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLCB2b3RlSW5pdC5jb21taXNzaW9uKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUF1dGhvcml6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVBdXRob3JpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgICB2YXIgX2RlY29kZURhdGEyID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemUsIGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICBuZXdBdXRob3JpemVkID0gX2RlY29kZURhdGEyLm5ld0F1dGhvcml6ZWQsXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSA9IF9kZWNvZGVEYXRhMi52b3RlQXV0aG9yaXphdGlvblR5cGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYW4gYXV0aG9yaXplIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImRlY29kZUF1dGhvcml6ZVdpdGhTZWVkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlY29kZUF1dGhvcml6ZVdpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgICAgdmFyIF9kZWNvZGVEYXRhMyA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpLFxuICAgICAgICBfZGVjb2RlRGF0YTMkdm90ZUF1dGggPSBfZGVjb2RlRGF0YTMudm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncyxcbiAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleSA9IF9kZWNvZGVEYXRhMyR2b3RlQXV0aC5jdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQgPSBfZGVjb2RlRGF0YTMkdm90ZUF1dGguY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgICBuZXdBdXRob3JpemVkID0gX2RlY29kZURhdGEzJHZvdGVBdXRoLm5ld0F1dGhvcml6ZWQsXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSA9IF9kZWNvZGVEYXRhMyR2b3RlQXV0aC52b3RlQXV0aG9yaXphdGlvblR5cGU7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiBuZXcgUHVibGljS2V5KGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXkpLFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgICAgaW5kZXg6IHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgICAgICB9LFxuICAgICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSB3aXRoZHJhdyBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJkZWNvZGVXaXRoZHJhd1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZWNvZGVXaXRoZHJhdyhpbnN0cnVjdGlvbikge1xuICAgICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICAgIHZhciBfZGVjb2RlRGF0YTQgPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3LCBpbnN0cnVjdGlvbi5kYXRhKSxcbiAgICAgICAgbGFtcG9ydHMgPSBfZGVjb2RlRGF0YTQubGFtcG9ydHM7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2b3RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgICBsYW1wb3J0czogbGFtcG9ydHMsXG4gICAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleVxuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjaGVja1Byb2dyYW1JZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBWb3RlUHJvZ3JhbScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNoZWNrS2V5TGVuZ3RoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNoZWNrS2V5TGVuZ3RoKGtleXMsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCBcIi5jb25jYXQoa2V5cy5sZW5ndGgsIFwiIGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IFwiKS5jb25jYXQoZXhwZWN0ZWRMZW5ndGgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFZvdGVJbnN0cnVjdGlvbjtcbn0oKTtcblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKiogQGludGVybmFsICovXG5cbnZhciBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgSW5pdGlhbGl6ZUFjY291bnQ6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHZvdGVJbml0KCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCd2b3RlQXV0aG9yaXphdGlvblR5cGUnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlQXV0aG9yaXphdGlvbiBsYXlvdXRzLlxuICovXG52YXIgVm90ZUF1dGhvcml6YXRpb25MYXlvdXQgPSBPYmplY3QuZnJlZXplKHtcbiAgVm90ZXI6IHtcbiAgICBpbmRleDogMFxuICB9LFxuICBXaXRoZHJhd2VyOiB7XG4gICAgaW5kZXg6IDFcbiAgfVxufSk7XG5cbi8qKlxuICogRmFjdG9yeSBjbGFzcyBmb3IgdHJhbnNhY3Rpb25zIHRvIGludGVyYWN0IHdpdGggdGhlIFZvdGUgcHJvZ3JhbVxuICovXG52YXIgVm90ZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBmdW5jdGlvbiBWb3RlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgVm90ZVByb2dyYW0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBWb3RlIHByb2dyYW1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhWb3RlUHJvZ3JhbSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiaW5pdGlhbGl6ZUFjY291bnRcIixcbiAgICB2YWx1ZTpcbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWxpemVBY2NvdW50KHBhcmFtcykge1xuICAgICAgdmFyIHZvdGVQdWJrZXkgPSBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgICAgbm9kZVB1YmtleSA9IHBhcmFtcy5ub2RlUHVia2V5LFxuICAgICAgICB2b3RlSW5pdCA9IHBhcmFtcy52b3RlSW5pdDtcbiAgICAgIHZhciB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50O1xuICAgICAgdmFyIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgICBub2RlUHVia2V5OiB0b0J1ZmZlcih2b3RlSW5pdC5ub2RlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICAgIGF1dGhvcml6ZWRWb3RlcjogdG9CdWZmZXIodm90ZUluaXQuYXV0aG9yaXplZFZvdGVyLnRvQnVmZmVyKCkpLFxuICAgICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpKSxcbiAgICAgICAgICBjb21taXNzaW9uOiB2b3RlSW5pdC5jb21taXNzaW9uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICAgIH1dLFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgICBkYXRhOiBkYXRhXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUFjY291bnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICAgIHZhciB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplQWNjb3VudCh7XG4gICAgICAgIHZvdGVQdWJrZXk6IHBhcmFtcy52b3RlUHVia2V5LFxuICAgICAgICBub2RlUHVia2V5OiBwYXJhbXMudm90ZUluaXQubm9kZVB1YmtleSxcbiAgICAgICAgdm90ZUluaXQ6IHBhcmFtcy52b3RlSW5pdFxuICAgICAgfSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFZvdGVyIG9yIFdpdGhkcmF3ZXIgb24gdGhlIFZvdGUgYWNjb3VudC5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdXRob3JpemVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYXV0aG9yaXplKHBhcmFtcykge1xuICAgICAgdmFyIHZvdGVQdWJrZXkgPSBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFB1YmtleSA9IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBuZXdBdXRob3JpemVkUHVia2V5ID0gcGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSA9IHBhcmFtcy52b3RlQXV0aG9yaXphdGlvblR5cGU7XG4gICAgICB2YXIgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICB2b3RlQXV0aG9yaXphdGlvblR5cGU6IHZvdGVBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgICAgfSk7XG4gICAgICB2YXIga2V5cyA9IFt7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgVm90ZXIgb3IgV2l0aGRyYXdlciBvbiB0aGUgVm90ZSBhY2NvdW50XG4gICAgICogd2hlcmUgdGhlIGN1cnJlbnQgVm90ZXIgb3IgV2l0aGRyYXdlciBhdXRob3JpdHkgaXMgYSBkZXJpdmVkIGtleS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhdXRob3JpemVXaXRoU2VlZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICAgIHZhciBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXkgPSBwYXJhbXMuY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5ID0gcGFyYW1zLmN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCA9IHBhcmFtcy5jdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQsXG4gICAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXkgPSBwYXJhbXMubmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlID0gcGFyYW1zLnZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgICAgdm90ZVB1YmtleSA9IHBhcmFtcy52b3RlUHVia2V5O1xuICAgICAgdmFyIHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgICB2YXIgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogdG9CdWZmZXIoY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmFyIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcIndpdGhkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHdpdGhkcmF3KHBhcmFtcykge1xuICAgICAgdmFyIHZvdGVQdWJrZXkgPSBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXkgPSBwYXJhbXMuYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzID0gcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgICB0b1B1YmtleSA9IHBhcmFtcy50b1B1YmtleTtcbiAgICAgIHZhciB0eXBlID0gVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgICAgdmFyIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IGxhbXBvcnRzXG4gICAgICB9KTtcbiAgICAgIHZhciBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB0b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czoga2V5cyxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogZGF0YVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBzYWZlbHkgZnJvbSBhIFZvdGUgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2FzIGNyZWF0ZWQgYXMgYSBzYWZlZ3VhcmQgZm9yIHZvdGUgYWNjb3VudHMgcnVubmluZyB2YWxpZGF0b3JzLCBgc2FmZVdpdGhkcmF3YFxuICAgICAqIGNoZWNrcyB0aGF0IHRoZSB3aXRoZHJhdyBhbW91bnQgd2lsbCBub3QgZXhjZWVkIHRoZSBzcGVjaWZpZWQgYmFsYW5jZSB3aGlsZSBsZWF2aW5nIGVub3VnaCBsZWZ0XG4gICAgICogdG8gY292ZXIgcmVudC4gSWYgeW91IHdpc2ggdG8gY2xvc2UgdGhlIHZvdGUgYWNjb3VudCBieSB3aXRoZHJhd2luZyB0aGUgZnVsbCBhbW91bnQsIGNhbGwgdGhlXG4gICAgICogYHdpdGhkcmF3YCBtZXRob2QgZGlyZWN0bHkuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2FmZVdpdGhkcmF3XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNhZmVXaXRoZHJhdyhwYXJhbXMsIGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UsIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgICBpZiAocGFyYW1zLmxhbXBvcnRzID4gY3VycmVudFZvdGVBY2NvdW50QmFsYW5jZSAtIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2l0aGRyYXcgd2lsbCBsZWF2ZSB2b3RlIGFjY291bnQgd2l0aCBpbnN1ZmZjaWVudCBmdW5kcy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBWb3RlUHJvZ3JhbS53aXRoZHJhdyhwYXJhbXMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVm90ZVByb2dyYW07XG59KCk7XG5Wb3RlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFZvdGUgYWNjb3VudFxuICpcbiAqIFRoaXMgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHNvbGFuYS12b3RlLXByb2dyYW0gVm90ZVN0YXRlIHN0cnVjdCBhc1xuICogYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtdm90ZS1wcm9ncmFtLzEuOS41L3NvbGFuYV92b3RlX3Byb2dyYW0vdm90ZV9zdGF0ZS9zdHJ1Y3QuVm90ZVN0YXRlLmh0bWwjbWV0aG9kLnNpemVfb2ZcbiAqXG4gKiBLRUVQIElOIFNZTkMgV0lUSCBgVm90ZVN0YXRlOjpzaXplX29mKClgIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9hNDc0Y2IyNGI5MjM4ZjVlZGNjOTgyZjY1YzBiMzdkNGExMDQ2ZjdlL3Nkay9wcm9ncmFtL3NyYy92b3RlL3N0YXRlL21vZC5ycyNMMzQwLUwzNDJcbiAqL1xuVm90ZVByb2dyYW0uc3BhY2UgPSAzNzMxO1xuXG52YXIgVkFMSURBVE9SX0lORk9fS0VZID0gbmV3IFB1YmxpY0tleSgnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogSW5mbyB1c2VkIHRvIGlkZW50aXR5IHZhbGlkYXRvcnMuXG4gKi9cblxudmFyIEluZm9TdHJpbmcgPSB0eXBlKHtcbiAgbmFtZTogc3RyaW5nKCksXG4gIHdlYnNpdGU6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgZGV0YWlsczogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBrZXliYXNlVXNlcm5hbWU6IG9wdGlvbmFsKHN0cmluZygpKVxufSk7XG5cbi8qKlxuICogVmFsaWRhdG9ySW5mbyBjbGFzc1xuICovXG52YXIgVmFsaWRhdG9ySW5mbyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYSB2YWxpZCBWYWxpZGF0b3JJbmZvXG4gICAqXG4gICAqIEBwYXJhbSBrZXkgdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICogQHBhcmFtIGluZm8gdmFsaWRhdG9yIGluZm9ybWF0aW9uXG4gICAqL1xuICBmdW5jdGlvbiBWYWxpZGF0b3JJbmZvKGtleSwgaW5mbykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWYWxpZGF0b3JJbmZvKTtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgcHVibGljIGtleVxuICAgICAqL1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIHRoaXMuaW5mbyA9IHZvaWQgMDtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLmluZm8gPSBpbmZvO1xuICB9XG5cbiAgLyoqXG4gICAqIERlc2VyaWFsaXplIFZhbGlkYXRvckluZm8gZnJvbSB0aGUgY29uZmlnIGFjY291bnQgZGF0YS4gRXhhY3RseSB0d28gY29uZmlnXG4gICAqIGtleXMgYXJlIHJlcXVpcmVkIGluIHRoZSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGNvbmZpZyBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBudWxsIGlmIGluZm8gd2FzIG5vdCBmb3VuZFxuICAgKi9cbiAgX2NyZWF0ZUNsYXNzKFZhbGlkYXRvckluZm8sIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21Db25maWdEYXRhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb21Db25maWdEYXRhKGJ1ZmZlcikge1xuICAgICAgdmFyIGJ5dGVBcnJheSA9IF90b0NvbnN1bWFibGVBcnJheShidWZmZXIpO1xuICAgICAgdmFyIGNvbmZpZ0tleUNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBpZiAoY29uZmlnS2V5Q291bnQgIT09IDIpIHJldHVybiBudWxsO1xuICAgICAgdmFyIGNvbmZpZ0tleXMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG4gICAgICAgIHZhciBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGJ5dGVBcnJheS5zbGljZSgwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgICBieXRlQXJyYXkgPSBieXRlQXJyYXkuc2xpY2UoUFVCTElDX0tFWV9MRU5HVEgpO1xuICAgICAgICB2YXIgaXNTaWduZXIgPSBieXRlQXJyYXkuc2xpY2UoMCwgMSlbMF0gPT09IDE7XG4gICAgICAgIGJ5dGVBcnJheSA9IGJ5dGVBcnJheS5zbGljZSgxKTtcbiAgICAgICAgY29uZmlnS2V5cy5wdXNoKHtcbiAgICAgICAgICBwdWJsaWNLZXk6IHB1YmxpY0tleSxcbiAgICAgICAgICBpc1NpZ25lcjogaXNTaWduZXJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnS2V5c1swXS5wdWJsaWNLZXkuZXF1YWxzKFZBTElEQVRPUl9JTkZPX0tFWSkpIHtcbiAgICAgICAgaWYgKGNvbmZpZ0tleXNbMV0uaXNTaWduZXIpIHtcbiAgICAgICAgICB2YXIgcmF3SW5mbyA9IHJ1c3RTdHJpbmcoKS5kZWNvZGUoQnVmZmVyLmZyb20oYnl0ZUFycmF5KSk7XG4gICAgICAgICAgdmFyIGluZm8gPSBKU09OLnBhcnNlKHJhd0luZm8pO1xuICAgICAgICAgIGFzc2VydCQxKGluZm8sIEluZm9TdHJpbmcpO1xuICAgICAgICAgIHJldHVybiBuZXcgVmFsaWRhdG9ySW5mbyhjb25maWdLZXlzWzFdLnB1YmxpY0tleSwgaW5mbyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVmFsaWRhdG9ySW5mbztcbn0oKTtcblxudmFyIFZPVEVfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ1ZvdGUxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBIaXN0b3J5IG9mIGhvdyBtYW55IGNyZWRpdHMgZWFybmVkIGJ5IHRoZSBlbmQgb2YgZWFjaCBlcG9jaFxuICovXG5cbi8qKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi84YTEyZWQwMjljZmEzOGQ0YTQ1NDAwOTE2YzI0NjNmYjgyYmJlYzhjL3Byb2dyYW1zL3ZvdGVfYXBpL3NyYy92b3RlX3N0YXRlLnJzI0w2OC1MODhcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFZvdGVBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyB2b3Rlcy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0LnUzMignY29uZmlybWF0aW9uQ291bnQnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAndm90ZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdyb290U2xvdFZhbGlkJyksIEJ1ZmZlckxheW91dC5udTY0KCdyb290U2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgpLFxuLy8gYXV0aG9yaXplZFZvdGVycy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyldKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2F1dGhvcml6ZWRWb3RlcnMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgndGFyZ2V0RXBvY2gnKV0pLCAzMiwgJ2J1ZicpLCBCdWZmZXJMYXlvdXQubnU2NCgnaWR4JyksIEJ1ZmZlckxheW91dC51OCgnaXNFbXB0eScpXSwgJ3ByaW9yVm90ZXJzJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBlcG9jaENyZWRpdHMubGVuZ3RoXG5CdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdlcG9jaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnY3JlZGl0cycpLCBCdWZmZXJMYXlvdXQubnU2NCgncHJldkNyZWRpdHMnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnZXBvY2hDcmVkaXRzJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCd0aW1lc3RhbXAnKV0sICdsYXN0VGltZXN0YW1wJyldKTtcbi8qKlxuICogVm90ZUFjY291bnQgY2xhc3NcbiAqL1xudmFyIFZvdGVBY2NvdW50ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZnVuY3Rpb24gVm90ZUFjY291bnQoYXJncykge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBWb3RlQWNjb3VudCk7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMucm9vdFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy52b3RlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gYXJncy5ub2RlUHVia2V5O1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSBhcmdzLmF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGFyZ3MuY29tbWlzc2lvbjtcbiAgICB0aGlzLnJvb3RTbG90ID0gYXJncy5yb290U2xvdDtcbiAgICB0aGlzLnZvdGVzID0gYXJncy52b3RlcztcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSBhcmdzLmF1dGhvcml6ZWRWb3RlcnM7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IGFyZ3MucHJpb3JWb3RlcnM7XG4gICAgdGhpcy5lcG9jaENyZWRpdHMgPSBhcmdzLmVwb2NoQ3JlZGl0cztcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBhcmdzLmxhc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVm90ZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIFZvdGVBY2NvdW50XG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoVm90ZUFjY291bnQsIG51bGwsIFt7XG4gICAga2V5OiBcImZyb21BY2NvdW50RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgICB2YXIgdmVyc2lvbk9mZnNldCA9IDQ7XG4gICAgICB2YXIgdmEgPSBWb3RlQWNjb3VudExheW91dC5kZWNvZGUodG9CdWZmZXIoYnVmZmVyKSwgdmVyc2lvbk9mZnNldCk7XG4gICAgICB2YXIgcm9vdFNsb3QgPSB2YS5yb290U2xvdDtcbiAgICAgIGlmICghdmEucm9vdFNsb3RWYWxpZCkge1xuICAgICAgICByb290U2xvdCA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFZvdGVBY2NvdW50KHtcbiAgICAgICAgbm9kZVB1YmtleTogbmV3IFB1YmxpY0tleSh2YS5ub2RlUHVia2V5KSxcbiAgICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXI6IG5ldyBQdWJsaWNLZXkodmEuYXV0aG9yaXplZFdpdGhkcmF3ZXIpLFxuICAgICAgICBjb21taXNzaW9uOiB2YS5jb21taXNzaW9uLFxuICAgICAgICB2b3RlczogdmEudm90ZXMsXG4gICAgICAgIHJvb3RTbG90OiByb290U2xvdCxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyczogdmEuYXV0aG9yaXplZFZvdGVycy5tYXAocGFyc2VBdXRob3JpemVkVm90ZXIpLFxuICAgICAgICBwcmlvclZvdGVyczogZ2V0UHJpb3JWb3RlcnModmEucHJpb3JWb3RlcnMpLFxuICAgICAgICBlcG9jaENyZWRpdHM6IHZhLmVwb2NoQ3JlZGl0cyxcbiAgICAgICAgbGFzdFRpbWVzdGFtcDogdmEubGFzdFRpbWVzdGFtcFxuICAgICAgfSk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBWb3RlQWNjb3VudDtcbn0oKTtcbmZ1bmN0aW9uIHBhcnNlQXV0aG9yaXplZFZvdGVyKF9yZWYpIHtcbiAgdmFyIGF1dGhvcml6ZWRWb3RlciA9IF9yZWYuYXV0aG9yaXplZFZvdGVyLFxuICAgIGVwb2NoID0gX3JlZi5lcG9jaDtcbiAgcmV0dXJuIHtcbiAgICBlcG9jaDogZXBvY2gsXG4gICAgYXV0aG9yaXplZFZvdGVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWRWb3RlcilcbiAgfTtcbn1cbmZ1bmN0aW9uIHBhcnNlUHJpb3JWb3RlcnMoX3JlZjIpIHtcbiAgdmFyIGF1dGhvcml6ZWRQdWJrZXkgPSBfcmVmMi5hdXRob3JpemVkUHVia2V5LFxuICAgIGVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCA9IF9yZWYyLmVwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCxcbiAgICB0YXJnZXRFcG9jaCA9IF9yZWYyLnRhcmdldEVwb2NoO1xuICByZXR1cm4ge1xuICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZFB1YmtleSksXG4gICAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoOiBlcG9jaE9mTGFzdEF1dGhvcml6ZWRTd2l0Y2gsXG4gICAgdGFyZ2V0RXBvY2g6IHRhcmdldEVwb2NoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQcmlvclZvdGVycyhfcmVmMykge1xuICB2YXIgYnVmID0gX3JlZjMuYnVmLFxuICAgIGlkeCA9IF9yZWYzLmlkeCxcbiAgICBpc0VtcHR5ID0gX3JlZjMuaXNFbXB0eTtcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIFtdLmNvbmNhdChfdG9Db25zdW1hYmxlQXJyYXkoYnVmLnNsaWNlKGlkeCArIDEpLm1hcChwYXJzZVByaW9yVm90ZXJzKSksIF90b0NvbnN1bWFibGVBcnJheShidWYuc2xpY2UoMCwgaWR4KS5tYXAocGFyc2VQcmlvclZvdGVycykpKTtcbn1cblxudmFyIGVuZHBvaW50ID0ge1xuICBodHRwOiB7XG4gICAgZGV2bmV0OiAnaHR0cDovL2FwaS5kZXZuZXQuc29sYW5hLmNvbScsXG4gICAgdGVzdG5ldDogJ2h0dHA6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tJyxcbiAgICAnbWFpbm5ldC1iZXRhJzogJ2h0dHA6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20vJ1xuICB9LFxuICBodHRwczoge1xuICAgIGRldm5ldDogJ2h0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tJyxcbiAgICAnbWFpbm5ldC1iZXRhJzogJ2h0dHBzOi8vYXBpLm1haW5uZXQtYmV0YS5zb2xhbmEuY29tLydcbiAgfVxufTtcbi8qKlxuICogUmV0cmlldmVzIHRoZSBSUEMgQVBJIFVSTCBmb3IgdGhlIHNwZWNpZmllZCBjbHVzdGVyXG4gKiBAcGFyYW0ge0NsdXN0ZXJ9IFtjbHVzdGVyPVwiZGV2bmV0XCJdIC0gVGhlIGNsdXN0ZXIgbmFtZSBvZiB0aGUgUlBDIEFQSSBVUkwgdG8gdXNlLiBQb3NzaWJsZSBvcHRpb25zOiAnZGV2bmV0JyB8ICd0ZXN0bmV0JyB8ICdtYWlubmV0LWJldGEnXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFt0bHM9XCJodHRwXCJdIC0gVXNlIFRMUyB3aGVuIGNvbm5lY3RpbmcgdG8gY2x1c3Rlci5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBVUkwgc3RyaW5nIG9mIHRoZSBSUEMgZW5kcG9pbnRcbiAqL1xuZnVuY3Rpb24gY2x1c3RlckFwaVVybChjbHVzdGVyLCB0bHMpIHtcbiAgdmFyIGtleSA9IHRscyA9PT0gZmFsc2UgPyAnaHR0cCcgOiAnaHR0cHMnO1xuICBpZiAoIWNsdXN0ZXIpIHtcbiAgICByZXR1cm4gZW5kcG9pbnRba2V5XVsnZGV2bmV0J107XG4gIH1cbiAgdmFyIHVybCA9IGVuZHBvaW50W2tleV1bY2x1c3Rlcl07XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBcIi5jb25jYXQoa2V5LCBcIiBjbHVzdGVyOiBcIikuY29uY2F0KGNsdXN0ZXIpKTtcbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovIF9yZWdlbmVyYXRvclJ1bnRpbWUgPSBmdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkgeyByZXR1cm4gZXhwb3J0czsgfTsgdmFyIGV4cG9ydHMgPSB7fSwgT3AgPSBPYmplY3QucHJvdG90eXBlLCBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eSwgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7IG9ialtrZXldID0gZGVzYy52YWx1ZTsgfSwgJFN5bWJvbCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sID8gU3ltYm9sIDoge30sIGl0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIiwgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLCB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHsgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6ICEwLCBjb25maWd1cmFibGU6ICEwLCB3cml0YWJsZTogITAgfSksIG9ialtrZXldOyB9IHRyeSB7IGRlZmluZSh7fSwgXCJcIik7IH0gY2F0Y2ggKGVycikgeyBkZWZpbmUgPSBmdW5jdGlvbiBkZWZpbmUob2JqLCBrZXksIHZhbHVlKSB7IHJldHVybiBvYmpba2V5XSA9IHZhbHVlOyB9OyB9IGZ1bmN0aW9uIHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpIHsgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3IsIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKSwgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTsgcmV0dXJuIGRlZmluZVByb3BlcnR5KGdlbmVyYXRvciwgXCJfaW52b2tlXCIsIHsgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkgfSksIGdlbmVyYXRvcjsgfSBmdW5jdGlvbiB0cnlDYXRjaChmbiwgb2JqLCBhcmcpIHsgdHJ5IHsgcmV0dXJuIHsgdHlwZTogXCJub3JtYWxcIiwgYXJnOiBmbi5jYWxsKG9iaiwgYXJnKSB9OyB9IGNhdGNoIChlcnIpIHsgcmV0dXJuIHsgdHlwZTogXCJ0aHJvd1wiLCBhcmc6IGVyciB9OyB9IH0gZXhwb3J0cy53cmFwID0gd3JhcDsgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTsgZnVuY3Rpb24gR2VuZXJhdG9yKCkge30gZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fSBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9IHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9OyBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9KTsgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLCBOYXRpdmVJdGVyYXRvclByb3RvdHlwZSA9IGdldFByb3RvICYmIGdldFByb3RvKGdldFByb3RvKHZhbHVlcyhbXSkpKTsgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgJiYgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmIGhhc093bi5jYWxsKE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlLCBpdGVyYXRvclN5bWJvbCkgJiYgKEl0ZXJhdG9yUHJvdG90eXBlID0gTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUpOyB2YXIgR3AgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShJdGVyYXRvclByb3RvdHlwZSk7IGZ1bmN0aW9uIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhwcm90b3R5cGUpIHsgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkgeyBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uIChhcmcpIHsgcmV0dXJuIHRoaXMuX2ludm9rZShtZXRob2QsIGFyZyk7IH0pOyB9KTsgfSBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKGdlbmVyYXRvciwgUHJvbWlzZUltcGwpIHsgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHsgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGdlbmVyYXRvclttZXRob2RdLCBnZW5lcmF0b3IsIGFyZyk7IGlmIChcInRocm93XCIgIT09IHJlY29yZC50eXBlKSB7IHZhciByZXN1bHQgPSByZWNvcmQuYXJnLCB2YWx1ZSA9IHJlc3VsdC52YWx1ZTsgcmV0dXJuIHZhbHVlICYmIFwib2JqZWN0XCIgPT0gX3R5cGVvZih2YWx1ZSkgJiYgaGFzT3duLmNhbGwodmFsdWUsIFwiX19hd2FpdFwiKSA/IFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbiAodmFsdWUpIHsgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTsgfSwgZnVuY3Rpb24gKGVycikgeyBpbnZva2UoXCJ0aHJvd1wiLCBlcnIsIHJlc29sdmUsIHJlamVjdCk7IH0pIDogUHJvbWlzZUltcGwucmVzb2x2ZSh2YWx1ZSkudGhlbihmdW5jdGlvbiAodW53cmFwcGVkKSB7IHJlc3VsdC52YWx1ZSA9IHVud3JhcHBlZCwgcmVzb2x2ZShyZXN1bHQpOyB9LCBmdW5jdGlvbiAoZXJyb3IpIHsgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZWplY3QocmVjb3JkLmFyZyk7IH0gdmFyIHByZXZpb3VzUHJvbWlzZTsgZGVmaW5lUHJvcGVydHkodGhpcywgXCJfaW52b2tlXCIsIHsgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7IGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkgeyByZXR1cm4gbmV3IFByb21pc2VJbXBsKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpOyB9KTsgfSByZXR1cm4gcHJldmlvdXNQcm9taXNlID0gcHJldmlvdXNQcm9taXNlID8gcHJldmlvdXNQcm9taXNlLnRoZW4oY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcsIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKSA6IGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCk7IH0gfSk7IH0gZnVuY3Rpb24gbWFrZUludm9rZU1ldGhvZChpbm5lckZuLCBzZWxmLCBjb250ZXh0KSB7IHZhciBzdGF0ZSA9IFwic3VzcGVuZGVkU3RhcnRcIjsgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykgeyBpZiAoXCJleGVjdXRpbmdcIiA9PT0gc3RhdGUpIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7IGlmIChcImNvbXBsZXRlZFwiID09PSBzdGF0ZSkgeyBpZiAoXCJ0aHJvd1wiID09PSBtZXRob2QpIHRocm93IGFyZzsgcmV0dXJuIGRvbmVSZXN1bHQoKTsgfSBmb3IgKGNvbnRleHQubWV0aG9kID0gbWV0aG9kLCBjb250ZXh0LmFyZyA9IGFyZzs7KSB7IHZhciBkZWxlZ2F0ZSA9IGNvbnRleHQuZGVsZWdhdGU7IGlmIChkZWxlZ2F0ZSkgeyB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTsgaWYgKGRlbGVnYXRlUmVzdWx0KSB7IGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7IHJldHVybiBkZWxlZ2F0ZVJlc3VsdDsgfSB9IGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7IGlmIChcInN1c3BlbmRlZFN0YXJ0XCIgPT09IHN0YXRlKSB0aHJvdyBzdGF0ZSA9IFwiY29tcGxldGVkXCIsIGNvbnRleHQuYXJnOyBjb250ZXh0LmRpc3BhdGNoRXhjZXB0aW9uKGNvbnRleHQuYXJnKTsgfSBlbHNlIFwicmV0dXJuXCIgPT09IGNvbnRleHQubWV0aG9kICYmIGNvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIGNvbnRleHQuYXJnKTsgc3RhdGUgPSBcImV4ZWN1dGluZ1wiOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goaW5uZXJGbiwgc2VsZiwgY29udGV4dCk7IGlmIChcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSkgeyBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTsgcmV0dXJuIHsgdmFsdWU6IHJlY29yZC5hcmcsIGRvbmU6IGNvbnRleHQuZG9uZSB9OyB9IFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7IH0gfTsgfSBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7IHZhciBtZXRob2ROYW1lID0gY29udGV4dC5tZXRob2QsIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdOyBpZiAodW5kZWZpbmVkID09PSBtZXRob2QpIHJldHVybiBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgXCJ0aHJvd1wiID09PSBtZXRob2ROYW1lICYmIGRlbGVnYXRlLml0ZXJhdG9yW1wicmV0dXJuXCJdICYmIChjb250ZXh0Lm1ldGhvZCA9IFwicmV0dXJuXCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkLCBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSwgXCJ0aHJvd1wiID09PSBjb250ZXh0Lm1ldGhvZCkgfHwgXCJyZXR1cm5cIiAhPT0gbWV0aG9kTmFtZSAmJiAoY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gbmV3IFR5cGVFcnJvcihcIlRoZSBpdGVyYXRvciBkb2VzIG5vdCBwcm92aWRlIGEgJ1wiICsgbWV0aG9kTmFtZSArIFwiJyBtZXRob2RcIikpLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2gobWV0aG9kLCBkZWxlZ2F0ZS5pdGVyYXRvciwgY29udGV4dC5hcmcpOyBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsOyB2YXIgaW5mbyA9IHJlY29yZC5hcmc7IHJldHVybiBpbmZvID8gaW5mby5kb25lID8gKGNvbnRleHRbZGVsZWdhdGUucmVzdWx0TmFtZV0gPSBpbmZvLnZhbHVlLCBjb250ZXh0Lm5leHQgPSBkZWxlZ2F0ZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSBjb250ZXh0Lm1ldGhvZCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCBjb250ZXh0LmRlbGVnYXRlID0gbnVsbCwgQ29udGludWVTZW50aW5lbCkgOiBpbmZvIDogKGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpOyB9IGZ1bmN0aW9uIHB1c2hUcnlFbnRyeShsb2NzKSB7IHZhciBlbnRyeSA9IHsgdHJ5TG9jOiBsb2NzWzBdIH07IDEgaW4gbG9jcyAmJiAoZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdKSwgMiBpbiBsb2NzICYmIChlbnRyeS5maW5hbGx5TG9jID0gbG9jc1syXSwgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdKSwgdGhpcy50cnlFbnRyaWVzLnB1c2goZW50cnkpOyB9IGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb24gfHwge307IHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7IH0gZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkgeyB0aGlzLnRyeUVudHJpZXMgPSBbeyB0cnlMb2M6IFwicm9vdFwiIH1dLCB0cnlMb2NzTGlzdC5mb3JFYWNoKHB1c2hUcnlFbnRyeSwgdGhpcyksIHRoaXMucmVzZXQoITApOyB9IGZ1bmN0aW9uIHZhbHVlcyhpdGVyYWJsZSkgeyBpZiAoaXRlcmFibGUpIHsgdmFyIGl0ZXJhdG9yTWV0aG9kID0gaXRlcmFibGVbaXRlcmF0b3JTeW1ib2xdOyBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTsgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgaXRlcmFibGUubmV4dCkgcmV0dXJuIGl0ZXJhYmxlOyBpZiAoIWlzTmFOKGl0ZXJhYmxlLmxlbmd0aCkpIHsgdmFyIGkgPSAtMSwgbmV4dCA9IGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyArK2kgPCBpdGVyYWJsZS5sZW5ndGg7KSBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSByZXR1cm4gbmV4dC52YWx1ZSA9IGl0ZXJhYmxlW2ldLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDsgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyByZXR1cm4gbmV4dC5uZXh0ID0gbmV4dDsgfSB9IHJldHVybiB7IG5leHQ6IGRvbmVSZXN1bHQgfTsgfSBmdW5jdGlvbiBkb25lUmVzdWx0KCkgeyByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiAhMCB9OyB9IHJldHVybiBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgZGVmaW5lUHJvcGVydHkoR3AsIFwiY29uc3RydWN0b3JcIiwgeyB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGNvbmZpZ3VyYWJsZTogITAgfSksIGRlZmluZVByb3BlcnR5KEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHsgdmFsdWU6IEdlbmVyYXRvckZ1bmN0aW9uLCBjb25maWd1cmFibGU6ICEwIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgdmFyIGN0b3IgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGdlbkZ1biAmJiBnZW5GdW4uY29uc3RydWN0b3I7IHJldHVybiAhIWN0b3IgJiYgKGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8IFwiR2VuZXJhdG9yRnVuY3Rpb25cIiA9PT0gKGN0b3IuZGlzcGxheU5hbWUgfHwgY3Rvci5uYW1lKSk7IH0sIGV4cG9ydHMubWFyayA9IGZ1bmN0aW9uIChnZW5GdW4pIHsgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47IH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7IHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9OyB9LCBkZWZpbmVJdGVyYXRvck1ldGhvZHMoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUpLCBkZWZpbmUoQXN5bmNJdGVyYXRvci5wcm90b3R5cGUsIGFzeW5jSXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yLCBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24gKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0LCBQcm9taXNlSW1wbCkgeyB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpOyB2YXIgaXRlciA9IG5ldyBBc3luY0l0ZXJhdG9yKHdyYXAoaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QpLCBQcm9taXNlSW1wbCk7IHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbikgPyBpdGVyIDogaXRlci5uZXh0KCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7IHJldHVybiByZXN1bHQuZG9uZSA/IHJlc3VsdC52YWx1ZSA6IGl0ZXIubmV4dCgpOyB9KTsgfSwgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKSwgZGVmaW5lKEdwLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JcIiksIGRlZmluZShHcCwgaXRlcmF0b3JTeW1ib2wsIGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkgeyByZXR1cm4gXCJbb2JqZWN0IEdlbmVyYXRvcl1cIjsgfSksIGV4cG9ydHMua2V5cyA9IGZ1bmN0aW9uICh2YWwpIHsgdmFyIG9iamVjdCA9IE9iamVjdCh2YWwpLCBrZXlzID0gW107IGZvciAodmFyIGtleSBpbiBvYmplY3QpIGtleXMucHVzaChrZXkpOyByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7IGZvciAoOyBrZXlzLmxlbmd0aDspIHsgdmFyIGtleSA9IGtleXMucG9wKCk7IGlmIChrZXkgaW4gb2JqZWN0KSByZXR1cm4gbmV4dC52YWx1ZSA9IGtleSwgbmV4dC5kb25lID0gITEsIG5leHQ7IH0gcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0OyB9OyB9LCBleHBvcnRzLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBDb250ZXh0LCByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkgeyBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZCwgdGhpcy5kb25lID0gITEsIHRoaXMuZGVsZWdhdGUgPSBudWxsLCB0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLmFyZyA9IHVuZGVmaW5lZCwgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSksICFza2lwVGVtcFJlc2V0KSBmb3IgKHZhciBuYW1lIGluIHRoaXMpIFwidFwiID09PSBuYW1lLmNoYXJBdCgwKSAmJiBoYXNPd24uY2FsbCh0aGlzLCBuYW1lKSAmJiAhaXNOYU4oK25hbWUuc2xpY2UoMSkpICYmICh0aGlzW25hbWVdID0gdW5kZWZpbmVkKTsgfSwgc3RvcDogZnVuY3Rpb24gc3RvcCgpIHsgdGhpcy5kb25lID0gITA7IHZhciByb290UmVjb3JkID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJvb3RSZWNvcmQudHlwZSkgdGhyb3cgcm9vdFJlY29yZC5hcmc7IHJldHVybiB0aGlzLnJ2YWw7IH0sIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiBkaXNwYXRjaEV4Y2VwdGlvbihleGNlcHRpb24pIHsgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZXhjZXB0aW9uOyB2YXIgY29udGV4dCA9IHRoaXM7IGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkgeyByZXR1cm4gcmVjb3JkLnR5cGUgPSBcInRocm93XCIsIHJlY29yZC5hcmcgPSBleGNlcHRpb24sIGNvbnRleHQubmV4dCA9IGxvYywgY2F1Z2h0ICYmIChjb250ZXh0Lm1ldGhvZCA9IFwibmV4dFwiLCBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZCksICEhY2F1Z2h0OyB9IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLCByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uOyBpZiAoXCJyb290XCIgPT09IGVudHJ5LnRyeUxvYykgcmV0dXJuIGhhbmRsZShcImVuZFwiKTsgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHsgdmFyIGhhc0NhdGNoID0gaGFzT3duLmNhbGwoZW50cnksIFwiY2F0Y2hMb2NcIiksIGhhc0ZpbmFsbHkgPSBoYXNPd24uY2FsbChlbnRyeSwgXCJmaW5hbGx5TG9jXCIpOyBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkgeyBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsICEwKTsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7IH0gZWxzZSBpZiAoaGFzQ2F0Y2gpIHsgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7IH0gZWxzZSB7IGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7IGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmZpbmFsbHlMb2MpOyB9IH0gfSB9LCBhYnJ1cHQ6IGZ1bmN0aW9uIGFicnVwdCh0eXBlLCBhcmcpIHsgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkgeyB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07IGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgeyB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7IGJyZWFrOyB9IH0gZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpOyB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTsgcmV0dXJuIHJlY29yZC50eXBlID0gdHlwZSwgcmVjb3JkLmFyZyA9IGFyZywgZmluYWxseUVudHJ5ID8gKHRoaXMubWV0aG9kID0gXCJuZXh0XCIsIHRoaXMubmV4dCA9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jLCBDb250aW51ZVNlbnRpbmVsKSA6IHRoaXMuY29tcGxldGUocmVjb3JkKTsgfSwgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHsgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHRocm93IHJlY29yZC5hcmc7IHJldHVybiBcImJyZWFrXCIgPT09IHJlY29yZC50eXBlIHx8IFwiY29udGludWVcIiA9PT0gcmVjb3JkLnR5cGUgPyB0aGlzLm5leHQgPSByZWNvcmQuYXJnIDogXCJyZXR1cm5cIiA9PT0gcmVjb3JkLnR5cGUgPyAodGhpcy5ydmFsID0gdGhpcy5hcmcgPSByZWNvcmQuYXJnLCB0aGlzLm1ldGhvZCA9IFwicmV0dXJuXCIsIHRoaXMubmV4dCA9IFwiZW5kXCIpIDogXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUgJiYgYWZ0ZXJMb2MgJiYgKHRoaXMubmV4dCA9IGFmdGVyTG9jKSwgQ29udGludWVTZW50aW5lbDsgfSwgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykgeyBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7IHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTsgaWYgKGVudHJ5LmZpbmFsbHlMb2MgPT09IGZpbmFsbHlMb2MpIHJldHVybiB0aGlzLmNvbXBsZXRlKGVudHJ5LmNvbXBsZXRpb24sIGVudHJ5LmFmdGVyTG9jKSwgcmVzZXRUcnlFbnRyeShlbnRyeSksIENvbnRpbnVlU2VudGluZWw7IH0gfSwgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7IGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHsgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldOyBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHsgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247IGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB7IHZhciB0aHJvd24gPSByZWNvcmQuYXJnOyByZXNldFRyeUVudHJ5KGVudHJ5KTsgfSByZXR1cm4gdGhyb3duOyB9IH0gdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpOyB9LCBkZWxlZ2F0ZVlpZWxkOiBmdW5jdGlvbiBkZWxlZ2F0ZVlpZWxkKGl0ZXJhYmxlLCByZXN1bHROYW1lLCBuZXh0TG9jKSB7IHJldHVybiB0aGlzLmRlbGVnYXRlID0geyBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSwgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSwgbmV4dExvYzogbmV4dExvYyB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdW5kZWZpbmVkKSwgQ29udGludWVTZW50aW5lbDsgfSB9LCBleHBvcnRzOyB9XG4vKipcbiAqIFNlbmQgYW5kIGNvbmZpcm0gYSByYXcgdHJhbnNhY3Rpb25cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmF3VHJhbnNhY3Rpb25cbiAqIEBwYXJhbSB7VHJhbnNhY3Rpb25Db25maXJtYXRpb25TdHJhdGVneX0gY29uZmlybWF0aW9uU3RyYXRlZ3lcbiAqIEBwYXJhbSB7Q29uZmlybU9wdGlvbnN9IFtvcHRpb25zXVxuICogQHJldHVybnMge1Byb21pc2U8VHJhbnNhY3Rpb25TaWduYXR1cmU+fVxuICovXG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgQ2FsbGluZyBgc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbigpYCB3aXRob3V0IGEgYGNvbmZpcm1hdGlvblN0cmF0ZWd5YFxuICogaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHZlcnNpb24uXG4gKi8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbihfeCwgX3gyLCBfeDMsIF94NCkge1xuICByZXR1cm4gX3NlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIF9zZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uKCkge1xuICBfc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbiA9IF9hc3luY1RvR2VuZXJhdG9yKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yUnVudGltZSgpLm1hcmsoZnVuY3Rpb24gX2NhbGxlZShjb25uZWN0aW9uLCByYXdUcmFuc2FjdGlvbiwgY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCBtYXliZUNvbmZpcm1PcHRpb25zKSB7XG4gICAgdmFyIGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBvcHRpb25zLCBzZW5kT3B0aW9ucywgc2lnbmF0dXJlLCBjb21taXRtZW50LCBjb25maXJtYXRpb25Qcm9taXNlLCBzdGF0dXM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICB3aGlsZSAoMSkgc3dpdGNoIChfY29udGV4dC5wcmV2ID0gX2NvbnRleHQubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgICAgICAgICAgY29uZmlybWF0aW9uU3RyYXRlZ3kgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucyAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zLCAnbm9uY2VWYWx1ZScpKSB7XG4gICAgICAgICAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBtYXliZUNvbmZpcm1PcHRpb25zO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgICAgICAgICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IG9wdGlvbnMuY29tbWl0bWVudCxcbiAgICAgICAgICAgIG1pbkNvbnRleHRTbG90OiBvcHRpb25zLm1pbkNvbnRleHRTbG90XG4gICAgICAgICAgfTtcbiAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNDtcbiAgICAgICAgICByZXR1cm4gY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNpZ25hdHVyZSA9IF9jb250ZXh0LnNlbnQ7XG4gICAgICAgICAgY29tbWl0bWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50O1xuICAgICAgICAgIGNvbmZpcm1hdGlvblByb21pc2UgPSBjb25maXJtYXRpb25TdHJhdGVneSA/IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKGNvbmZpcm1hdGlvblN0cmF0ZWd5LCBjb21taXRtZW50KSA6IGNvbm5lY3Rpb24uY29uZmlybVRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudCk7XG4gICAgICAgICAgX2NvbnRleHQubmV4dCA9IDk7XG4gICAgICAgICAgcmV0dXJuIGNvbmZpcm1hdGlvblByb21pc2U7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBzdGF0dXMgPSBfY29udGV4dC5zZW50LnZhbHVlO1xuICAgICAgICAgIGlmICghc3RhdHVzLmVycikge1xuICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDEyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJhdyB0cmFuc2FjdGlvbiBcIi5jb25jYXQoc2lnbmF0dXJlLCBcIiBmYWlsZWQgKFwiKS5jb25jYXQoSlNPTi5zdHJpbmdpZnkoc3RhdHVzKSwgXCIpXCIpKTtcbiAgICAgICAgY2FzZSAxMjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUpO1xuICB9KSk7XG4gIHJldHVybiBfc2VuZEFuZENvbmZpcm1SYXdUcmFuc2FjdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG52YXIgTEFNUE9SVFNfUEVSX1NPTCA9IDEwMDAwMDAwMDA7XG5cbmV4cG9ydCB7IEFjY291bnQsIEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQsIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uLCBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtLCBBdXRob3JpemVkLCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUywgQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQsIEJQRl9MT0FERVJfUFJPR1JBTV9JRCwgQnBmTG9hZGVyLCBDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLCBDb21wdXRlQnVkZ2V0SW5zdHJ1Y3Rpb24sIENvbXB1dGVCdWRnZXRQcm9ncmFtLCBDb25uZWN0aW9uLCBFZDI1NTE5UHJvZ3JhbSwgRW51bSwgRXBvY2hTY2hlZHVsZSwgRmVlQ2FsY3VsYXRvckxheW91dCwgS2V5cGFpciwgTEFNUE9SVFNfUEVSX1NPTCwgTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMsIExvYWRlciwgTG9ja3VwLCBNQVhfU0VFRF9MRU5HVEgsIE1lc3NhZ2UsIE1lc3NhZ2VBY2NvdW50S2V5cywgTWVzc2FnZVYwLCBOT05DRV9BQ0NPVU5UX0xFTkdUSCwgTm9uY2VBY2NvdW50LCBQQUNLRVRfREFUQV9TSVpFLCBQVUJMSUNfS0VZX0xFTkdUSCwgUHVibGljS2V5LCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTLCBTT0xBTkFfU0NIRU1BLCBTVEFLRV9DT05GSUdfSUQsIFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLCBTWVNWQVJfQ0xPQ0tfUFVCS0VZLCBTWVNWQVJfRVBPQ0hfU0NIRURVTEVfUFVCS0VZLCBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSwgU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksIFNZU1ZBUl9SRU5UX1BVQktFWSwgU1lTVkFSX1JFV0FSRFNfUFVCS0VZLCBTWVNWQVJfU0xPVF9IQVNIRVNfUFVCS0VZLCBTWVNWQVJfU0xPVF9ISVNUT1JZX1BVQktFWSwgU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZLCBTZWNwMjU2azFQcm9ncmFtLCBTZW5kVHJhbnNhY3Rpb25FcnJvciwgU29sYW5hSlNPTlJQQ0Vycm9yLCBTb2xhbmFKU09OUlBDRXJyb3JDb2RlLCBTdGFrZUF1dGhvcml6YXRpb25MYXlvdXQsIFN0YWtlSW5zdHJ1Y3Rpb24sIFN0YWtlUHJvZ3JhbSwgU3RydWN0LCBTeXN0ZW1JbnN0cnVjdGlvbiwgU3lzdGVtUHJvZ3JhbSwgVHJhbnNhY3Rpb24sIFRyYW5zYWN0aW9uRXhwaXJlZEJsb2NraGVpZ2h0RXhjZWVkZWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3IsIFRyYW5zYWN0aW9uRXhwaXJlZFRpbWVvdXRFcnJvciwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbiwgVHJhbnNhY3Rpb25NZXNzYWdlLCBUcmFuc2FjdGlvblN0YXR1cywgVkFMSURBVE9SX0lORk9fS0VZLCBWRVJTSU9OX1BSRUZJWF9NQVNLLCBWT1RFX1BST0dSQU1fSUQsIFZhbGlkYXRvckluZm8sIFZlcnNpb25lZE1lc3NhZ2UsIFZlcnNpb25lZFRyYW5zYWN0aW9uLCBWb3RlQWNjb3VudCwgVm90ZUF1dGhvcml6YXRpb25MYXlvdXQsIFZvdGVJbml0LCBWb3RlSW5zdHJ1Y3Rpb24sIFZvdGVQcm9ncmFtLCBjbHVzdGVyQXBpVXJsLCBzZW5kQW5kQ29uZmlybVJhd1RyYW5zYWN0aW9uLCBzZW5kQW5kQ29uZmlybVRyYW5zYWN0aW9uIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5icm93c2VyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@solana/web3.js/lib/index.browser.esm.js\n"));

/***/ }),

/***/ "./node_modules/base-x/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/base-x/src/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0ZBQTZCO0FBQzNDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLHFDQUFxQztBQUNyQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzPzRmN2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbi8vIEB0cy1pZ25vcmVcbnZhciBfQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXJcbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSB8fCBzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7IHNvdXJjZSA9IF9CdWZmZXIuZnJvbShzb3VyY2UpIH1cbiAgICBpZiAoIV9CdWZmZXIuaXNCdWZmZXIoc291cmNlKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBCdWZmZXInKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gX0J1ZmZlci5hbGxvYygwKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IF9CdWZmZXIuYWxsb2NVbnNhZmUoemVyb2VzICsgKHNpemUgLSBpdDQpKVxuICAgIHZjaC5maWxsKDB4MDAsIDAsIHplcm9lcylcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/base-x/src/index.js\n"));

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIscUJBQXFCOztBQUVyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUMsU0FBUztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDLFVBQVU7QUFDckQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzPzM3NzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxuLy8gU2VlOiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CYXNlNjQjVVJMX2FwcGxpY2F0aW9uc1xucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gZ2V0TGVucyAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG5cbiAgaWYgKGxlbiAlIDQgPiAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcbiAgfVxuXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxuICAvLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iZWF0Z2FtbWl0L2Jhc2U2NC1qcy9pc3N1ZXMvNDJcbiAgdmFyIHZhbGlkTGVuID0gYjY0LmluZGV4T2YoJz0nKVxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxuXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSB2YWxpZExlbiA9PT0gbGVuXG4gICAgPyAwXG4gICAgOiA0IC0gKHZhbGlkTGVuICUgNClcblxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXG59XG5cbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIF9ieXRlTGVuZ3RoIChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pIHtcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXG4gIHZhciBwbGFjZUhvbGRlcnNMZW4gPSBsZW5zWzFdXG5cbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcblxuICB2YXIgY3VyQnl0ZSA9IDBcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIHZhciBsZW4gPSBwbGFjZUhvbGRlcnNMZW4gPiAwXG4gICAgPyB2YWxpZExlbiAtIDRcbiAgICA6IHZhbGlkTGVuXG5cbiAgdmFyIGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA8PCA2KSB8XG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnNMZW4gPT09IDEpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICByZXR1cm4gYXJyXG59XG5cbmZ1bmN0aW9uIHRyaXBsZXRUb0Jhc2U2NCAobnVtKSB7XG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gK1xuICAgIGxvb2t1cFtudW0gJiAweDNGXVxufVxuXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHRtcFxuICB2YXIgb3V0cHV0ID0gW11cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcbiAgICB0bXAgPVxuICAgICAgKCh1aW50OFtpXSA8PCAxNikgJiAweEZGMDAwMCkgK1xuICAgICAgKCh1aW50OFtpICsgMV0gPDwgOCkgJiAweEZGMDApICtcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgcGFydHMgPSBbXVxuICB2YXIgbWF4Q2h1bmtMZW5ndGggPSAxNjM4MyAvLyBtdXN0IGJlIG11bHRpcGxlIG9mIDNcblxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4yID0gbGVuIC0gZXh0cmFCeXRlczsgaSA8IGxlbjI7IGkgKz0gbWF4Q2h1bmtMZW5ndGgpIHtcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxuICB9XG5cbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xuICAgIHRtcCA9IHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXSArXG4gICAgICAnPT0nXG4gICAgKVxuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxuICAgIHBhcnRzLnB1c2goXG4gICAgICBsb29rdXBbdG1wID4+IDEwXSArXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcbiAgICAgIGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl0gK1xuICAgICAgJz0nXG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "./node_modules/bigint-buffer/dist/browser.js":
/*!****************************************************!*\
  !*** ./node_modules/bigint-buffer/dist/browser.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet converter;\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\nfunction toBigIntLE(buf) {\n    {\n        const reversed = Buffer.from(buf);\n        reversed.reverse();\n        const hex = reversed.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, false);\n}\nexports.toBigIntLE = toBigIntLE;\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\nfunction toBigIntBE(buf) {\n    {\n        const hex = buf.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, true);\n}\nexports.toBigIntBE = toBigIntBE;\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\nfunction toBufferLE(num, width) {\n    {\n        const hex = num.toString(16);\n        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n        buffer.reverse();\n        return buffer;\n    }\n    // Allocation is done here, since it is slower using napi in C\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);\n}\nexports.toBufferLE = toBufferLE;\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\nfunction toBufferBE(num, width) {\n    {\n        const hex = num.toString(16);\n        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n    }\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);\n}\nexports.toBufferBE = toBufferBE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYmlnaW50LWJ1ZmZlci9kaXN0L2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IjtBQUFhOztBQUViLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE1BQU07QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixJQUFJO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxNQUFNO0FBQ3JCO0FBQ0EscUNBQXFDLE1BQU07QUFDM0M7QUFDQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JpZ2ludC1idWZmZXIvZGlzdC9icm93c2VyLmpzP2VhZDMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5sZXQgY29udmVydGVyO1xuLyoqXG4gKiBDb252ZXJ0IGEgbGl0dGxlLWVuZGlhbiBidWZmZXIgaW50byBhIEJpZ0ludC5cbiAqIEBwYXJhbSBidWYgVGhlIGxpdHRsZS1lbmRpYW4gYnVmZmVyIHRvIGNvbnZlcnRcbiAqIEByZXR1cm5zIEEgQmlnSW50IHdpdGggdGhlIGxpdHRsZS1lbmRpYW4gcmVwcmVzZW50YXRpb24gb2YgYnVmLlxuICovXG5mdW5jdGlvbiB0b0JpZ0ludExFKGJ1Zikge1xuICAgIHtcbiAgICAgICAgY29uc3QgcmV2ZXJzZWQgPSBCdWZmZXIuZnJvbShidWYpO1xuICAgICAgICByZXZlcnNlZC5yZXZlcnNlKCk7XG4gICAgICAgIGNvbnN0IGhleCA9IHJldmVyc2VkLnRvU3RyaW5nKCdoZXgnKTtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQoMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ0ludChgMHgke2hleH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlci50b0JpZ0ludChidWYsIGZhbHNlKTtcbn1cbmV4cG9ydHMudG9CaWdJbnRMRSA9IHRvQmlnSW50TEU7XG4vKipcbiAqIENvbnZlcnQgYSBiaWctZW5kaWFuIGJ1ZmZlciBpbnRvIGEgQmlnSW50XG4gKiBAcGFyYW0gYnVmIFRoZSBiaWctZW5kaWFuIGJ1ZmZlciB0byBjb252ZXJ0LlxuICogQHJldHVybnMgQSBCaWdJbnQgd2l0aCB0aGUgYmlnLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiBidWYuXG4gKi9cbmZ1bmN0aW9uIHRvQmlnSW50QkUoYnVmKSB7XG4gICAge1xuICAgICAgICBjb25zdCBoZXggPSBidWYudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KGAweCR7aGV4fWApO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVyLnRvQmlnSW50KGJ1ZiwgdHJ1ZSk7XG59XG5leHBvcnRzLnRvQmlnSW50QkUgPSB0b0JpZ0ludEJFO1xuLyoqXG4gKiBDb252ZXJ0IGEgQmlnSW50IHRvIGEgbGl0dGxlLWVuZGlhbiBidWZmZXIuXG4gKiBAcGFyYW0gbnVtICAgVGhlIEJpZ0ludCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHdpZHRoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBzaG91bGQgYmUuXG4gKiBAcmV0dXJucyBBIGxpdHRsZS1lbmRpYW4gYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIG51bS5cbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXJMRShudW0sIHdpZHRoKSB7XG4gICAge1xuICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShoZXgucGFkU3RhcnQod2lkdGggKiAyLCAnMCcpLnNsaWNlKDAsIHdpZHRoICogMiksICdoZXgnKTtcbiAgICAgICAgYnVmZmVyLnJldmVyc2UoKTtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG4gICAgLy8gQWxsb2NhdGlvbiBpcyBkb25lIGhlcmUsIHNpbmNlIGl0IGlzIHNsb3dlciB1c2luZyBuYXBpIGluIENcbiAgICByZXR1cm4gY29udmVydGVyLmZyb21CaWdJbnQobnVtLCBCdWZmZXIuYWxsb2NVbnNhZmUod2lkdGgpLCBmYWxzZSk7XG59XG5leHBvcnRzLnRvQnVmZmVyTEUgPSB0b0J1ZmZlckxFO1xuLyoqXG4gKiBDb252ZXJ0IGEgQmlnSW50IHRvIGEgYmlnLWVuZGlhbiBidWZmZXIuXG4gKiBAcGFyYW0gbnVtICAgVGhlIEJpZ0ludCB0byBjb252ZXJ0LlxuICogQHBhcmFtIHdpZHRoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdGhhdCB0aGUgcmVzdWx0aW5nIGJ1ZmZlciBzaG91bGQgYmUuXG4gKiBAcmV0dXJucyBBIGJpZy1lbmRpYW4gYnVmZmVyIHJlcHJlc2VudGF0aW9uIG9mIG51bS5cbiAqL1xuZnVuY3Rpb24gdG9CdWZmZXJCRShudW0sIHdpZHRoKSB7XG4gICAge1xuICAgICAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4LnBhZFN0YXJ0KHdpZHRoICogMiwgJzAnKS5zbGljZSgwLCB3aWR0aCAqIDIpLCAnaGV4Jyk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbUJpZ0ludChudW0sIEJ1ZmZlci5hbGxvY1Vuc2FmZSh3aWR0aCksIHRydWUpO1xufVxuZXhwb3J0cy50b0J1ZmZlckJFID0gdG9CdWZmZXJCRTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bigint-buffer/dist/browser.js\n"));

/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"?f4e8\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFD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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxNQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzP2ZkODgiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtudW1iZXIgJiAweDNmZmZmZmZdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgaWYgKGMgPj0gNDggJiYgYyA8PSA1Nykge1xuICAgICAgcmV0dXJuIGMgLSA0ODtcbiAgICAvLyAnQScgLSAnRidcbiAgICB9IGVsc2UgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgY2hhcmFjdGVyIGluICcgKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZSAoc3RyaW5nLCBsb3dlckJvdW5kLCBpbmRleCkge1xuICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggLSAxID49IGxvd2VyQm91bmQpIHtcbiAgICAgIHIgfD0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4IC0gMSkgPDwgNDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyAyNC1iaXRzIGNodW5rc1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKGkgPSBwYXJzZUxlbmd0aCAlIDIgPT09IDAgPyBzdGFydCArIDEgOiBzdGFydDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICBiID0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICBiID0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBjO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGMgPj0gMCAmJiBiIDwgbXVsLCAnSW52YWxpZCBjaGFyYWN0ZXInKTtcbiAgICAgIHIgKz0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbW92ZSAoZGVzdCwgc3JjKSB7XG4gICAgZGVzdC53b3JkcyA9IHNyYy53b3JkcztcbiAgICBkZXN0Lmxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHNyYy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHNyYy5yZWQ7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiBfbW92ZSAoZGVzdCkge1xuICAgIG1vdmUoZGVzdCwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2hlY2sgU3ltYm9sLmZvciBiZWNhdXNlIG5vdCBldmVyeXdoZXJlIHdoZXJlIFN5bWJvbCBkZWZpbmVkXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW1ib2wjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBCTi5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBpbnNwZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH1cblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2Rybihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gIH07XG5cbiAgaWYgKEJ1ZmZlcikge1xuICAgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlIChBcnJheVR5cGUsIHNpemUpIHtcbiAgICBpZiAoQXJyYXlUeXBlLmFsbG9jVW5zYWZlKSB7XG4gICAgICByZXR1cm4gQXJyYXlUeXBlLmFsbG9jVW5zYWZlKHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5VHlwZShzaXplKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB2YXIgcmVzID0gYWxsb2NhdGUoQXJyYXlUeXBlLCByZXFMZW5ndGgpO1xuICAgIHZhciBwb3N0Zml4ID0gZW5kaWFuID09PSAnbGUnID8gJ0xFJyA6ICdCRSc7XG4gICAgdGhpc1snX3RvQXJyYXlMaWtlJyArIHBvc3RmaXhdKHJlcywgYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VMRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlQkUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHJlcy5sZW5ndGggLSAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSA+Pj4gd2JpdCkgJiAweDAxO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIC8vIFRlbXBvcmFyeSBkaXNhYmxlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvaXNzdWVzLzIxMVxuICAgIC8vIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICAvLyByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgICByZXR1cm4gYmlnTXVsVG8oc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5fc3RyaXAoKTtcbiAgICB9XG4gICAgYS5fc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgKHIyID09PSAxICYmIGNtcCA9PT0gMCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24gbW9kcm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gLWFjYyA6IGFjYztcbiAgfTtcblxuICAvLyBXQVJOSU5HOiBERVBSRUNBVEVEXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kcm4obnVtKTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjUgaW5zdGFuY2VcbiAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIG1vdmUoYSwgYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/bn.js/lib/bn.js\n"));

/***/ }),

/***/ "./node_modules/borsh/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/borsh/lib/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"./node_modules/bn.js/lib/bn.js\"));\nconst bs58_1 = __importDefault(__webpack_require__(/*! bs58 */ \"./node_modules/bs58/index.js\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(__webpack_require__(/*! text-encoding-utf-8 */ \"./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", { fatal: true });\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message) {\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor() {\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH),\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array) {\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function (...args) {\n        try {\n            return originalMethod.apply(this, args);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        }\n        catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for (let i = 0; i < len; ++i) {\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        }\n        else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            }\n            else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for (let i = 0; i < fieldType[1]; i++) {\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            }\n            else {\n                writer.writeArray(value, (item) => {\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        }\n        else if (fieldType.kind !== undefined) {\n            switch (fieldType.kind) {\n                case \"option\": {\n                    if (value === null || value === undefined) {\n                        writer.writeU8(0);\n                    }\n                    else {\n                        writer.writeU8(1);\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\n                    }\n                    break;\n                }\n                case \"map\": {\n                    writer.writeU32(value.size);\n                    value.forEach((val, key) => {\n                        serializeField(schema, fieldName, key, fieldType.key, writer);\n                        serializeField(schema, fieldName, val, fieldType.value, writer);\n                    });\n                    break;\n                }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        }\n        else {\n            serializeStruct(schema, value, writer);\n        }\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    }\n    else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    }\n    else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            }\n            else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for (let i = 0; i < fieldType[1]; i++) {\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            }\n            else {\n                return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for (let i = 0; i < length; i++) {\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({ [fieldName]: fieldValue });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQSxvREFBb0QsbUJBQW1CLE1BQU0sMkJBQTJCO0FBQ3hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQywrQkFBK0I7QUFDMUU7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JvcnNoL2xpYi9pbmRleC5qcz82ZmRmIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9fZGVjb3JhdGUgPSAodGhpcyAmJiB0aGlzLl9fZGVjb3JhdGUpIHx8IGZ1bmN0aW9uIChkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0LmRlY29yYXRlID09PSBcImZ1bmN0aW9uXCIpIHIgPSBSZWZsZWN0LmRlY29yYXRlKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKTtcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XG59O1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVzZXJpYWxpemVVbmNoZWNrZWQgPSBleHBvcnRzLmRlc2VyaWFsaXplID0gZXhwb3J0cy5zZXJpYWxpemUgPSBleHBvcnRzLkJpbmFyeVJlYWRlciA9IGV4cG9ydHMuQmluYXJ5V3JpdGVyID0gZXhwb3J0cy5Cb3JzaEVycm9yID0gZXhwb3J0cy5iYXNlRGVjb2RlID0gZXhwb3J0cy5iYXNlRW5jb2RlID0gdm9pZCAwO1xuY29uc3QgYm5fanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm4uanNcIikpO1xuY29uc3QgYnM1OF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiczU4XCIpKTtcbi8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIHBvbHlmaWxsIG5vdCBpbmNsdWRlZCB3aGVuIG5vdCByZXF1aXJlZFxuY29uc3QgZW5jb2RpbmcgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInRleHQtZW5jb2RpbmctdXRmLThcIikpO1xuY29uc3QgUmVzb2x2ZWRUZXh0RGVjb2RlciA9IHR5cGVvZiBUZXh0RGVjb2RlciAhPT0gXCJmdW5jdGlvblwiID8gZW5jb2RpbmcuVGV4dERlY29kZXIgOiBUZXh0RGVjb2RlcjtcbmNvbnN0IHRleHREZWNvZGVyID0gbmV3IFJlc29sdmVkVGV4dERlY29kZXIoXCJ1dGYtOFwiLCB7IGZhdGFsOiB0cnVlIH0pO1xuZnVuY3Rpb24gYmFzZUVuY29kZSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSBCdWZmZXIuZnJvbSh2YWx1ZSwgXCJ1dGY4XCIpO1xuICAgIH1cbiAgICByZXR1cm4gYnM1OF8xLmRlZmF1bHQuZW5jb2RlKEJ1ZmZlci5mcm9tKHZhbHVlKSk7XG59XG5leHBvcnRzLmJhc2VFbmNvZGUgPSBiYXNlRW5jb2RlO1xuZnVuY3Rpb24gYmFzZURlY29kZSh2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShiczU4XzEuZGVmYXVsdC5kZWNvZGUodmFsdWUpKTtcbn1cbmV4cG9ydHMuYmFzZURlY29kZSA9IGJhc2VEZWNvZGU7XG5jb25zdCBJTklUSUFMX0xFTkdUSCA9IDEwMjQ7XG5jbGFzcyBCb3JzaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZmllbGRQYXRoID0gW107XG4gICAgICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG4gICAgYWRkVG9GaWVsZFBhdGgoZmllbGROYW1lKSB7XG4gICAgICAgIHRoaXMuZmllbGRQYXRoLnNwbGljZSgwLCAwLCBmaWVsZE5hbWUpO1xuICAgICAgICAvLyBOT1RFOiBNb2RpZnlpbmcgbWVzc2FnZSBkaXJlY3RseSBhcyBqZXN0IGRvZXNuJ3QgdXNlIC50b1N0cmluZygpXG4gICAgICAgIHRoaXMubWVzc2FnZSA9IHRoaXMub3JpZ2luYWxNZXNzYWdlICsgXCI6IFwiICsgdGhpcy5maWVsZFBhdGguam9pbihcIi5cIik7XG4gICAgfVxufVxuZXhwb3J0cy5Cb3JzaEVycm9yID0gQm9yc2hFcnJvcjtcbi8vLyBCaW5hcnkgZW5jb2Rlci5cbmNsYXNzIEJpbmFyeVdyaXRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmFsbG9jKElOSVRJQUxfTEVOR1RIKTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBtYXliZVJlc2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuYnVmLmxlbmd0aCA8IDE2ICsgdGhpcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWYsIEJ1ZmZlci5hbGxvYyhJTklUSUFMX0xFTkdUSCldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZVU4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50OCh2YWx1ZSwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAxO1xuICAgIH1cbiAgICB3cml0ZVUxNih2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDE2TEUodmFsdWUsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gMjtcbiAgICB9XG4gICAgd3JpdGVVMzIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQzMkxFKHZhbHVlLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDQ7XG4gICAgfVxuICAgIHdyaXRlVTY0KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgOCkpKTtcbiAgICB9XG4gICAgd3JpdGVVMTI4KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgMTYpKSk7XG4gICAgfVxuICAgIHdyaXRlVTI1Nih2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDMyKSkpO1xuICAgIH1cbiAgICB3cml0ZVU1MTIodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCA2NCkpKTtcbiAgICB9XG4gICAgd3JpdGVCdWZmZXIoYnVmZmVyKSB7XG4gICAgICAgIC8vIEJ1ZmZlci5mcm9tIGlzIG5lZWRlZCBhcyB0aGlzLmJ1Zi5zdWJhcnJheSBjYW4gcmV0dXJuIHBsYWluIFVpbnQ4QXJyYXkgaW4gYnJvd3NlclxuICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5jb25jYXQoW1xuICAgICAgICAgICAgQnVmZmVyLmZyb20odGhpcy5idWYuc3ViYXJyYXkoMCwgdGhpcy5sZW5ndGgpKSxcbiAgICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICAgIEJ1ZmZlci5hbGxvYyhJTklUSUFMX0xFTkdUSCksXG4gICAgICAgIF0pO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSBidWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICB3cml0ZVN0cmluZyhzdHIpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICBjb25zdCBiID0gQnVmZmVyLmZyb20oc3RyLCBcInV0ZjhcIik7XG4gICAgICAgIHRoaXMud3JpdGVVMzIoYi5sZW5ndGgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKGIpO1xuICAgIH1cbiAgICB3cml0ZUZpeGVkQXJyYXkoYXJyYXkpIHtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShhcnJheSkpO1xuICAgIH1cbiAgICB3cml0ZUFycmF5KGFycmF5LCBmbikge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVVMzIoYXJyYXkubGVuZ3RoKTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtIG9mIGFycmF5KSB7XG4gICAgICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgICAgICBmbihlbGVtKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0FycmF5KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYuc3ViYXJyYXkoMCwgdGhpcy5sZW5ndGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQmluYXJ5V3JpdGVyID0gQmluYXJ5V3JpdGVyO1xuZnVuY3Rpb24gaGFuZGxpbmdSYW5nZUVycm9yKHRhcmdldCwgcHJvcGVydHlLZXksIHByb3BlcnR5RGVzY3JpcHRvcikge1xuICAgIGNvbnN0IG9yaWdpbmFsTWV0aG9kID0gcHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlO1xuICAgIHByb3BlcnR5RGVzY3JpcHRvci52YWx1ZSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxNZXRob2QuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvZGUgPSBlLmNvZGU7XG4gICAgICAgICAgICAgICAgaWYgKFtcIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EU1wiLCBcIkVSUl9PVVRfT0ZfUkFOR0VcIl0uaW5kZXhPZihjb2RlKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKFwiUmVhY2hlZCB0aGUgZW5kIG9mIGJ1ZmZlciB3aGVuIGRlc2VyaWFsaXppbmdcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5jbGFzcyBCaW5hcnlSZWFkZXIge1xuICAgIGNvbnN0cnVjdG9yKGJ1Zikge1xuICAgICAgICB0aGlzLmJ1ZiA9IGJ1ZjtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgIH1cbiAgICByZWFkVTgoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5idWYucmVhZFVJbnQ4KHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTE2KCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmLnJlYWRVSW50MTZMRSh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFUzMigpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1Zi5yZWFkVUludDMyTEUodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSA0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJlYWRVNjQoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMucmVhZEJ1ZmZlcig4KTtcbiAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYnVmLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkVTEyOCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDE2KTtcbiAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYnVmLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkVTI1NigpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDMyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYnVmLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkVTUxMigpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDY0KTtcbiAgICAgICAgcmV0dXJuIG5ldyBibl9qc18xLmRlZmF1bHQoYnVmLCBcImxlXCIpO1xuICAgIH1cbiAgICByZWFkQnVmZmVyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5vZmZzZXQgKyBsZW4gPiB0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFeHBlY3RlZCBidWZmZXIgbGVuZ3RoICR7bGVufSBpc24ndCB3aXRoaW4gYm91bmRzYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5idWYuc2xpY2UodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gbGVuO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZWFkU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLnJlYWRVMzIoKTtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKGxlbik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBOT1RFOiBVc2luZyBUZXh0RGVjb2RlciB0byBmYWlsIG9uIGludmFsaWQgVVRGLThcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RGVjb2Rlci5kZWNvZGUoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEVycm9yIGRlY29kaW5nIFVURi04IHN0cmluZzogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlYWRGaXhlZEFycmF5KGxlbikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5yZWFkQnVmZmVyKGxlbikpO1xuICAgIH1cbiAgICByZWFkQXJyYXkoZm4pIHtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5yZWFkVTMyKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEFycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZuKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVOFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTE2XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMzJcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFU2NFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTEyOFwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTI1NlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTUxMlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkU3RyaW5nXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRGaXhlZEFycmF5XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRBcnJheVwiLCBudWxsKTtcbmV4cG9ydHMuQmluYXJ5UmVhZGVyID0gQmluYXJ5UmVhZGVyO1xuZnVuY3Rpb24gY2FwaXRhbGl6ZUZpcnN0TGV0dGVyKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHJpbmcuc2xpY2UoMSk7XG59XG5mdW5jdGlvbiBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgdmFsdWUsIGZpZWxkVHlwZSwgd3JpdGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gVE9ETzogSGFuZGxlIG1pc3NpbmcgdmFsdWVzIHByb3Blcmx5IChtYWtlIHN1cmUgdGhleSBuZXZlciByZXN1bHQgaW4ganVzdCBza2lwcGVkIHdyaXRlKVxuICAgICAgICBpZiAodHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgd3JpdGVyW2B3cml0ZSR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGZpZWxkVHlwZSl9YF0odmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkVHlwZSBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpZWxkVHlwZVswXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IGZpZWxkVHlwZVswXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXhwZWN0aW5nIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoICR7ZmllbGRUeXBlWzBdfSwgYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlRml4ZWRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZFR5cGUubGVuZ3RoID09PSAyICYmIHR5cGVvZiBmaWVsZFR5cGVbMV0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoICE9PSBmaWVsZFR5cGVbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEV4cGVjdGluZyBieXRlIGFycmF5IG9mIGxlbmd0aCAke2ZpZWxkVHlwZVsxXX0sIGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRUeXBlWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBudWxsLCB2YWx1ZVtpXSwgZmllbGRUeXBlWzBdLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZUFycmF5KHZhbHVlLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgaXRlbSwgZmllbGRUeXBlWzBdLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGZpZWxkVHlwZS5raW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZmllbGRUeXBlLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwib3B0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdyaXRlci53cml0ZVU4KDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVTgoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgdmFsdWUsIGZpZWxkVHlwZS50eXBlLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwibWFwXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVTMyKHZhbHVlLnNpemUpO1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2YWwsIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGtleSwgZmllbGRUeXBlLmtleSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCB2YWwsIGZpZWxkVHlwZS52YWx1ZSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRmllbGRUeXBlICR7ZmllbGRUeXBlfSB1bnJlY29nbml6ZWRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIHZhbHVlLCB3cml0ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCb3JzaEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5hZGRUb0ZpZWxkUGF0aChmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIG9iaiwgd3JpdGVyKSB7XG4gICAgaWYgKHR5cGVvZiBvYmouYm9yc2hTZXJpYWxpemUgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBvYmouYm9yc2hTZXJpYWxpemUod3JpdGVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzdHJ1Y3RTY2hlbWEgPSBzY2hlbWEuZ2V0KG9iai5jb25zdHJ1Y3Rvcik7XG4gICAgaWYgKCFzdHJ1Y3RTY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYENsYXNzICR7b2JqLmNvbnN0cnVjdG9yLm5hbWV9IGlzIG1pc3NpbmcgaW4gc2NoZW1hYCk7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3RTY2hlbWEua2luZCA9PT0gXCJzdHJ1Y3RcIikge1xuICAgICAgICBzdHJ1Y3RTY2hlbWEuZmllbGRzLm1hcCgoW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSkgPT4ge1xuICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIG9ialtmaWVsZE5hbWVdLCBmaWVsZFR5cGUsIHdyaXRlcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHJ1Y3RTY2hlbWEua2luZCA9PT0gXCJlbnVtXCIpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9ialtzdHJ1Y3RTY2hlbWEuZmllbGRdO1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzdHJ1Y3RTY2hlbWEudmFsdWVzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0gPSBzdHJ1Y3RTY2hlbWEudmFsdWVzW2lkeF07XG4gICAgICAgICAgICBpZiAoZmllbGROYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVTgoaWR4KTtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgb2JqW2ZpZWxkTmFtZV0sIGZpZWxkVHlwZSwgd3JpdGVyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYFVuZXhwZWN0ZWQgc2NoZW1hIGtpbmQ6ICR7c3RydWN0U2NoZW1hLmtpbmR9IGZvciAke29iai5jb25zdHJ1Y3Rvci5uYW1lfWApO1xuICAgIH1cbn1cbi8vLyBTZXJpYWxpemUgZ2l2ZW4gb2JqZWN0IHVzaW5nIHNjaGVtYSBvZiB0aGUgZm9ybTpcbi8vLyB7IGNsYXNzX25hbWUgLT4gWyBbZmllbGRfbmFtZSwgZmllbGRfdHlwZV0sIC4uIF0sIC4uIH1cbmZ1bmN0aW9uIHNlcmlhbGl6ZShzY2hlbWEsIG9iaiwgV3JpdGVyID0gQmluYXJ5V3JpdGVyKSB7XG4gICAgY29uc3Qgd3JpdGVyID0gbmV3IFdyaXRlcigpO1xuICAgIHNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIG9iaiwgd3JpdGVyKTtcbiAgICByZXR1cm4gd3JpdGVyLnRvQXJyYXkoKTtcbn1cbmV4cG9ydHMuc2VyaWFsaXplID0gc2VyaWFsaXplO1xuZnVuY3Rpb24gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLCByZWFkZXIpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGZpZWxkVHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIHJlYWRlcltgcmVhZCR7Y2FwaXRhbGl6ZUZpcnN0TGV0dGVyKGZpZWxkVHlwZSl9YF0oKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRUeXBlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkRml4ZWRBcnJheShmaWVsZFR5cGVbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZpZWxkVHlwZVsxXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmllbGRUeXBlWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJyLnB1c2goZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIG51bGwsIGZpZWxkVHlwZVswXSwgcmVhZGVyKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRBcnJheSgoKSA9PiBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGVbMF0sIHJlYWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUua2luZCA9PT0gXCJvcHRpb25cIikge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gcmVhZGVyLnJlYWRVOCgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUudHlwZSwgcmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVHlwZS5raW5kID09PSBcIm1hcFwiKSB7XG4gICAgICAgICAgICBsZXQgbWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcmVhZGVyLnJlYWRVMzIoKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUua2V5LCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZS52YWx1ZSwgcmVhZGVyKTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGtleSwgdmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgZmllbGRUeXBlLCByZWFkZXIpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQm9yc2hFcnJvcikge1xuICAgICAgICAgICAgZXJyb3IuYWRkVG9GaWVsZFBhdGgoZmllbGROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVN0cnVjdChzY2hlbWEsIGNsYXNzVHlwZSwgcmVhZGVyKSB7XG4gICAgaWYgKHR5cGVvZiBjbGFzc1R5cGUuYm9yc2hEZXNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBjbGFzc1R5cGUuYm9yc2hEZXNlcmlhbGl6ZShyZWFkZXIpO1xuICAgIH1cbiAgICBjb25zdCBzdHJ1Y3RTY2hlbWEgPSBzY2hlbWEuZ2V0KGNsYXNzVHlwZSk7XG4gICAgaWYgKCFzdHJ1Y3RTY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYENsYXNzICR7Y2xhc3NUeXBlLm5hbWV9IGlzIG1pc3NpbmcgaW4gc2NoZW1hYCk7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3RTY2hlbWEua2luZCA9PT0gXCJzdHJ1Y3RcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBbZmllbGROYW1lLCBmaWVsZFR5cGVdIG9mIHNjaGVtYS5nZXQoY2xhc3NUeXBlKS5maWVsZHMpIHtcbiAgICAgICAgICAgIHJlc3VsdFtmaWVsZE5hbWVdID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLCByZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3NUeXBlKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmIChzdHJ1Y3RTY2hlbWEua2luZCA9PT0gXCJlbnVtXCIpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gcmVhZGVyLnJlYWRVOCgpO1xuICAgICAgICBpZiAoaWR4ID49IHN0cnVjdFNjaGVtYS52YWx1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRW51bSBpbmRleDogJHtpZHh9IGlzIG91dCBvZiByYW5nZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0gPSBzdHJ1Y3RTY2hlbWEudmFsdWVzW2lkeF07XG4gICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUsIHJlYWRlcik7XG4gICAgICAgIHJldHVybiBuZXcgY2xhc3NUeXBlKHsgW2ZpZWxkTmFtZV06IGZpZWxkVmFsdWUgfSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBVbmV4cGVjdGVkIHNjaGVtYSBraW5kOiAke3N0cnVjdFNjaGVtYS5raW5kfSBmb3IgJHtjbGFzc1R5cGUuY29uc3RydWN0b3IubmFtZX1gKTtcbn1cbi8vLyBEZXNlcmlhbGl6ZXMgb2JqZWN0IGZyb20gYnl0ZXMgdXNpbmcgc2NoZW1hLlxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2NoZW1hLCBjbGFzc1R5cGUsIGJ1ZmZlciwgUmVhZGVyID0gQmluYXJ5UmVhZGVyKSB7XG4gICAgY29uc3QgcmVhZGVyID0gbmV3IFJlYWRlcihidWZmZXIpO1xuICAgIGNvbnN0IHJlc3VsdCA9IGRlc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgY2xhc3NUeXBlLCByZWFkZXIpO1xuICAgIGlmIChyZWFkZXIub2Zmc2V0IDwgYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgVW5leHBlY3RlZCAke2J1ZmZlci5sZW5ndGggLSByZWFkZXIub2Zmc2V0fSBieXRlcyBhZnRlciBkZXNlcmlhbGl6ZWQgZGF0YWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZSA9IGRlc2VyaWFsaXplO1xuLy8vIERlc2VyaWFsaXplcyBvYmplY3QgZnJvbSBieXRlcyB1c2luZyBzY2hlbWEsIHdpdGhvdXQgY2hlY2tpbmcgdGhlIGxlbmd0aCByZWFkXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVVuY2hlY2tlZChzY2hlbWEsIGNsYXNzVHlwZSwgYnVmZmVyLCBSZWFkZXIgPSBCaW5hcnlSZWFkZXIpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgY2xhc3NUeXBlLCByZWFkZXIpO1xufVxuZXhwb3J0cy5kZXNlcmlhbGl6ZVVuY2hlY2tlZCA9IGRlc2VyaWFsaXplVW5jaGVja2VkO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/borsh/lib/index.js\n"));

/***/ }),

/***/ "./node_modules/bs58/index.js":
/*!************************************!*\
  !*** ./node_modules/bs58/index.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var basex = __webpack_require__(/*! base-x */ \"./node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsa0RBQVE7QUFDNUI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/NWFmNSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bs58/index.js\n"));

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVZOztBQUVaLGVBQWUsbUJBQU8sQ0FBQyxvREFBVztBQUNsQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnREFBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLHlCQUF5Qjs7QUFFekI7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFD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Q047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanM/OTAxZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QixXQUFXLGlCQUFpQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBELE9BQU87QUFDakU7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGdCQUFnQixZQUFZO0FBQzVCOztBQUVBO0FBQ0EsNERBQTREO0FBQzVELGdFQUFnRTtBQUNoRSxvRUFBb0U7QUFDcEUsd0VBQXdFO0FBQ3hFO0FBQ0EsMkRBQTJELFNBQVM7QUFDcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDREQUE0RCxZQUFZO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxjQUFjO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUksSUFBNkI7QUFDakM7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvZXZlbnRlbWl0dGVyMy9pbmRleC5qcz80YzNmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCBwcmVmaXggPSAnfic7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgdG8gY3JlYXRlIGEgc3RvcmFnZSBmb3Igb3VyIGBFRWAgb2JqZWN0cy5cbiAqIEFuIGBFdmVudHNgIGluc3RhbmNlIGlzIGEgcGxhaW4gb2JqZWN0IHdob3NlIHByb3BlcnRpZXMgYXJlIGV2ZW50IG5hbWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRXZlbnRzKCkge31cblxuLy9cbi8vIFdlIHRyeSB0byBub3QgaW5oZXJpdCBmcm9tIGBPYmplY3QucHJvdG90eXBlYC4gSW4gc29tZSBlbmdpbmVzIGNyZWF0aW5nIGFuXG4vLyBpbnN0YW5jZSBpbiB0aGlzIHdheSBpcyBmYXN0ZXIgdGhhbiBjYWxsaW5nIGBPYmplY3QuY3JlYXRlKG51bGwpYCBkaXJlY3RseS5cbi8vIElmIGBPYmplY3QuY3JlYXRlKG51bGwpYCBpcyBub3Qgc3VwcG9ydGVkIHdlIHByZWZpeCB0aGUgZXZlbnQgbmFtZXMgd2l0aCBhXG4vLyBjaGFyYWN0ZXIgdG8gbWFrZSBzdXJlIHRoYXQgdGhlIGJ1aWx0LWluIG9iamVjdCBwcm9wZXJ0aWVzIGFyZSBub3Rcbi8vIG92ZXJyaWRkZW4gb3IgdXNlZCBhcyBhbiBhdHRhY2sgdmVjdG9yLlxuLy9cbmlmIChPYmplY3QuY3JlYXRlKSB7XG4gIEV2ZW50cy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gIC8vXG4gIC8vIFRoaXMgaGFjayBpcyBuZWVkZWQgYmVjYXVzZSB0aGUgYF9fcHJvdG9fX2AgcHJvcGVydHkgaXMgc3RpbGwgaW5oZXJpdGVkIGluXG4gIC8vIHNvbWUgb2xkIGJyb3dzZXJzIGxpa2UgQW5kcm9pZCA0LCBpUGhvbmUgNS4xLCBPcGVyYSAxMSBhbmQgU2FmYXJpIDUuXG4gIC8vXG4gIGlmICghbmV3IEV2ZW50cygpLl9fcHJvdG9fXykgcHJlZml4ID0gZmFsc2U7XG59XG5cbi8qKlxuICogUmVwcmVzZW50YXRpb24gb2YgYSBzaW5nbGUgZXZlbnQgbGlzdGVuZXIuXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29uY2U9ZmFsc2VdIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEVFKGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHRoaXMuZm4gPSBmbjtcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5vbmNlID0gb25jZSB8fCBmYWxzZTtcbn1cblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVyKGVtaXR0ZXIsIGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIGxpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVyID0gbmV3IEVFKGZuLCBjb250ZXh0IHx8IGVtaXR0ZXIsIG9uY2UpXG4gICAgLCBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0pIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gbGlzdGVuZXIsIGVtaXR0ZXIuX2V2ZW50c0NvdW50Kys7XG4gIGVsc2UgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XS5mbikgZW1pdHRlci5fZXZlbnRzW2V2dF0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2UgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBbZW1pdHRlci5fZXZlbnRzW2V2dF0sIGxpc3RlbmVyXTtcblxuICByZXR1cm4gZW1pdHRlcjtcbn1cblxuLyoqXG4gKiBDbGVhciBldmVudCBieSBuYW1lLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZ0IFRoZSBFdmVudCBuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJFdmVudChlbWl0dGVyLCBldnQpIHtcbiAgaWYgKC0tZW1pdHRlci5fZXZlbnRzQ291bnQgPT09IDApIGVtaXR0ZXIuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgZWxzZSBkZWxldGUgZW1pdHRlci5fZXZlbnRzW2V2dF07XG59XG5cbi8qKlxuICogTWluaW1hbCBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UgdGhhdCBpcyBtb2xkZWQgYWdhaW5zdCB0aGUgTm9kZS5qc1xuICogYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xufVxuXG4vKipcbiAqIFJldHVybiBhbiBhcnJheSBsaXN0aW5nIHRoZSBldmVudHMgZm9yIHdoaWNoIHRoZSBlbWl0dGVyIGhhcyByZWdpc3RlcmVkXG4gKiBsaXN0ZW5lcnMuXG4gKlxuICogQHJldHVybnMge0FycmF5fVxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICB2YXIgbmFtZXMgPSBbXVxuICAgICwgZXZlbnRzXG4gICAgLCBuYW1lO1xuXG4gIGlmICh0aGlzLl9ldmVudHNDb3VudCA9PT0gMCkgcmV0dXJuIG5hbWVzO1xuXG4gIGZvciAobmFtZSBpbiAoZXZlbnRzID0gdGhpcy5fZXZlbnRzKSkge1xuICAgIGlmIChoYXMuY2FsbChldmVudHMsIG5hbWUpKSBuYW1lcy5wdXNoKHByZWZpeCA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lKTtcbiAgfVxuXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgcmV0dXJuIG5hbWVzLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGV2ZW50cykpO1xuICB9XG5cbiAgcmV0dXJuIG5hbWVzO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtBcnJheX0gVGhlIHJlZ2lzdGVyZWQgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgaGFuZGxlcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWhhbmRsZXJzKSByZXR1cm4gW107XG4gIGlmIChoYW5kbGVycy5mbikgcmV0dXJuIFtoYW5kbGVycy5mbl07XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGgsIGVlID0gbmV3IEFycmF5KGwpOyBpIDwgbDsgaSsrKSB7XG4gICAgZWVbaV0gPSBoYW5kbGVyc1tpXS5mbjtcbiAgfVxuXG4gIHJldHVybiBlZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbGlzdGVuZXJzIGxpc3RlbmluZyB0byBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1iZXIgb2YgbGlzdGVuZXJzLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiBsaXN0ZW5lckNvdW50KGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAoIWxpc3RlbmVycykgcmV0dXJuIDA7XG4gIGlmIChsaXN0ZW5lcnMuZm4pIHJldHVybiAxO1xuICByZXR1cm4gbGlzdGVuZXJzLmxlbmd0aDtcbn07XG5cbi8qKlxuICogQ2FsbHMgZWFjaCBvZiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgZXZlbnQgaGFkIGxpc3RlbmVycywgZWxzZSBgZmFsc2VgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KGV2ZW50LCBhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XVxuICAgICwgbGVuID0gYXJndW1lbnRzLmxlbmd0aFxuICAgICwgYXJnc1xuICAgICwgaTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKGxpc3RlbmVycy5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnMuZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgY2FzZSAxOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQpLCB0cnVlO1xuICAgICAgY2FzZSAyOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExKSwgdHJ1ZTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIpLCB0cnVlO1xuICAgICAgY2FzZSA0OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMpLCB0cnVlO1xuICAgICAgY2FzZSA1OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgNjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCwgYTUpLCB0cnVlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG5cbiAgICBsaXN0ZW5lcnMuZm4uYXBwbHkobGlzdGVuZXJzLmNvbnRleHQsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoXG4gICAgICAsIGo7XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbaV0ub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzW2ldLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgICBzd2l0Y2ggKGxlbikge1xuICAgICAgICBjYXNlIDE6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0KTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMjogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgMzogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMik7IGJyZWFrO1xuICAgICAgICBjYXNlIDQ6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIsIGEzKTsgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFhcmdzKSBmb3IgKGogPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGogPCBsZW47IGorKykge1xuICAgICAgICAgICAgYXJnc1tqIC0gMV0gPSBhcmd1bWVudHNbal07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgbGlzdGVuZXJzW2ldLmZuLmFwcGx5KGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhcmdzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBmdW5jdGlvbiBvbihldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgZmFsc2UpO1xufTtcblxuLyoqXG4gKiBBZGQgYSBvbmUtdGltZSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZShldmVudCwgZm4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIGFkZExpc3RlbmVyKHRoaXMsIGV2ZW50LCBmbiwgY29udGV4dCwgdHJ1ZSk7XG59O1xuXG4vKipcbiAqIFJlbW92ZSB0aGUgbGlzdGVuZXJzIG9mIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IG1hdGNoIHRoaXMgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgT25seSByZW1vdmUgdGhlIGxpc3RlbmVycyB0aGF0IGhhdmUgdGhpcyBjb250ZXh0LlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIE9ubHkgcmVtb3ZlIG9uZS10aW1lIGxpc3RlbmVycy5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKGV2ZW50LCBmbiwgY29udGV4dCwgb25jZSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gdGhpcztcbiAgaWYgKCFmbikge1xuICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbZXZ0XTtcblxuICBpZiAobGlzdGVuZXJzLmZuKSB7XG4gICAgaWYgKFxuICAgICAgbGlzdGVuZXJzLmZuID09PSBmbiAmJlxuICAgICAgKCFvbmNlIHx8IGxpc3RlbmVycy5vbmNlKSAmJlxuICAgICAgKCFjb250ZXh0IHx8IGxpc3RlbmVycy5jb250ZXh0ID09PSBjb250ZXh0KVxuICAgICkge1xuICAgICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMCwgZXZlbnRzID0gW10sIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKFxuICAgICAgICBsaXN0ZW5lcnNbaV0uZm4gIT09IGZuIHx8XG4gICAgICAgIChvbmNlICYmICFsaXN0ZW5lcnNbaV0ub25jZSkgfHxcbiAgICAgICAgKGNvbnRleHQgJiYgbGlzdGVuZXJzW2ldLmNvbnRleHQgIT09IGNvbnRleHQpXG4gICAgICApIHtcbiAgICAgICAgZXZlbnRzLnB1c2gobGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIFJlc2V0IHRoZSBhcnJheSwgb3IgcmVtb3ZlIGl0IGNvbXBsZXRlbHkgaWYgd2UgaGF2ZSBubyBtb3JlIGxpc3RlbmVycy5cbiAgICAvL1xuICAgIGlmIChldmVudHMubGVuZ3RoKSB0aGlzLl9ldmVudHNbZXZ0XSA9IGV2ZW50cy5sZW5ndGggPT09IDEgPyBldmVudHNbMF0gOiBldmVudHM7XG4gICAgZWxzZSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFsbCBsaXN0ZW5lcnMsIG9yIHRob3NlIG9mIHRoZSBzcGVjaWZpZWQgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IFtldmVudF0gVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQ7XG5cbiAgaWYgKGV2ZW50KSB7XG4gICAgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcbiAgICBpZiAodGhpcy5fZXZlbnRzW2V2dF0pIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vL1xuLy8gQWxpYXMgbWV0aG9kcyBuYW1lcyBiZWNhdXNlIHBlb3BsZSByb2xsIGxpa2UgdGhhdC5cbi8vXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgcHJlZml4LlxuLy9cbkV2ZW50RW1pdHRlci5wcmVmaXhlZCA9IHByZWZpeDtcblxuLy9cbi8vIEFsbG93IGBFdmVudEVtaXR0ZXJgIHRvIGJlIGltcG9ydGVkIGFzIG1vZHVsZSBuYW1lc3BhY2UuXG4vL1xuRXZlbnRFbWl0dGVyLkV2ZW50RW1pdHRlciA9IEV2ZW50RW1pdHRlcjtcblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmlmICgndW5kZWZpbmVkJyAhPT0gdHlwZW9mIG1vZHVsZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxTQUFTLFVBQVU7O0FBRW5CO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanM/ZWJjMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "./node_modules/jayson/lib/client/browser/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/jayson/lib/client/browser/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst uuid = (__webpack_require__(/*! uuid */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/index.js\").v4);\nconst generateRequest = __webpack_require__(/*! ../../generateRequest */ \"./node_modules/jayson/lib/generateRequest.js\");\n\n/**\n * Constructor for a Jayson Browser Client that does not depend any node.js core libraries\n * @class ClientBrowser\n * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback\n * @param {Object} [options]\n * @param {Function} [options.reviver] Reviver function for JSON\n * @param {Function} [options.replacer] Replacer function for JSON\n * @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n * @param {Function} [options.generator] Function to use for generating request IDs\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n * @return {ClientBrowser}\n */\nconst ClientBrowser = function(callServer, options) {\n  if(!(this instanceof ClientBrowser)) {\n    return new ClientBrowser(callServer, options);\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  this.options = {\n    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,\n    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,\n    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },\n    version: typeof options.version !== 'undefined' ? options.version : 2,\n    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,\n  };\n\n  this.callServer = callServer;\n};\n\nmodule.exports = ClientBrowser;\n\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} [params] Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\nClientBrowser.prototype.request = function(method, params, id, callback) {\n  const self = this;\n  let request = null;\n\n  // is this a batch request?\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  }\n\n  // is this a raw request?\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if(isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if(typeof id === 'function') {\n      callback = id;\n      // specifically undefined because \"null\" is a notification request\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = generateRequest(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull,\n      });\n    } catch(err) {\n      if(hasCallback) {\n        return callback(err);\n      }\n      throw err;\n    }\n\n    // no callback means we should just return a raw request\n    if(!hasCallback) {\n      return request;\n    }\n\n  }\n\n  let message;\n  try {\n    message = JSON.stringify(request, this.options.replacer);\n  } catch(err) {\n    return callback(err);\n  }\n\n  this.callServer(message, function(err, response) {\n    self._parseResponse(err, response, callback);\n  });\n\n  // always return the raw request\n  return request;\n};\n\n/**\n * Parses a response from a server\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {String} responseText JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\nClientBrowser.prototype._parseResponse = function(err, responseText, callback) {\n  if(err) {\n    callback(err);\n    return;\n  }\n\n  if(!responseText) {\n    // empty response text, assume that is correct because it could be a\n    // notification which jayson does not give any body for\n    return callback();\n  }\n\n  let response;\n  try {\n    response = JSON.parse(responseText, this.options.reviver);\n  } catch(err) {\n    return callback(err);\n  }\n\n  if(callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n\n    // is batch response?\n    if(Array.isArray(response)) {\n\n      // neccesary to split strictly on validity according to spec here\n      const isError = function(res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    \n    } else {\n\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    \n    }\n  \n  }\n\n  callback(null, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL2xpYi9jbGllbnQvYnJvd3Nlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLHlHQUFrQjtBQUMvQix3QkFBd0IsbUJBQU8sQ0FBQywyRUFBdUI7O0FBRXZEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVksU0FBUztBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkZBQTJGLGdCQUFnQjtBQUMzRztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxVQUFVO0FBQ3RCLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2NsaWVudC9icm93c2VyL2luZGV4LmpzP2UxYzAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB1dWlkID0gcmVxdWlyZSgndXVpZCcpLnY0O1xuY29uc3QgZ2VuZXJhdGVSZXF1ZXN0ID0gcmVxdWlyZSgnLi4vLi4vZ2VuZXJhdGVSZXF1ZXN0Jyk7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgZm9yIGEgSmF5c29uIEJyb3dzZXIgQ2xpZW50IHRoYXQgZG9lcyBub3QgZGVwZW5kIGFueSBub2RlLmpzIGNvcmUgbGlicmFyaWVzXG4gKiBAY2xhc3MgQ2xpZW50QnJvd3NlclxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbFNlcnZlciBNZXRob2QgdGhhdCBjYWxscyB0aGUgc2VydmVyLCByZWNlaXZlcyB0aGUgc3RyaW5naWZpZWQgcmVxdWVzdCBhbmQgYSByZWd1bGFyIG5vZGUtc3R5bGUgY2FsbGJhY2tcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnJldml2ZXJdIFJldml2ZXIgZnVuY3Rpb24gZm9yIEpTT05cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLnJlcGxhY2VyXSBSZXBsYWNlciBmdW5jdGlvbiBmb3IgSlNPTlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZlcnNpb249Ml0gSlNPTi1SUEMgdmVyc2lvbiB0byB1c2UgKDF8MilcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRvcl0gRnVuY3Rpb24gdG8gdXNlIGZvciBnZW5lcmF0aW5nIHJlcXVlc3QgSURzXG4gKiAgQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGw9ZmFsc2VdIFdoZW4gdHJ1ZSwgdmVyc2lvbiAyIHJlcXVlc3RzIHdpbGwgc2V0IGlkIHRvIG51bGwgaW5zdGVhZCBvZiBvbWl0dGluZyBpdFxuICogQHJldHVybiB7Q2xpZW50QnJvd3Nlcn1cbiAqL1xuY29uc3QgQ2xpZW50QnJvd3NlciA9IGZ1bmN0aW9uKGNhbGxTZXJ2ZXIsIG9wdGlvbnMpIHtcbiAgaWYoISh0aGlzIGluc3RhbmNlb2YgQ2xpZW50QnJvd3NlcikpIHtcbiAgICByZXR1cm4gbmV3IENsaWVudEJyb3dzZXIoY2FsbFNlcnZlciwgb3B0aW9ucyk7XG4gIH1cblxuICBpZiAoIW9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0ge307XG4gIH1cblxuICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgcmV2aXZlcjogdHlwZW9mIG9wdGlvbnMucmV2aXZlciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJldml2ZXIgOiBudWxsLFxuICAgIHJlcGxhY2VyOiB0eXBlb2Ygb3B0aW9ucy5yZXBsYWNlciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnJlcGxhY2VyIDogbnVsbCxcbiAgICBnZW5lcmF0b3I6IHR5cGVvZiBvcHRpb25zLmdlbmVyYXRvciAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmdlbmVyYXRvciA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdXVpZCgpOyB9LFxuICAgIHZlcnNpb246IHR5cGVvZiBvcHRpb25zLnZlcnNpb24gIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy52ZXJzaW9uIDogMixcbiAgICBub3RpZmljYXRpb25JZE51bGw6IHR5cGVvZiBvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbCA9PT0gJ2Jvb2xlYW4nID8gb3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGwgOiBmYWxzZSxcbiAgfTtcblxuICB0aGlzLmNhbGxTZXJ2ZXIgPSBjYWxsU2VydmVyO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRCcm93c2VyO1xuXG4vKipcbiAqICBDcmVhdGVzIGEgcmVxdWVzdCBhbmQgZGlzcGF0Y2hlcyBpdCBpZiBnaXZlbiBhIGNhbGxiYWNrLlxuICogIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgQSBiYXRjaCByZXF1ZXN0IGlmIHBhc3NlZCBhbiBBcnJheSwgb3IgYSBtZXRob2QgbmFtZSBpZiBwYXNzZWQgYSBTdHJpbmdcbiAqICBAcGFyYW0ge0FycmF5fE9iamVjdH0gW3BhcmFtc10gUGFyYW1ldGVycyBmb3IgdGhlIG1ldGhvZFxuICogIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gW2lkXSBPcHRpb25hbCBpZC4gSWYgdW5kZWZpbmVkIGFuIGlkIHdpbGwgYmUgZ2VuZXJhdGVkLiBJZiBudWxsIGl0IGNyZWF0ZXMgYSBub3RpZmljYXRpb24gcmVxdWVzdFxuICogIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gUmVxdWVzdCBjYWxsYmFjay4gSWYgc3BlY2lmaWVkLCBleGVjdXRlcyB0aGUgcmVxdWVzdCByYXRoZXIgdGhhbiBvbmx5IHJldHVybmluZyBpdC5cbiAqICBAdGhyb3dzIHtUeXBlRXJyb3J9IEludmFsaWQgcGFyYW1ldGVyc1xuICogIEByZXR1cm4ge09iamVjdH0gSlNPTi1SUEMgMS4wIG9yIDIuMCBjb21wYXRpYmxlIHJlcXVlc3RcbiAqL1xuQ2xpZW50QnJvd3Nlci5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGFyYW1zLCBpZCwgY2FsbGJhY2spIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIGxldCByZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBpcyB0aGlzIGEgYmF0Y2ggcmVxdWVzdD9cbiAgY29uc3QgaXNCYXRjaCA9IEFycmF5LmlzQXJyYXkobWV0aG9kKSAmJiB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmICh0aGlzLm9wdGlvbnMudmVyc2lvbiA9PT0gMSAmJiBpc0JhdGNoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignSlNPTi1SUEMgMS4wIGRvZXMgbm90IHN1cHBvcnQgYmF0Y2hpbmcnKTtcbiAgfVxuXG4gIC8vIGlzIHRoaXMgYSByYXcgcmVxdWVzdD9cbiAgY29uc3QgaXNSYXcgPSAhaXNCYXRjaCAmJiBtZXRob2QgJiYgdHlwZW9mIG1ldGhvZCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJztcblxuICBpZihpc0JhdGNoIHx8IGlzUmF3KSB7XG4gICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgcmVxdWVzdCA9IG1ldGhvZDtcbiAgfSBlbHNlIHtcbiAgICBpZih0eXBlb2YgaWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gaWQ7XG4gICAgICAvLyBzcGVjaWZpY2FsbHkgdW5kZWZpbmVkIGJlY2F1c2UgXCJudWxsXCIgaXMgYSBub3RpZmljYXRpb24gcmVxdWVzdFxuICAgICAgaWQgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgaGFzQ2FsbGJhY2sgPSB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbic7XG5cbiAgICB0cnkge1xuICAgICAgcmVxdWVzdCA9IGdlbmVyYXRlUmVxdWVzdChtZXRob2QsIHBhcmFtcywgaWQsIHtcbiAgICAgICAgZ2VuZXJhdG9yOiB0aGlzLm9wdGlvbnMuZ2VuZXJhdG9yLFxuICAgICAgICB2ZXJzaW9uOiB0aGlzLm9wdGlvbnMudmVyc2lvbixcbiAgICAgICAgbm90aWZpY2F0aW9uSWROdWxsOiB0aGlzLm9wdGlvbnMubm90aWZpY2F0aW9uSWROdWxsLFxuICAgICAgfSk7XG4gICAgfSBjYXRjaChlcnIpIHtcbiAgICAgIGlmKGhhc0NhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cblxuICAgIC8vIG5vIGNhbGxiYWNrIG1lYW5zIHdlIHNob3VsZCBqdXN0IHJldHVybiBhIHJhdyByZXF1ZXN0XG4gICAgaWYoIWhhc0NhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcmVxdWVzdDtcbiAgICB9XG5cbiAgfVxuXG4gIGxldCBtZXNzYWdlO1xuICB0cnkge1xuICAgIG1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShyZXF1ZXN0LCB0aGlzLm9wdGlvbnMucmVwbGFjZXIpO1xuICB9IGNhdGNoKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgdGhpcy5jYWxsU2VydmVyKG1lc3NhZ2UsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcbiAgICBzZWxmLl9wYXJzZVJlc3BvbnNlKGVyciwgcmVzcG9uc2UsIGNhbGxiYWNrKTtcbiAgfSk7XG5cbiAgLy8gYWx3YXlzIHJldHVybiB0aGUgcmF3IHJlcXVlc3RcbiAgcmV0dXJuIHJlcXVlc3Q7XG59O1xuXG4vKipcbiAqIFBhcnNlcyBhIHJlc3BvbnNlIGZyb20gYSBzZXJ2ZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgRXJyb3IgdG8gcGFzcyBvbiB0aGF0IGlzIHVucmVsYXRlZCB0byB0aGUgYWN0dWFsIHJlc3BvbnNlXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVzcG9uc2VUZXh0IEpTT04tUlBDIDEuMCBvciAyLjAgcmVzcG9uc2VcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIHRoYXQgd2lsbCByZWNlaXZlIGRpZmZlcmVudCBhcmd1bWVudHMgZGVwZW5kaW5nIG9uIHRoZSBhbW91bnQgb2YgcGFyYW1ldGVyc1xuICogQHByaXZhdGVcbiAqL1xuQ2xpZW50QnJvd3Nlci5wcm90b3R5cGUuX3BhcnNlUmVzcG9uc2UgPSBmdW5jdGlvbihlcnIsIHJlc3BvbnNlVGV4dCwgY2FsbGJhY2spIHtcbiAgaWYoZXJyKSB7XG4gICAgY2FsbGJhY2soZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZighcmVzcG9uc2VUZXh0KSB7XG4gICAgLy8gZW1wdHkgcmVzcG9uc2UgdGV4dCwgYXNzdW1lIHRoYXQgaXMgY29ycmVjdCBiZWNhdXNlIGl0IGNvdWxkIGJlIGFcbiAgICAvLyBub3RpZmljYXRpb24gd2hpY2ggamF5c29uIGRvZXMgbm90IGdpdmUgYW55IGJvZHkgZm9yXG4gICAgcmV0dXJuIGNhbGxiYWNrKCk7XG4gIH1cblxuICBsZXQgcmVzcG9uc2U7XG4gIHRyeSB7XG4gICAgcmVzcG9uc2UgPSBKU09OLnBhcnNlKHJlc3BvbnNlVGV4dCwgdGhpcy5vcHRpb25zLnJldml2ZXIpO1xuICB9IGNhdGNoKGVycikge1xuICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICB9XG5cbiAgaWYoY2FsbGJhY2subGVuZ3RoID09PSAzKSB7XG4gICAgLy8gaWYgY2FsbGJhY2sgbGVuZ3RoIGlzIDMsIHdlIHNwbGl0IGNhbGxiYWNrIGFyZ3VtZW50cyBvbiBlcnJvciBhbmQgcmVzcG9uc2VcblxuICAgIC8vIGlzIGJhdGNoIHJlc3BvbnNlP1xuICAgIGlmKEFycmF5LmlzQXJyYXkocmVzcG9uc2UpKSB7XG5cbiAgICAgIC8vIG5lY2Nlc2FyeSB0byBzcGxpdCBzdHJpY3RseSBvbiB2YWxpZGl0eSBhY2NvcmRpbmcgdG8gc3BlYyBoZXJlXG4gICAgICBjb25zdCBpc0Vycm9yID0gZnVuY3Rpb24ocmVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgcmVzLmVycm9yICE9PSAndW5kZWZpbmVkJztcbiAgICAgIH07XG5cbiAgICAgIGNvbnN0IGlzTm90RXJyb3IgPSBmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIHJldHVybiAhaXNFcnJvcihyZXMpO1xuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlLmZpbHRlcihpc0Vycm9yKSwgcmVzcG9uc2UuZmlsdGVyKGlzTm90RXJyb3IpKTtcbiAgICBcbiAgICB9IGVsc2Uge1xuXG4gICAgICAvLyBzcGxpdCByZWdhcmRsZXNzIG9mIHZhbGlkaXR5XG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UuZXJyb3IsIHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgXG4gICAgfVxuICBcbiAgfVxuXG4gIGNhbGxiYWNrKG51bGwsIHJlc3BvbnNlKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jayson/lib/client/browser/index.js\n"));

/***/ }),

/***/ "./node_modules/jayson/lib/generateRequest.js":
/*!****************************************************!*\
  !*** ./node_modules/jayson/lib/generateRequest.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst uuid = (__webpack_require__(/*! uuid */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/index.js\").v4);\n\n/**\n *  Generates a JSON-RPC 1.0 or 2.0 request\n *  @param {String} method Name of method to call\n *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value\n *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation\n *  @param {Object} [options]\n *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID\n *  @throws {TypeError} If any of the parameters are invalid\n *  @return {Object} A JSON-RPC 1.0 or 2.0 request\n *  @memberOf Utils\n */\nconst generateRequest = function(method, params, id, options) {\n  if(typeof method !== 'string') {\n    throw new TypeError(method + ' must be a string');\n  }\n\n  options = options || {};\n\n  // check valid version provided\n  const version = typeof options.version === 'number' ? options.version : 2;\n  if (version !== 1 && version !== 2) {\n    throw new TypeError(version + ' must be 1 or 2');\n  }\n\n  const request = {\n    method: method\n  };\n\n  if(version === 2) {\n    request.jsonrpc = '2.0';\n  }\n\n  if(params) {\n    // params given, but invalid?\n    if(typeof params !== 'object' && !Array.isArray(params)) {\n      throw new TypeError(params + ' must be an object, array or omitted');\n    }\n    request.params = params;\n  }\n\n  // if id was left out, generate one (null means explicit notification)\n  if(typeof(id) === 'undefined') {\n    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };\n    request.id = generator(request, options);\n  } else if (version === 2 && id === null) {\n    // we have a version 2 notification\n    if (options.notificationIdNull) {\n      request.id = null; // id will not be set at all unless option provided\n    }\n  } else {\n    request.id = id;\n  }\n\n  return request;\n};\n\nmodule.exports = generateRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL2xpYi9nZW5lcmF0ZVJlcXVlc3QuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsYUFBYSx5R0FBa0I7O0FBRS9CO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxjQUFjO0FBQzFCLFlBQVksb0JBQW9CO0FBQ2hDLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxTQUFTO0FBQ3JCLFlBQVksVUFBVTtBQUN0QixhQUFhLFdBQVc7QUFDeEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlHQUFpRztBQUNqRztBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvamF5c29uL2xpYi9nZW5lcmF0ZVJlcXVlc3QuanM/NmU0MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5cbi8qKlxuICogIEdlbmVyYXRlcyBhIEpTT04tUlBDIDEuMCBvciAyLjAgcmVxdWVzdFxuICogIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgTmFtZSBvZiBtZXRob2QgdG8gY2FsbFxuICogIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBwYXJhbXMgQXJyYXkgb2YgcGFyYW1ldGVycyBwYXNzZWQgdG8gdGhlIG1ldGhvZCBhcyBzcGVjaWZpZWQsIG9yIGFuIG9iamVjdCBvZiBwYXJhbWV0ZXIgbmFtZXMgYW5kIGNvcnJlc3BvbmRpbmcgdmFsdWVcbiAqICBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ8bnVsbH0gW2lkXSBSZXF1ZXN0IElEIGNhbiBiZSBhIHN0cmluZywgbnVtYmVyLCBudWxsIGZvciBleHBsaWNpdCBub3RpZmljYXRpb24gb3IgbGVmdCBvdXQgZm9yIGF1dG9tYXRpYyBnZW5lcmF0aW9uXG4gKiAgQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy52ZXJzaW9uPTJdIEpTT04tUlBDIHZlcnNpb24gdG8gdXNlICgxIG9yIDIpXG4gKiAgQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGw9ZmFsc2VdIFdoZW4gdHJ1ZSwgdmVyc2lvbiAyIHJlcXVlc3RzIHdpbGwgc2V0IGlkIHRvIG51bGwgaW5zdGVhZCBvZiBvbWl0dGluZyBpdFxuICogIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRvcl0gUGFzc2VkIHRoZSByZXF1ZXN0LCBhbmQgdGhlIG9wdGlvbnMgb2JqZWN0IGFuZCBpcyBleHBlY3RlZCB0byByZXR1cm4gYSByZXF1ZXN0IElEXG4gKiAgQHRocm93cyB7VHlwZUVycm9yfSBJZiBhbnkgb2YgdGhlIHBhcmFtZXRlcnMgYXJlIGludmFsaWRcbiAqICBAcmV0dXJuIHtPYmplY3R9IEEgSlNPTi1SUEMgMS4wIG9yIDIuMCByZXF1ZXN0XG4gKiAgQG1lbWJlck9mIFV0aWxzXG4gKi9cbmNvbnN0IGdlbmVyYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGFyYW1zLCBpZCwgb3B0aW9ucykge1xuICBpZih0eXBlb2YgbWV0aG9kICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWV0aG9kICsgJyBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBjaGVjayB2YWxpZCB2ZXJzaW9uIHByb3ZpZGVkXG4gIGNvbnN0IHZlcnNpb24gPSB0eXBlb2Ygb3B0aW9ucy52ZXJzaW9uID09PSAnbnVtYmVyJyA/IG9wdGlvbnMudmVyc2lvbiA6IDI7XG4gIGlmICh2ZXJzaW9uICE9PSAxICYmIHZlcnNpb24gIT09IDIpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHZlcnNpb24gKyAnIG11c3QgYmUgMSBvciAyJyk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0ID0ge1xuICAgIG1ldGhvZDogbWV0aG9kXG4gIH07XG5cbiAgaWYodmVyc2lvbiA9PT0gMikge1xuICAgIHJlcXVlc3QuanNvbnJwYyA9ICcyLjAnO1xuICB9XG5cbiAgaWYocGFyYW1zKSB7XG4gICAgLy8gcGFyYW1zIGdpdmVuLCBidXQgaW52YWxpZD9cbiAgICBpZih0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHBhcmFtcyArICcgbXVzdCBiZSBhbiBvYmplY3QsIGFycmF5IG9yIG9taXR0ZWQnKTtcbiAgICB9XG4gICAgcmVxdWVzdC5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cblxuICAvLyBpZiBpZCB3YXMgbGVmdCBvdXQsIGdlbmVyYXRlIG9uZSAobnVsbCBtZWFucyBleHBsaWNpdCBub3RpZmljYXRpb24pXG4gIGlmKHR5cGVvZihpZCkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gdHlwZW9mIG9wdGlvbnMuZ2VuZXJhdG9yID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy5nZW5lcmF0b3IgOiBmdW5jdGlvbigpIHsgcmV0dXJuIHV1aWQoKTsgfTtcbiAgICByZXF1ZXN0LmlkID0gZ2VuZXJhdG9yKHJlcXVlc3QsIG9wdGlvbnMpO1xuICB9IGVsc2UgaWYgKHZlcnNpb24gPT09IDIgJiYgaWQgPT09IG51bGwpIHtcbiAgICAvLyB3ZSBoYXZlIGEgdmVyc2lvbiAyIG5vdGlmaWNhdGlvblxuICAgIGlmIChvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbCkge1xuICAgICAgcmVxdWVzdC5pZCA9IG51bGw7IC8vIGlkIHdpbGwgbm90IGJlIHNldCBhdCBhbGwgdW5sZXNzIG9wdGlvbiBwcm92aWRlZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXF1ZXN0LmlkID0gaWQ7XG4gIH1cblxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZ2VuZXJhdGVSZXF1ZXN0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/lib/generateRequest.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: function() { return /* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   parse: function() { return /* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; },\n/* harmony export */   stringify: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   v1: function() { return /* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   v3: function() { return /* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   v4: function() { return /* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   v5: function() { return /* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   validate: function() { return /* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   version: function() { return /* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2luZGV4LmpzPzk2NDYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHsgZGVmYXVsdCBhcyB2MSB9IGZyb20gJy4vdjEuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2MyB9IGZyb20gJy4vdjMuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NCB9IGZyb20gJy4vdjQuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2NSB9IGZyb20gJy4vdjUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBOSUwgfSBmcm9tICcuL25pbC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZlcnNpb24gfSBmcm9tICcuL3ZlcnNpb24uanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2YWxpZGF0ZSB9IGZyb20gJy4vdmFsaWRhdGUuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBzdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHBhcnNlIH0gZnJvbSAnLi9wYXJzZS5qcyc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/index.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/md5.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/md5.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtEQUFlLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL21kNS5qcz83ZDdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBCcm93c2VyLWNvbXBhdGlibGUgSmF2YVNjcmlwdCBNRDVcbiAqXG4gKiBNb2RpZmljYXRpb24gb2YgSmF2YVNjcmlwdCBNRDVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9ibHVlaW1wL0phdmFTY3JpcHQtTUQ1XG4gKlxuICogQ29weXJpZ2h0IDIwMTEsIFNlYmFzdGlhbiBUc2NoYW5cbiAqIGh0dHBzOi8vYmx1ZWltcC5uZXRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2U6XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVFxuICpcbiAqIEJhc2VkIG9uXG4gKiBBIEphdmFTY3JpcHQgaW1wbGVtZW50YXRpb24gb2YgdGhlIFJTQSBEYXRhIFNlY3VyaXR5LCBJbmMuIE1ENSBNZXNzYWdlXG4gKiBEaWdlc3QgQWxnb3JpdGhtLCBhcyBkZWZpbmVkIGluIFJGQyAxMzIxLlxuICogVmVyc2lvbiAyLjIgQ29weXJpZ2h0IChDKSBQYXVsIEpvaG5zdG9uIDE5OTkgLSAyMDA5XG4gKiBPdGhlciBjb250cmlidXRvcnM6IEdyZWcgSG9sdCwgQW5kcmV3IEtlcGVydCwgWWRuYXIsIExvc3RpbmV0XG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgQlNEIExpY2Vuc2VcbiAqIFNlZSBodHRwOi8vcGFqaG9tZS5vcmcudWsvY3J5cHQvbWQ1IGZvciBtb3JlIGluZm8uXG4gKi9cbmZ1bmN0aW9uIG1kNShieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobXNnLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXNbaV0gPSBtc2cuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWQ1VG9IZXhFbmNvZGVkQXJyYXkod29yZHNUb01kNShieXRlc1RvV29yZHMoYnl0ZXMpLCBieXRlcy5sZW5ndGggKiA4KSk7XG59XG4vKlxuICogQ29udmVydCBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzIHRvIGFuIGFycmF5IG9mIGJ5dGVzXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVUb0hleEVuY29kZWRBcnJheShpbnB1dCkge1xuICB2YXIgb3V0cHV0ID0gW107XG4gIHZhciBsZW5ndGgzMiA9IGlucHV0Lmxlbmd0aCAqIDMyO1xuICB2YXIgaGV4VGFiID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMzI7IGkgKz0gOCkge1xuICAgIHZhciB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICB2YXIgaGV4ID0gcGFyc2VJbnQoaGV4VGFiLmNoYXJBdCh4ID4+PiA0ICYgMHgwZikgKyBoZXhUYWIuY2hhckF0KHggJiAweDBmKSwgMTYpO1xuICAgIG91dHB1dC5wdXNoKGhleCk7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgb3V0cHV0IGxlbmd0aCB3aXRoIHBhZGRpbmcgYW5kIGJpdCBsZW5ndGhcbiAqL1xuXG5cbmZ1bmN0aW9uIGdldE91dHB1dExlbmd0aChpbnB1dExlbmd0aDgpIHtcbiAgcmV0dXJuIChpbnB1dExlbmd0aDggKyA2NCA+Pj4gOSA8PCA0KSArIDE0ICsgMTtcbn1cbi8qXG4gKiBDYWxjdWxhdGUgdGhlIE1ENSBvZiBhbiBhcnJheSBvZiBsaXR0bGUtZW5kaWFuIHdvcmRzLCBhbmQgYSBiaXQgbGVuZ3RoLlxuICovXG5cblxuZnVuY3Rpb24gd29yZHNUb01kNSh4LCBsZW4pIHtcbiAgLyogYXBwZW5kIHBhZGRpbmcgKi9cbiAgeFtsZW4gPj4gNV0gfD0gMHg4MCA8PCBsZW4gJSAzMjtcbiAgeFtnZXRPdXRwdXRMZW5ndGgobGVuKSAtIDFdID0gbGVuO1xuICB2YXIgYSA9IDE3MzI1ODQxOTM7XG4gIHZhciBiID0gLTI3MTczMzg3OTtcbiAgdmFyIGMgPSAtMTczMjU4NDE5NDtcbiAgdmFyIGQgPSAyNzE3MzM4Nzg7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB4Lmxlbmd0aDsgaSArPSAxNikge1xuICAgIHZhciBvbGRhID0gYTtcbiAgICB2YXIgb2xkYiA9IGI7XG4gICAgdmFyIG9sZGMgPSBjO1xuICAgIHZhciBvbGRkID0gZDtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpXSwgNywgLTY4MDg3NjkzNik7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDFdLCAxMiwgLTM4OTU2NDU4Nik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDJdLCAxNywgNjA2MTA1ODE5KTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgM10sIDIyLCAtMTA0NDUyNTMzMCk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA3LCAtMTc2NDE4ODk3KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgNV0sIDEyLCAxMjAwMDgwNDI2KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE3LCAtMTQ3MzIzMTM0MSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDddLCAyMiwgLTQ1NzA1OTgzKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgOF0sIDcsIDE3NzAwMzU0MTYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyA5XSwgMTIsIC0xOTU4NDE0NDE3KTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNywgLTQyMDYzKTtcbiAgICBiID0gbWQ1ZmYoYiwgYywgZCwgYSwgeFtpICsgMTFdLCAyMiwgLTE5OTA0MDQxNjIpO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDcsIDE4MDQ2MDM2ODIpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxM10sIDEyLCAtNDAzNDExMDEpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE3LCAtMTUwMjAwMjI5MCk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDE1XSwgMjIsIDEyMzY1MzUzMjkpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNSwgLTE2NTc5NjUxMCk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDZdLCA5LCAtMTA2OTUwMTYzMik7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTQsIDY0MzcxNzcxMyk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaV0sIDIwLCAtMzczODk3MzAyKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgNV0sIDUsIC03MDE1NTg2OTEpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxMF0sIDksIDM4MDE2MDgzKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNCwgLTY2MDQ3ODMzNSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDRdLCAyMCwgLTQwNTUzNzg0OCk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDldLCA1LCA1Njg0NDY0MzgpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAxNF0sIDksIC0xMDE5ODAzNjkwKTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgM10sIDE0LCAtMTg3MzYzOTYxKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgOF0sIDIwLCAxMTYzNTMxNTAxKTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMTNdLCA1LCAtMTQ0NDY4MTQ2Nyk7XG4gICAgZCA9IG1kNWdnKGQsIGEsIGIsIGMsIHhbaSArIDJdLCA5LCAtNTE0MDM3ODQpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTQsIDE3MzUzMjg0NzMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyAxMl0sIDIwLCAtMTkyNjYwNzczNCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA0LCAtMzc4NTU4KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgOF0sIDExLCAtMjAyMjU3NDQ2Myk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDExXSwgMTYsIDE4MzkwMzA1NjIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxNF0sIDIzLCAtMzUzMDk1NTYpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxXSwgNCwgLTE1MzA5OTIwNjApO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyA0XSwgMTEsIDEyNzI4OTMzNTMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyA3XSwgMTYsIC0xNTU0OTc2MzIpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyAxMF0sIDIzLCAtMTA5NDczMDY0MCk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNCwgNjgxMjc5MTc0KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpXSwgMTEsIC0zNTg1MzcyMjIpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAzXSwgMTYsIC03MjI1MjE5NzkpO1xuICAgIGIgPSBtZDVoaChiLCBjLCBkLCBhLCB4W2kgKyA2XSwgMjMsIDc2MDI5MTg5KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgOV0sIDQsIC02NDAzNjQ0ODcpO1xuICAgIGQgPSBtZDVoaChkLCBhLCBiLCBjLCB4W2kgKyAxMl0sIDExLCAtNDIxODE1ODM1KTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgMTVdLCAxNiwgNTMwNzQyNTIwKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMl0sIDIzLCAtOTk1MzM4NjUxKTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpXSwgNiwgLTE5ODYzMDg0NCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDddLCAxMCwgMTEyNjg5MTQxNSk7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDE0XSwgMTUsIC0xNDE2MzU0OTA1KTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgNV0sIDIxLCAtNTc0MzQwNTUpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyAxMl0sIDYsIDE3MDA0ODU1NzEpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAzXSwgMTAsIC0xODk0OTg2NjA2KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMTBdLCAxNSwgLTEwNTE1MjMpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyAxXSwgMjEsIC0yMDU0OTIyNzk5KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgOF0sIDYsIDE4NzMzMTMzNTkpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyAxNV0sIDEwLCAtMzA2MTE3NDQpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyA2XSwgMTUsIC0xNTYwMTk4MzgwKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMTNdLCAyMSwgMTMwOTE1MTY0OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDRdLCA2LCAtMTQ1NTIzMDcwKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTFdLCAxMCwgLTExMjAyMTAzNzkpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTUsIDcxODc4NzI1OSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDldLCAyMSwgLTM0MzQ4NTU1MSk7XG4gICAgYSA9IHNhZmVBZGQoYSwgb2xkYSk7XG4gICAgYiA9IHNhZmVBZGQoYiwgb2xkYik7XG4gICAgYyA9IHNhZmVBZGQoYywgb2xkYyk7XG4gICAgZCA9IHNhZmVBZGQoZCwgb2xkZCk7XG4gIH1cblxuICByZXR1cm4gW2EsIGIsIGMsIGRdO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgYnl0ZXMgdG8gYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3Jkc1xuICogQ2hhcmFjdGVycyA+MjU1IGhhdmUgdGhlaXIgaGlnaC1ieXRlIHNpbGVudGx5IGlnbm9yZWQuXG4gKi9cblxuXG5mdW5jdGlvbiBieXRlc1RvV29yZHMoaW5wdXQpIHtcbiAgaWYgKGlucHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIHZhciBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgdmFyIG91dHB1dCA9IG5ldyBVaW50MzJBcnJheShnZXRPdXRwdXRMZW5ndGgobGVuZ3RoOCkpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoODsgaSArPSA4KSB7XG4gICAgb3V0cHV0W2kgPj4gNV0gfD0gKGlucHV0W2kgLyA4XSAmIDB4ZmYpIDw8IGkgJSAzMjtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKlxuICogQWRkIGludGVnZXJzLCB3cmFwcGluZyBhdCAyXjMyLiBUaGlzIHVzZXMgMTYtYml0IG9wZXJhdGlvbnMgaW50ZXJuYWxseVxuICogdG8gd29yayBhcm91bmQgYnVncyBpbiBzb21lIEpTIGludGVycHJldGVycy5cbiAqL1xuXG5cbmZ1bmN0aW9uIHNhZmVBZGQoeCwgeSkge1xuICB2YXIgbHN3ID0gKHggJiAweGZmZmYpICsgKHkgJiAweGZmZmYpO1xuICB2YXIgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/md5.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/nil.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/nil.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL25pbC5qcz9jYTRhIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0ICcwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDAnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/nil.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/parse.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/parse.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3BhcnNlLmpzPzhlNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiBwYXJzZSh1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgdmFyIHY7XG4gIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxNik7IC8vIFBhcnNlICMjIyMjIyMjLS4uLi4tLi4uLi0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFyclswXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgwLCA4KSwgMTYpKSA+Pj4gMjQ7XG4gIGFyclsxXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzJdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclszXSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0jIyMjLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbNF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoOSwgMTMpLCAxNikpID4+PiA4O1xuICBhcnJbNV0gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0jIyMjLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzZdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE0LCAxOCksIDE2KSkgPj4+IDg7XG4gIGFycls3XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tIyMjIy0uLi4uLi4uLi4uLi5cblxuICBhcnJbOF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMTksIDIzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzldID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tLi4uLi0uLi4uLSMjIyMjIyMjIyMjI1xuICAvLyAoVXNlIFwiL1wiIHRvIGF2b2lkIDMyLWJpdCB0cnVuY2F0aW9uIHdoZW4gYml0LXNoaWZ0aW5nIGhpZ2gtb3JkZXIgYnl0ZXMpXG5cbiAgYXJyWzEwXSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgyNCwgMzYpLCAxNikpIC8gMHgxMDAwMDAwMDAwMCAmIDB4ZmY7XG4gIGFyclsxMV0gPSB2IC8gMHgxMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTJdID0gdiA+Pj4gMjQgJiAweGZmO1xuICBhcnJbMTNdID0gdiA+Pj4gMTYgJiAweGZmO1xuICBhcnJbMTRdID0gdiA+Pj4gOCAmIDB4ZmY7XG4gIGFyclsxNV0gPSB2ICYgMHhmZjtcbiAgcmV0dXJuIGFycjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGFyc2U7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/parse.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/regex.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/regex.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzPzVmNWIiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMS01XVswLTlhLWZdezN9LVs4OWFiXVswLTlhLWZdezN9LVswLTlhLWZdezEyfXwwMDAwMDAwMC0wMDAwLTAwMDAtMDAwMC0wMDAwMDAwMDAwMDApJC9pOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/rng.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/rng.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rng; }\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcz9kZTc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxudmFyIGdldFJhbmRvbVZhbHVlcztcbnZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJuZygpIHtcbiAgLy8gbGF6eSBsb2FkIHNvIHRoYXQgZW52aXJvbm1lbnRzIHRoYXQgbmVlZCB0byBwb2x5ZmlsbCBoYXZlIGEgY2hhbmNlIHRvIGRvIHNvXG4gIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgLy8gZ2V0UmFuZG9tVmFsdWVzIG5lZWRzIHRvIGJlIGludm9rZWQgaW4gYSBjb250ZXh0IHdoZXJlIFwidGhpc1wiIGlzIGEgQ3J5cHRvIGltcGxlbWVudGF0aW9uLiBBbHNvLFxuICAgIC8vIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byAobXNDcnlwdG8pIG9uIElFMTEuXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSB8fCB0eXBlb2YgbXNDcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBtc0NyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pO1xuXG4gICAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpIG5vdCBzdXBwb3J0ZWQuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQjZ2V0cmFuZG9tdmFsdWVzLW5vdC1zdXBwb3J0ZWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/sha1.js":
/*!************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/sha1.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zaGExLmpzPzU4NGQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQWRhcHRlZCBmcm9tIENocmlzIFZlbmVzcycgU0hBMSBjb2RlIGF0XG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL3NoYTEuaHRtbFxuZnVuY3Rpb24gZihzLCB4LCB5LCB6KSB7XG4gIHN3aXRjaCAocykge1xuICAgIGNhc2UgMDpcbiAgICAgIHJldHVybiB4ICYgeSBeIH54ICYgejtcblxuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG5cbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4geCAmIHkgXiB4ICYgeiBeIHkgJiB6O1xuXG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcbiAgfVxufVxuXG5mdW5jdGlvbiBST1RMKHgsIG4pIHtcbiAgcmV0dXJuIHggPDwgbiB8IHggPj4+IDMyIC0gbjtcbn1cblxuZnVuY3Rpb24gc2hhMShieXRlcykge1xuICB2YXIgSyA9IFsweDVhODI3OTk5LCAweDZlZDllYmExLCAweDhmMWJiY2RjLCAweGNhNjJjMWQ2XTtcbiAgdmFyIEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzLnB1c2gobXNnLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShieXRlcykpIHtcbiAgICAvLyBDb252ZXJ0IEFycmF5LWxpa2UgdG8gQXJyYXlcbiAgICBieXRlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGJ5dGVzKTtcbiAgfVxuXG4gIGJ5dGVzLnB1c2goMHg4MCk7XG4gIHZhciBsID0gYnl0ZXMubGVuZ3RoIC8gNCArIDI7XG4gIHZhciBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIHZhciBNID0gbmV3IEFycmF5KE4pO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBOOyArK19pKSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50MzJBcnJheSgxNik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIGFycltqXSA9IGJ5dGVzW19pICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAxXSA8PCAxNiB8IGJ5dGVzW19pICogNjQgKyBqICogNCArIDJdIDw8IDggfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW19pXSA9IGFycjtcbiAgfVxuXG4gIE1bTiAtIDFdWzE0XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggLyBNYXRoLnBvdygyLCAzMik7XG4gIE1bTiAtIDFdWzE0XSA9IE1hdGguZmxvb3IoTVtOIC0gMV1bMTRdKTtcbiAgTVtOIC0gMV1bMTVdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAmIDB4ZmZmZmZmZmY7XG5cbiAgZm9yICh2YXIgX2kyID0gMDsgX2kyIDwgTjsgKytfaTIpIHtcbiAgICB2YXIgVyA9IG5ldyBVaW50MzJBcnJheSg4MCk7XG5cbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IDE2OyArK3QpIHtcbiAgICAgIFdbdF0gPSBNW19pMl1bdF07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgX3QgPSAxNjsgX3QgPCA4MDsgKytfdCkge1xuICAgICAgV1tfdF0gPSBST1RMKFdbX3QgLSAzXSBeIFdbX3QgLSA4XSBeIFdbX3QgLSAxNF0gXiBXW190IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICB2YXIgYSA9IEhbMF07XG4gICAgdmFyIGIgPSBIWzFdO1xuICAgIHZhciBjID0gSFsyXTtcbiAgICB2YXIgZCA9IEhbM107XG4gICAgdmFyIGUgPSBIWzRdO1xuXG4gICAgZm9yICh2YXIgX3QyID0gMDsgX3QyIDwgODA7ICsrX3QyKSB7XG4gICAgICB2YXIgcyA9IE1hdGguZmxvb3IoX3QyIC8gMjApO1xuICAgICAgdmFyIFQgPSBST1RMKGEsIDUpICsgZihzLCBiLCBjLCBkKSArIGUgKyBLW3NdICsgV1tfdDJdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/sha1.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7O0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwZ0JBQTBnQjtBQUMxZ0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9zdHJpbmdpZnkuanM/Y2RjNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG4vKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cblxudmFyIGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyKSB7XG4gIHZhciBvZmZzZXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDA7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICB2YXIgdXVpZCA9IChieXRlVG9IZXhbYXJyW29mZnNldCArIDBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDNdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA1XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDZdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgN11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA4XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDldXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTBdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTNdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMTVdXSkudG9Mb3dlckNhc2UoKTsgLy8gQ29uc2lzdGVuY3kgY2hlY2sgZm9yIHZhbGlkIFVVSUQuICBJZiB0aGlzIHRocm93cywgaXQncyBsaWtlbHkgZHVlIHRvIG9uZVxuICAvLyBvZiB0aGUgZm9sbG93aW5nOlxuICAvLyAtIE9uZSBvciBtb3JlIGlucHV0IGFycmF5IHZhbHVlcyBkb24ndCBtYXAgdG8gYSBoZXggb2N0ZXQgKGxlYWRpbmcgdG9cbiAgLy8gXCJ1bmRlZmluZWRcIiBpbiB0aGUgdXVpZClcbiAgLy8gLSBJbnZhbGlkIGlucHV0IHZhbHVlcyBmb3IgdGhlIFJGQyBgdmVyc2lvbmAgb3IgYHZhcmlhbnRgIGZpZWxkc1xuXG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ1N0cmluZ2lmaWVkIFVVSUQgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgcmV0dXJuIHV1aWQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ2lmeTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/v1.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/v1.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ1ksQ0FBQztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTs7O0FBR2Y7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCwrQ0FBRzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSx3RUFBd0U7QUFDeEU7O0FBRUEsNEVBQTRFOztBQUU1RSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsb0NBQW9DOztBQUVwQyw4QkFBOEI7O0FBRTlCLGtDQUFrQzs7QUFFbEMsNEJBQTRCOztBQUU1QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBLGdCQUFnQix5REFBUztBQUN6Qjs7QUFFQSwrREFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MS5qcz82OWNiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7IC8vICoqYHYxKClgIC0gR2VuZXJhdGUgdGltZS1iYXNlZCBVVUlEKipcbi8vXG4vLyBJbnNwaXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vTGlvc0svVVVJRC5qc1xuLy8gYW5kIGh0dHA6Ly9kb2NzLnB5dGhvbi5vcmcvbGlicmFyeS91dWlkLmh0bWxcblxudmFyIF9ub2RlSWQ7XG5cbnZhciBfY2xvY2tzZXE7IC8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxuXG5cbnZhciBfbGFzdE1TZWNzID0gMDtcbnZhciBfbGFzdE5TZWNzID0gMDsgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZCBmb3IgQVBJIGRldGFpbHNcblxuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTtcblxuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbc2VlZEJ5dGVzWzBdIHwgMHgwMSwgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1dO1xuICAgIH1cblxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfSAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cblxuXG4gIHZhciBtc2VjcyA9IG9wdGlvbnMubXNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubXNlY3MgOiBEYXRlLm5vdygpOyAvLyBQZXIgNC4yLjEuMiwgdXNlIGNvdW50IG9mIHV1aWQncyBnZW5lcmF0ZWQgZHVyaW5nIHRoZSBjdXJyZW50IGNsb2NrXG4gIC8vIGN5Y2xlIHRvIHNpbXVsYXRlIGhpZ2hlciByZXNvbHV0aW9uIGNsb2NrXG5cbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxOyAvLyBUaW1lIHNpbmNlIGxhc3QgdXVpZCBjcmVhdGlvbiAoaW4gbXNlY3MpXG5cbiAgdmFyIGR0ID0gbXNlY3MgLSBfbGFzdE1TZWNzICsgKG5zZWNzIC0gX2xhc3ROU2VjcykgLyAxMDAwMDsgLy8gUGVyIDQuMi4xLjIsIEJ1bXAgY2xvY2tzZXEgb24gY2xvY2sgcmVncmVzc2lvblxuXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH0gLy8gUmVzZXQgbnNlY3MgaWYgY2xvY2sgcmVncmVzc2VzIChuZXcgY2xvY2tzZXEpIG9yIHdlJ3ZlIG1vdmVkIG9udG8gYSBuZXdcbiAgLy8gdGltZSBpbnRlcnZhbFxuXG5cbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH0gLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuXG5cbiAgaWYgKG5zZWNzID49IDEwMDAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidXVpZC52MSgpOiBDYW4ndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWNcIik7XG4gIH1cblxuICBfbGFzdE1TZWNzID0gbXNlY3M7XG4gIF9sYXN0TlNlY3MgPSBuc2VjcztcbiAgX2Nsb2Nrc2VxID0gY2xvY2tzZXE7IC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuXG4gIG1zZWNzICs9IDEyMjE5MjkyODAwMDAwOyAvLyBgdGltZV9sb3dgXG5cbiAgdmFyIHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIHZhciB0bWggPSBtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDAgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7IC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG5cbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMTYgJiAweGZmOyAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcblxuICBiW2krK10gPSBjbG9ja3NlcSA+Pj4gOCB8IDB4ODA7IC8vIGBjbG9ja19zZXFfbG93YFxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxICYgMHhmZjsgLy8gYG5vZGVgXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCA2OyArK24pIHtcbiAgICBiW2kgKyBuXSA9IG5vZGVbbl07XG4gIH1cblxuICByZXR1cm4gYnVmIHx8IHN0cmluZ2lmeShiKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/v1.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/v3.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/v3.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/md5.js\");\n\n\nvar v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ0E7QUFDM0IsU0FBUyxtREFBRyxhQUFhLCtDQUFHO0FBQzVCLCtEQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzLmpzP2I1YjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgbWQ1IGZyb20gJy4vbWQ1LmpzJztcbnZhciB2MyA9IHYzNSgndjMnLCAweDMwLCBtZDUpO1xuZXhwb3J0IGRlZmF1bHQgdjM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/v3.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/v35.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/v35.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: function() { return /* binding */ DNS; },\n/* harmony export */   URL: function() { return /* binding */ URL; },\n/* harmony export */   \"default\": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nvar DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nvar URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ1I7O0FBRS9CO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNBO0FBQ1AsNkJBQWUsb0NBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx5REFBUztBQUNwQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzPzE1ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICB2YXIgYnl0ZXMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGJ5dGVzLnB1c2goc3RyLmNoYXJDb2RlQXQoaSkpO1xuICB9XG5cbiAgcmV0dXJuIGJ5dGVzO1xufVxuXG5leHBvcnQgdmFyIEROUyA9ICc2YmE3YjgxMC05ZGFkLTExZDEtODBiNC0wMGMwNGZkNDMwYzgnO1xuZXhwb3J0IHZhciBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIChuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgdmFsdWUgPSBzdHJpbmdUb0J5dGVzKHZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5hbWVzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIG5hbWVzcGFjZSA9IHBhcnNlKG5hbWVzcGFjZSk7XG4gICAgfVxuXG4gICAgaWYgKG5hbWVzcGFjZS5sZW5ndGggIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiBzdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/v35.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/v4.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/v4.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ1k7O0FBRXZDO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQUcsS0FBSzs7QUFFdkQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMseURBQVM7QUFDbEI7O0FBRUEsK0RBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanM/MGZjNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gc3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/v5.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/v5.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/sha1.js\");\n\n\nvar v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ0U7QUFDN0IsU0FBUyxtREFBRyxhQUFhLGdEQUFJO0FBQzdCLCtEQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzPzE0OTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHYzNSBmcm9tICcuL3YzNS5qcyc7XG5pbXBvcnQgc2hhMSBmcm9tICcuL3NoYTEuanMnO1xudmFyIHY1ID0gdjM1KCd2NScsIDB4NTAsIHNoYTEpO1xuZXhwb3J0IGRlZmF1bHQgdjU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/v5.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLHNEQUFVO0FBQy9DOztBQUVBLCtEQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzP2Y5ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJFR0VYIGZyb20gJy4vcmVnZXguanMnO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh1dWlkKSB7XG4gIHJldHVybiB0eXBlb2YgdXVpZCA9PT0gJ3N0cmluZycgJiYgUkVHRVgudGVzdCh1dWlkKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmFsaWRhdGU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "./node_modules/jayson/node_modules/uuid/dist/esm-browser/version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jayson/node_modules/uuid/dist/esm-browser/version.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/jayson/node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvamF5c29uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZlcnNpb24uanM/ZDU2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHZlcnNpb24odXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHJldHVybiBwYXJzZUludCh1dWlkLnN1YnN0cigxNCwgMSksIDE2KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdmVyc2lvbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/jayson/node_modules/uuid/dist/esm-browser/version.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fhunterstein%2Fopos%2Fsrc%2Fpages%2Findex.tsx&page=%2F!":
/*!*********************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fhunterstein%2Fopos%2Fsrc%2Fpages%2Findex.tsx&page=%2F! ***!
  \*********************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./src/pages/index.tsx */ \"./src/pages/index.tsx\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD0lMkZVc2VycyUyRmh1bnRlcnN0ZWluJTJGb3BvcyUyRnNyYyUyRnBhZ2VzJTJGaW5kZXgudHN4JnBhZ2U9JTJGISIsIm1hcHBpbmdzIjoiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxtQkFBTyxDQUFDLG9EQUF1QjtBQUM5QztBQUNBO0FBQ0EsT0FBTyxJQUFVO0FBQ2pCLE1BQU0sVUFBVTtBQUNoQjtBQUNBLE9BQU87QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/NDYxNCJdLCJzb3VyY2VzQ29udGVudCI6WyJcbiAgICAod2luZG93Ll9fTkVYVF9QID0gd2luZG93Ll9fTkVYVF9QIHx8IFtdKS5wdXNoKFtcbiAgICAgIFwiL1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmVxdWlyZShcIi4vc3JjL3BhZ2VzL2luZGV4LnRzeFwiKTtcbiAgICAgIH1cbiAgICBdKTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24gKCkge1xuICAgICAgICB3aW5kb3cuX19ORVhUX1AucHVzaChbXCIvXCJdKVxuICAgICAgfSk7XG4gICAgfVxuICAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fhunterstein%2Fopos%2Fsrc%2Fpages%2Findex.tsx&page=%2F!\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js ***!
  \*****************************************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\n0 && (0);\nfunction _export(target, all) {\n    for(var name in all)Object.defineProperty(target, name, {\n        enumerable: true,\n        get: all[name]\n    });\n}\n_export(exports, {\n    PrefetchKind: function() {\n        return PrefetchKind;\n    },\n    ACTION_REFRESH: function() {\n        return ACTION_REFRESH;\n    },\n    ACTION_NAVIGATE: function() {\n        return ACTION_NAVIGATE;\n    },\n    ACTION_RESTORE: function() {\n        return ACTION_RESTORE;\n    },\n    ACTION_SERVER_PATCH: function() {\n        return ACTION_SERVER_PATCH;\n    },\n    ACTION_PREFETCH: function() {\n        return ACTION_PREFETCH;\n    },\n    ACTION_FAST_REFRESH: function() {\n        return ACTION_FAST_REFRESH;\n    },\n    ACTION_SERVER_ACTION: function() {\n        return ACTION_SERVER_ACTION;\n    }\n});\nconst ACTION_REFRESH = \"refresh\";\nconst ACTION_NAVIGATE = \"navigate\";\nconst ACTION_RESTORE = \"restore\";\nconst ACTION_SERVER_PATCH = \"server-patch\";\nconst ACTION_PREFETCH = \"prefetch\";\nconst ACTION_FAST_REFRESH = \"fast-refresh\";\nconst ACTION_SERVER_ACTION = \"server-action\";\nvar PrefetchKind;\n(function(PrefetchKind) {\n    PrefetchKind[\"AUTO\"] = \"auto\";\n    PrefetchKind[\"FULL\"] = \"full\";\n    PrefetchKind[\"TEMPORARY\"] = \"temporary\";\n})(PrefetchKind || (PrefetchKind = {}));\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=router-reducer-types.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGLEtBQU1DLENBQUFBLENBU047QUFDQSxTQUFTUyxRQUFRQyxNQUFNLEVBQUVDLEdBQUc7SUFDeEIsSUFBSSxJQUFJQyxRQUFRRCxJQUFJZixPQUFPQyxjQUFjLENBQUNhLFFBQVFFLE1BQU07UUFDcERDLFlBQVk7UUFDWkMsS0FBS0gsR0FBRyxDQUFDQyxLQUFLO0lBQ2xCO0FBQ0o7QUFDQUgsUUFBUVgsU0FBUztJQUNiRyxjQUFjO1FBQ1YsT0FBT0E7SUFDWDtJQUNBQyxnQkFBZ0I7UUFDWixPQUFPQTtJQUNYO0lBQ0FDLGlCQUFpQjtRQUNiLE9BQU9BO0lBQ1g7SUFDQUMsZ0JBQWdCO1FBQ1osT0FBT0E7SUFDWDtJQUNBQyxxQkFBcUI7UUFDakIsT0FBT0E7SUFDWDtJQUNBQyxpQkFBaUI7UUFDYixPQUFPQTtJQUNYO0lBQ0FDLHFCQUFxQjtRQUNqQixPQUFPQTtJQUNYO0lBQ0FDLHNCQUFzQjtRQUNsQixPQUFPQTtJQUNYO0FBQ0o7QUFDQSxNQUFNTixpQkFBaUI7QUFDdkIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLGlCQUFpQjtBQUN2QixNQUFNQyxzQkFBc0I7QUFDNUIsTUFBTUMsa0JBQWtCO0FBQ3hCLE1BQU1DLHNCQUFzQjtBQUM1QixNQUFNQyx1QkFBdUI7QUFDN0IsSUFBSVA7QUFDSCxVQUFTQSxZQUFZO0lBQ2xCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCQSxZQUFZLENBQUMsT0FBTyxHQUFHO0lBQ3ZCQSxZQUFZLENBQUMsWUFBWSxHQUFHO0FBQ2hDLEdBQUdBLGdCQUFpQkEsQ0FBQUEsZUFBZSxDQUFDO0FBRXBDLElBQUksQ0FBQyxPQUFPSCxRQUFRaUIsT0FBTyxLQUFLLGNBQWUsT0FBT2pCLFFBQVFpQixPQUFPLEtBQUssWUFBWWpCLFFBQVFpQixPQUFPLEtBQUssSUFBSSxLQUFNLE9BQU9qQixRQUFRaUIsT0FBTyxDQUFDQyxVQUFVLEtBQUssYUFBYTtJQUNyS3BCLE9BQU9DLGNBQWMsQ0FBQ0MsUUFBUWlCLE9BQU8sRUFBRSxjQUFjO1FBQUVoQixPQUFPO0lBQUs7SUFDbkVILE9BQU9xQixNQUFNLENBQUNuQixRQUFRaUIsT0FBTyxFQUFFakI7SUFDL0JFLE9BQU9GLE9BQU8sR0FBR0EsUUFBUWlCLE9BQU87QUFDbEMsRUFFQSxnREFBZ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvY29tcG9uZW50cy9yb3V0ZXItcmVkdWNlci9yb3V0ZXItcmVkdWNlci10eXBlcy5qcz82NTdkIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gICAgdmFsdWU6IHRydWVcbn0pO1xuMCAmJiAobW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUHJlZmV0Y2hLaW5kOiBudWxsLFxuICAgIEFDVElPTl9SRUZSRVNIOiBudWxsLFxuICAgIEFDVElPTl9OQVZJR0FURTogbnVsbCxcbiAgICBBQ1RJT05fUkVTVE9SRTogbnVsbCxcbiAgICBBQ1RJT05fU0VSVkVSX1BBVENIOiBudWxsLFxuICAgIEFDVElPTl9QUkVGRVRDSDogbnVsbCxcbiAgICBBQ1RJT05fRkFTVF9SRUZSRVNIOiBudWxsLFxuICAgIEFDVElPTl9TRVJWRVJfQUNUSU9OOiBudWxsXG59KTtcbmZ1bmN0aW9uIF9leHBvcnQodGFyZ2V0LCBhbGwpIHtcbiAgICBmb3IodmFyIG5hbWUgaW4gYWxsKU9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgZ2V0OiBhbGxbbmFtZV1cbiAgICB9KTtcbn1cbl9leHBvcnQoZXhwb3J0cywge1xuICAgIFByZWZldGNoS2luZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBQcmVmZXRjaEtpbmQ7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVGUkVTSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVGUkVTSDtcbiAgICB9LFxuICAgIEFDVElPTl9OQVZJR0FURTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fTkFWSUdBVEU7XG4gICAgfSxcbiAgICBBQ1RJT05fUkVTVE9SRTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUkVTVE9SRTtcbiAgICB9LFxuICAgIEFDVElPTl9TRVJWRVJfUEFUQ0g6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gQUNUSU9OX1NFUlZFUl9QQVRDSDtcbiAgICB9LFxuICAgIEFDVElPTl9QUkVGRVRDSDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fUFJFRkVUQ0g7XG4gICAgfSxcbiAgICBBQ1RJT05fRkFTVF9SRUZSRVNIOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFDVElPTl9GQVNUX1JFRlJFU0g7XG4gICAgfSxcbiAgICBBQ1RJT05fU0VSVkVSX0FDVElPTjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBBQ1RJT05fU0VSVkVSX0FDVElPTjtcbiAgICB9XG59KTtcbmNvbnN0IEFDVElPTl9SRUZSRVNIID0gXCJyZWZyZXNoXCI7XG5jb25zdCBBQ1RJT05fTkFWSUdBVEUgPSBcIm5hdmlnYXRlXCI7XG5jb25zdCBBQ1RJT05fUkVTVE9SRSA9IFwicmVzdG9yZVwiO1xuY29uc3QgQUNUSU9OX1NFUlZFUl9QQVRDSCA9IFwic2VydmVyLXBhdGNoXCI7XG5jb25zdCBBQ1RJT05fUFJFRkVUQ0ggPSBcInByZWZldGNoXCI7XG5jb25zdCBBQ1RJT05fRkFTVF9SRUZSRVNIID0gXCJmYXN0LXJlZnJlc2hcIjtcbmNvbnN0IEFDVElPTl9TRVJWRVJfQUNUSU9OID0gXCJzZXJ2ZXItYWN0aW9uXCI7XG52YXIgUHJlZmV0Y2hLaW5kO1xuKGZ1bmN0aW9uKFByZWZldGNoS2luZCkge1xuICAgIFByZWZldGNoS2luZFtcIkFVVE9cIl0gPSBcImF1dG9cIjtcbiAgICBQcmVmZXRjaEtpbmRbXCJGVUxMXCJdID0gXCJmdWxsXCI7XG4gICAgUHJlZmV0Y2hLaW5kW1wiVEVNUE9SQVJZXCJdID0gXCJ0ZW1wb3JhcnlcIjtcbn0pKFByZWZldGNoS2luZCB8fCAoUHJlZmV0Y2hLaW5kID0ge30pKTtcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cm91dGVyLXJlZHVjZXItdHlwZXMuanMubWFwIl0sIm5hbWVzIjpbIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwibW9kdWxlIiwiUHJlZmV0Y2hLaW5kIiwiQUNUSU9OX1JFRlJFU0giLCJBQ1RJT05fTkFWSUdBVEUiLCJBQ1RJT05fUkVTVE9SRSIsIkFDVElPTl9TRVJWRVJfUEFUQ0giLCJBQ1RJT05fUFJFRkVUQ0giLCJBQ1RJT05fRkFTVF9SRUZSRVNIIiwiQUNUSU9OX1NFUlZFUl9BQ1RJT04iLCJfZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZSIsImVudW1lcmFibGUiLCJnZXQiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/get-domain-locale.js":
/*!************************************************************!*\
  !*** ./node_modules/next/dist/client/get-domain-locale.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"getDomainLocale\", ({\n    enumerable: true,\n    get: function() {\n        return getDomainLocale;\n    }\n}));\nconst _normalizetrailingslash = __webpack_require__(/*! ./normalize-trailing-slash */ \"./node_modules/next/dist/client/normalize-trailing-slash.js\");\nconst basePath =  false || \"\";\nfunction getDomainLocale(path, locale, locales, domainLocales) {\n    if (false) {} else {\n        return false;\n    }\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=get-domain-locale.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9nZXQtZG9tYWluLWxvY2FsZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiQSw4Q0FBNkM7SUFDekNHLE9BQU87QUFDWCxDQUFDLEVBQUM7QUFDRkgsbURBQWtEO0lBQzlDSSxZQUFZO0lBQ1pDLEtBQUs7UUFDRCxPQUFPQztJQUNYO0FBQ0osQ0FBQyxFQUFDO0FBQ0YsTUFBTUMsMEJBQTBCQyxtQkFBT0EsQ0FBQywrRkFBNEI7QUFDcEUsTUFBTUMsV0FBV0MsTUFBa0MsSUFBSTtBQUN2RCxTQUFTSixnQkFBZ0JPLElBQUksRUFBRUMsTUFBTSxFQUFFQyxPQUFPLEVBQUVDLGFBQWE7SUFDekQsSUFBSU4sS0FBK0IsRUFBRSxFQVdwQyxNQUFNO1FBQ0gsT0FBTztJQUNYO0FBQ0o7QUFFQSxJQUFJLENBQUMsT0FBT1IsUUFBUTJCLE9BQU8sS0FBSyxjQUFlLE9BQU8zQixRQUFRMkIsT0FBTyxLQUFLLFlBQVkzQixRQUFRMkIsT0FBTyxLQUFLLElBQUksS0FBTSxPQUFPM0IsUUFBUTJCLE9BQU8sQ0FBQ0MsVUFBVSxLQUFLLGFBQWE7SUFDcks5QixPQUFPQyxjQUFjLENBQUNDLFFBQVEyQixPQUFPLEVBQUUsY0FBYztRQUFFMUIsT0FBTztJQUFLO0lBQ25FSCxPQUFPK0IsTUFBTSxDQUFDN0IsUUFBUTJCLE9BQU8sRUFBRTNCO0lBQy9COEIsT0FBTzlCLE9BQU8sR0FBR0EsUUFBUTJCLE9BQU87QUFDbEMsRUFFQSw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvZ2V0LWRvbWFpbi1sb2NhbGUuanM/NWMyNyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwge1xuICAgIHZhbHVlOiB0cnVlXG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvbWFpbkxvY2FsZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ2V0RG9tYWluTG9jYWxlO1xuICAgIH1cbn0pO1xuY29uc3QgX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2ggPSByZXF1aXJlKFwiLi9ub3JtYWxpemUtdHJhaWxpbmctc2xhc2hcIik7XG5jb25zdCBiYXNlUGF0aCA9IHByb2Nlc3MuZW52Ll9fTkVYVF9ST1VURVJfQkFTRVBBVEggfHwgXCJcIjtcbmZ1bmN0aW9uIGdldERvbWFpbkxvY2FsZShwYXRoLCBsb2NhbGUsIGxvY2FsZXMsIGRvbWFpbkxvY2FsZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuX19ORVhUX0kxOE5fU1VQUE9SVCkge1xuICAgICAgICBjb25zdCBub3JtYWxpemVMb2NhbGVQYXRoID0gcmVxdWlyZShcIi4vbm9ybWFsaXplLWxvY2FsZS1wYXRoXCIpLm5vcm1hbGl6ZUxvY2FsZVBhdGg7XG4gICAgICAgIGNvbnN0IGRldGVjdERvbWFpbkxvY2FsZSA9IHJlcXVpcmUoXCIuL2RldGVjdC1kb21haW4tbG9jYWxlXCIpLmRldGVjdERvbWFpbkxvY2FsZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gbG9jYWxlIHx8IG5vcm1hbGl6ZUxvY2FsZVBhdGgocGF0aCwgbG9jYWxlcykuZGV0ZWN0ZWRMb2NhbGU7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IGRldGVjdERvbWFpbkxvY2FsZShkb21haW5Mb2NhbGVzLCB1bmRlZmluZWQsIHRhcmdldCk7XG4gICAgICAgIGlmIChkb21haW4pIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvID0gXCJodHRwXCIgKyAoZG9tYWluLmh0dHAgPyBcIlwiIDogXCJzXCIpICsgXCI6Ly9cIjtcbiAgICAgICAgICAgIGNvbnN0IGZpbmFsTG9jYWxlID0gdGFyZ2V0ID09PSBkb21haW4uZGVmYXVsdExvY2FsZSA/IFwiXCIgOiBcIi9cIiArIHRhcmdldDtcbiAgICAgICAgICAgIHJldHVybiBcIlwiICsgcHJvdG8gKyBkb21haW4uZG9tYWluICsgKDAsIF9ub3JtYWxpemV0cmFpbGluZ3NsYXNoLm5vcm1hbGl6ZVBhdGhUcmFpbGluZ1NsYXNoKShcIlwiICsgYmFzZVBhdGggKyBmaW5hbExvY2FsZSArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXQtZG9tYWluLWxvY2FsZS5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiZ2V0RG9tYWluTG9jYWxlIiwiX25vcm1hbGl6ZXRyYWlsaW5nc2xhc2giLCJyZXF1aXJlIiwiYmFzZVBhdGgiLCJwcm9jZXNzIiwiZW52IiwiX19ORVhUX1JPVVRFUl9CQVNFUEFUSCIsInBhdGgiLCJsb2NhbGUiLCJsb2NhbGVzIiwiZG9tYWluTG9jYWxlcyIsIl9fTkVYVF9JMThOX1NVUFBPUlQiLCJub3JtYWxpemVMb2NhbGVQYXRoIiwiZGV0ZWN0RG9tYWluTG9jYWxlIiwidGFyZ2V0IiwiZGV0ZWN0ZWRMb2NhbGUiLCJkb21haW4iLCJ1bmRlZmluZWQiLCJwcm90byIsImh0dHAiLCJmaW5hbExvY2FsZSIsImRlZmF1bHRMb2NhbGUiLCJub3JtYWxpemVQYXRoVHJhaWxpbmdTbGFzaCIsImRlZmF1bHQiLCJfX2VzTW9kdWxlIiwiYXNzaWduIiwibW9kdWxlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/get-domain-locale.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/link.js":
/*!***********************************************!*\
  !*** ./node_modules/next/dist/client/link.js ***!
  \***********************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* __next_internal_client_entry_do_not_use__  cjs */ \nvar _s = $RefreshSig$();\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"default\", ({\n    enumerable: true,\n    get: function() {\n        return _default;\n    }\n}));\nconst _interop_require_default = __webpack_require__(/*! @swc/helpers/_/_interop_require_default */ \"./node_modules/@swc/helpers/esm/_interop_require_default.js\");\nconst _react = /*#__PURE__*/ _interop_require_default._(__webpack_require__(/*! react */ \"./node_modules/react/index.js\"));\nconst _resolvehref = __webpack_require__(/*! ../shared/lib/router/utils/resolve-href */ \"./node_modules/next/dist/shared/lib/router/utils/resolve-href.js\");\nconst _islocalurl = __webpack_require__(/*! ../shared/lib/router/utils/is-local-url */ \"./node_modules/next/dist/shared/lib/router/utils/is-local-url.js\");\nconst _formaturl = __webpack_require__(/*! ../shared/lib/router/utils/format-url */ \"./node_modules/next/dist/shared/lib/router/utils/format-url.js\");\nconst _utils = __webpack_require__(/*! ../shared/lib/utils */ \"./node_modules/next/dist/shared/lib/utils.js\");\nconst _addlocale = __webpack_require__(/*! ./add-locale */ \"./node_modules/next/dist/client/add-locale.js\");\nconst _routercontext = __webpack_require__(/*! ../shared/lib/router-context */ \"./node_modules/next/dist/shared/lib/router-context.js\");\nconst _approutercontext = __webpack_require__(/*! ../shared/lib/app-router-context */ \"./node_modules/next/dist/shared/lib/app-router-context.js\");\nconst _useintersection = __webpack_require__(/*! ./use-intersection */ \"./node_modules/next/dist/client/use-intersection.js\");\nconst _getdomainlocale = __webpack_require__(/*! ./get-domain-locale */ \"./node_modules/next/dist/client/get-domain-locale.js\");\nconst _addbasepath = __webpack_require__(/*! ./add-base-path */ \"./node_modules/next/dist/client/add-base-path.js\");\nconst _routerreducertypes = __webpack_require__(/*! ./components/router-reducer/router-reducer-types */ \"./node_modules/next/dist/client/components/router-reducer/router-reducer-types.js\");\nconst prefetched = new Set();\nfunction prefetch(router, href, as, options, appOptions, isAppRouter) {\n    if (false) {}\n    // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    if (!isAppRouter && !(0, _islocalurl.isLocalURL)(href)) {\n        return;\n    }\n    // We should only dedupe requests when experimental.optimisticClientCache is\n    // disabled.\n    if (!options.bypassPrefetchedCheck) {\n        const locale = typeof options.locale !== \"undefined\" ? options.locale : \"locale\" in router ? router.locale : undefined;\n        const prefetchedKey = href + \"%\" + as + \"%\" + locale;\n        // If we've already fetched the key, then don't prefetch it again!\n        if (prefetched.has(prefetchedKey)) {\n            return;\n        }\n        // Mark this URL as prefetched.\n        prefetched.add(prefetchedKey);\n    }\n    const prefetchPromise = isAppRouter ? router.prefetch(href, appOptions) : router.prefetch(href, as, options);\n    // Prefetch the JSON page if asked (only in the client)\n    // We need to handle a prefetch error here since we may be\n    // loading with priority which can reject but we don't\n    // want to force navigation since this is only a prefetch\n    Promise.resolve(prefetchPromise).catch((err)=>{\n        if (true) {\n            // rethrow to show invalid URL errors\n            throw err;\n        }\n    });\n}\nfunction isModifiedEvent(event) {\n    const eventTarget = event.currentTarget;\n    const target = eventTarget.getAttribute(\"target\");\n    return target && target !== \"_self\" || event.metaKey || event.ctrlKey || event.shiftKey || event.altKey || // triggers resource download\n    event.nativeEvent && event.nativeEvent.which === 2;\n}\nfunction linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled) {\n    const { nodeName } = e.currentTarget;\n    // anchors inside an svg have a lowercase nodeName\n    const isAnchorNodeName = nodeName.toUpperCase() === \"A\";\n    if (isAnchorNodeName && (isModifiedEvent(e) || // app-router supports external urls out of the box so it shouldn't short-circuit here as support for e.g. `replace` is added in the app-router.\n    !isAppRouter && !(0, _islocalurl.isLocalURL)(href))) {\n        // ignore click for browsers default behavior\n        return;\n    }\n    e.preventDefault();\n    const navigate = ()=>{\n        // If the router is an NextRouter instance it will have `beforePopState`\n        const routerScroll = scroll != null ? scroll : true;\n        if (\"beforePopState\" in router) {\n            router[replace ? \"replace\" : \"push\"](href, as, {\n                shallow,\n                locale,\n                scroll: routerScroll\n            });\n        } else {\n            router[replace ? \"replace\" : \"push\"](as || href, {\n                forceOptimisticNavigation: !prefetchEnabled,\n                scroll: routerScroll\n            });\n        }\n    };\n    if (isAppRouter) {\n        _react.default.startTransition(navigate);\n    } else {\n        navigate();\n    }\n}\nfunction formatStringOrUrl(urlObjOrString) {\n    if (typeof urlObjOrString === \"string\") {\n        return urlObjOrString;\n    }\n    return (0, _formaturl.formatUrl)(urlObjOrString);\n}\n/**\n * React Component that enables client-side transitions between routes.\n */ const Link = /*#__PURE__*/ _s(_react.default.forwardRef(_c = _s(function LinkComponent(props, forwardedRef) {\n    _s();\n    let children;\n    const { href: hrefProp, as: asProp, children: childrenProp, prefetch: prefetchProp = null, passHref, replace, shallow, scroll, locale, onClick, onMouseEnter: onMouseEnterProp, onTouchStart: onTouchStartProp, legacyBehavior = true === false, ...restProps } = props;\n    children = childrenProp;\n    if (legacyBehavior && (typeof children === \"string\" || typeof children === \"number\")) {\n        children = /*#__PURE__*/ _react.default.createElement(\"a\", null, children);\n    }\n    const pagesRouter = _react.default.useContext(_routercontext.RouterContext);\n    const appRouter = _react.default.useContext(_approutercontext.AppRouterContext);\n    const router = pagesRouter != null ? pagesRouter : appRouter;\n    // We're in the app directory if there is no pages router.\n    const isAppRouter = !pagesRouter;\n    const prefetchEnabled = prefetchProp !== false;\n    /**\n     * The possible states for prefetch are:\n     * - null: this is the default \"auto\" mode, where we will prefetch partially if the link is in the viewport\n     * - true: we will prefetch if the link is visible and prefetch the full page, not just partially\n     * - false: we will not prefetch if in the viewport at all\n     */ const appPrefetchKind = prefetchProp === null ? _routerreducertypes.PrefetchKind.AUTO : _routerreducertypes.PrefetchKind.FULL;\n    if (true) {\n        function createPropError(args) {\n            return new Error(\"Failed prop type: The prop `\" + args.key + \"` expects a \" + args.expected + \" in `<Link>`, but got `\" + args.actual + \"` instead.\" + ( true ? \"\\nOpen your browser's console to view the Component stack trace.\" : 0));\n        }\n        // TypeScript trick for type-guarding:\n        const requiredPropsGuard = {\n            href: true\n        };\n        const requiredProps = Object.keys(requiredPropsGuard);\n        requiredProps.forEach((key)=>{\n            if (key === \"href\") {\n                if (props[key] == null || typeof props[key] !== \"string\" && typeof props[key] !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: props[key] === null ? \"null\" : typeof props[key]\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // TypeScript trick for type-guarding:\n        const optionalPropsGuard = {\n            as: true,\n            replace: true,\n            scroll: true,\n            shallow: true,\n            passHref: true,\n            prefetch: true,\n            locale: true,\n            onClick: true,\n            onMouseEnter: true,\n            onTouchStart: true,\n            legacyBehavior: true\n        };\n        const optionalProps = Object.keys(optionalPropsGuard);\n        optionalProps.forEach((key)=>{\n            const valType = typeof props[key];\n            if (key === \"as\") {\n                if (props[key] && valType !== \"string\" && valType !== \"object\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string` or `object`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"locale\") {\n                if (props[key] && valType !== \"string\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`string`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"onClick\" || key === \"onMouseEnter\" || key === \"onTouchStart\") {\n                if (props[key] && valType !== \"function\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`function`\",\n                        actual: valType\n                    });\n                }\n            } else if (key === \"replace\" || key === \"scroll\" || key === \"shallow\" || key === \"passHref\" || key === \"prefetch\" || key === \"legacyBehavior\") {\n                if (props[key] != null && valType !== \"boolean\") {\n                    throw createPropError({\n                        key,\n                        expected: \"`boolean`\",\n                        actual: valType\n                    });\n                }\n            } else {\n                // TypeScript trick for type-guarding:\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                const _ = key;\n            }\n        });\n        // This hook is in a conditional but that is ok because `process.env.NODE_ENV` never changes\n        // eslint-disable-next-line react-hooks/rules-of-hooks\n        const hasWarned = _react.default.useRef(false);\n        if (props.prefetch && !hasWarned.current && !isAppRouter) {\n            hasWarned.current = true;\n            console.warn(\"Next.js auto-prefetches automatically based on viewport. The prefetch attribute is no longer needed. More: https://nextjs.org/docs/messages/prefetch-true-deprecated\");\n        }\n    }\n    if (true) {\n        if (isAppRouter && !asProp) {\n            let href;\n            if (typeof hrefProp === \"string\") {\n                href = hrefProp;\n            } else if (typeof hrefProp === \"object\" && typeof hrefProp.pathname === \"string\") {\n                href = hrefProp.pathname;\n            }\n            if (href) {\n                const hasDynamicSegment = href.split(\"/\").some((segment)=>segment.startsWith(\"[\") && segment.endsWith(\"]\"));\n                if (hasDynamicSegment) {\n                    throw new Error(\"Dynamic href `\" + href + \"` found in <Link> while using the `/app` router, this is not supported. Read more: https://nextjs.org/docs/messages/app-dir-dynamic-href\");\n                }\n            }\n        }\n    }\n    const { href, as } = _react.default.useMemo(()=>{\n        if (!pagesRouter) {\n            const resolvedHref = formatStringOrUrl(hrefProp);\n            return {\n                href: resolvedHref,\n                as: asProp ? formatStringOrUrl(asProp) : resolvedHref\n            };\n        }\n        const [resolvedHref, resolvedAs] = (0, _resolvehref.resolveHref)(pagesRouter, hrefProp, true);\n        return {\n            href: resolvedHref,\n            as: asProp ? (0, _resolvehref.resolveHref)(pagesRouter, asProp) : resolvedAs || resolvedHref\n        };\n    }, [\n        pagesRouter,\n        hrefProp,\n        asProp\n    ]);\n    const previousHref = _react.default.useRef(href);\n    const previousAs = _react.default.useRef(as);\n    // This will return the first child, if multiple are provided it will throw an error\n    let child;\n    if (legacyBehavior) {\n        if (true) {\n            if (onClick) {\n                console.warn('\"onClick\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onClick be set on the child of next/link');\n            }\n            if (onMouseEnterProp) {\n                console.warn('\"onMouseEnter\" was passed to <Link> with `href` of `' + hrefProp + '` but \"legacyBehavior\" was set. The legacy behavior requires onMouseEnter be set on the child of next/link');\n            }\n            try {\n                child = _react.default.Children.only(children);\n            } catch (err) {\n                if (!children) {\n                    throw new Error(\"No children were passed to <Link> with `href` of `\" + hrefProp + \"` but one child is required https://nextjs.org/docs/messages/link-no-children\");\n                }\n                throw new Error(\"Multiple children were passed to <Link> with `href` of `\" + hrefProp + \"` but only one child is supported https://nextjs.org/docs/messages/link-multiple-children\" + ( true ? \" \\nOpen your browser's console to view the Component stack trace.\" : 0));\n            }\n        } else {}\n    } else {\n        if (true) {\n            if ((children == null ? void 0 : children.type) === \"a\") {\n                throw new Error(\"Invalid <Link> with <a> child. Please remove <a> or use <Link legacyBehavior>.\\nLearn more: https://nextjs.org/docs/messages/invalid-new-link-with-extra-anchor\");\n            }\n        }\n    }\n    const childRef = legacyBehavior ? child && typeof child === \"object\" && child.ref : forwardedRef;\n    const [setIntersectionRef, isVisible, resetVisible] = (0, _useintersection.useIntersection)({\n        rootMargin: \"200px\"\n    });\n    const setRef = _react.default.useCallback((el)=>{\n        // Before the link getting observed, check if visible state need to be reset\n        if (previousAs.current !== as || previousHref.current !== href) {\n            resetVisible();\n            previousAs.current = as;\n            previousHref.current = href;\n        }\n        setIntersectionRef(el);\n        if (childRef) {\n            if (typeof childRef === \"function\") childRef(el);\n            else if (typeof childRef === \"object\") {\n                childRef.current = el;\n            }\n        }\n    }, [\n        as,\n        childRef,\n        href,\n        resetVisible,\n        setIntersectionRef\n    ]);\n    // Prefetch the URL if we haven't already and it's visible.\n    _react.default.useEffect(()=>{\n        // in dev, we only prefetch on hover to avoid wasting resources as the prefetch will trigger compiling the page.\n        if (true) {\n            return;\n        }\n        if (!router) {\n            return;\n        }\n        // If we don't need to prefetch the URL, don't do prefetch.\n        if (!isVisible || !prefetchEnabled) {\n            return;\n        }\n        // Prefetch the URL.\n        prefetch(router, href, as, {\n            locale\n        }, {\n            kind: appPrefetchKind\n        }, isAppRouter);\n    }, [\n        as,\n        href,\n        isVisible,\n        locale,\n        prefetchEnabled,\n        pagesRouter == null ? void 0 : pagesRouter.locale,\n        router,\n        isAppRouter,\n        appPrefetchKind\n    ]);\n    const childProps = {\n        ref: setRef,\n        onClick (e) {\n            if (true) {\n                if (!e) {\n                    throw new Error('Component rendered inside next/link has to pass click event to \"onClick\" prop.');\n                }\n            }\n            if (!legacyBehavior && typeof onClick === \"function\") {\n                onClick(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onClick === \"function\") {\n                child.props.onClick(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (e.defaultPrevented) {\n                return;\n            }\n            linkClicked(e, router, href, as, replace, shallow, scroll, locale, isAppRouter, prefetchEnabled);\n        },\n        onMouseEnter (e) {\n            if (!legacyBehavior && typeof onMouseEnterProp === \"function\") {\n                onMouseEnterProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onMouseEnter === \"function\") {\n                child.props.onMouseEnter(e);\n            }\n            if (!router) {\n                return;\n            }\n            if ((!prefetchEnabled || \"development\" === \"development\") && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        },\n        onTouchStart (e) {\n            if (!legacyBehavior && typeof onTouchStartProp === \"function\") {\n                onTouchStartProp(e);\n            }\n            if (legacyBehavior && child.props && typeof child.props.onTouchStart === \"function\") {\n                child.props.onTouchStart(e);\n            }\n            if (!router) {\n                return;\n            }\n            if (!prefetchEnabled && isAppRouter) {\n                return;\n            }\n            prefetch(router, href, as, {\n                locale,\n                priority: true,\n                // @see {https://github.com/vercel/next.js/discussions/40268?sort=top#discussioncomment-3572642}\n                bypassPrefetchedCheck: true\n            }, {\n                kind: appPrefetchKind\n            }, isAppRouter);\n        }\n    };\n    // If child is an <a> tag and doesn't have a href attribute, or if the 'passHref' property is\n    // defined, we specify the current 'href', so that repetition is not needed by the user.\n    // If the url is absolute, we can bypass the logic to prepend the domain and locale.\n    if ((0, _utils.isAbsoluteUrl)(as)) {\n        childProps.href = as;\n    } else if (!legacyBehavior || passHref || child.type === \"a\" && !(\"href\" in child.props)) {\n        const curLocale = typeof locale !== \"undefined\" ? locale : pagesRouter == null ? void 0 : pagesRouter.locale;\n        // we only render domain locales if we are currently on a domain locale\n        // so that locale links are still visitable in development/preview envs\n        const localeDomain = (pagesRouter == null ? void 0 : pagesRouter.isLocaleDomain) && (0, _getdomainlocale.getDomainLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.locales, pagesRouter == null ? void 0 : pagesRouter.domainLocales);\n        childProps.href = localeDomain || (0, _addbasepath.addBasePath)((0, _addlocale.addLocale)(as, curLocale, pagesRouter == null ? void 0 : pagesRouter.defaultLocale));\n    }\n    return legacyBehavior ? /*#__PURE__*/ _react.default.cloneElement(child, childProps) : /*#__PURE__*/ _react.default.createElement(\"a\", {\n        ...restProps,\n        ...childProps\n    }, children);\n}, \"iGdYZW22TllPihoUFJYL0qIKigo=\")), \"iGdYZW22TllPihoUFJYL0qIKigo=\");\n_c1 = Link;\nconst _default = Link;\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=link.js.map\nvar _c, _c1;\n$RefreshReg$(_c, \"Link$_react.default.forwardRef\");\n$RefreshReg$(_c1, \"Link\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC9saW5rLmpzIiwibWFwcGluZ3MiOiJxREFDYTs7QUFDYkEsOENBQTZDO0lBQ3pDRyxPQUFPO0FBQ1gsQ0FBQyxFQUFDO0FBQ0ZILDJDQUEwQztJQUN0Q0ksWUFBWTtJQUNaQyxLQUFLO1FBQ0QsT0FBT0M7SUFDWDtBQUNKLENBQUMsRUFBQztBQUNGLE1BQU1DLDJCQUEyQkMsbUJBQU9BLENBQUMsNEdBQXlDO0FBQ2xGLE1BQU1DLFNBQVMsV0FBVyxHQUFHRix5QkFBeUJHLENBQUMsQ0FBQ0YsbUJBQU9BLENBQUMsNENBQU87QUFDdkUsTUFBTUcsZUFBZUgsbUJBQU9BLENBQUMsaUhBQXlDO0FBQ3RFLE1BQU1JLGNBQWNKLG1CQUFPQSxDQUFDLGlIQUF5QztBQUNyRSxNQUFNSyxhQUFhTCxtQkFBT0EsQ0FBQyw2R0FBdUM7QUFDbEUsTUFBTU0sU0FBU04sbUJBQU9BLENBQUMseUVBQXFCO0FBQzVDLE1BQU1PLGFBQWFQLG1CQUFPQSxDQUFDLG1FQUFjO0FBQ3pDLE1BQU1RLGlCQUFpQlIsbUJBQU9BLENBQUMsMkZBQThCO0FBQzdELE1BQU1TLG9CQUFvQlQsbUJBQU9BLENBQUMsbUdBQWtDO0FBQ3BFLE1BQU1VLG1CQUFtQlYsbUJBQU9BLENBQUMsK0VBQW9CO0FBQ3JELE1BQU1XLG1CQUFtQlgsbUJBQU9BLENBQUMsaUZBQXFCO0FBQ3RELE1BQU1ZLGVBQWVaLG1CQUFPQSxDQUFDLHlFQUFpQjtBQUM5QyxNQUFNYSxzQkFBc0JiLG1CQUFPQSxDQUFDLDJJQUFrRDtBQUV0RixNQUFNYyxhQUFhLElBQUlDO0FBQ3ZCLFNBQVNDLFNBQVNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxXQUFXO0lBQ2hFLElBQUksS0FBNkIsRUFBRSxFQUVsQztJQUNELGdKQUFnSjtJQUNoSixJQUFJLENBQUNBLGVBQWUsQ0FBQyxDQUFDLEdBQUdsQixZQUFZbUIsVUFBVSxF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QUFPLEVBQUUsY0FBYztRQUFFbEUsT0FBTztJQUFLO0lBQ25FSCxPQUFPc0ssTUFBTSxDQUFDcEssUUFBUW1FLE9BQU8sRUFBRW5FO0lBQy9CcUssT0FBT3JLLE9BQU8sR0FBR0EsUUFBUW1FLE9BQU87QUFDbEMsRUFFQSxnQ0FBZ0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvbGluay5qcz9lNGY5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJkZWZhdWx0XCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBfZGVmYXVsdDtcbiAgICB9XG59KTtcbmNvbnN0IF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdCA9IHJlcXVpcmUoXCJAc3djL2hlbHBlcnMvXy9faW50ZXJvcF9yZXF1aXJlX2RlZmF1bHRcIik7XG5jb25zdCBfcmVhY3QgPSAvKiNfX1BVUkVfXyovIF9pbnRlcm9wX3JlcXVpcmVfZGVmYXVsdC5fKHJlcXVpcmUoXCJyZWFjdFwiKSk7XG5jb25zdCBfcmVzb2x2ZWhyZWYgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvcmVzb2x2ZS1ocmVmXCIpO1xuY29uc3QgX2lzbG9jYWx1cmwgPSByZXF1aXJlKFwiLi4vc2hhcmVkL2xpYi9yb3V0ZXIvdXRpbHMvaXMtbG9jYWwtdXJsXCIpO1xuY29uc3QgX2Zvcm1hdHVybCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL3JvdXRlci91dGlscy9mb3JtYXQtdXJsXCIpO1xuY29uc3QgX3V0aWxzID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvdXRpbHNcIik7XG5jb25zdCBfYWRkbG9jYWxlID0gcmVxdWlyZShcIi4vYWRkLWxvY2FsZVwiKTtcbmNvbnN0IF9yb3V0ZXJjb250ZXh0ID0gcmVxdWlyZShcIi4uL3NoYXJlZC9saWIvcm91dGVyLWNvbnRleHRcIik7XG5jb25zdCBfYXBwcm91dGVyY29udGV4dCA9IHJlcXVpcmUoXCIuLi9zaGFyZWQvbGliL2FwcC1yb3V0ZXItY29udGV4dFwiKTtcbmNvbnN0IF91c2VpbnRlcnNlY3Rpb24gPSByZXF1aXJlKFwiLi91c2UtaW50ZXJzZWN0aW9uXCIpO1xuY29uc3QgX2dldGRvbWFpbmxvY2FsZSA9IHJlcXVpcmUoXCIuL2dldC1kb21haW4tbG9jYWxlXCIpO1xuY29uc3QgX2FkZGJhc2VwYXRoID0gcmVxdWlyZShcIi4vYWRkLWJhc2UtcGF0aFwiKTtcbmNvbnN0IF9yb3V0ZXJyZWR1Y2VydHlwZXMgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL3JvdXRlci1yZWR1Y2VyL3JvdXRlci1yZWR1Y2VyLXR5cGVzXCIpO1xuXG5jb25zdCBwcmVmZXRjaGVkID0gbmV3IFNldCgpO1xuZnVuY3Rpb24gcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywgb3B0aW9ucywgYXBwT3B0aW9ucywgaXNBcHBSb3V0ZXIpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuICAgIGlmICghaXNBcHBSb3V0ZXIgJiYgISgwLCBfaXNsb2NhbHVybC5pc0xvY2FsVVJMKShocmVmKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFdlIHNob3VsZCBvbmx5IGRlZHVwZSByZXF1ZXN0cyB3aGVuIGV4cGVyaW1lbnRhbC5vcHRpbWlzdGljQ2xpZW50Q2FjaGUgaXNcbiAgICAvLyBkaXNhYmxlZC5cbiAgICBpZiAoIW9wdGlvbnMuYnlwYXNzUHJlZmV0Y2hlZENoZWNrKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IC8vIExldCB0aGUgbGluaydzIGxvY2FsZSBwcm9wIG92ZXJyaWRlIHRoZSBkZWZhdWx0IHJvdXRlciBsb2NhbGUuXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmxvY2FsZSAhPT0gXCJ1bmRlZmluZWRcIiA/IG9wdGlvbnMubG9jYWxlIDogXCJsb2NhbGVcIiBpbiByb3V0ZXIgPyByb3V0ZXIubG9jYWxlIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwcmVmZXRjaGVkS2V5ID0gaHJlZiArIFwiJVwiICsgYXMgKyBcIiVcIiArIGxvY2FsZTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBmZXRjaGVkIHRoZSBrZXksIHRoZW4gZG9uJ3QgcHJlZmV0Y2ggaXQgYWdhaW4hXG4gICAgICAgIGlmIChwcmVmZXRjaGVkLmhhcyhwcmVmZXRjaGVkS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1hcmsgdGhpcyBVUkwgYXMgcHJlZmV0Y2hlZC5cbiAgICAgICAgcHJlZmV0Y2hlZC5hZGQocHJlZmV0Y2hlZEtleSk7XG4gICAgfVxuICAgIGNvbnN0IHByZWZldGNoUHJvbWlzZSA9IGlzQXBwUm91dGVyID8gcm91dGVyLnByZWZldGNoKGhyZWYsIGFwcE9wdGlvbnMpIDogcm91dGVyLnByZWZldGNoKGhyZWYsIGFzLCBvcHRpb25zKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgSlNPTiBwYWdlIGlmIGFza2VkIChvbmx5IGluIHRoZSBjbGllbnQpXG4gICAgLy8gV2UgbmVlZCB0byBoYW5kbGUgYSBwcmVmZXRjaCBlcnJvciBoZXJlIHNpbmNlIHdlIG1heSBiZVxuICAgIC8vIGxvYWRpbmcgd2l0aCBwcmlvcml0eSB3aGljaCBjYW4gcmVqZWN0IGJ1dCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gZm9yY2UgbmF2aWdhdGlvbiBzaW5jZSB0aGlzIGlzIG9ubHkgYSBwcmVmZXRjaFxuICAgIFByb21pc2UucmVzb2x2ZShwcmVmZXRjaFByb21pc2UpLmNhdGNoKChlcnIpPT57XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIC8vIHJldGhyb3cgdG8gc2hvdyBpbnZhbGlkIFVSTCBlcnJvcnNcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gaXNNb2RpZmllZEV2ZW50KGV2ZW50KSB7XG4gICAgY29uc3QgZXZlbnRUYXJnZXQgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50VGFyZ2V0LmdldEF0dHJpYnV0ZShcInRhcmdldFwiKTtcbiAgICByZXR1cm4gdGFyZ2V0ICYmIHRhcmdldCAhPT0gXCJfc2VsZlwiIHx8IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSB8fCBldmVudC5hbHRLZXkgfHwgLy8gdHJpZ2dlcnMgcmVzb3VyY2UgZG93bmxvYWRcbiAgICBldmVudC5uYXRpdmVFdmVudCAmJiBldmVudC5uYXRpdmVFdmVudC53aGljaCA9PT0gMjtcbn1cbmZ1bmN0aW9uIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKSB7XG4gICAgY29uc3QgeyBub2RlTmFtZSAgfSA9IGUuY3VycmVudFRhcmdldDtcbiAgICAvLyBhbmNob3JzIGluc2lkZSBhbiBzdmcgaGF2ZSBhIGxvd2VyY2FzZSBub2RlTmFtZVxuICAgIGNvbnN0IGlzQW5jaG9yTm9kZU5hbWUgPSBub2RlTmFtZS50b1VwcGVyQ2FzZSgpID09PSBcIkFcIjtcbiAgICBpZiAoaXNBbmNob3JOb2RlTmFtZSAmJiAoaXNNb2RpZmllZEV2ZW50KGUpIHx8IC8vIGFwcC1yb3V0ZXIgc3VwcG9ydHMgZXh0ZXJuYWwgdXJscyBvdXQgb2YgdGhlIGJveCBzbyBpdCBzaG91bGRuJ3Qgc2hvcnQtY2lyY3VpdCBoZXJlIGFzIHN1cHBvcnQgZm9yIGUuZy4gYHJlcGxhY2VgIGlzIGFkZGVkIGluIHRoZSBhcHAtcm91dGVyLlxuICAgICFpc0FwcFJvdXRlciAmJiAhKDAsIF9pc2xvY2FsdXJsLmlzTG9jYWxVUkwpKGhyZWYpKSkge1xuICAgICAgICAvLyBpZ25vcmUgY2xpY2sgZm9yIGJyb3dzZXLigJlzIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgbmF2aWdhdGUgPSAoKT0+e1xuICAgICAgICAvLyBJZiB0aGUgcm91dGVyIGlzIGFuIE5leHRSb3V0ZXIgaW5zdGFuY2UgaXQgd2lsbCBoYXZlIGBiZWZvcmVQb3BTdGF0ZWBcbiAgICAgICAgY29uc3Qgcm91dGVyU2Nyb2xsID0gc2Nyb2xsICE9IG51bGwgPyBzY3JvbGwgOiB0cnVlO1xuICAgICAgICBpZiAoXCJiZWZvcmVQb3BTdGF0ZVwiIGluIHJvdXRlcikge1xuICAgICAgICAgICAgcm91dGVyW3JlcGxhY2UgPyBcInJlcGxhY2VcIiA6IFwicHVzaFwiXShocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIHNoYWxsb3csXG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHNjcm9sbDogcm91dGVyU2Nyb2xsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvdXRlcltyZXBsYWNlID8gXCJyZXBsYWNlXCIgOiBcInB1c2hcIl0oYXMgfHwgaHJlZiwge1xuICAgICAgICAgICAgICAgIGZvcmNlT3B0aW1pc3RpY05hdmlnYXRpb246ICFwcmVmZXRjaEVuYWJsZWQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsOiByb3V0ZXJTY3JvbGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAoaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgX3JlYWN0LmRlZmF1bHQuc3RhcnRUcmFuc2l0aW9uKG5hdmlnYXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBuYXZpZ2F0ZSgpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdFN0cmluZ09yVXJsKHVybE9iak9yU3RyaW5nKSB7XG4gICAgaWYgKHR5cGVvZiB1cmxPYmpPclN0cmluZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdXJsT2JqT3JTdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiAoMCwgX2Zvcm1hdHVybC5mb3JtYXRVcmwpKHVybE9iak9yU3RyaW5nKTtcbn1cbi8qKlxuICogUmVhY3QgQ29tcG9uZW50IHRoYXQgZW5hYmxlcyBjbGllbnQtc2lkZSB0cmFuc2l0aW9ucyBiZXR3ZWVuIHJvdXRlcy5cbiAqLyBjb25zdCBMaW5rID0gLyojX19QVVJFX18qLyBfcmVhY3QuZGVmYXVsdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIExpbmtDb21wb25lbnQocHJvcHMsIGZvcndhcmRlZFJlZikge1xuICAgIGxldCBjaGlsZHJlbjtcbiAgICBjb25zdCB7IGhyZWY6IGhyZWZQcm9wICwgYXM6IGFzUHJvcCAsIGNoaWxkcmVuOiBjaGlsZHJlblByb3AgLCBwcmVmZXRjaDogcHJlZmV0Y2hQcm9wID0gbnVsbCAsIHBhc3NIcmVmICwgcmVwbGFjZSAsIHNoYWxsb3cgLCBzY3JvbGwgLCBsb2NhbGUgLCBvbkNsaWNrICwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXJQcm9wICwgb25Ub3VjaFN0YXJ0OiBvblRvdWNoU3RhcnRQcm9wICwgLy8gQHRzLWV4cGVjdC1lcnJvciB0aGlzIGlzIGlubGluZWQgYXMgYSBsaXRlcmFsIGJvb2xlYW4gbm90IGEgc3RyaW5nXG4gICAgbGVnYWN5QmVoYXZpb3IgPXByb2Nlc3MuZW52Ll9fTkVYVF9ORVdfTElOS19CRUhBVklPUiA9PT0gZmFsc2UgLCAuLi5yZXN0UHJvcHMgfSA9IHByb3BzO1xuICAgIGNoaWxkcmVuID0gY2hpbGRyZW5Qcm9wO1xuICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiAodHlwZW9mIGNoaWxkcmVuID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBjaGlsZHJlbiA9PT0gXCJudW1iZXJcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSAvKiNfX1BVUkVfXyovIF9yZWFjdC5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXCJhXCIsIG51bGwsIGNoaWxkcmVuKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZXNSb3V0ZXIgPSBfcmVhY3QuZGVmYXVsdC51c2VDb250ZXh0KF9yb3V0ZXJjb250ZXh0LlJvdXRlckNvbnRleHQpO1xuICAgIGNvbnN0IGFwcFJvdXRlciA9IF9yZWFjdC5kZWZhdWx0LnVzZUNvbnRleHQoX2FwcHJvdXRlcmNvbnRleHQuQXBwUm91dGVyQ29udGV4dCk7XG4gICAgY29uc3Qgcm91dGVyID0gcGFnZXNSb3V0ZXIgIT0gbnVsbCA/IHBhZ2VzUm91dGVyIDogYXBwUm91dGVyO1xuICAgIC8vIFdlJ3JlIGluIHRoZSBhcHAgZGlyZWN0b3J5IGlmIHRoZXJlIGlzIG5vIHBhZ2VzIHJvdXRlci5cbiAgICBjb25zdCBpc0FwcFJvdXRlciA9ICFwYWdlc1JvdXRlcjtcbiAgICBjb25zdCBwcmVmZXRjaEVuYWJsZWQgPSBwcmVmZXRjaFByb3AgIT09IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIFRoZSBwb3NzaWJsZSBzdGF0ZXMgZm9yIHByZWZldGNoIGFyZTpcbiAgICAgKiAtIG51bGw6IHRoaXMgaXMgdGhlIGRlZmF1bHQgXCJhdXRvXCIgbW9kZSwgd2hlcmUgd2Ugd2lsbCBwcmVmZXRjaCBwYXJ0aWFsbHkgaWYgdGhlIGxpbmsgaXMgaW4gdGhlIHZpZXdwb3J0XG4gICAgICogLSB0cnVlOiB3ZSB3aWxsIHByZWZldGNoIGlmIHRoZSBsaW5rIGlzIHZpc2libGUgYW5kIHByZWZldGNoIHRoZSBmdWxsIHBhZ2UsIG5vdCBqdXN0IHBhcnRpYWxseVxuICAgICAqIC0gZmFsc2U6IHdlIHdpbGwgbm90IHByZWZldGNoIGlmIGluIHRoZSB2aWV3cG9ydCBhdCBhbGxcbiAgICAgKi8gY29uc3QgYXBwUHJlZmV0Y2hLaW5kID0gcHJlZmV0Y2hQcm9wID09PSBudWxsID8gX3JvdXRlcnJlZHVjZXJ0eXBlcy5QcmVmZXRjaEtpbmQuQVVUTyA6IF9yb3V0ZXJyZWR1Y2VydHlwZXMuUHJlZmV0Y2hLaW5kLkZVTEw7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBmdW5jdGlvbiBjcmVhdGVQcm9wRXJyb3IoYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcIkZhaWxlZCBwcm9wIHR5cGU6IFRoZSBwcm9wIGBcIiArIGFyZ3Mua2V5ICsgXCJgIGV4cGVjdHMgYSBcIiArIGFyZ3MuZXhwZWN0ZWQgKyBcIiBpbiBgPExpbms+YCwgYnV0IGdvdCBgXCIgKyBhcmdzLmFjdHVhbCArIFwiYCBpbnN0ZWFkLlwiICsgKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyBcIlxcbk9wZW4geW91ciBicm93c2VyJ3MgY29uc29sZSB0byB2aWV3IHRoZSBDb21wb25lbnQgc3RhY2sgdHJhY2UuXCIgOiBcIlwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgY29uc3QgcmVxdWlyZWRQcm9wc0d1YXJkID0ge1xuICAgICAgICAgICAgaHJlZjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXF1aXJlZFByb3BzID0gT2JqZWN0LmtleXMocmVxdWlyZWRQcm9wc0d1YXJkKTtcbiAgICAgICAgcmVxdWlyZWRQcm9wcy5mb3JFYWNoKChrZXkpPT57XG4gICAgICAgICAgICBpZiAoa2V5ID09PSBcImhyZWZcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldID09IG51bGwgfHwgdHlwZW9mIHByb3BzW2tleV0gIT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIHByb3BzW2tleV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgIG9yIGBvYmplY3RgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHByb3BzW2tleV0gPT09IG51bGwgPyBcIm51bGxcIiA6IHR5cGVvZiBwcm9wc1trZXldXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHlwZVNjcmlwdCB0cmljayBmb3IgdHlwZS1ndWFyZGluZzpcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgICAgY29uc3QgXyA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHNHdWFyZCA9IHtcbiAgICAgICAgICAgIGFzOiB0cnVlLFxuICAgICAgICAgICAgcmVwbGFjZTogdHJ1ZSxcbiAgICAgICAgICAgIHNjcm9sbDogdHJ1ZSxcbiAgICAgICAgICAgIHNoYWxsb3c6IHRydWUsXG4gICAgICAgICAgICBwYXNzSHJlZjogdHJ1ZSxcbiAgICAgICAgICAgIHByZWZldGNoOiB0cnVlLFxuICAgICAgICAgICAgbG9jYWxlOiB0cnVlLFxuICAgICAgICAgICAgb25DbGljazogdHJ1ZSxcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdHJ1ZSxcbiAgICAgICAgICAgIG9uVG91Y2hTdGFydDogdHJ1ZSxcbiAgICAgICAgICAgIGxlZ2FjeUJlaGF2aW9yOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9wdGlvbmFsUHJvcHMgPSBPYmplY3Qua2V5cyhvcHRpb25hbFByb3BzR3VhcmQpO1xuICAgICAgICBvcHRpb25hbFByb3BzLmZvckVhY2goKGtleSk9PntcbiAgICAgICAgICAgIGNvbnN0IHZhbFR5cGUgPSB0eXBlb2YgcHJvcHNba2V5XTtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiYXNcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIgJiYgdmFsVHlwZSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBjcmVhdGVQcm9wRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IFwiYHN0cmluZ2Agb3IgYG9iamVjdGBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJsb2NhbGVcIikge1xuICAgICAgICAgICAgICAgIGlmIChwcm9wc1trZXldICYmIHZhbFR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBzdHJpbmdgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3R1YWw6IHZhbFR5cGVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwib25DbGlja1wiIHx8IGtleSA9PT0gXCJvbk1vdXNlRW50ZXJcIiB8fCBrZXkgPT09IFwib25Ub3VjaFN0YXJ0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAmJiB2YWxUeXBlICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgY3JlYXRlUHJvcEVycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBcImBmdW5jdGlvbmBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJyZXBsYWNlXCIgfHwga2V5ID09PSBcInNjcm9sbFwiIHx8IGtleSA9PT0gXCJzaGFsbG93XCIgfHwga2V5ID09PSBcInBhc3NIcmVmXCIgfHwga2V5ID09PSBcInByZWZldGNoXCIgfHwga2V5ID09PSBcImxlZ2FjeUJlaGF2aW9yXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvcHNba2V5XSAhPSBudWxsICYmIHZhbFR5cGUgIT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGNyZWF0ZVByb3BFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogXCJgYm9vbGVhbmBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdHVhbDogdmFsVHlwZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFR5cGVTY3JpcHQgdHJpY2sgZm9yIHR5cGUtZ3VhcmRpbmc6XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgICAgICAgICAgICAgIGNvbnN0IF8gPSBrZXk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIGhvb2sgaXMgaW4gYSBjb25kaXRpb25hbCBidXQgdGhhdCBpcyBvayBiZWNhdXNlIGBwcm9jZXNzLmVudi5OT0RFX0VOVmAgbmV2ZXIgY2hhbmdlc1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvcnVsZXMtb2YtaG9va3NcbiAgICAgICAgY29uc3QgaGFzV2FybmVkID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGZhbHNlKTtcbiAgICAgICAgaWYgKHByb3BzLnByZWZldGNoICYmICFoYXNXYXJuZWQuY3VycmVudCAmJiAhaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgIGhhc1dhcm5lZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIk5leHQuanMgYXV0by1wcmVmZXRjaGVzIGF1dG9tYXRpY2FsbHkgYmFzZWQgb24gdmlld3BvcnQuIFRoZSBwcmVmZXRjaCBhdHRyaWJ1dGUgaXMgbm8gbG9uZ2VyIG5lZWRlZC4gTW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvcHJlZmV0Y2gtdHJ1ZS1kZXByZWNhdGVkXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgaWYgKGlzQXBwUm91dGVyICYmICFhc1Byb3ApIHtcbiAgICAgICAgICAgIGxldCBocmVmO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBocmVmUHJvcCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGhyZWZQcm9wID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBocmVmUHJvcC5wYXRobmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIGhyZWYgPSBocmVmUHJvcC5wYXRobmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChocmVmKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRHluYW1pY1NlZ21lbnQgPSBocmVmLnNwbGl0KFwiL1wiKS5zb21lKChzZWdtZW50KT0+c2VnbWVudC5zdGFydHNXaXRoKFwiW1wiKSAmJiBzZWdtZW50LmVuZHNXaXRoKFwiXVwiKSk7XG4gICAgICAgICAgICAgICAgaWYgKGhhc0R5bmFtaWNTZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkR5bmFtaWMgaHJlZiBgXCIgKyBocmVmICsgXCJgIGZvdW5kIGluIDxMaW5rPiB3aGlsZSB1c2luZyB0aGUgYC9hcHBgIHJvdXRlciwgdGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBSZWFkIG1vcmU6IGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2FwcC1kaXItZHluYW1pYy1ocmVmXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7IGhyZWYgLCBhcyAgfSA9IF9yZWFjdC5kZWZhdWx0LnVzZU1lbW8oKCk9PntcbiAgICAgICAgaWYgKCFwYWdlc1JvdXRlcikge1xuICAgICAgICAgICAgY29uc3QgcmVzb2x2ZWRIcmVmID0gZm9ybWF0U3RyaW5nT3JVcmwoaHJlZlByb3ApO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBocmVmOiByZXNvbHZlZEhyZWYsXG4gICAgICAgICAgICAgICAgYXM6IGFzUHJvcCA/IGZvcm1hdFN0cmluZ09yVXJsKGFzUHJvcCkgOiByZXNvbHZlZEhyZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW3Jlc29sdmVkSHJlZiwgcmVzb2x2ZWRBc10gPSAoMCwgX3Jlc29sdmVocmVmLnJlc29sdmVIcmVmKShwYWdlc1JvdXRlciwgaHJlZlByb3AsIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaHJlZjogcmVzb2x2ZWRIcmVmLFxuICAgICAgICAgICAgYXM6IGFzUHJvcCA/ICgwLCBfcmVzb2x2ZWhyZWYucmVzb2x2ZUhyZWYpKHBhZ2VzUm91dGVyLCBhc1Byb3ApIDogcmVzb2x2ZWRBcyB8fCByZXNvbHZlZEhyZWZcbiAgICAgICAgfTtcbiAgICB9LCBbXG4gICAgICAgIHBhZ2VzUm91dGVyLFxuICAgICAgICBocmVmUHJvcCxcbiAgICAgICAgYXNQcm9wXG4gICAgXSk7XG4gICAgY29uc3QgcHJldmlvdXNIcmVmID0gX3JlYWN0LmRlZmF1bHQudXNlUmVmKGhyZWYpO1xuICAgIGNvbnN0IHByZXZpb3VzQXMgPSBfcmVhY3QuZGVmYXVsdC51c2VSZWYoYXMpO1xuICAgIC8vIFRoaXMgd2lsbCByZXR1cm4gdGhlIGZpcnN0IGNoaWxkLCBpZiBtdWx0aXBsZSBhcmUgcHJvdmlkZWQgaXQgd2lsbCB0aHJvdyBhbiBlcnJvclxuICAgIGxldCBjaGlsZDtcbiAgICBpZiAobGVnYWN5QmVoYXZpb3IpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICAgIGlmIChvbkNsaWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uQ2xpY2tcIiB3YXMgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgJyArIGhyZWZQcm9wICsgJ2AgYnV0IFwibGVnYWN5QmVoYXZpb3JcIiB3YXMgc2V0LiBUaGUgbGVnYWN5IGJlaGF2aW9yIHJlcXVpcmVzIG9uQ2xpY2sgYmUgc2V0IG9uIHRoZSBjaGlsZCBvZiBuZXh0L2xpbmsnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvbk1vdXNlRW50ZXJQcm9wKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdcIm9uTW91c2VFbnRlclwiIHdhcyBwYXNzZWQgdG8gPExpbms+IHdpdGggYGhyZWZgIG9mIGAnICsgaHJlZlByb3AgKyAnYCBidXQgXCJsZWdhY3lCZWhhdmlvclwiIHdhcyBzZXQuIFRoZSBsZWdhY3kgYmVoYXZpb3IgcmVxdWlyZXMgb25Nb3VzZUVudGVyIGJlIHNldCBvbiB0aGUgY2hpbGQgb2YgbmV4dC9saW5rJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25lIGNoaWxkIGlzIHJlcXVpcmVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbm8tY2hpbGRyZW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpcGxlIGNoaWxkcmVuIHdlcmUgcGFzc2VkIHRvIDxMaW5rPiB3aXRoIGBocmVmYCBvZiBgXCIgKyBocmVmUHJvcCArIFwiYCBidXQgb25seSBvbmUgY2hpbGQgaXMgc3VwcG9ydGVkIGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL21lc3NhZ2VzL2xpbmstbXVsdGlwbGUtY2hpbGRyZW5cIiArICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gXCIgXFxuT3BlbiB5b3VyIGJyb3dzZXIncyBjb25zb2xlIHRvIHZpZXcgdGhlIENvbXBvbmVudCBzdGFjayB0cmFjZS5cIiA6IFwiXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNoaWxkID0gX3JlYWN0LmRlZmF1bHQuQ2hpbGRyZW4ub25seShjaGlsZHJlbik7XG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICAgICAgaWYgKChjaGlsZHJlbiA9PSBudWxsID8gdm9pZCAwIDogY2hpbGRyZW4udHlwZSkgPT09IFwiYVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCA8TGluaz4gd2l0aCA8YT4gY2hpbGQuIFBsZWFzZSByZW1vdmUgPGE+IG9yIHVzZSA8TGluayBsZWdhY3lCZWhhdmlvcj4uXFxuTGVhcm4gbW9yZTogaHR0cHM6Ly9uZXh0anMub3JnL2RvY3MvbWVzc2FnZXMvaW52YWxpZC1uZXctbGluay13aXRoLWV4dHJhLWFuY2hvclwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjaGlsZFJlZiA9IGxlZ2FjeUJlaGF2aW9yID8gY2hpbGQgJiYgdHlwZW9mIGNoaWxkID09PSBcIm9iamVjdFwiICYmIGNoaWxkLnJlZiA6IGZvcndhcmRlZFJlZjtcbiAgICBjb25zdCBbc2V0SW50ZXJzZWN0aW9uUmVmLCBpc1Zpc2libGUsIHJlc2V0VmlzaWJsZV0gPSAoMCwgX3VzZWludGVyc2VjdGlvbi51c2VJbnRlcnNlY3Rpb24pKHtcbiAgICAgICAgcm9vdE1hcmdpbjogXCIyMDBweFwiXG4gICAgfSk7XG4gICAgY29uc3Qgc2V0UmVmID0gX3JlYWN0LmRlZmF1bHQudXNlQ2FsbGJhY2soKGVsKT0+e1xuICAgICAgICAvLyBCZWZvcmUgdGhlIGxpbmsgZ2V0dGluZyBvYnNlcnZlZCwgY2hlY2sgaWYgdmlzaWJsZSBzdGF0ZSBuZWVkIHRvIGJlIHJlc2V0XG4gICAgICAgIGlmIChwcmV2aW91c0FzLmN1cnJlbnQgIT09IGFzIHx8IHByZXZpb3VzSHJlZi5jdXJyZW50ICE9PSBocmVmKSB7XG4gICAgICAgICAgICByZXNldFZpc2libGUoKTtcbiAgICAgICAgICAgIHByZXZpb3VzQXMuY3VycmVudCA9IGFzO1xuICAgICAgICAgICAgcHJldmlvdXNIcmVmLmN1cnJlbnQgPSBocmVmO1xuICAgICAgICB9XG4gICAgICAgIHNldEludGVyc2VjdGlvblJlZihlbCk7XG4gICAgICAgIGlmIChjaGlsZFJlZikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZFJlZiA9PT0gXCJmdW5jdGlvblwiKSBjaGlsZFJlZihlbCk7XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2hpbGRSZWYgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBjaGlsZFJlZi5jdXJyZW50ID0gZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBjaGlsZFJlZixcbiAgICAgICAgaHJlZixcbiAgICAgICAgcmVzZXRWaXNpYmxlLFxuICAgICAgICBzZXRJbnRlcnNlY3Rpb25SZWZcbiAgICBdKTtcbiAgICAvLyBQcmVmZXRjaCB0aGUgVVJMIGlmIHdlIGhhdmVuJ3QgYWxyZWFkeSBhbmQgaXQncyB2aXNpYmxlLlxuICAgIF9yZWFjdC5kZWZhdWx0LnVzZUVmZmVjdCgoKT0+e1xuICAgICAgICAvLyBpbiBkZXYsIHdlIG9ubHkgcHJlZmV0Y2ggb24gaG92ZXIgdG8gYXZvaWQgd2FzdGluZyByZXNvdXJjZXMgYXMgdGhlIHByZWZldGNoIHdpbGwgdHJpZ2dlciBjb21waWxpbmcgdGhlIHBhZ2UuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJvdXRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IG5lZWQgdG8gcHJlZmV0Y2ggdGhlIFVSTCwgZG9uJ3QgZG8gcHJlZmV0Y2guXG4gICAgICAgIGlmICghaXNWaXNpYmxlIHx8ICFwcmVmZXRjaEVuYWJsZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmVmZXRjaCB0aGUgVVJMLlxuICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICBsb2NhbGVcbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2luZDogYXBwUHJlZmV0Y2hLaW5kXG4gICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICB9LCBbXG4gICAgICAgIGFzLFxuICAgICAgICBocmVmLFxuICAgICAgICBpc1Zpc2libGUsXG4gICAgICAgIGxvY2FsZSxcbiAgICAgICAgcHJlZmV0Y2hFbmFibGVkLFxuICAgICAgICBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlLFxuICAgICAgICByb3V0ZXIsXG4gICAgICAgIGlzQXBwUm91dGVyLFxuICAgICAgICBhcHBQcmVmZXRjaEtpbmRcbiAgICBdKTtcbiAgICBjb25zdCBjaGlsZFByb3BzID0ge1xuICAgICAgICByZWY6IHNldFJlZixcbiAgICAgICAgb25DbGljayAoZSkge1xuICAgICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGlmICghZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbXBvbmVudCByZW5kZXJlZCBpbnNpZGUgbmV4dC9saW5rIGhhcyB0byBwYXNzIGNsaWNrIGV2ZW50IHRvIFwib25DbGlja1wiIHByb3AuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFsZWdhY3lCZWhhdmlvciAmJiB0eXBlb2Ygb25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgb25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZWdhY3lCZWhhdmlvciAmJiBjaGlsZC5wcm9wcyAmJiB0eXBlb2YgY2hpbGQucHJvcHMub25DbGljayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQucHJvcHMub25DbGljayhlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpbmtDbGlja2VkKGUsIHJvdXRlciwgaHJlZiwgYXMsIHJlcGxhY2UsIHNoYWxsb3csIHNjcm9sbCwgbG9jYWxlLCBpc0FwcFJvdXRlciwgcHJlZmV0Y2hFbmFibGVkKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Nb3VzZUVudGVyIChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvbk1vdXNlRW50ZXJQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbk1vdXNlRW50ZXJQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vbk1vdXNlRW50ZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uTW91c2VFbnRlcihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCghcHJlZmV0Y2hFbmFibGVkIHx8IHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpICYmIGlzQXBwUm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJlZmV0Y2gocm91dGVyLCBocmVmLCBhcywge1xuICAgICAgICAgICAgICAgIGxvY2FsZSxcbiAgICAgICAgICAgICAgICBwcmlvcml0eTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAvLyBAc2VlIHtodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL25leHQuanMvZGlzY3Vzc2lvbnMvNDAyNjg/c29ydD10b3AjZGlzY3Vzc2lvbmNvbW1lbnQtMzU3MjY0Mn1cbiAgICAgICAgICAgICAgICBieXBhc3NQcmVmZXRjaGVkQ2hlY2s6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBraW5kOiBhcHBQcmVmZXRjaEtpbmRcbiAgICAgICAgICAgIH0sIGlzQXBwUm91dGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25Ub3VjaFN0YXJ0IChlKSB7XG4gICAgICAgICAgICBpZiAoIWxlZ2FjeUJlaGF2aW9yICYmIHR5cGVvZiBvblRvdWNoU3RhcnRQcm9wID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvblRvdWNoU3RhcnRQcm9wKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlZ2FjeUJlaGF2aW9yICYmIGNoaWxkLnByb3BzICYmIHR5cGVvZiBjaGlsZC5wcm9wcy5vblRvdWNoU3RhcnQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGNoaWxkLnByb3BzLm9uVG91Y2hTdGFydChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcm91dGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFwcmVmZXRjaEVuYWJsZWQgJiYgaXNBcHBSb3V0ZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcmVmZXRjaChyb3V0ZXIsIGhyZWYsIGFzLCB7XG4gICAgICAgICAgICAgICAgbG9jYWxlLFxuICAgICAgICAgICAgICAgIHByaW9yaXR5OiB0cnVlLFxuICAgICAgICAgICAgICAgIC8vIEBzZWUge2h0dHBzOi8vZ2l0aHViLmNvbS92ZXJjZWwvbmV4dC5qcy9kaXNjdXNzaW9ucy80MDI2OD9zb3J0PXRvcCNkaXNjdXNzaW9uY29tbWVudC0zNTcyNjQyfVxuICAgICAgICAgICAgICAgIGJ5cGFzc1ByZWZldGNoZWRDaGVjazogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGFwcFByZWZldGNoS2luZFxuICAgICAgICAgICAgfSwgaXNBcHBSb3V0ZXIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJZiBjaGlsZCBpcyBhbiA8YT4gdGFnIGFuZCBkb2Vzbid0IGhhdmUgYSBocmVmIGF0dHJpYnV0ZSwgb3IgaWYgdGhlICdwYXNzSHJlZicgcHJvcGVydHkgaXNcbiAgICAvLyBkZWZpbmVkLCB3ZSBzcGVjaWZ5IHRoZSBjdXJyZW50ICdocmVmJywgc28gdGhhdCByZXBldGl0aW9uIGlzIG5vdCBuZWVkZWQgYnkgdGhlIHVzZXIuXG4gICAgLy8gSWYgdGhlIHVybCBpcyBhYnNvbHV0ZSwgd2UgY2FuIGJ5cGFzcyB0aGUgbG9naWMgdG8gcHJlcGVuZCB0aGUgZG9tYWluIGFuZCBsb2NhbGUuXG4gICAgaWYgKCgwLCBfdXRpbHMuaXNBYnNvbHV0ZVVybCkoYXMpKSB7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGFzO1xuICAgIH0gZWxzZSBpZiAoIWxlZ2FjeUJlaGF2aW9yIHx8IHBhc3NIcmVmIHx8IGNoaWxkLnR5cGUgPT09IFwiYVwiICYmICEoXCJocmVmXCIgaW4gY2hpbGQucHJvcHMpKSB7XG4gICAgICAgIGNvbnN0IGN1ckxvY2FsZSA9IHR5cGVvZiBsb2NhbGUgIT09IFwidW5kZWZpbmVkXCIgPyBsb2NhbGUgOiBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIubG9jYWxlO1xuICAgICAgICAvLyB3ZSBvbmx5IHJlbmRlciBkb21haW4gbG9jYWxlcyBpZiB3ZSBhcmUgY3VycmVudGx5IG9uIGEgZG9tYWluIGxvY2FsZVxuICAgICAgICAvLyBzbyB0aGF0IGxvY2FsZSBsaW5rcyBhcmUgc3RpbGwgdmlzaXRhYmxlIGluIGRldmVsb3BtZW50L3ByZXZpZXcgZW52c1xuICAgICAgICBjb25zdCBsb2NhbGVEb21haW4gPSAocGFnZXNSb3V0ZXIgPT0gbnVsbCA/IHZvaWQgMCA6IHBhZ2VzUm91dGVyLmlzTG9jYWxlRG9tYWluKSAmJiAoMCwgX2dldGRvbWFpbmxvY2FsZS5nZXREb21haW5Mb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5sb2NhbGVzLCBwYWdlc1JvdXRlciA9PSBudWxsID8gdm9pZCAwIDogcGFnZXNSb3V0ZXIuZG9tYWluTG9jYWxlcyk7XG4gICAgICAgIGNoaWxkUHJvcHMuaHJlZiA9IGxvY2FsZURvbWFpbiB8fCAoMCwgX2FkZGJhc2VwYXRoLmFkZEJhc2VQYXRoKSgoMCwgX2FkZGxvY2FsZS5hZGRMb2NhbGUpKGFzLCBjdXJMb2NhbGUsIHBhZ2VzUm91dGVyID09IG51bGwgPyB2b2lkIDAgOiBwYWdlc1JvdXRlci5kZWZhdWx0TG9jYWxlKSk7XG4gICAgfVxuICAgIHJldHVybiBsZWdhY3lCZWhhdmlvciA/IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY2xvbmVFbGVtZW50KGNoaWxkLCBjaGlsZFByb3BzKSA6IC8qI19fUFVSRV9fKi8gX3JlYWN0LmRlZmF1bHQuY3JlYXRlRWxlbWVudChcImFcIiwge1xuICAgICAgICAuLi5yZXN0UHJvcHMsXG4gICAgICAgIC4uLmNoaWxkUHJvcHNcbiAgICB9LCBjaGlsZHJlbik7XG59KTtcbmNvbnN0IF9kZWZhdWx0ID0gTGluaztcblxuaWYgKCh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnZnVuY3Rpb24nIHx8ICh0eXBlb2YgZXhwb3J0cy5kZWZhdWx0ID09PSAnb2JqZWN0JyAmJiBleHBvcnRzLmRlZmF1bHQgIT09IG51bGwpKSAmJiB0eXBlb2YgZXhwb3J0cy5kZWZhdWx0Ll9fZXNNb2R1bGUgPT09ICd1bmRlZmluZWQnKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLmRlZmF1bHQsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiAgT2JqZWN0LmFzc2lnbihleHBvcnRzLmRlZmF1bHQsIGV4cG9ydHMpO1xuICBtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMuZGVmYXVsdDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGluay5qcy5tYXAiXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiX2RlZmF1bHQiLCJfaW50ZXJvcF9yZXF1aXJlX2RlZmF1bHQiLCJyZXF1aXJlIiwiX3JlYWN0IiwiXyIsIl9yZXNvbHZlaHJlZiIsIl9pc2xvY2FsdXJsIiwiX2Zvcm1hdHVybCIsIl91dGlscyIsIl9hZGRsb2NhbGUiLCJfcm91dGVyY29udGV4dCIsIl9hcHByb3V0ZXJjb250ZXh0IiwiX3VzZWludGVyc2VjdGlvbiIsIl9nZXRkb21haW5sb2NhbGUiLCJfYWRkYmFzZXBhdGgiLCJfcm91dGVycmVkdWNlcnR5cGVzIiwicHJlZmV0Y2hlZCIsIlNldCIsInByZWZldGNoIiwicm91dGVyIiwiaHJlZiIsImFzIiwib3B0aW9ucyIsImFwcE9wdGlvbnMiLCJpc0FwcFJvdXRlciIsImlzTG9jYWxVUkwiLCJieXBhc3NQcmVmZXRjaGVkQ2hlY2siLCJsb2NhbGUiLCJ1bmRlZmluZWQiLCJwcmVmZXRjaGVkS2V5IiwiaGFzIiwiYWRkIiwicHJlZmV0Y2hQcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJjYXRjaCIsImVyciIsInByb2Nlc3MiLCJpc01vZGlmaWVkRXZlbnQiLCJldmVudCIsImV2ZW50VGFyZ2V0IiwiY3VycmVudFRhcmdldCIsInRhcmdldCIsImdldEF0dHJpYnV0ZSIsIm1ldGFLZXkiLCJjdHJsS2V5Iiwic2hpZnRLZXkiLCJhbHRLZXkiLCJuYXRpdmVFdmVudCIsIndoaWNoIiwibGlua0NsaWNrZWQiLCJlIiwicmVwbGFjZSIsInNoYWxsb3ciLCJzY3JvbGwiLCJwcmVmZXRjaEVuYWJsZWQiLCJub2RlTmFtZSIsImlzQW5jaG9yTm9kZU5hbWUiLCJ0b1VwcGVyQ2FzZSIsInByZXZlbnREZWZhdWx0IiwibmF2aWdhdGUiLCJyb3V0ZXJTY3JvbGwiLCJmb3JjZU9wdGltaXN0aWNOYXZpZ2F0aW9uIiwiZGVmYXVsdCIsInN0YXJ0VHJhbnNpdGlvbiIsImZvcm1hdFN0cmluZ09yVXJsIiwidXJsT2JqT3JTdHJpbmciLCJmb3JtYXRVcmwiLCJMaW5rIiwiZm9yd2FyZFJlZiIsIkxpbmtDb21wb25lbnQiLCJwcm9wcyIsImZvcndhcmRlZFJlZiIsImNoaWxkcmVuIiwiaHJlZlByb3AiLCJhc1Byb3AiLCJjaGlsZHJlblByb3AiLCJwcmVmZXRjaFByb3AiLCJwYXNzSHJlZiIsIm9uQ2xpY2siLCJvbk1vdXNlRW50ZXIiLCJvbk1vdXNlRW50ZXJQcm9wIiwib25Ub3VjaFN0YXJ0Iiwib25Ub3VjaFN0YXJ0UHJvcCIsImxlZ2FjeUJlaGF2aW9yIiwiZW52IiwiX19ORVhUX05FV19MSU5LX0JFSEFWSU9SIiwicmVzdFByb3BzIiwiY3JlYXRlRWxlbWVudCIsInBhZ2VzUm91dGVyIiwidXNlQ29udGV4dCIsIlJvdXRlckNvbnRleHQiLCJhcHBSb3V0ZXIiLCJBcHBSb3V0ZXJDb250ZXh0IiwiYXBwUHJlZmV0Y2hLaW5kIiwiUHJlZmV0Y2hLaW5kIiwiQVVUTyIsIkZVTEwiLCJjcmVhdGVQcm9wRXJyb3IiLCJhcmdzIiwiRXJyb3IiLCJrZXkiLCJleHBlY3RlZCIsImFjdHVhbCIsInJlcXVpcmVkUHJvcHNHdWFyZCIsInJlcXVpcmVkUHJvcHMiLCJrZXlzIiwiZm9yRWFjaCIsIm9wdGlvbmFsUHJvcHNHdWFyZCIsIm9wdGlvbmFsUHJvcHMiLCJ2YWxUeXBlIiwiaGFzV2FybmVkIiwidXNlUmVmIiwiY3VycmVudCIsImNvbnNvbGUiLCJ3YXJuIiwicGF0aG5hbWUiLCJoYXNEeW5hbWljU2VnbWVudCIsInNwbGl0Iiwic29tZSIsInNlZ21lbnQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ1c2VNZW1vIiwicmVzb2x2ZWRIcmVmIiwicmVzb2x2ZWRBcyIsInJlc29sdmVIcmVmIiwicHJldmlvdXNIcmVmIiwicHJldmlvdXNBcyIsImNoaWxkIiwiQ2hpbGRyZW4iLCJvbmx5IiwidHlwZSIsImNoaWxkUmVmIiwicmVmIiwic2V0SW50ZXJzZWN0aW9uUmVmIiwiaXNWaXNpYmxlIiwicmVzZXRWaXNpYmxlIiwidXNlSW50ZXJzZWN0aW9uIiwicm9vdE1hcmdpbiIsInNldFJlZiIsInVzZUNhbGxiYWNrIiwiZWwiLCJ1c2VFZmZlY3QiLCJraW5kIiwiY2hpbGRQcm9wcyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJwcmlvcml0eSIsImlzQWJzb2x1dGVVcmwiLCJjdXJMb2NhbGUiLCJsb2NhbGVEb21haW4iLCJpc0xvY2FsZURvbWFpbiIsImdldERvbWFpbkxvY2FsZSIsImxvY2FsZXMiLCJkb21haW5Mb2NhbGVzIiwiYWRkQmFzZVBhdGgiLCJhZGRMb2NhbGUiLCJkZWZhdWx0TG9jYWxlIiwiY2xvbmVFbGVtZW50IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/link.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/client/use-intersection.js":
/*!***********************************************************!*\
  !*** ./node_modules/next/dist/client/use-intersection.js ***!
  \***********************************************************/
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nObject.defineProperty(exports, \"useIntersection\", ({\n    enumerable: true,\n    get: function() {\n        return useIntersection;\n    }\n}));\nconst _react = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nconst _requestidlecallback = __webpack_require__(/*! ./request-idle-callback */ \"./node_modules/next/dist/client/request-idle-callback.js\");\nconst hasIntersectionObserver = typeof IntersectionObserver === \"function\";\nconst observers = new Map();\nconst idList = [];\nfunction createObserver(options) {\n    const id = {\n        root: options.root || null,\n        margin: options.rootMargin || \"\"\n    };\n    const existing = idList.find((obj)=>obj.root === id.root && obj.margin === id.margin);\n    let instance;\n    if (existing) {\n        instance = observers.get(existing);\n        if (instance) {\n            return instance;\n        }\n    }\n    const elements = new Map();\n    const observer = new IntersectionObserver((entries)=>{\n        entries.forEach((entry)=>{\n            const callback = elements.get(entry.target);\n            const isVisible = entry.isIntersecting || entry.intersectionRatio > 0;\n            if (callback && isVisible) {\n                callback(isVisible);\n            }\n        });\n    }, options);\n    instance = {\n        id,\n        observer,\n        elements\n    };\n    idList.push(id);\n    observers.set(id, instance);\n    return instance;\n}\nfunction observe(element, callback, options) {\n    const { id, observer, elements } = createObserver(options);\n    elements.set(element, callback);\n    observer.observe(element);\n    return function unobserve() {\n        elements.delete(element);\n        observer.unobserve(element);\n        // Destroy observer when there's nothing left to watch:\n        if (elements.size === 0) {\n            observer.disconnect();\n            observers.delete(id);\n            const index = idList.findIndex((obj)=>obj.root === id.root && obj.margin === id.margin);\n            if (index > -1) {\n                idList.splice(index, 1);\n            }\n        }\n    };\n}\nfunction useIntersection(param) {\n    let { rootRef, rootMargin, disabled } = param;\n    const isDisabled = disabled || !hasIntersectionObserver;\n    const [visible, setVisible] = (0, _react.useState)(false);\n    const elementRef = (0, _react.useRef)(null);\n    const setElement = (0, _react.useCallback)((element)=>{\n        elementRef.current = element;\n    }, []);\n    (0, _react.useEffect)(()=>{\n        if (hasIntersectionObserver) {\n            if (isDisabled || visible) return;\n            const element = elementRef.current;\n            if (element && element.tagName) {\n                const unobserve = observe(element, (isVisible)=>isVisible && setVisible(isVisible), {\n                    root: rootRef == null ? void 0 : rootRef.current,\n                    rootMargin\n                });\n                return unobserve;\n            }\n        } else {\n            if (!visible) {\n                const idleCallback = (0, _requestidlecallback.requestIdleCallback)(()=>setVisible(true));\n                return ()=>(0, _requestidlecallback.cancelIdleCallback)(idleCallback);\n            }\n        }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [\n        isDisabled,\n        rootMargin,\n        rootRef,\n        visible,\n        elementRef.current\n    ]);\n    const resetVisible = (0, _react.useCallback)(()=>{\n        setVisible(false);\n    }, []);\n    return [\n        setElement,\n        visible,\n        resetVisible\n    ];\n}\nif ((typeof exports.default === \"function\" || typeof exports.default === \"object\" && exports.default !== null) && typeof exports.default.__esModule === \"undefined\") {\n    Object.defineProperty(exports.default, \"__esModule\", {\n        value: true\n    });\n    Object.assign(exports.default, exports);\n    module.exports = exports.default;\n} //# sourceMappingURL=use-intersection.js.map\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2JBLDhDQUE2QztJQUN6Q0csT0FBTztBQUNYLENBQUMsRUFBQztBQUNGSCxtREFBa0Q7SUFDOUNJLFlBQVk7SUFDWkMsS0FBSztRQUNELE9BQU9DO0lBQ1g7QUFDSixDQUFDLEVBQUM7QUFDRixNQUFNQyxTQUFTQyxtQkFBT0EsQ0FBQyw0Q0FBTztBQUM5QixNQUFNQyx1QkFBdUJELG1CQUFPQSxDQUFDLHlGQUF5QjtBQUM5RCxNQUFNRSwwQkFBMEIsT0FBT0MseUJBQXlCO0FBQ2hFLE1BQU1DLFlBQVksSUFBSUM7QUFDdEIsTUFBTUMsU0FBUyxFQUFFO0FBQ2pCLFNBQVNDLGVBQWVDLE9BQU87SUFDM0IsTUFBTUMsS0FBSztRQUNQQyxNQUFNRixRQUFRRSxJQUFJLElBQUk7UUFDdEJDLFFBQVFILFFBQVFJLFVBQVUsSUFBSTtJQUNsQztJQUNBLE1BQU1DLFdBQVdQLE9BQU9RLElBQUksQ0FBQyxDQUFDQyxNQUFNQSxJQUFJTCxJQUFJLEtBQUtELEdBQUdDLElBQUksSUFBSUssSUFBSUosTUFBTSxLQUFLRixHQUFHRSxNQUFNO0lBQ3BGLElBQUlLO0lBQ0osSUFBSUgsVUFBVTtRQUNWRyxXQUFXWixVQUFVUCxHQUFHLENBQUNnQjtRQUN6QixJQUFJRyxVQUFVO1lBQ1YsT0FBT0E7UUFDWDtJQUNKO0lBQ0EsTUFBTUMsV0FBVyxJQUFJWjtJQUNyQixNQUFNYSxXQUFXLElBQUlmLHFCQUFxQixDQUFDZ0I7UUFDdkNBLFFBQVFDLE9BQU8sQ0FBQyxDQUFDQztZQUNiLE1BQU1DLFdBQVdMLFNBQVNwQixHQUFHLENBQUN3QixNQUFNRSxNQUFNO1lBQzFDLE1BQU1DLFlBQVlILE1BQU1JLGNBQWMsSUFBSUosTUFBTUssaUJBQWlCLEdBQUc7WUFDcEUsSUFBSUosWUFBWUUsV0FBVztnQkFDdkJGLFNBQVNFO1lBQ2I7UUFDSjtJQUNKLEdBQUdo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SUFDL0JpRSxPQUFPakUsT0FBTyxHQUFHQSxRQUFROEQsT0FBTztBQUNsQyxFQUVBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NsaWVudC91c2UtaW50ZXJzZWN0aW9uLmpzP2ZkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgICB2YWx1ZTogdHJ1ZVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1c2VJbnRlcnNlY3Rpb25cIiwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHVzZUludGVyc2VjdGlvbjtcbiAgICB9XG59KTtcbmNvbnN0IF9yZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcbmNvbnN0IF9yZXF1ZXN0aWRsZWNhbGxiYWNrID0gcmVxdWlyZShcIi4vcmVxdWVzdC1pZGxlLWNhbGxiYWNrXCIpO1xuY29uc3QgaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSB0eXBlb2YgSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IG9ic2VydmVycyA9IG5ldyBNYXAoKTtcbmNvbnN0IGlkTGlzdCA9IFtdO1xuZnVuY3Rpb24gY3JlYXRlT2JzZXJ2ZXIob3B0aW9ucykge1xuICAgIGNvbnN0IGlkID0ge1xuICAgICAgICByb290OiBvcHRpb25zLnJvb3QgfHwgbnVsbCxcbiAgICAgICAgbWFyZ2luOiBvcHRpb25zLnJvb3RNYXJnaW4gfHwgXCJcIlxuICAgIH07XG4gICAgY29uc3QgZXhpc3RpbmcgPSBpZExpc3QuZmluZCgob2JqKT0+b2JqLnJvb3QgPT09IGlkLnJvb3QgJiYgb2JqLm1hcmdpbiA9PT0gaWQubWFyZ2luKTtcbiAgICBsZXQgaW5zdGFuY2U7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIGluc3RhbmNlID0gb2JzZXJ2ZXJzLmdldChleGlzdGluZyk7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG9ic2VydmVyID0gbmV3IEludGVyc2VjdGlvbk9ic2VydmVyKChlbnRyaWVzKT0+e1xuICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KT0+e1xuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSBlbGVtZW50cy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IGVudHJ5LmlzSW50ZXJzZWN0aW5nIHx8IGVudHJ5LmludGVyc2VjdGlvblJhdGlvID4gMDtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayAmJiBpc1Zpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhpc1Zpc2libGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9LCBvcHRpb25zKTtcbiAgICBpbnN0YW5jZSA9IHtcbiAgICAgICAgaWQsXG4gICAgICAgIG9ic2VydmVyLFxuICAgICAgICBlbGVtZW50c1xuICAgIH07XG4gICAgaWRMaXN0LnB1c2goaWQpO1xuICAgIG9ic2VydmVycy5zZXQoaWQsIGluc3RhbmNlKTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiBvYnNlcnZlKGVsZW1lbnQsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3QgeyBpZCAsIG9ic2VydmVyICwgZWxlbWVudHMgIH0gPSBjcmVhdGVPYnNlcnZlcihvcHRpb25zKTtcbiAgICBlbGVtZW50cy5zZXQoZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIG9ic2VydmVyLm9ic2VydmUoZWxlbWVudCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVub2JzZXJ2ZSgpIHtcbiAgICAgICAgZWxlbWVudHMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICBvYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgICAgIC8vIERlc3Ryb3kgb2JzZXJ2ZXIgd2hlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byB3YXRjaDpcbiAgICAgICAgaWYgKGVsZW1lbnRzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIG9ic2VydmVycy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpZExpc3QuZmluZEluZGV4KChvYmopPT5vYmoucm9vdCA9PT0gaWQucm9vdCAmJiBvYmoubWFyZ2luID09PSBpZC5tYXJnaW4pO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBpZExpc3Quc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiB1c2VJbnRlcnNlY3Rpb24ocGFyYW0pIHtcbiAgICBsZXQgeyByb290UmVmICwgcm9vdE1hcmdpbiAsIGRpc2FibGVkICB9ID0gcGFyYW07XG4gICAgY29uc3QgaXNEaXNhYmxlZCA9IGRpc2FibGVkIHx8ICFoYXNJbnRlcnNlY3Rpb25PYnNlcnZlcjtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSAoMCwgX3JlYWN0LnVzZVN0YXRlKShmYWxzZSk7XG4gICAgY29uc3QgZWxlbWVudFJlZiA9ICgwLCBfcmVhY3QudXNlUmVmKShudWxsKTtcbiAgICBjb25zdCBzZXRFbGVtZW50ID0gKDAsIF9yZWFjdC51c2VDYWxsYmFjaykoKGVsZW1lbnQpPT57XG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgfSwgW10pO1xuICAgICgwLCBfcmVhY3QudXNlRWZmZWN0KSgoKT0+e1xuICAgICAgICBpZiAoaGFzSW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGlmIChpc0Rpc2FibGVkIHx8IHZpc2libGUpIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50UmVmLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bm9ic2VydmUgPSBvYnNlcnZlKGVsZW1lbnQsIChpc1Zpc2libGUpPT5pc1Zpc2libGUgJiYgc2V0VmlzaWJsZShpc1Zpc2libGUpLCB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3Q6IHJvb3RSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3RSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICAgICAgcm9vdE1hcmdpblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB1bm9ic2VydmU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIXZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpZGxlQ2FsbGJhY2sgPSAoMCwgX3JlcXVlc3RpZGxlY2FsbGJhY2sucmVxdWVzdElkbGVDYWxsYmFjaykoKCk9PnNldFZpc2libGUodHJ1ZSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoKT0+KDAsIF9yZXF1ZXN0aWRsZWNhbGxiYWNrLmNhbmNlbElkbGVDYWxsYmFjaykoaWRsZUNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB9LCBbXG4gICAgICAgIGlzRGlzYWJsZWQsXG4gICAgICAgIHJvb3RNYXJnaW4sXG4gICAgICAgIHJvb3RSZWYsXG4gICAgICAgIHZpc2libGUsXG4gICAgICAgIGVsZW1lbnRSZWYuY3VycmVudFxuICAgIF0pO1xuICAgIGNvbnN0IHJlc2V0VmlzaWJsZSA9ICgwLCBfcmVhY3QudXNlQ2FsbGJhY2spKCgpPT57XG4gICAgICAgIHNldFZpc2libGUoZmFsc2UpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gW1xuICAgICAgICBzZXRFbGVtZW50LFxuICAgICAgICB2aXNpYmxlLFxuICAgICAgICByZXNldFZpc2libGVcbiAgICBdO1xufVxuXG5pZiAoKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdmdW5jdGlvbicgfHwgKHR5cGVvZiBleHBvcnRzLmRlZmF1bHQgPT09ICdvYmplY3QnICYmIGV4cG9ydHMuZGVmYXVsdCAhPT0gbnVsbCkpICYmIHR5cGVvZiBleHBvcnRzLmRlZmF1bHQuX19lc01vZHVsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMuZGVmYXVsdCwgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuICBPYmplY3QuYXNzaWduKGV4cG9ydHMuZGVmYXVsdCwgZXhwb3J0cyk7XG4gIG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cy5kZWZhdWx0O1xufVxuXG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2UtaW50ZXJzZWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImVudW1lcmFibGUiLCJnZXQiLCJ1c2VJbnRlcnNlY3Rpb24iLCJfcmVhY3QiLCJyZXF1aXJlIiwiX3JlcXVlc3RpZGxlY2FsbGJhY2siLCJoYXNJbnRlcnNlY3Rpb25PYnNlcnZlciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwib2JzZXJ2ZXJzIiwiTWFwIiwiaWRMaXN0IiwiY3JlYXRlT2JzZXJ2ZXIiLCJvcHRpb25zIiwiaWQiLCJyb290IiwibWFyZ2luIiwicm9vdE1hcmdpbiIsImV4aXN0aW5nIiwiZmluZCIsIm9iaiIsImluc3RhbmNlIiwiZWxlbWVudHMiLCJvYnNlcnZlciIsImVudHJpZXMiLCJmb3JFYWNoIiwiZW50cnkiLCJjYWxsYmFjayIsInRhcmdldCIsImlzVmlzaWJsZSIsImlzSW50ZXJzZWN0aW5nIiwiaW50ZXJzZWN0aW9uUmF0aW8iLCJwdXNoIiwic2V0Iiwib2JzZXJ2ZSIsImVsZW1lbnQiLCJ1bm9ic2VydmUiLCJkZWxldGUiLCJzaXplIiwiZGlzY29ubmVjdCIsImluZGV4IiwiZmluZEluZGV4Iiwic3BsaWNlIiwicGFyYW0iLCJyb290UmVmIiwiZGlzYWJsZWQiLCJpc0Rpc2FibGVkIiwidmlzaWJsZSIsInNldFZpc2libGUiLCJ1c2VTdGF0ZSIsImVsZW1lbnRSZWYiLCJ1c2VSZWYiLCJzZXRFbGVtZW50IiwidXNlQ2FsbGJhY2siLCJjdXJyZW50IiwidXNlRWZmZWN0IiwidGFnTmFtZSIsImlkbGVDYWxsYmFjayIsInJlcXVlc3RJZGxlQ2FsbGJhY2siLCJjYW5jZWxJZGxlQ2FsbGJhY2siLCJyZXNldFZpc2libGUiLCJkZWZhdWx0IiwiX19lc01vZHVsZSIsImFzc2lnbiIsIm1vZHVsZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/client/use-intersection.js\n"));

/***/ }),

/***/ "./src/components/Home.tsx":
/*!*********************************!*\
  !*** ./src/components/Home.tsx ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Home; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _supabase_auth_ui_react__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @supabase/auth-ui-react */ \"./node_modules/@supabase/auth-ui-react/dist/index.es.js\");\n/* harmony import */ var _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @supabase/auth-ui-shared */ \"./node_modules/@supabase/auth-ui-shared/dist/index.mjs\");\n/* harmony import */ var _contexts_UserContext__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../contexts/UserContext */ \"./src/contexts/UserContext.tsx\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! uuid */ \"./node_modules/uuid/dist/esm-browser/index.js\");\n/* harmony import */ var _supabase__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../supabase */ \"./supabase.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! next/link */ \"./node_modules/next/link.js\");\n/* harmony import */ var next_link__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(next_link__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/web3.js */ \"./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n // Import the UserContext\n\n\n\n\nfunction Home() {\n    _s();\n    const { user, updateUserWalletAddress, handleLogout } = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(_contexts_UserContext__WEBPACK_IMPORTED_MODULE_3__.UserContext); // Access the user context using useContext\n    const [formStatus, setFormStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Submit\"); // State to manage the form submission status\n    const [walletStatus, setWalletStatus] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"Submit\"); // State to manage the form submission status\n    const [directory, setDirectory] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [walletAddress, setWalletAddress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n    //console.log(user)\n    function isValidSolanaAddress(address) {\n        try {\n            new _solana_web3_js__WEBPACK_IMPORTED_MODULE_6__.PublicKey(address);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n    const handleClick = async (event)=>{\n        event.preventDefault(); // Prevent the default form submission behavior\n        if (walletAddress && user) {\n            // Save the wallet address to the user context and Supabase\n            const validate = isValidSolanaAddress(walletAddress);\n            if (validate) {\n                await updateUserWalletAddress(walletAddress);\n                setWalletStatus(\"Saved\"); // Update the wallet status to 'Saved'\n            } else {\n                setWalletStatus(\"Invalid Address\");\n            }\n        }\n    };\n    const handleSubmit = async (event)=>{\n        event.preventDefault();\n        // Get the form data from the input fields\n        const name = event.target.elements.name.value;\n        const price = parseInt(event.target.elements[\"price\"].value.replace(/\\$/g, \"\"));\n        const wallet = user.user_metadata.walletAddress;\n        const link = (0,uuid__WEBPACK_IMPORTED_MODULE_7__.v4)().substr(0, 10);\n        const user_uid = user.id;\n        try {\n            const formData = {\n                name,\n                price,\n                wallet,\n                link,\n                user_uid\n            };\n            // Insert the form data into the merchants table\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.from(\"merchants\").insert([\n                formData\n            ]);\n            if (error) {\n                console.error(\"Error saving data:\", error);\n                setFormStatus(\"Error\");\n            } else {\n                //console.log('Data saved successfully:', data);\n                setFormStatus(\"Success\");\n                setDirectory([\n                    ...directory,\n                    formData\n                ]); // Update the directory with the new form data\n                createList();\n                setTimeout(()=>{\n                    setFormStatus(\"Submit\"); // Reset the status back to 'Submit' after a delay\n                }, 1000);\n            }\n        } catch (error) {\n            console.error(\"Error saving data:\", error);\n            setFormStatus(\"Error\");\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        if (user) {\n            createList();\n        }\n    }, [\n        user\n    ]);\n    const createList = async ()=>{\n        try {\n            const { data, error } = await _supabase__WEBPACK_IMPORTED_MODULE_4__.supabase.from(\"merchants\").select(\"*\").eq(\"user_uid\", user.id).order(\"created_at\", {\n                ascending: false\n            }); // Sort by 'created_at' in descending order (newest to oldest)\n            if (error) {\n                console.error(\"Error fetching data:\", error);\n            } else {\n                setDirectory(data);\n            }\n        } catch (error) {\n            console.error(\"Error fetching data:\", error);\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"max-h-screen\",\n        children: [\n            user && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute top-4 right-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                    className: \"bg-[#344154] px-4 py-2 rounded-md text-white font-semibold text-sm ml-auto\",\n                    onClick: handleLogout,\n                    children: \"Logout\"\n                }, void 0, false, {\n                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                    lineNumber: 109,\n                    columnNumber: 21\n                }, this)\n            }, void 0, false, {\n                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                lineNumber: 108,\n                columnNumber: 17\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"grid grid-cols-1 lg:grid-cols-2 px-6 md:px-24 lg:px-0 py-10 lg:py-30 lg:mt-16\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"grid row-span-1 lg:col-span-1 mt-12 mx-auto lg:mx-16\",\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                className: \"text-4xl lg:text-5xl text-white font-bold text-center\",\n                                children: \"Get Paid in SPL Tokens\"\n                            }, void 0, false, {\n                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                lineNumber: 120,\n                                columnNumber: 21\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"img\", {\n                                className: \"w-full lg:object-cover\",\n                                src: \"/qr.png\",\n                                alt: \"QR Code\"\n                            }, void 0, false, {\n                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                lineNumber: 123,\n                                columnNumber: 21\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                        lineNumber: 119,\n                        columnNumber: 17\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"mt-12 mx-8 lg:mx-16 grid row-span-1 lg:col-span-1\",\n                        children: [\n                            !user && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n                                                className: \"text-3xl text-center lg:text-left text-white font-bold\",\n                                                children: \"Get started now\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                lineNumber: 130,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                className: \"text-white my-2 text-center lg:text-left \",\n                                                children: \"Enter your credentials to access your account\"\n                                            }, void 0, false, {\n                                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                lineNumber: 131,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 129,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_supabase_auth_ui_react__WEBPACK_IMPORTED_MODULE_8__.Auth, {\n                                        supabaseClient: _supabase__WEBPACK_IMPORTED_MODULE_4__.supabase,\n                                        theme: \"dark\",\n                                        appearance: {\n                                            theme: _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_2__.ThemeSupa,\n                                            variables: {\n                                                default: {\n                                                    colors: {\n                                                        brand: \"#303C4D\",\n                                                        brandAccent: \"#303C4D\"\n                                                    }\n                                                }\n                                            }\n                                        },\n                                        providers: [\n                                            \"github\"\n                                        ]\n                                    }, void 0, false, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 133,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                lineNumber: 128,\n                                columnNumber: 25\n                            }, this),\n                            user && !user.user_metadata.walletAddress && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"flex flex-col item-center text-center\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                            className: \"text-left text-2xl text-white mb-6\",\n                                            children: \"Wallet to receive payments.\"\n                                        }, void 0, false, {\n                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                            lineNumber: 154,\n                                            columnNumber: 33\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 153,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                                        onSubmit: handleClick,\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                className: \" bg-[#344154] relative rounded-md px-3 pb-1.5 pt-2.5 ring-1 ring-inset ring-gray-300 focus-within:z-10 outline-0 border-0 focus:ring-0 focus:ring-offset-0 focus:outline-0 \",\n                                                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                    type: \"text\",\n                                                    name: \"wallet\",\n                                                    id: \"wallet\",\n                                                    className: \"text-xl bg-[#344154] block w-full border-0 p-0 text-white placeholder:text-gray-400 focus:ring-0 \",\n                                                    placeholder: \"7AFi...NeX\",\n                                                    value: walletAddress,\n                                                    onChange: (e)=>setWalletAddress(e.target.value)\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                    lineNumber: 158,\n                                                    columnNumber: 37\n                                                }, this)\n                                            }, void 0, false, {\n                                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                lineNumber: 157,\n                                                columnNumber: 33\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                className: \"mt-3 items-center bg-[#344154] hover:bg-[#303C4D] ease-in duration-100 px-4 py-3 mb-4 text-md lg:text-sm text-white shadow-sm rounded-md w-full\",\n                                                onClick: handleClick,\n                                                children: walletStatus\n                                            }, void 0, false, {\n                                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                lineNumber: 168,\n                                                columnNumber: 33\n                                            }, this)\n                                        ]\n                                    }, void 0, true, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 156,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                lineNumber: 152,\n                                columnNumber: 25\n                            }, this),\n                            user && user.user_metadata.walletAddress && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                        className: \"text-bold text-xl text-white mb-1\",\n                                        children: \"Sell Something\"\n                                    }, void 0, false, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 181,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"isolate -space-y-px rounded-md shadow-sm\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                                            onSubmit: handleSubmit,\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \" bg-[#344154] relative rounded-md rounded-b-none px-3 pb-1.5 pt-2.5 ring-1 ring-inset ring-gray-300 focus-within:z-10 outline-0 border-0 focus:ring-0 focus:ring-offset-0 focus:outline-0 \",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                            htmlFor: \"name\",\n                                                            className: \"block text-xs font-medium text-white\",\n                                                            children: \"Name\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                            lineNumber: 185,\n                                                            columnNumber: 41\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                            type: \"text\",\n                                                            name: \"name\",\n                                                            id: \"name\",\n                                                            className: \"text-xl bg-[#344154] block w-full border-0 p-0 text-white placeholder:text-gray-400 outline-0 border-0 focus:ring-0 focus:ring-offset-0 focus:outline-0 \",\n                                                            placeholder: \"Icecream\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                            lineNumber: 188,\n                                                            columnNumber: 41\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                    lineNumber: 184,\n                                                    columnNumber: 37\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                    className: \" bg-[#344154] relative rounded-md rounded-t-none px-3 pb-1.5 pt-2.5 ring-1 ring-inset ring-gray-300 focus-within:z-10 outline-0 border-0 focus:ring-0 focus:ring-offset-0 focus:outline-0 \",\n                                                    children: [\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                                            htmlFor: \"price\",\n                                                            className: \"block text-xs font-medium text-white\",\n                                                            children: \"Price\"\n                                                        }, void 0, false, {\n                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                            lineNumber: 197,\n                                                            columnNumber: 41\n                                                        }, this),\n                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                            className: \"flex rounded-md shadow-sm \",\n                                                            children: [\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                                    className: \"mr-1 text-xl bg-[#344154] border-0 p-0 text-gray-400 outline-0 border-0 focus:ring-0 focus:ring-offset-0 focus:outline-0 \",\n                                                                    children: \"$\"\n                                                                }, void 0, false, {\n                                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                    lineNumber: 201,\n                                                                    columnNumber: 45\n                                                                }, this),\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                                    type: \"text\",\n                                                                    name: \"price\",\n                                                                    id: \"price\",\n                                                                    className: \"text-xl bg-[#344154] block w-full border-0 p-0 text-white placeholder:text-gray-400 outline-0 border-0 focus:ring-0 focus:ring-offset-0 focus:outline-0\",\n                                                                    placeholder: \"5\"\n                                                                }, void 0, false, {\n                                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                    lineNumber: 206,\n                                                                    columnNumber: 45\n                                                                }, this)\n                                                            ]\n                                                        }, void 0, true, {\n                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                            lineNumber: 200,\n                                                            columnNumber: 41\n                                                        }, this)\n                                                    ]\n                                                }, void 0, true, {\n                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                    lineNumber: 196,\n                                                    columnNumber: 37\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                                                    type: \"submit\",\n                                                    className: \"mt-3 items-center bg-[#344154] hover:bg-[#303C4D] ease-in duration-100 px-4 py-3 mb-4 text-md lg:text-sm text-white shadow-sm rounded-md w-full\",\n                                                    onSubmit: handleSubmit,\n                                                    children: formStatus\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                    lineNumber: 215,\n                                                    columnNumber: 37\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                            lineNumber: 183,\n                                            columnNumber: 33\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 182,\n                                        columnNumber: 29\n                                    }, this),\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                        className: \"h-80 mt-2\",\n                                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"nav\", {\n                                            className: \"ring-1 ring-inset ring-gray-300 rounded-2xl border-white h-full overflow-y-auto\",\n                                            \"aria-label\": \"Directory\",\n                                            children: [\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                                                    className: \"text-bold text-xl text-white pl-4 pt-2\",\n                                                    children: \"Your Links\"\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                    lineNumber: 227,\n                                                    columnNumber: 37\n                                                }, this),\n                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                                                    role: \"list\",\n                                                    className: \"divide-y divide-gray-100/10 px-4\",\n                                                    children: directory.map((merchant)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                                            className: \"flex gap-x-4 px-3 py-5\",\n                                                            children: [\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                    className: \"flex-grow\",\n                                                                    children: [\n                                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                                            className: \"text-sm font-semibold leading-6 text-white\",\n                                                                            children: merchant.name\n                                                                        }, void 0, false, {\n                                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                            lineNumber: 234,\n                                                                            columnNumber: 53\n                                                                        }, this),\n                                                                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                                                            className: \"mt-1 truncate text-sm leading-5 text-gray-500\",\n                                                                            children: [\n                                                                                \"$\",\n                                                                                merchant.price\n                                                                            ]\n                                                                        }, void 0, true, {\n                                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                            lineNumber: 235,\n                                                                            columnNumber: 53\n                                                                        }, this)\n                                                                    ]\n                                                                }, void 0, true, {\n                                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                    lineNumber: 233,\n                                                                    columnNumber: 49\n                                                                }, this),\n                                                                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                                                    className: \"flex flex-col items-center justify-center\",\n                                                                    children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)((next_link__WEBPACK_IMPORTED_MODULE_5___default()), {\n                                                                        href: \"/checkout/\".concat(merchant.link),\n                                                                        className: \"text-sm font-semibold leading-6 text-white\",\n                                                                        children: \"Visit Checkout\"\n                                                                    }, void 0, false, {\n                                                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                        lineNumber: 238,\n                                                                        columnNumber: 53\n                                                                    }, this)\n                                                                }, void 0, false, {\n                                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                                    lineNumber: 237,\n                                                                    columnNumber: 49\n                                                                }, this)\n                                                            ]\n                                                        }, merchant.link, true, {\n                                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                            lineNumber: 232,\n                                                            columnNumber: 45\n                                                        }, this))\n                                                }, void 0, false, {\n                                                    fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                                    lineNumber: 230,\n                                                    columnNumber: 37\n                                                }, this)\n                                            ]\n                                        }, void 0, true, {\n                                            fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                            lineNumber: 226,\n                                            columnNumber: 33\n                                        }, this)\n                                    }, void 0, false, {\n                                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                        lineNumber: 225,\n                                        columnNumber: 29\n                                    }, this)\n                                ]\n                            }, void 0, true, {\n                                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                                lineNumber: 180,\n                                columnNumber: 25\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                        lineNumber: 126,\n                        columnNumber: 17\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n                lineNumber: 117,\n                columnNumber: 13\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/hunterstein/opos/src/components/Home.tsx\",\n        lineNumber: 106,\n        columnNumber: 9\n    }, this);\n}\n_s(Home, \"n0LCWDTe0CiCGJV7MMwERj7h0Is=\");\n_c = Home;\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Ozs7Ozs7Ozs7Ozs7OzhEQUl4Qiw4REFBQ3JCO29EQUNHb0IsTUFBSztvREFDTHJCLFdBQVU7b0RBQ1ZtQixVQUFVN0M7OERBRVRmOzs7Ozs7Ozs7Ozs7Ozs7OztrREFLYiw4REFBQ3dDO3dDQUFJQyxXQUFVO2tEQUNYLDRFQUFDNEI7NENBQUk1QixXQUFVOzRDQUFrRjZCLGNBQVc7OzhEQUN4Ryw4REFBQ1o7b0RBQUdqQixXQUFVOzhEQUF5Qzs7Ozs7OzhEQUd2RCw4REFBQzhCO29EQUFHQyxNQUFLO29EQUFPL0IsV0FBVTs4REFDckJyQyxVQUFVcUUsR0FBRyxDQUFDLENBQUNDLHlCQUNaLDhEQUFDQzs0REFBdUJsQyxXQUFVOzs4RUFDOUIsOERBQUNEO29FQUFJQyxXQUFVOztzRkFDWCw4REFBQ087NEVBQUVQLFdBQVU7c0ZBQThDaUMsU0FBUzFELElBQUk7Ozs7OztzRkFDeEUsOERBQUNnQzs0RUFBRVAsV0FBVTs7Z0ZBQWdEO2dGQUFFaUMsU0FBU3RELEtBQUs7Ozs7Ozs7Ozs7Ozs7OEVBRWpGLDhEQUFDb0I7b0VBQUlDLFdBQVU7OEVBQ1gsNEVBQUMvQyxrREFBSUE7d0VBQUNrRixNQUFNLGFBQTJCLE9BQWRGLFNBQVNqRCxJQUFJO3dFQUFJZ0IsV0FBVTtrRkFBNkM7Ozs7Ozs7Ozs7OzsyREFOaEdpQyxTQUFTakQsSUFBSTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBcUJsRTtHQW5Qd0I3QjtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvY29tcG9uZW50cy9Ib21lLnRzeD8xNTAxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBBdXRoIH0gZnJvbSAnQHN1cGFiYXNlL2F1dGgtdWktcmVhY3QnXG5pbXBvcnQgeyBUaGVtZVN1cGEgfSBmcm9tICdAc3VwYWJhc2UvYXV0aC11aS1zaGFyZWQnXG5pbXBvcnQgeyBVc2VyQ29udGV4dCB9IGZyb20gJy4uL2NvbnRleHRzL1VzZXJDb250ZXh0JzsgLy8gSW1wb3J0IHRoZSBVc2VyQ29udGV4dFxuaW1wb3J0IHsgdjQgYXMgdXVpZHY0IH0gZnJvbSAndXVpZCc7XG5pbXBvcnQgeyBzdXBhYmFzZSB9IGZyb20gJy4uLy4uL3N1cGFiYXNlJztcbmltcG9ydCBMaW5rIGZyb20gXCJuZXh0L2xpbmtcIjtcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSG9tZSgpIHtcbiAgICBjb25zdCB7IHVzZXIsIHVwZGF0ZVVzZXJXYWxsZXRBZGRyZXNzLCBoYW5kbGVMb2dvdXQgfSA9IHVzZUNvbnRleHQoVXNlckNvbnRleHQpOyAvLyBBY2Nlc3MgdGhlIHVzZXIgY29udGV4dCB1c2luZyB1c2VDb250ZXh0XG4gICAgY29uc3QgW2Zvcm1TdGF0dXMsIHNldEZvcm1TdGF0dXNdID0gdXNlU3RhdGUoJ1N1Ym1pdCcpOyAvLyBTdGF0ZSB0byBtYW5hZ2UgdGhlIGZvcm0gc3VibWlzc2lvbiBzdGF0dXNcbiAgICBjb25zdCBbd2FsbGV0U3RhdHVzLCBzZXRXYWxsZXRTdGF0dXNdID0gdXNlU3RhdGUoJ1N1Ym1pdCcpOyAvLyBTdGF0ZSB0byBtYW5hZ2UgdGhlIGZvcm0gc3VibWlzc2lvbiBzdGF0dXNcbiAgICBjb25zdCBbZGlyZWN0b3J5LCBzZXREaXJlY3RvcnldID0gdXNlU3RhdGUoW10pO1xuICAgIGNvbnN0IFt3YWxsZXRBZGRyZXNzLCBzZXRXYWxsZXRBZGRyZXNzXSA9IHVzZVN0YXRlKCcnKTtcbiAgICAvL2NvbnNvbGUubG9nKHVzZXIpXG4gICAgZnVuY3Rpb24gaXNWYWxpZFNvbGFuYUFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IFB1YmxpY0tleShhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaGFuZGxlQ2xpY2sgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCB0aGUgZGVmYXVsdCBmb3JtIHN1Ym1pc3Npb24gYmVoYXZpb3JcbiAgICAgICAgaWYgKHdhbGxldEFkZHJlc3MgJiYgdXNlcikge1xuICAgICAgICAgICAgLy8gU2F2ZSB0aGUgd2FsbGV0IGFkZHJlc3MgdG8gdGhlIHVzZXIgY29udGV4dCBhbmQgU3VwYWJhc2VcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlID0gaXNWYWxpZFNvbGFuYUFkZHJlc3Mod2FsbGV0QWRkcmVzcylcbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHVwZGF0ZVVzZXJXYWxsZXRBZGRyZXNzKHdhbGxldEFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIHNldFdhbGxldFN0YXR1cygnU2F2ZWQnKTsgLy8gVXBkYXRlIHRoZSB3YWxsZXQgc3RhdHVzIHRvICdTYXZlZCdcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0V2FsbGV0U3RhdHVzKCdJbnZhbGlkIEFkZHJlc3MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBmb3JtIGRhdGEgZnJvbSB0aGUgaW5wdXQgZmllbGRzXG4gICAgICAgIGNvbnN0IG5hbWUgPSBldmVudC50YXJnZXQuZWxlbWVudHMubmFtZS52YWx1ZTtcbiAgICAgICAgY29uc3QgcHJpY2UgPSBwYXJzZUludChldmVudC50YXJnZXQuZWxlbWVudHNbJ3ByaWNlJ10udmFsdWUucmVwbGFjZSgvXFwkL2csICcnKSk7XG4gICAgICAgIGNvbnN0IHdhbGxldCA9IHVzZXIudXNlcl9tZXRhZGF0YS53YWxsZXRBZGRyZXNzO1xuICAgICAgICBjb25zdCBsaW5rID0gdXVpZHY0KCkuc3Vic3RyKDAsIDEwKTtcbiAgICAgICAgY29uc3QgdXNlcl91aWQgPSB1c2VyLmlkO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmb3JtRGF0YSA9IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHByaWNlLFxuICAgICAgICAgICAgICAgIHdhbGxldCxcbiAgICAgICAgICAgICAgICBsaW5rLFxuICAgICAgICAgICAgICAgIHVzZXJfdWlkLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBmb3JtIGRhdGEgaW50byB0aGUgbWVyY2hhbnRzIHRhYmxlXG4gICAgICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgICAgICAgIC5mcm9tKCdtZXJjaGFudHMnKVxuICAgICAgICAgICAgICAgIC5pbnNlcnQoW2Zvcm1EYXRhXSk7XG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBzZXRGb3JtU3RhdHVzKCdFcnJvcicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKCdEYXRhIHNhdmVkIHN1Y2Nlc3NmdWxseTonLCBkYXRhKTtcbiAgICAgICAgICAgICAgICBzZXRGb3JtU3RhdHVzKCdTdWNjZXNzJyk7XG4gICAgICAgICAgICAgICAgc2V0RGlyZWN0b3J5KFsuLi5kaXJlY3RvcnksIGZvcm1EYXRhXSk7IC8vIFVwZGF0ZSB0aGUgZGlyZWN0b3J5IHdpdGggdGhlIG5ldyBmb3JtIGRhdGFcbiAgICAgICAgICAgICAgICBjcmVhdGVMaXN0KCk7IFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBzZXRGb3JtU3RhdHVzKCdTdWJtaXQnKTsgLy8gUmVzZXQgdGhlIHN0YXR1cyBiYWNrIHRvICdTdWJtaXQnIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgICAgICB9LCAxMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgICAgIHNldEZvcm1TdGF0dXMoJ0Vycm9yJyk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHVzZXIpIHtcbiAgICAgICAgICAgIGNyZWF0ZUxpc3QoKTtcbiAgICAgICAgfVxuICAgIH0sIFt1c2VyXSk7XG5cbiAgICBjb25zdCBjcmVhdGVMaXN0ID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgeyBkYXRhLCBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAgICAgICAuZnJvbSgnbWVyY2hhbnRzJylcbiAgICAgICAgICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgICAgICAgICAuZXEoJ3VzZXJfdWlkJywgdXNlci5pZClcbiAgICAgICAgICAgICAgICAub3JkZXIoJ2NyZWF0ZWRfYXQnLCB7IGFzY2VuZGluZzogZmFsc2UgfSk7IC8vIFNvcnQgYnkgJ2NyZWF0ZWRfYXQnIGluIGRlc2NlbmRpbmcgb3JkZXIgKG5ld2VzdCB0byBvbGRlc3QpXG5cbiAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIGRhdGE6JywgZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXREaXJlY3RvcnkoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBmZXRjaGluZyBkYXRhOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm1heC1oLXNjcmVlblwiPlxuICAgICAgICAgICAge3VzZXIgJiYgKFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgdG9wLTQgcmlnaHQtNFwiPlxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJiZy1bIzM0NDE1NF0gcHgtNCBweS0yIHJvdW5kZWQtbWQgdGV4dC13aGl0ZSBmb250LXNlbWlib2xkIHRleHQtc20gbWwtYXV0b1wiXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNsaWNrPXtoYW5kbGVMb2dvdXR9XG4gICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgIExvZ291dFxuICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICl9XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgZ3JpZC1jb2xzLTEgbGc6Z3JpZC1jb2xzLTIgcHgtNiBtZDpweC0yNCBsZzpweC0wIHB5LTEwIGxnOnB5LTMwIGxnOm10LTE2XCI+XG4gICAgICAgICAgICAgICAgey8qIExlZnQgU2VjdGlvbiAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImdyaWQgcm93LXNwYW4tMSBsZzpjb2wtc3Bhbi0xIG10LTEyIG14LWF1dG8gbGc6bXgtMTZcIj5cbiAgICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtNHhsIGxnOnRleHQtNXhsIHRleHQtd2hpdGUgZm9udC1ib2xkIHRleHQtY2VudGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICBHZXQgUGFpZCBpbiBTUEwgVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIDwvaDE+XG4gICAgICAgICAgICAgICAgICAgIDxpbWcgY2xhc3NOYW1lPVwidy1mdWxsIGxnOm9iamVjdC1jb3ZlclwiIHNyYz1cIi9xci5wbmdcIiBhbHQ9XCJRUiBDb2RlXCIgLz5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICB7LyogUmlnaHQgU2VjdGlvbiAqL31cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIm10LTEyIG14LTggbGc6bXgtMTYgZ3JpZCByb3ctc3Bhbi0xIGxnOmNvbC1zcGFuLTFcIj5cbiAgICAgICAgICAgICAgICAgICAgeyF1c2VyICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGgxIGNsYXNzTmFtZT1cInRleHQtM3hsIHRleHQtY2VudGVyIGxnOnRleHQtbGVmdCB0ZXh0LXdoaXRlIGZvbnQtYm9sZFwiPkdldCBzdGFydGVkIG5vdzwvaDE+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtd2hpdGUgbXktMiB0ZXh0LWNlbnRlciBsZzp0ZXh0LWxlZnQgXCI+RW50ZXIgeW91ciBjcmVkZW50aWFscyB0byBhY2Nlc3MgeW91ciBhY2NvdW50PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxBdXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1cGFiYXNlQ2xpZW50PXtzdXBhYmFzZX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU9XCJkYXJrXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZWFyYW5jZT17e1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlbWU6IFRoZW1lU3VwYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3JzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFuZDogJyMzMDNDNEQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhbmRBY2NlbnQ6ICcjMzAzQzREJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXJzPXtbJ2dpdGh1YiddfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgKX1cbiAgICAgICAgICAgICAgICAgICAge3VzZXIgJiYgIXVzZXIudXNlcl9tZXRhZGF0YS53YWxsZXRBZGRyZXNzICYmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtLWNlbnRlciB0ZXh0LWNlbnRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoMiBjbGFzc05hbWU9XCJ0ZXh0LWxlZnQgdGV4dC0yeGwgdGV4dC13aGl0ZSBtYi02XCI+V2FsbGV0IHRvIHJlY2VpdmUgcGF5bWVudHMuPC9oMj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlQ2xpY2t9PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiBiZy1bIzM0NDE1NF0gcmVsYXRpdmUgcm91bmRlZC1tZCBweC0zIHBiLTEuNSBwdC0yLjUgcmluZy0xIHJpbmctaW5zZXQgcmluZy1ncmF5LTMwMCBmb2N1cy13aXRoaW46ei0xMCBvdXRsaW5lLTAgYm9yZGVyLTAgZm9jdXM6cmluZy0wIGZvY3VzOnJpbmctb2Zmc2V0LTAgZm9jdXM6b3V0bGluZS0wIFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cInRleHRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJ3YWxsZXRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkPVwid2FsbGV0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXhsIGJnLVsjMzQ0MTU0XSBibG9jayB3LWZ1bGwgYm9yZGVyLTAgcC0wIHRleHQtd2hpdGUgcGxhY2Vob2xkZXI6dGV4dC1ncmF5LTQwMCBmb2N1czpyaW5nLTAgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIjdBRmkuLi5OZVhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlPXt3YWxsZXRBZGRyZXNzfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2hhbmdlPXsoZSkgPT4gc2V0V2FsbGV0QWRkcmVzcyhlLnRhcmdldC52YWx1ZSl9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtMyBpdGVtcy1jZW50ZXIgYmctWyMzNDQxNTRdIGhvdmVyOmJnLVsjMzAzQzREXSBlYXNlLWluIGR1cmF0aW9uLTEwMCBweC00IHB5LTMgbWItNCB0ZXh0LW1kIGxnOnRleHQtc20gdGV4dC13aGl0ZSBzaGFkb3ctc20gcm91bmRlZC1tZCB3LWZ1bGxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25DbGljaz17aGFuZGxlQ2xpY2t9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt3YWxsZXRTdGF0dXN9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cblxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICl9XG4gICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAge3VzZXIgJiYgdXNlci51c2VyX21ldGFkYXRhLndhbGxldEFkZHJlc3MgJiYgKFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1ib2xkIHRleHQteGwgdGV4dC13aGl0ZSBtYi0xXCI+U2VsbCBTb21ldGhpbmc8L2gyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaXNvbGF0ZSAtc3BhY2UteS1weCByb3VuZGVkLW1kIHNoYWRvdy1zbVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0fT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiIGJnLVsjMzQ0MTU0XSByZWxhdGl2ZSByb3VuZGVkLW1kIHJvdW5kZWQtYi1ub25lIHB4LTMgcGItMS41IHB0LTIuNSByaW5nLTEgcmluZy1pbnNldCByaW5nLWdyYXktMzAwIGZvY3VzLXdpdGhpbjp6LTEwIG91dGxpbmUtMCBib3JkZXItMCBmb2N1czpyaW5nLTAgZm9jdXM6cmluZy1vZmZzZXQtMCBmb2N1czpvdXRsaW5lLTAgXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsIGh0bWxGb3I9XCJuYW1lXCIgY2xhc3NOYW1lPVwiYmxvY2sgdGV4dC14cyBmb250LW1lZGl1bSB0ZXh0LXdoaXRlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIE5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJuYW1lXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lPVwidGV4dC14bCBiZy1bIzM0NDE1NF0gYmxvY2sgdy1mdWxsIGJvcmRlci0wIHAtMCB0ZXh0LXdoaXRlIHBsYWNlaG9sZGVyOnRleHQtZ3JheS00MDAgb3V0bGluZS0wIGJvcmRlci0wIGZvY3VzOnJpbmctMCBmb2N1czpyaW5nLW9mZnNldC0wIGZvY3VzOm91dGxpbmUtMCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcj1cIkljZWNyZWFtXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cIiBiZy1bIzM0NDE1NF0gcmVsYXRpdmUgcm91bmRlZC1tZCByb3VuZGVkLXQtbm9uZSBweC0zIHBiLTEuNSBwdC0yLjUgcmluZy0xIHJpbmctaW5zZXQgcmluZy1ncmF5LTMwMCBmb2N1cy13aXRoaW46ei0xMCBvdXRsaW5lLTAgYm9yZGVyLTAgZm9jdXM6cmluZy0wIGZvY3VzOnJpbmctb2Zmc2V0LTAgZm9jdXM6b3V0bGluZS0wIFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbCBodG1sRm9yPVwicHJpY2VcIiBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXhzIGZvbnQtbWVkaXVtIHRleHQtd2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUHJpY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCByb3VuZGVkLW1kIHNoYWRvdy1zbSBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzTmFtZT1cIm1yLTEgdGV4dC14bCBiZy1bIzM0NDE1NF0gYm9yZGVyLTAgcC0wIHRleHQtZ3JheS00MDAgb3V0bGluZS0wIGJvcmRlci0wIGZvY3VzOnJpbmctMCBmb2N1czpyaW5nLW9mZnNldC0wIGZvY3VzOm91dGxpbmUtMCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwidGV4dFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lPVwicHJpY2VcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ9XCJwcmljZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJ0ZXh0LXhsIGJnLVsjMzQ0MTU0XSBibG9jayB3LWZ1bGwgYm9yZGVyLTAgcC0wIHRleHQtd2hpdGUgcGxhY2Vob2xkZXI6dGV4dC1ncmF5LTQwMCBvdXRsaW5lLTAgYm9yZGVyLTAgZm9jdXM6cmluZy0wIGZvY3VzOnJpbmctb2Zmc2V0LTAgZm9jdXM6b3V0bGluZS0wXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyPVwiNVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlPVwic3VibWl0XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0zIGl0ZW1zLWNlbnRlciBiZy1bIzM0NDE1NF0gaG92ZXI6YmctWyMzMDNDNERdIGVhc2UtaW4gZHVyYXRpb24tMTAwIHB4LTQgcHktMyBtYi00IHRleHQtbWQgbGc6dGV4dC1zbSB0ZXh0LXdoaXRlIHNoYWRvdy1zbSByb3VuZGVkLW1kIHctZnVsbFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7Zm9ybVN0YXR1c31cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImgtODAgbXQtMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bmF2IGNsYXNzTmFtZT1cInJpbmctMSByaW5nLWluc2V0IHJpbmctZ3JheS0zMDAgcm91bmRlZC0yeGwgYm9yZGVyLXdoaXRlIGgtZnVsbCBvdmVyZmxvdy15LWF1dG9cIiBhcmlhLWxhYmVsPVwiRGlyZWN0b3J5XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDIgY2xhc3NOYW1lPVwidGV4dC1ib2xkIHRleHQteGwgdGV4dC13aGl0ZSBwbC00IHB0LTJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBZb3VyIExpbmtzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2gyPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIHJvbGU9XCJsaXN0XCIgY2xhc3NOYW1lPVwiZGl2aWRlLXkgZGl2aWRlLWdyYXktMTAwLzEwIHB4LTRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7ZGlyZWN0b3J5Lm1hcCgobWVyY2hhbnQpID0+IChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpIGtleT17bWVyY2hhbnQubGlua30gY2xhc3NOYW1lPVwiZmxleCBnYXAteC00IHB4LTMgcHktNVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJmbGV4LWdyb3dcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgbGVhZGluZy02IHRleHQtd2hpdGVcIj57bWVyY2hhbnQubmFtZX08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwibXQtMSB0cnVuY2F0ZSB0ZXh0LXNtIGxlYWRpbmctNSB0ZXh0LWdyYXktNTAwXCI+JHttZXJjaGFudC5wcmljZX08L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiZmxleCBmbGV4LWNvbCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8TGluayBocmVmPXtgL2NoZWNrb3V0LyR7bWVyY2hhbnQubGlua31gfSBjbGFzc05hbWU9XCJ0ZXh0LXNtIGZvbnQtc2VtaWJvbGQgbGVhZGluZy02IHRleHQtd2hpdGVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVmlzaXQgQ2hlY2tvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L0xpbms+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbmF2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICApfSBcbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICApXG59Il0sIm5hbWVzIjpbIlJlYWN0IiwidXNlQ29udGV4dCIsInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiQXV0aCIsIlRoZW1lU3VwYSIsIlVzZXJDb250ZXh0IiwidjQiLCJ1dWlkdjQiLCJzdXBhYmFzZSIsIkxpbmsiLCJQdWJsaWNLZXkiLCJIb21lIiwidXNlciIsInVwZGF0ZVVzZXJXYWxsZXRBZGRyZXNzIiwiaGFuZGxlTG9nb3V0IiwiZm9ybVN0YXR1cyIsInNldEZvcm1TdGF0dXMiLCJ3YWxsZXRTdGF0dXMiLCJzZXRXYWxsZXRTdGF0dXMiLCJkaXJlY3RvcnkiLCJzZXREaXJlY3RvcnkiLCJ3YWxsZXRBZGRyZXNzIiwic2V0V2FsbGV0QWRkcmVzcyIsImlzVmFsaWRTb2xhbmFBZGRyZXNzIiwiYWRkcmVzcyIsImVycm9yIiwiaGFuZGxlQ2xpY2siLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwidmFsaWRhdGUiLCJoYW5kbGVTdWJtaXQiLCJuYW1lIiwidGFyZ2V0IiwiZWxlbWVudHMiLCJ2YWx1ZSIsInByaWNlIiwicGFyc2VJbnQiLCJyZXBsYWNlIiwid2FsbGV0IiwidXNlcl9tZXRhZGF0YSIsImxpbmsiLCJzdWJzdHIiLCJ1c2VyX3VpZCIsImlkIiwiZm9ybURhdGEiLCJkYXRhIiwiZnJvbSIsImluc2VydCIsImNvbnNvbGUiLCJjcmVhdGVMaXN0Iiwic2V0VGltZW91dCIsInNlbGVjdCIsImVxIiwib3JkZXIiLCJhc2NlbmRpbmciLCJkaXYiLCJjbGFzc05hbWUiLCJidXR0b24iLCJvbkNsaWNrIiwiaDEiLCJpbWciLCJzcmMiLCJhbHQiLCJwIiwic3VwYWJhc2VDbGllbnQiLCJ0aGVtZSIsImFwcGVhcmFuY2UiLCJ2YXJpYWJsZXMiLCJkZWZhdWx0IiwiY29sb3JzIiwiYnJhbmQiLCJicmFuZEFjY2VudCIsInByb3ZpZGVycyIsImgyIiwiZm9ybSIsIm9uU3VibWl0IiwiaW5wdXQiLCJ0eXBlIiwicGxhY2Vob2xkZXIiLCJvbkNoYW5nZSIsImUiLCJsYWJlbCIsImh0bWxGb3IiLCJzcGFuIiwibmF2IiwiYXJpYS1sYWJlbCIsInVsIiwicm9sZSIsIm1hcCIsIm1lcmNoYW50IiwibGkiLCJocmVmIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/components/Home.tsx\n"));

/***/ }),

/***/ "./src/pages/index.tsx":
/*!*****************************!*\
  !*** ./src/pages/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _views__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../views */ \"./src/views/index.tsx\");\n\n\nconst Home = (props)=>{\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_views__WEBPACK_IMPORTED_MODULE_1__.HomeView, {}, void 0, false, {\n            fileName: \"/Users/hunterstein/opos/src/pages/index.tsx\",\n            lineNumber: 7,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false);\n};\n_c = Home;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Home);\nvar _c;\n$RefreshReg$(_c, \"Home\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvcGFnZXMvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7O0FBQ29DO0FBRXBDLE1BQU1DLE9BQWlCLENBQUNDO0lBQ3RCLHFCQUNFO2tCQUNFLDRFQUFDRiw0Q0FBUUE7Ozs7OztBQUdmO0tBTk1DO0FBUU4sK0RBQWVBLElBQUlBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3BhZ2VzL2luZGV4LnRzeD8xOWEwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB0eXBlIHsgTmV4dFBhZ2UgfSBmcm9tIFwibmV4dFwiO1xuaW1wb3J0IHsgSG9tZVZpZXcgfSBmcm9tIFwiLi4vdmlld3NcIjtcblxuY29uc3QgSG9tZTogTmV4dFBhZ2UgPSAocHJvcHMpID0+IHtcbiAgcmV0dXJuIChcbiAgICA8PlxuICAgICAgPEhvbWVWaWV3IC8+XG4gICAgPC8+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBIb21lOyBcbiJdLCJuYW1lcyI6WyJIb21lVmlldyIsIkhvbWUiLCJwcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/pages/index.tsx\n"));

/***/ }),

/***/ "./src/views/home/index.tsx":
/*!**********************************!*\
  !*** ./src/views/home/index.tsx ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HomeView: function() { return /* binding */ HomeView; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _components_Home__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../components/Home */ \"./src/components/Home.tsx\");\n// Next, React\n\n\nconst HomeView = (param)=>{\n    let {} = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Home__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {}, void 0, false, {\n            fileName: \"/Users/hunterstein/opos/src/views/home/index.tsx\",\n            lineNumber: 9,\n            columnNumber: 5\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/hunterstein/opos/src/views/home/index.tsx\",\n        lineNumber: 8,\n        columnNumber: 3\n    }, undefined);\n};\n_c = HomeView;\nvar _c;\n$RefreshReg$(_c, \"HomeView\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvaG9tZS9pbmRleC50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBLGNBQWM7O0FBRTJCO0FBQ2xDLE1BQU1DLFdBQWU7UUFBQyxFQUFHO0lBRWhDLHFCQUVFLDhEQUFDQztrQkFDQyw0RUFBQ0Ysd0RBQUlBOzs7Ozs7Ozs7O0FBSVQsRUFBRTtLQVRXQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdmlld3MvaG9tZS9pbmRleC50c3g/NzRiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBOZXh0LCBSZWFjdFxuaW1wb3J0IHsgRkMsIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgSG9tZSBmcm9tICcuLi8uLi9jb21wb25lbnRzL0hvbWUnO1xuZXhwb3J0IGNvbnN0IEhvbWVWaWV3OiBGQyA9ICh7IH0pID0+IHtcblxucmV0dXJuIChcbiAgXG4gIDxkaXY+ICAgXG4gICAgPEhvbWUvPlxuICA8L2Rpdj5cblxuKTtcbn07XG4iXSwibmFtZXMiOlsiSG9tZSIsIkhvbWVWaWV3IiwiZGl2Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/views/home/index.tsx\n"));

/***/ }),

/***/ "./src/views/index.tsx":
/*!*****************************!*\
  !*** ./src/views/index.tsx ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HomeView: function() { return /* reexport safe */ _home__WEBPACK_IMPORTED_MODULE_0__.HomeView; }\n/* harmony export */ });\n/* harmony import */ var _home__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./home */ \"./src/views/home/index.tsx\");\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvdmlld3MvaW5kZXgudHN4IiwibWFwcGluZ3MiOiI7Ozs7O0FBQWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy92aWV3cy9pbmRleC50c3g/Y2Y0MiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBIb21lVmlldyB9IGZyb20gXCIuL2hvbWVcIiJdLCJuYW1lcyI6WyJIb21lVmlldyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/views/index.tsx\n"));

/***/ }),

/***/ "./node_modules/next/link.js":
/*!***********************************!*\
  !*** ./node_modules/next/link.js ***!
  \***********************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("module.exports = __webpack_require__(/*! ./dist/client/link */ \"./node_modules/next/dist/client/link.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzIiwibWFwcGluZ3MiOiJBQUFBLHlHQUE4QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9saW5rLmpzPzc1YjMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Rpc3QvY2xpZW50L2xpbmsnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/link.js\n"));

/***/ }),

/***/ "./node_modules/rpc-websockets/dist/lib/client.js":
/*!********************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/lib/client.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nvar _regenerator = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/regenerator */ \"./node_modules/@babel/runtime/regenerator/index.js\"));\n\nvar _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"./node_modules/@babel/runtime/helpers/asyncToGenerator.js\"));\n\nvar _typeof2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/typeof */ \"./node_modules/@babel/runtime/helpers/typeof.js\"));\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _eventemitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar __rest = void 0 && (void 0).__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}; // @ts-ignore\n\n\nvar CommonClient = /*#__PURE__*/function (_EventEmitter) {\n  (0, _inherits2[\"default\"])(CommonClient, _EventEmitter);\n\n  var _super = _createSuper(CommonClient);\n\n  /**\n   * Instantiate a Client class.\n   * @constructor\n   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n   * @param {String} address - url to a websocket server\n   * @param {Object} options - ws options object with reconnect parameters\n   * @param {Function} generate_request_id - custom generation request Id\n   * @return {CommonClient}\n   */\n  function CommonClient(webSocketFactory) {\n    var _this;\n\n    var address = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ws://localhost:8080\";\n\n    var _a = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    var generate_request_id = arguments.length > 3 ? arguments[3] : undefined;\n    (0, _classCallCheck2[\"default\"])(this, CommonClient);\n\n    var _a$autoconnect = _a.autoconnect,\n        autoconnect = _a$autoconnect === void 0 ? true : _a$autoconnect,\n        _a$reconnect = _a.reconnect,\n        reconnect = _a$reconnect === void 0 ? true : _a$reconnect,\n        _a$reconnect_interval = _a.reconnect_interval,\n        reconnect_interval = _a$reconnect_interval === void 0 ? 1000 : _a$reconnect_interval,\n        _a$max_reconnects = _a.max_reconnects,\n        max_reconnects = _a$max_reconnects === void 0 ? 5 : _a$max_reconnects,\n        rest_options = __rest(_a, [\"autoconnect\", \"reconnect\", \"reconnect_interval\", \"max_reconnects\"]);\n\n    _this = _super.call(this);\n    _this.webSocketFactory = webSocketFactory;\n    _this.queue = {};\n    _this.rpc_id = 0;\n    _this.address = address;\n    _this.autoconnect = autoconnect;\n    _this.ready = false;\n    _this.reconnect = reconnect;\n    _this.reconnect_timer_id = undefined;\n    _this.reconnect_interval = reconnect_interval;\n    _this.max_reconnects = max_reconnects;\n    _this.rest_options = rest_options;\n    _this.current_reconnects = 0;\n\n    _this.generate_request_id = generate_request_id || function () {\n      return ++_this.rpc_id;\n    };\n\n    if (_this.autoconnect) _this._connect(_this.address, Object.assign({\n      autoconnect: _this.autoconnect,\n      reconnect: _this.reconnect,\n      reconnect_interval: _this.reconnect_interval,\n      max_reconnects: _this.max_reconnects\n    }, _this.rest_options));\n    return _this;\n  }\n  /**\n   * Connects to a defined server if not connected already.\n   * @method\n   * @return {Undefined}\n   */\n\n\n  (0, _createClass2[\"default\"])(CommonClient, [{\n    key: \"connect\",\n    value: function connect() {\n      if (this.socket) return;\n\n      this._connect(this.address, Object.assign({\n        autoconnect: this.autoconnect,\n        reconnect: this.reconnect,\n        reconnect_interval: this.reconnect_interval,\n        max_reconnects: this.max_reconnects\n      }, this.rest_options));\n    }\n    /**\n     * Calls a registered RPC method on server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object|Array} params - optional method parameters\n     * @param {Number} timeout - RPC reply timeout value\n     * @param {Object} ws_opts - options passed to ws\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(method, params, timeout, ws_opts) {\n      var _this2 = this;\n\n      if (!ws_opts && \"object\" === (0, _typeof2[\"default\"])(timeout)) {\n        ws_opts = timeout;\n        timeout = null;\n      }\n\n      return new Promise(function (resolve, reject) {\n        if (!_this2.ready) return reject(new Error(\"socket not ready\"));\n\n        var rpc_id = _this2.generate_request_id(method, params);\n\n        var message = {\n          jsonrpc: \"2.0\",\n          method: method,\n          params: params || null,\n          id: rpc_id\n        };\n\n        _this2.socket.send(JSON.stringify(message), ws_opts, function (error) {\n          if (error) return reject(error);\n          _this2.queue[rpc_id] = {\n            promise: [resolve, reject]\n          };\n\n          if (timeout) {\n            _this2.queue[rpc_id].timeout = setTimeout(function () {\n              delete _this2.queue[rpc_id];\n              reject(new Error(\"reply timeout\"));\n            }, timeout);\n          }\n        });\n      });\n    }\n    /**\n     * Logins with the other side of the connection.\n     * @method\n     * @param {Object} params - Login credentials object\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"login\",\n    value: function () {\n      var _login = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee(params) {\n        var resp;\n        return _regenerator[\"default\"].wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this.call(\"rpc.login\", params);\n\n              case 2:\n                resp = _context.sent;\n\n                if (resp) {\n                  _context.next = 5;\n                  break;\n                }\n\n                throw new Error(\"authentication failed\");\n\n              case 5:\n                return _context.abrupt(\"return\", resp);\n\n              case 6:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function login(_x) {\n        return _login.apply(this, arguments);\n      }\n\n      return login;\n    }()\n    /**\n     * Fetches a list of client's methods registered on server.\n     * @method\n     * @return {Array}\n     */\n\n  }, {\n    key: \"listMethods\",\n    value: function () {\n      var _listMethods = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee2() {\n        return _regenerator[\"default\"].wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.call(\"__listMethods\");\n\n              case 2:\n                return _context2.abrupt(\"return\", _context2.sent);\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function listMethods() {\n        return _listMethods.apply(this, arguments);\n      }\n\n      return listMethods;\n    }()\n    /**\n     * Sends a JSON-RPC 2.0 notification to server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object} params - optional method parameters\n     * @return {Promise}\n     */\n\n  }, {\n    key: \"notify\",\n    value: function notify(method, params) {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        if (!_this3.ready) return reject(new Error(\"socket not ready\"));\n        var message = {\n          jsonrpc: \"2.0\",\n          method: method,\n          params: params || null\n        };\n\n        _this3.socket.send(JSON.stringify(message), function (error) {\n          if (error) return reject(error);\n          resolve();\n        });\n      });\n    }\n    /**\n     * Subscribes for a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function () {\n      var _subscribe = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee3(event) {\n        var result;\n        return _regenerator[\"default\"].wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                if (typeof event === \"string\") event = [event];\n                _context3.next = 3;\n                return this.call(\"rpc.on\", event);\n\n              case 3:\n                result = _context3.sent;\n\n                if (!(typeof event === \"string\" && result[event] !== \"ok\")) {\n                  _context3.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n\n              case 6:\n                return _context3.abrupt(\"return\", result);\n\n              case 7:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this);\n      }));\n\n      function subscribe(_x2) {\n        return _subscribe.apply(this, arguments);\n      }\n\n      return subscribe;\n    }()\n    /**\n     * Unsubscribes from a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n\n  }, {\n    key: \"unsubscribe\",\n    value: function () {\n      var _unsubscribe = (0, _asyncToGenerator2[\"default\"])( /*#__PURE__*/_regenerator[\"default\"].mark(function _callee4(event) {\n        var result;\n        return _regenerator[\"default\"].wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                if (typeof event === \"string\") event = [event];\n                _context4.next = 3;\n                return this.call(\"rpc.off\", event);\n\n              case 3:\n                result = _context4.sent;\n\n                if (!(typeof event === \"string\" && result[event] !== \"ok\")) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                throw new Error(\"Failed unsubscribing from an event with: \" + result);\n\n              case 6:\n                return _context4.abrupt(\"return\", result);\n\n              case 7:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this);\n      }));\n\n      function unsubscribe(_x3) {\n        return _unsubscribe.apply(this, arguments);\n      }\n\n      return unsubscribe;\n    }()\n    /**\n     * Closes a WebSocket connection gracefully.\n     * @method\n     * @param {Number} code - socket close code\n     * @param {String} data - optional data to be sent before closing\n     * @return {Undefined}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(code, data) {\n      this.socket.close(code || 1000, data);\n    }\n    /**\n     * Connection/Message handler.\n     * @method\n     * @private\n     * @param {String} address - WebSocket API address\n     * @param {Object} options - ws options object\n     * @return {Undefined}\n     */\n\n  }, {\n    key: \"_connect\",\n    value: function _connect(address, options) {\n      var _this4 = this;\n\n      clearTimeout(this.reconnect_timer_id);\n      this.socket = this.webSocketFactory(address, options);\n      this.socket.addEventListener(\"open\", function () {\n        _this4.ready = true;\n\n        _this4.emit(\"open\");\n\n        _this4.current_reconnects = 0;\n      });\n      this.socket.addEventListener(\"message\", function (_ref) {\n        var message = _ref.data;\n        if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n\n        try {\n          message = JSON.parse(message);\n        } catch (error) {\n          return;\n        } // check if any listeners are attached and forward event\n\n\n        if (message.notification && _this4.listeners(message.notification).length) {\n          if (!Object.keys(message.params).length) return _this4.emit(message.notification);\n          var args = [message.notification];\n          if (message.params.constructor === Object) args.push(message.params);else // using for-loop instead of unshift/spread because performance is better\n            for (var i = 0; i < message.params.length; i++) {\n              args.push(message.params[i]);\n            } // run as microtask so that pending queue messages are resolved first\n          // eslint-disable-next-line prefer-spread\n\n          return Promise.resolve().then(function () {\n            _this4.emit.apply(_this4, args);\n          });\n        }\n\n        if (!_this4.queue[message.id]) {\n          // general JSON RPC 2.0 events\n          if (message.method && message.params) {\n            // run as microtask so that pending queue messages are resolved first\n            return Promise.resolve().then(function () {\n              _this4.emit(message.method, message.params);\n            });\n          }\n\n          return;\n        } // reject early since server's response is invalid\n\n\n        if (\"error\" in message === \"result\" in message) _this4.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" + \" or \\\"error\\\", but not both.\"));\n        if (_this4.queue[message.id].timeout) clearTimeout(_this4.queue[message.id].timeout);\n        if (message.error) _this4.queue[message.id].promise[1](message.error);else _this4.queue[message.id].promise[0](message.result);\n        delete _this4.queue[message.id];\n      });\n      this.socket.addEventListener(\"error\", function (error) {\n        return _this4.emit(\"error\", error);\n      });\n      this.socket.addEventListener(\"close\", function (_ref2) {\n        var code = _ref2.code,\n            reason = _ref2.reason;\n        if (_this4.ready) // Delay close event until internal state is updated\n          setTimeout(function () {\n            return _this4.emit(\"close\", code, reason);\n          }, 0);\n        _this4.ready = false;\n        _this4.socket = undefined;\n        if (code === 1000) return;\n        _this4.current_reconnects++;\n        if (_this4.reconnect && (_this4.max_reconnects > _this4.current_reconnects || _this4.max_reconnects === 0)) _this4.reconnect_timer_id = setTimeout(function () {\n          return _this4._connect(address, options);\n        }, _this4.reconnect_interval);\n      });\n    }\n  }]);\n  return CommonClient;\n}(_eventemitter.EventEmitter);\n\nexports[\"default\"] = CommonClient;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsb0hBQThDOztBQUVuRiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLDBDQUEwQyxtQkFBTyxDQUFDLHNGQUE0Qjs7QUFFOUUsZ0RBQWdELG1CQUFPLENBQUMsMEdBQXlDOztBQUVqRyxzQ0FBc0MsbUJBQU8sQ0FBQyxzRkFBK0I7O0FBRTdFLDhDQUE4QyxtQkFBTyxDQUFDLHNHQUF1Qzs7QUFFN0YsMkNBQTJDLG1CQUFPLENBQUMsZ0dBQW9DOztBQUV2Rix3Q0FBd0MsbUJBQU8sQ0FBQywwRkFBaUM7O0FBRWpGLHlEQUF5RCxtQkFBTyxDQUFDLDRIQUFrRDs7QUFFbkgsOENBQThDLG1CQUFPLENBQUMsc0dBQXVDOztBQUU3RixvQkFBb0IsbUJBQU8sQ0FBQyw0REFBZTs7QUFFM0MsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsK0RBQStELGlDQUFpQyxvRUFBb0UsMkRBQTJELE9BQU8seUNBQXlDOztBQUV0Wix1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDRIQUE0SCxjQUFjO0FBQzFJO0FBQ0E7QUFDQTtBQUNBLEdBQUc7OztBQUdIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0IsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QU87QUFDUDtBQUNBO0FBQ0Esc0RBQXNELE1BQU07O0FBRTVEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0UsNEJBQTRCLDJCQUEyQjtBQUN2RDtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuanM/NTUzOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFwiQ2xpZW50XCIgd3JhcHMgXCJ3c1wiIG9yIGEgYnJvd3Nlci1pbXBsZW1lbnRlZCBcIldlYlNvY2tldFwiIGxpYnJhcnlcbiAqIGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgcHJvdmlkaW5nIEpTT04gUlBDIDIuMCBzdXBwb3J0IG9uIHRvcC5cbiAqIEBtb2R1bGUgQ2xpZW50XG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2ludGVyb3BSZXF1aXJlRGVmYXVsdCA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2ludGVyb3BSZXF1aXJlRGVmYXVsdFwiKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7XG4gIHZhbHVlOiB0cnVlXG59KTtcbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gdm9pZCAwO1xuXG52YXIgX3JlZ2VuZXJhdG9yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3JcIikpO1xuXG52YXIgX2FzeW5jVG9HZW5lcmF0b3IyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yXCIpKTtcblxudmFyIF90eXBlb2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2ZcIikpO1xuXG52YXIgX2NsYXNzQ2FsbENoZWNrMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY2xhc3NDYWxsQ2hlY2tcIikpO1xuXG52YXIgX2NyZWF0ZUNsYXNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvY3JlYXRlQ2xhc3NcIikpO1xuXG52YXIgX2luaGVyaXRzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW5oZXJpdHNcIikpO1xuXG52YXIgX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4yID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuXCIpKTtcblxudmFyIF9nZXRQcm90b3R5cGVPZjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mXCIpKTtcblxudmFyIF9ldmVudGVtaXR0ZXIgPSByZXF1aXJlKFwiZXZlbnRlbWl0dGVyM1wiKTtcblxuZnVuY3Rpb24gX2NyZWF0ZVN1cGVyKERlcml2ZWQpIHsgdmFyIGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCk7IHJldHVybiBmdW5jdGlvbiBfY3JlYXRlU3VwZXJJbnRlcm5hbCgpIHsgdmFyIFN1cGVyID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKShEZXJpdmVkKSwgcmVzdWx0OyBpZiAoaGFzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCkgeyB2YXIgTmV3VGFyZ2V0ID0gKDAsIF9nZXRQcm90b3R5cGVPZjJbXCJkZWZhdWx0XCJdKSh0aGlzKS5jb25zdHJ1Y3RvcjsgcmVzdWx0ID0gUmVmbGVjdC5jb25zdHJ1Y3QoU3VwZXIsIGFyZ3VtZW50cywgTmV3VGFyZ2V0KTsgfSBlbHNlIHsgcmVzdWx0ID0gU3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTsgfSByZXR1cm4gKDAsIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMltcImRlZmF1bHRcIl0pKHRoaXMsIHJlc3VsdCk7IH07IH1cblxuZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHsgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlOyBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlOyBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlOyB0cnkgeyBCb29sZWFuLnByb3RvdHlwZS52YWx1ZU9mLmNhbGwoUmVmbGVjdC5jb25zdHJ1Y3QoQm9vbGVhbiwgW10sIGZ1bmN0aW9uICgpIHt9KSk7IHJldHVybiB0cnVlOyB9IGNhdGNoIChlKSB7IHJldHVybiBmYWxzZTsgfSB9XG5cbnZhciBfX3Jlc3QgPSB2b2lkIDAgJiYgKHZvaWQgMCkuX19yZXN0IHx8IGZ1bmN0aW9uIChzLCBlKSB7XG4gIHZhciB0ID0ge307XG5cbiAgZm9yICh2YXIgcCBpbiBzKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKSB0W3BdID0gc1twXTtcbiAgfVxuXG4gIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIikgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSkgdFtwW2ldXSA9IHNbcFtpXV07XG4gIH1cbiAgcmV0dXJuIHQ7XG59OyAvLyBAdHMtaWdub3JlXG5cblxudmFyIENvbW1vbkNsaWVudCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0V2ZW50RW1pdHRlcikge1xuICAoMCwgX2luaGVyaXRzMltcImRlZmF1bHRcIl0pKENvbW1vbkNsaWVudCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihDb21tb25DbGllbnQpO1xuXG4gIC8qKlxuICAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBwYXJhbSB7d2ViU29ja2V0RmFjdG9yeX0gd2ViU29ja2V0RmFjdG9yeSAtIGZhY3RvcnkgbWV0aG9kIGZvciBXZWJTb2NrZXRcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3Mgb3B0aW9ucyBvYmplY3Qgd2l0aCByZWNvbm5lY3QgcGFyYW1ldGVyc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnZW5lcmF0ZV9yZXF1ZXN0X2lkIC0gY3VzdG9tIGdlbmVyYXRpb24gcmVxdWVzdCBJZFxuICAgKiBAcmV0dXJuIHtDb21tb25DbGllbnR9XG4gICAqL1xuICBmdW5jdGlvbiBDb21tb25DbGllbnQod2ViU29ja2V0RmFjdG9yeSkge1xuICAgIHZhciBfdGhpcztcblxuICAgIHZhciBhZGRyZXNzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcIndzOi8vbG9jYWxob3N0OjgwODBcIjtcblxuICAgIHZhciBfYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICB2YXIgZ2VuZXJhdGVfcmVxdWVzdF9pZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgICgwLCBfY2xhc3NDYWxsQ2hlY2syW1wiZGVmYXVsdFwiXSkodGhpcywgQ29tbW9uQ2xpZW50KTtcblxuICAgIHZhciBfYSRhdXRvY29ubmVjdCA9IF9hLmF1dG9jb25uZWN0LFxuICAgICAgICBhdXRvY29ubmVjdCA9IF9hJGF1dG9jb25uZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX2EkYXV0b2Nvbm5lY3QsXG4gICAgICAgIF9hJHJlY29ubmVjdCA9IF9hLnJlY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0ID0gX2EkcmVjb25uZWN0ID09PSB2b2lkIDAgPyB0cnVlIDogX2EkcmVjb25uZWN0LFxuICAgICAgICBfYSRyZWNvbm5lY3RfaW50ZXJ2YWwgPSBfYS5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbCA9IF9hJHJlY29ubmVjdF9pbnRlcnZhbCA9PT0gdm9pZCAwID8gMTAwMCA6IF9hJHJlY29ubmVjdF9pbnRlcnZhbCxcbiAgICAgICAgX2EkbWF4X3JlY29ubmVjdHMgPSBfYS5tYXhfcmVjb25uZWN0cyxcbiAgICAgICAgbWF4X3JlY29ubmVjdHMgPSBfYSRtYXhfcmVjb25uZWN0cyA9PT0gdm9pZCAwID8gNSA6IF9hJG1heF9yZWNvbm5lY3RzLFxuICAgICAgICByZXN0X29wdGlvbnMgPSBfX3Jlc3QoX2EsIFtcImF1dG9jb25uZWN0XCIsIFwicmVjb25uZWN0XCIsIFwicmVjb25uZWN0X2ludGVydmFsXCIsIFwibWF4X3JlY29ubmVjdHNcIl0pO1xuXG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICBfdGhpcy5xdWV1ZSA9IHt9O1xuICAgIF90aGlzLnJwY19pZCA9IDA7XG4gICAgX3RoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgX3RoaXMuYXV0b2Nvbm5lY3QgPSBhdXRvY29ubmVjdDtcbiAgICBfdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgIF90aGlzLnJlY29ubmVjdCA9IHJlY29ubmVjdDtcbiAgICBfdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgPSB1bmRlZmluZWQ7XG4gICAgX3RoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgIF90aGlzLm1heF9yZWNvbm5lY3RzID0gbWF4X3JlY29ubmVjdHM7XG4gICAgX3RoaXMucmVzdF9vcHRpb25zID0gcmVzdF9vcHRpb25zO1xuICAgIF90aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG5cbiAgICBfdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkID0gZ2VuZXJhdGVfcmVxdWVzdF9pZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gKytfdGhpcy5ycGNfaWQ7XG4gICAgfTtcblxuICAgIGlmIChfdGhpcy5hdXRvY29ubmVjdCkgX3RoaXMuX2Nvbm5lY3QoX3RoaXMuYWRkcmVzcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICBhdXRvY29ubmVjdDogX3RoaXMuYXV0b2Nvbm5lY3QsXG4gICAgICByZWNvbm5lY3Q6IF90aGlzLnJlY29ubmVjdCxcbiAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogX3RoaXMucmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgbWF4X3JlY29ubmVjdHM6IF90aGlzLm1heF9yZWNvbm5lY3RzXG4gICAgfSwgX3RoaXMucmVzdF9vcHRpb25zKSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBDb25uZWN0cyB0byBhIGRlZmluZWQgc2VydmVyIGlmIG5vdCBjb25uZWN0ZWQgYWxyZWFkeS5cbiAgICogQG1ldGhvZFxuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShDb21tb25DbGllbnQsIFt7XG4gICAga2V5OiBcImNvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29ubmVjdCgpIHtcbiAgICAgIGlmICh0aGlzLnNvY2tldCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jb25uZWN0KHRoaXMuYWRkcmVzcywgT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0aGlzLmF1dG9jb25uZWN0LFxuICAgICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IHRoaXMucmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogdGhpcy5tYXhfcmVjb25uZWN0c1xuICAgICAgfSwgdGhpcy5yZXN0X29wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbHMgYSByZWdpc3RlcmVkIFJQQyBtZXRob2Qgb24gc2VydmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gUlBDIG1ldGhvZCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHBhcmFtcyAtIG9wdGlvbmFsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgLSBSUEMgcmVwbHkgdGltZW91dCB2YWx1ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB3c19vcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gd3NcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2FsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjYWxsKG1ldGhvZCwgcGFyYW1zLCB0aW1lb3V0LCB3c19vcHRzKSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgaWYgKCF3c19vcHRzICYmIFwib2JqZWN0XCIgPT09ICgwLCBfdHlwZW9mMltcImRlZmF1bHRcIl0pKHRpbWVvdXQpKSB7XG4gICAgICAgIHdzX29wdHMgPSB0aW1lb3V0O1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFfdGhpczIucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG5cbiAgICAgICAgdmFyIHJwY19pZCA9IF90aGlzMi5nZW5lcmF0ZV9yZXF1ZXN0X2lkKG1ldGhvZCwgcGFyYW1zKTtcblxuICAgICAgICB2YXIgbWVzc2FnZSA9IHtcbiAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgIHBhcmFtczogcGFyYW1zIHx8IG51bGwsXG4gICAgICAgICAgaWQ6IHJwY19pZFxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzMi5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgd3Nfb3B0cywgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICBfdGhpczIucXVldWVbcnBjX2lkXSA9IHtcbiAgICAgICAgICAgIHByb21pc2U6IFtyZXNvbHZlLCByZWplY3RdXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICBfdGhpczIucXVldWVbcnBjX2lkXS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIGRlbGV0ZSBfdGhpczIucXVldWVbcnBjX2lkXTtcbiAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpO1xuICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2dpbnMgd2l0aCB0aGUgb3RoZXIgc2lkZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIExvZ2luIGNyZWRlbnRpYWxzIG9iamVjdFxuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJsb2dpblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX2xvZ2luID0gKDAsIF9hc3luY1RvR2VuZXJhdG9yMltcImRlZmF1bHRcIl0pKCAvKiNfX1BVUkVfXyovX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUocGFyYW1zKSB7XG4gICAgICAgIHZhciByZXNwO1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAyO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGwoXCJycGMubG9naW5cIiwgcGFyYW1zKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmVzcCA9IF9jb250ZXh0LnNlbnQ7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVzcCkge1xuICAgICAgICAgICAgICAgICAgX2NvbnRleHQubmV4dCA9IDU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRoZW50aWNhdGlvbiBmYWlsZWRcIik7XG5cbiAgICAgICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dC5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzcCk7XG5cbiAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICBjYXNlIFwiZW5kXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0LnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsb2dpbihfeCkge1xuICAgICAgICByZXR1cm4gX2xvZ2luLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsb2dpbjtcbiAgICB9KClcbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgbGlzdCBvZiBjbGllbnQncyBtZXRob2RzIHJlZ2lzdGVyZWQgb24gc2VydmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcImxpc3RNZXRob2RzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfbGlzdE1ldGhvZHMgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTIoKSB7XG4gICAgICAgIHJldHVybiBfcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgICAgIHdoaWxlICgxKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9jb250ZXh0Mi5wcmV2ID0gX2NvbnRleHQyLm5leHQpIHtcbiAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIF9jb250ZXh0Mi5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsKFwiX19saXN0TWV0aG9kc1wiKTtcblxuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0Mi5hYnJ1cHQoXCJyZXR1cm5cIiwgX2NvbnRleHQyLnNlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDIuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTIsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiBsaXN0TWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIF9saXN0TWV0aG9kcy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGlzdE1ldGhvZHM7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBKU09OLVJQQyAyLjAgbm90aWZpY2F0aW9uIHRvIHNlcnZlci5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCAtIFJQQyBtZXRob2QgbmFtZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBvcHRpb25hbCBtZXRob2QgcGFyYW1ldGVyc1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogXCJub3RpZnlcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gbm90aWZ5KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgaWYgKCFfdGhpczMucmVhZHkpIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICAgIHZhciBtZXNzYWdlID0ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgcGFyYW1zOiBwYXJhbXMgfHwgbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIF90aGlzMy5zb2NrZXQuc2VuZChKU09OLnN0cmluZ2lmeShtZXNzYWdlKSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgZm9yIGEgZGVmaW5lZCBldmVudC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInN1YnNjcmliZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3N1YnNjcmliZSA9ICgwLCBfYXN5bmNUb0dlbmVyYXRvcjJbXCJkZWZhdWx0XCJdKSggLyojX19QVVJFX18qL19yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhldmVudCkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICByZXR1cm4gX3JlZ2VuZXJhdG9yW1wiZGVmYXVsdFwiXS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgc3dpdGNoIChfY29udGV4dDMucHJldiA9IF9jb250ZXh0My5uZXh0KSB7XG4gICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSBldmVudCA9IFtldmVudF07XG4gICAgICAgICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAzO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGwoXCJycGMub25cIiwgZXZlbnQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBfY29udGV4dDMuc2VudDtcblxuICAgICAgICAgICAgICAgIGlmICghKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIiAmJiByZXN1bHRbZXZlbnRdICE9PSBcIm9rXCIpKSB7XG4gICAgICAgICAgICAgICAgICBfY29udGV4dDMubmV4dCA9IDY7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgc3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgd2l0aDogXCIgKyByZXN1bHRbZXZlbnRdKTtcblxuICAgICAgICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9jb250ZXh0My5hYnJ1cHQoXCJyZXR1cm5cIiwgcmVzdWx0KTtcblxuICAgICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQzLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sIF9jYWxsZWUzLCB0aGlzKTtcbiAgICAgIH0pKTtcblxuICAgICAgZnVuY3Rpb24gc3Vic2NyaWJlKF94Mikge1xuICAgICAgICByZXR1cm4gX3N1YnNjcmliZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gc3Vic2NyaWJlO1xuICAgIH0oKVxuICAgIC8qKlxuICAgICAqIFVuc3Vic2NyaWJlcyBmcm9tIGEgZGVmaW5lZCBldmVudC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiBcInVuc3Vic2NyaWJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdW5zdWJzY3JpYmUgPSAoMCwgX2FzeW5jVG9HZW5lcmF0b3IyW1wiZGVmYXVsdFwiXSkoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JbXCJkZWZhdWx0XCJdLm1hcmsoZnVuY3Rpb24gX2NhbGxlZTQoZXZlbnQpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvcltcImRlZmF1bHRcIl0ud3JhcChmdW5jdGlvbiBfY2FsbGVlNCQoX2NvbnRleHQ0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoX2NvbnRleHQ0LnByZXYgPSBfY29udGV4dDQubmV4dCkge1xuICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIikgZXZlbnQgPSBbZXZlbnRdO1xuICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gMztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jYWxsKFwicnBjLm9mZlwiLCBldmVudCk7XG5cbiAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IF9jb250ZXh0NC5zZW50O1xuXG4gICAgICAgICAgICAgICAgaWYgKCEodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiICYmIHJlc3VsdFtldmVudF0gIT09IFwib2tcIikpIHtcbiAgICAgICAgICAgICAgICAgIF9jb250ZXh0NC5uZXh0ID0gNjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB1bnN1YnNjcmliaW5nIGZyb20gYW4gZXZlbnQgd2l0aDogXCIgKyByZXN1bHQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQ0LmFicnVwdChcInJldHVyblwiLCByZXN1bHQpO1xuXG4gICAgICAgICAgICAgIGNhc2UgNzpcbiAgICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBfY29udGV4dDQuc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZTQsIHRoaXMpO1xuICAgICAgfSkpO1xuXG4gICAgICBmdW5jdGlvbiB1bnN1YnNjcmliZShfeDMpIHtcbiAgICAgICAgcmV0dXJuIF91bnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdW5zdWJzY3JpYmU7XG4gICAgfSgpXG4gICAgLyoqXG4gICAgICogQ2xvc2VzIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ3JhY2VmdWxseS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBzb2NrZXQgY2xvc2UgY29kZVxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gb3B0aW9uYWwgZGF0YSB0byBiZSBzZW50IGJlZm9yZSBjbG9zaW5nXG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoY29kZSwgZGF0YSkge1xuICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSB8fCAxMDAwLCBkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdGlvbi9NZXNzYWdlIGhhbmRsZXIuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSBXZWJTb2NrZXQgQVBJIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIHdzIG9wdGlvbnMgb2JqZWN0XG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2Nvbm5lY3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdF90aW1lcl9pZCk7XG4gICAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJvcGVuXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM0LnJlYWR5ID0gdHJ1ZTtcblxuICAgICAgICBfdGhpczQuZW1pdChcIm9wZW5cIik7XG5cbiAgICAgICAgX3RoaXM0LmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICAgIHZhciBtZXNzYWdlID0gX3JlZi5kYXRhO1xuICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSBtZXNzYWdlID0gQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKG1lc3NhZ2UpO1xuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBjaGVjayBpZiBhbnkgbGlzdGVuZXJzIGFyZSBhdHRhY2hlZCBhbmQgZm9yd2FyZCBldmVudFxuXG5cbiAgICAgICAgaWYgKG1lc3NhZ2Uubm90aWZpY2F0aW9uICYmIF90aGlzNC5saXN0ZW5lcnMobWVzc2FnZS5ub3RpZmljYXRpb24pLmxlbmd0aCkge1xuICAgICAgICAgIGlmICghT2JqZWN0LmtleXMobWVzc2FnZS5wYXJhbXMpLmxlbmd0aCkgcmV0dXJuIF90aGlzNC5lbWl0KG1lc3NhZ2Uubm90aWZpY2F0aW9uKTtcbiAgICAgICAgICB2YXIgYXJncyA9IFttZXNzYWdlLm5vdGlmaWNhdGlvbl07XG4gICAgICAgICAgaWYgKG1lc3NhZ2UucGFyYW1zLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtcyk7ZWxzZSAvLyB1c2luZyBmb3ItbG9vcCBpbnN0ZWFkIG9mIHVuc2hpZnQvc3ByZWFkIGJlY2F1c2UgcGVyZm9ybWFuY2UgaXMgYmV0dGVyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2UucGFyYW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGFyZ3MucHVzaChtZXNzYWdlLnBhcmFtc1tpXSk7XG4gICAgICAgICAgICB9IC8vIHJ1biBhcyBtaWNyb3Rhc2sgc28gdGhhdCBwZW5kaW5nIHF1ZXVlIG1lc3NhZ2VzIGFyZSByZXNvbHZlZCBmaXJzdFxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBwcmVmZXItc3ByZWFkXG5cbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpczQuZW1pdC5hcHBseShfdGhpczQsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFfdGhpczQucXVldWVbbWVzc2FnZS5pZF0pIHtcbiAgICAgICAgICAvLyBnZW5lcmFsIEpTT04gUlBDIDIuMCBldmVudHNcbiAgICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QgJiYgbWVzc2FnZS5wYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIHJ1biBhcyBtaWNyb3Rhc2sgc28gdGhhdCBwZW5kaW5nIHF1ZXVlIG1lc3NhZ2VzIGFyZSByZXNvbHZlZCBmaXJzdFxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBfdGhpczQuZW1pdChtZXNzYWdlLm1ldGhvZCwgbWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIHJlamVjdCBlYXJseSBzaW5jZSBzZXJ2ZXIncyByZXNwb25zZSBpcyBpbnZhbGlkXG5cblxuICAgICAgICBpZiAoXCJlcnJvclwiIGluIG1lc3NhZ2UgPT09IFwicmVzdWx0XCIgaW4gbWVzc2FnZSkgX3RoaXM0LnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMV0obmV3IEVycm9yKFwiU2VydmVyIHJlc3BvbnNlIG1hbGZvcm1lZC4gUmVzcG9uc2UgbXVzdCBpbmNsdWRlIGVpdGhlciBcXFwicmVzdWx0XFxcIlwiICsgXCIgb3IgXFxcImVycm9yXFxcIiwgYnV0IG5vdCBib3RoLlwiKSk7XG4gICAgICAgIGlmIChfdGhpczQucXVldWVbbWVzc2FnZS5pZF0udGltZW91dCkgY2xlYXJUaW1lb3V0KF90aGlzNC5xdWV1ZVttZXNzYWdlLmlkXS50aW1lb3V0KTtcbiAgICAgICAgaWYgKG1lc3NhZ2UuZXJyb3IpIF90aGlzNC5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzFdKG1lc3NhZ2UuZXJyb3IpO2Vsc2UgX3RoaXM0LnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMF0obWVzc2FnZS5yZXN1bHQpO1xuICAgICAgICBkZWxldGUgX3RoaXM0LnF1ZXVlW21lc3NhZ2UuaWRdO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBfdGhpczQuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIGZ1bmN0aW9uIChfcmVmMikge1xuICAgICAgICB2YXIgY29kZSA9IF9yZWYyLmNvZGUsXG4gICAgICAgICAgICByZWFzb24gPSBfcmVmMi5yZWFzb247XG4gICAgICAgIGlmIChfdGhpczQucmVhZHkpIC8vIERlbGF5IGNsb3NlIGV2ZW50IHVudGlsIGludGVybmFsIHN0YXRlIGlzIHVwZGF0ZWRcbiAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczQuZW1pdChcImNsb3NlXCIsIGNvZGUsIHJlYXNvbik7XG4gICAgICAgICAgfSwgMCk7XG4gICAgICAgIF90aGlzNC5yZWFkeSA9IGZhbHNlO1xuICAgICAgICBfdGhpczQuc29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoY29kZSA9PT0gMTAwMCkgcmV0dXJuO1xuICAgICAgICBfdGhpczQuY3VycmVudF9yZWNvbm5lY3RzKys7XG4gICAgICAgIGlmIChfdGhpczQucmVjb25uZWN0ICYmIChfdGhpczQubWF4X3JlY29ubmVjdHMgPiBfdGhpczQuY3VycmVudF9yZWNvbm5lY3RzIHx8IF90aGlzNC5tYXhfcmVjb25uZWN0cyA9PT0gMCkpIF90aGlzNC5yZWNvbm5lY3RfdGltZXJfaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM0Ll9jb25uZWN0KGFkZHJlc3MsIG9wdGlvbnMpO1xuICAgICAgICB9LCBfdGhpczQucmVjb25uZWN0X2ludGVydmFsKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gQ29tbW9uQ2xpZW50O1xufShfZXZlbnRlbWl0dGVyLkV2ZW50RW1pdHRlcik7XG5cbmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gQ29tbW9uQ2xpZW50OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/rpc-websockets/dist/lib/client.js\n"));

/***/ }),

/***/ "./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * WebSocket implements a browser-side WebSocket specification.\n * @module Client\n */\n\n\nvar _interopRequireDefault = __webpack_require__(/*! @babel/runtime/helpers/interopRequireDefault */ \"./node_modules/@babel/runtime/helpers/interopRequireDefault.js\");\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = _default;\n\nvar _classCallCheck2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/classCallCheck */ \"./node_modules/@babel/runtime/helpers/classCallCheck.js\"));\n\nvar _createClass2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/createClass */ \"./node_modules/@babel/runtime/helpers/createClass.js\"));\n\nvar _inherits2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/inherits */ \"./node_modules/@babel/runtime/helpers/inherits.js\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/possibleConstructorReturn */ \"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(/*! @babel/runtime/helpers/getPrototypeOf */ \"./node_modules/@babel/runtime/helpers/getPrototypeOf.js\"));\n\nvar _eventemitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2[\"default\"])(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2[\"default\"])(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2[\"default\"])(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nvar WebSocketBrowserImpl = /*#__PURE__*/function (_EventEmitter) {\n  (0, _inherits2[\"default\"])(WebSocketBrowserImpl, _EventEmitter);\n\n  var _super = _createSuper(WebSocketBrowserImpl);\n\n  /** Instantiate a WebSocket class\n   * @constructor\n   * @param {String} address - url to a websocket server\n   * @param {(Object)} options - websocket options\n   * @param {(String|Array)} protocols - a list of protocols\n   * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n   */\n  function WebSocketBrowserImpl(address, options, protocols) {\n    var _this;\n\n    (0, _classCallCheck2[\"default\"])(this, WebSocketBrowserImpl);\n    _this = _super.call(this);\n    _this.socket = new window.WebSocket(address, protocols);\n\n    _this.socket.onopen = function () {\n      return _this.emit(\"open\");\n    };\n\n    _this.socket.onmessage = function (event) {\n      return _this.emit(\"message\", event.data);\n    };\n\n    _this.socket.onerror = function (error) {\n      return _this.emit(\"error\", error);\n    };\n\n    _this.socket.onclose = function (event) {\n      _this.emit(\"close\", event.code, event.reason);\n    };\n\n    return _this;\n  }\n  /**\n   * Sends data through a websocket connection\n   * @method\n   * @param {(String|Object)} data - data to be sent via websocket\n   * @param {Object} optionsOrCallback - ws options\n   * @param {Function} callback - a callback called once the data is sent\n   * @return {Undefined}\n   */\n\n\n  (0, _createClass2[\"default\"])(WebSocketBrowserImpl, [{\n    key: \"send\",\n    value: function send(data, optionsOrCallback, callback) {\n      var cb = callback || optionsOrCallback;\n\n      try {\n        this.socket.send(data);\n        cb();\n      } catch (error) {\n        cb(error);\n      }\n    }\n    /**\n     * Closes an underlying socket\n     * @method\n     * @param {Number} code - status code explaining why the connection is being closed\n     * @param {String} reason - a description why the connection is closing\n     * @return {Undefined}\n     * @throws {Error}\n     */\n\n  }, {\n    key: \"close\",\n    value: function close(code, reason) {\n      this.socket.close(code, reason);\n    }\n  }, {\n    key: \"addEventListener\",\n    value: function addEventListener(type, listener, options) {\n      this.socket.addEventListener(type, listener, options);\n    }\n  }]);\n  return WebSocketBrowserImpl;\n}(_eventemitter.EventEmitter);\n/**\n * factory method for common WebSocket instance\n * @method\n * @param {String} address - url to a websocket server\n * @param {(Object)} options - websocket options\n * @return {Undefined}\n */\n\n\nfunction _default(address, options) {\n  return new WebSocketBrowserImpl(address, options);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50L3dlYnNvY2tldC5icm93c2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIsNkJBQTZCLG1CQUFPLENBQUMsb0hBQThDOztBQUVuRiw4Q0FBNkM7QUFDN0M7QUFDQSxDQUFDLEVBQUM7QUFDRixrQkFBa0I7O0FBRWxCLDhDQUE4QyxtQkFBTyxDQUFDLHNHQUF1Qzs7QUFFN0YsMkNBQTJDLG1CQUFPLENBQUMsZ0dBQW9DOztBQUV2Rix3Q0FBd0MsbUJBQU8sQ0FBQywwRkFBaUM7O0FBRWpGLHlEQUF5RCxtQkFBTyxDQUFDLDRIQUFrRDs7QUFFbkgsOENBQThDLG1CQUFPLENBQUMsc0dBQXVDOztBQUU3RixvQkFBb0IsbUJBQU8sQ0FBQyw0REFBZTs7QUFFM0MsaUNBQWlDLDZEQUE2RCx5Q0FBeUMsK0RBQStELGlDQUFpQyxvRUFBb0UsMkRBQTJELE9BQU8seUNBQXlDOztBQUV0Wix1Q0FBdUMsd0VBQXdFLDBDQUEwQyw4Q0FBOEMsTUFBTSw0RUFBNEUsSUFBSSxlQUFlLFlBQVk7O0FBRXhUO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsYUFBYSxnQkFBZ0I7QUFDN0IsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsY0FBYztBQUNkOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEIsZ0JBQWdCO0FBQ2hCOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFlBQVk7QUFDWjs7O0FBR0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQvd2Vic29ja2V0LmJyb3dzZXIuanM/YjNiYyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFdlYlNvY2tldCBpbXBsZW1lbnRzIGEgYnJvd3Nlci1zaWRlIFdlYlNvY2tldCBzcGVjaWZpY2F0aW9uLlxuICogQG1vZHVsZSBDbGllbnRcbiAqL1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0ID0gcmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0XCIpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHtcbiAgdmFsdWU6IHRydWVcbn0pO1xuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBfZGVmYXVsdDtcblxudmFyIF9jbGFzc0NhbGxDaGVjazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NsYXNzQ2FsbENoZWNrXCIpKTtcblxudmFyIF9jcmVhdGVDbGFzczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzXCIpKTtcblxudmFyIF9pbmhlcml0czIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzXCIpKTtcblxudmFyIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQocmVxdWlyZShcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvcG9zc2libGVDb25zdHJ1Y3RvclJldHVyblwiKSk7XG5cbnZhciBfZ2V0UHJvdG90eXBlT2YyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChyZXF1aXJlKFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZlwiKSk7XG5cbnZhciBfZXZlbnRlbWl0dGVyID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5cbmZ1bmN0aW9uIF9jcmVhdGVTdXBlcihEZXJpdmVkKSB7IHZhciBoYXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpOyByZXR1cm4gZnVuY3Rpb24gX2NyZWF0ZVN1cGVySW50ZXJuYWwoKSB7IHZhciBTdXBlciA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkoRGVyaXZlZCksIHJlc3VsdDsgaWYgKGhhc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QpIHsgdmFyIE5ld1RhcmdldCA9ICgwLCBfZ2V0UHJvdG90eXBlT2YyW1wiZGVmYXVsdFwiXSkodGhpcykuY29uc3RydWN0b3I7IHJlc3VsdCA9IFJlZmxlY3QuY29uc3RydWN0KFN1cGVyLCBhcmd1bWVudHMsIE5ld1RhcmdldCk7IH0gZWxzZSB7IHJlc3VsdCA9IFN1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7IH0gcmV0dXJuICgwLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybjJbXCJkZWZhdWx0XCJdKSh0aGlzLCByZXN1bHQpOyB9OyB9XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7IGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJ1bmRlZmluZWRcIiB8fCAhUmVmbGVjdC5jb25zdHJ1Y3QpIHJldHVybiBmYWxzZTsgaWYgKFJlZmxlY3QuY29uc3RydWN0LnNoYW0pIHJldHVybiBmYWxzZTsgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gdHJ1ZTsgdHJ5IHsgQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpOyByZXR1cm4gdHJ1ZTsgfSBjYXRjaCAoZSkgeyByZXR1cm4gZmFsc2U7IH0gfVxuXG52YXIgV2ViU29ja2V0QnJvd3NlckltcGwgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FdmVudEVtaXR0ZXIpIHtcbiAgKDAsIF9pbmhlcml0czJbXCJkZWZhdWx0XCJdKShXZWJTb2NrZXRCcm93c2VySW1wbCwgX0V2ZW50RW1pdHRlcik7XG5cbiAgdmFyIF9zdXBlciA9IF9jcmVhdGVTdXBlcihXZWJTb2NrZXRCcm93c2VySW1wbCk7XG5cbiAgLyoqIEluc3RhbnRpYXRlIGEgV2ViU29ja2V0IGNsYXNzXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHVybCB0byBhIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICogQHBhcmFtIHsoT2JqZWN0KX0gb3B0aW9ucyAtIHdlYnNvY2tldCBvcHRpb25zXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xBcnJheSl9IHByb3RvY29scyAtIGEgbGlzdCBvZiBwcm90b2NvbHNcbiAgICogQHJldHVybiB7V2ViU29ja2V0QnJvd3NlckltcGx9IC0gcmV0dXJucyBhIFdlYlNvY2tldCBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gV2ViU29ja2V0QnJvd3NlckltcGwoYWRkcmVzcywgb3B0aW9ucywgcHJvdG9jb2xzKSB7XG4gICAgdmFyIF90aGlzO1xuXG4gICAgKDAsIF9jbGFzc0NhbGxDaGVjazJbXCJkZWZhdWx0XCJdKSh0aGlzLCBXZWJTb2NrZXRCcm93c2VySW1wbCk7XG4gICAgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKTtcbiAgICBfdGhpcy5zb2NrZXQgPSBuZXcgd2luZG93LldlYlNvY2tldChhZGRyZXNzLCBwcm90b2NvbHMpO1xuXG4gICAgX3RoaXMuc29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBfdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJtZXNzYWdlXCIsIGV2ZW50LmRhdGEpO1xuICAgIH07XG5cbiAgICBfdGhpcy5zb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgcmV0dXJuIF90aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgfTtcblxuICAgIF90aGlzLnNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBfdGhpcy5lbWl0KFwiY2xvc2VcIiwgZXZlbnQuY29kZSwgZXZlbnQucmVhc29uKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBkYXRhIHRocm91Z2ggYSB3ZWJzb2NrZXQgY29ubmVjdGlvblxuICAgKiBAbWV0aG9kXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xPYmplY3QpfSBkYXRhIC0gZGF0YSB0byBiZSBzZW50IHZpYSB3ZWJzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNPckNhbGxiYWNrIC0gd3Mgb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGEgY2FsbGJhY2sgY2FsbGVkIG9uY2UgdGhlIGRhdGEgaXMgc2VudFxuICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAqL1xuXG5cbiAgKDAsIF9jcmVhdGVDbGFzczJbXCJkZWZhdWx0XCJdKShXZWJTb2NrZXRCcm93c2VySW1wbCwgW3tcbiAgICBrZXk6IFwic2VuZFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZW5kKGRhdGEsIG9wdGlvbnNPckNhbGxiYWNrLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGNiID0gY2FsbGJhY2sgfHwgb3B0aW9uc09yQ2FsbGJhY2s7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSk7XG4gICAgICAgIGNiKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYihlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbiB1bmRlcmx5aW5nIHNvY2tldFxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGJlaW5nIGNsb3NlZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb24gLSBhIGRlc2NyaXB0aW9uIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xvc2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoY29kZSwgcmVhc29uKSB7XG4gICAgICB0aGlzLnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJhZGRFdmVudExpc3RlbmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXIsIG9wdGlvbnMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gV2ViU29ja2V0QnJvd3NlckltcGw7XG59KF9ldmVudGVtaXR0ZXIuRXZlbnRFbWl0dGVyKTtcbi8qKlxuICogZmFjdG9yeSBtZXRob2QgZm9yIGNvbW1vbiBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBtZXRob2RcbiAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gdXJsIHRvIGEgd2Vic29ja2V0IHNlcnZlclxuICogQHBhcmFtIHsoT2JqZWN0KX0gb3B0aW9ucyAtIHdlYnNvY2tldCBvcHRpb25zXG4gKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gKi9cblxuXG5mdW5jdGlvbiBfZGVmYXVsdChhZGRyZXNzLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgV2ViU29ja2V0QnJvd3NlckltcGwoYWRkcmVzcywgb3B0aW9ucyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js\n"));

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4Q0FBUTtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFLGNBQWM7QUFDaEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcz9jZjJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBzYWZlLWJ1ZmZlci4gTUlUIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQnVmZmVyLnByb3RvdHlwZSlcblxuLy8gQ29weSBzdGF0aWMgbWV0aG9kcyBmcm9tIEJ1ZmZlclxuY29weVByb3BzKEJ1ZmZlciwgU2FmZUJ1ZmZlcilcblxuU2FmZUJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGJ1Zi5maWxsKDApXG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoc2l6ZSlcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/safe-buffer/index.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: function() { return /* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   parse: function() { return /* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; },\n/* harmony export */   stringify: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   v1: function() { return /* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   v3: function() { return /* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   v4: function() { return /* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   v5: function() { return /* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   validate: function() { return /* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   version: function() { return /* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"./node_modules/uuid/dist/esm-browser/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"./node_modules/uuid/dist/esm-browser/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"./node_modules/uuid/dist/esm-browser/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"./node_modules/uuid/dist/esm-browser/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"./node_modules/uuid/dist/esm-browser/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUF3QztBQUNBO0FBQ0E7QUFDQTtBQUNFO0FBQ1E7QUFDRTtBQUNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanM/M2M3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBkZWZhdWx0IGFzIHYxIH0gZnJvbSAnLi92MS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHYzIH0gZnJvbSAnLi92My5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY0IH0gZnJvbSAnLi92NC5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHY1IH0gZnJvbSAnLi92NS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIE5JTCB9IGZyb20gJy4vbmlsLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmVyc2lvbiB9IGZyb20gJy4vdmVyc2lvbi5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHZhbGlkYXRlIH0gZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5leHBvcnQgeyBkZWZhdWx0IGFzIHN0cmluZ2lmeSB9IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgcGFyc2UgfSBmcm9tICcuL3BhcnNlLmpzJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/index.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  const output = [];\n  const length32 = input.length * 32;\n  const hexTab = '0123456789abcdef';\n\n  for (let i = 0; i < length32; i += 8) {\n    const x = input[i >> 5] >>> i % 32 & 0xff;\n    const hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  let a = 1732584193;\n  let b = -271733879;\n  let c = -1732584194;\n  let d = 271733878;\n\n  for (let i = 0; i < x.length; i += 16) {\n    const olda = a;\n    const oldb = b;\n    const oldc = c;\n    const oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  const length8 = input.length * 8;\n  const output = new Uint32Array(getOutputLength(length8));\n\n  for (let i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  const lsw = (x & 0xffff) + (y & 0xffff);\n  const msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL21kNS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7O0FBRXJEOztBQUVBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxHQUFHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzP2ZlNGEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEJyb3dzZXItY29tcGF0aWJsZSBKYXZhU2NyaXB0IE1ENVxuICpcbiAqIE1vZGlmaWNhdGlvbiBvZiBKYXZhU2NyaXB0IE1ENVxuICogaHR0cHM6Ly9naXRodWIuY29tL2JsdWVpbXAvSmF2YVNjcmlwdC1NRDVcbiAqXG4gKiBDb3B5cmlnaHQgMjAxMSwgU2ViYXN0aWFuIFRzY2hhblxuICogaHR0cHM6Ly9ibHVlaW1wLm5ldFxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZTpcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlUXG4gKlxuICogQmFzZWQgb25cbiAqIEEgSmF2YVNjcmlwdCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgUlNBIERhdGEgU2VjdXJpdHksIEluYy4gTUQ1IE1lc3NhZ2VcbiAqIERpZ2VzdCBBbGdvcml0aG0sIGFzIGRlZmluZWQgaW4gUkZDIDEzMjEuXG4gKiBWZXJzaW9uIDIuMiBDb3B5cmlnaHQgKEMpIFBhdWwgSm9obnN0b24gMTk5OSAtIDIwMDlcbiAqIE90aGVyIGNvbnRyaWJ1dG9yczogR3JlZyBIb2x0LCBBbmRyZXcgS2VwZXJ0LCBZZG5hciwgTG9zdGluZXRcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBCU0QgTGljZW5zZVxuICogU2VlIGh0dHA6Ly9wYWpob21lLm9yZy51ay9jcnlwdC9tZDUgZm9yIG1vcmUgaW5mby5cbiAqL1xuZnVuY3Rpb24gbWQ1KGJ5dGVzKSB7XG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGNvbnN0IGxlbmd0aDMyID0gaW5wdXQubGVuZ3RoICogMzI7XG4gIGNvbnN0IGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICBjb25zdCB4ID0gaW5wdXRbaSA+PiA1XSA+Pj4gaSAlIDMyICYgMHhmZjtcbiAgICBjb25zdCBoZXggPSBwYXJzZUludChoZXhUYWIuY2hhckF0KHggPj4+IDQgJiAweDBmKSArIGhleFRhYi5jaGFyQXQoeCAmIDB4MGYpLCAxNik7XG4gICAgb3V0cHV0LnB1c2goaGV4KTtcbiAgfVxuXG4gIHJldHVybiBvdXRwdXQ7XG59XG4vKipcbiAqIENhbGN1bGF0ZSBvdXRwdXQgbGVuZ3RoIHdpdGggcGFkZGluZyBhbmQgYml0IGxlbmd0aFxuICovXG5cblxuZnVuY3Rpb24gZ2V0T3V0cHV0TGVuZ3RoKGlucHV0TGVuZ3RoOCkge1xuICByZXR1cm4gKGlucHV0TGVuZ3RoOCArIDY0ID4+PiA5IDw8IDQpICsgMTQgKyAxO1xufVxuLypcbiAqIENhbGN1bGF0ZSB0aGUgTUQ1IG9mIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHMsIGFuZCBhIGJpdCBsZW5ndGguXG4gKi9cblxuXG5mdW5jdGlvbiB3b3Jkc1RvTWQ1KHgsIGxlbikge1xuICAvKiBhcHBlbmQgcGFkZGluZyAqL1xuICB4W2xlbiA+PiA1XSB8PSAweDgwIDw8IGxlbiAlIDMyO1xuICB4W2dldE91dHB1dExlbmd0aChsZW4pIC0gMV0gPSBsZW47XG4gIGxldCBhID0gMTczMjU4NDE5MztcbiAgbGV0IGIgPSAtMjcxNzMzODc5O1xuICBsZXQgYyA9IC0xNzMyNTg0MTk0O1xuICBsZXQgZCA9IDI3MTczMzg3ODtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IHgubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgY29uc3Qgb2xkYSA9IGE7XG4gICAgY29uc3Qgb2xkYiA9IGI7XG4gICAgY29uc3Qgb2xkYyA9IGM7XG4gICAgY29uc3Qgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsZW5ndGg4ID0gaW5wdXQubGVuZ3RoICogODtcbiAgY29uc3Qgb3V0cHV0ID0gbmV3IFVpbnQzMkFycmF5KGdldE91dHB1dExlbmd0aChsZW5ndGg4KSk7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg4OyBpICs9IDgpIHtcbiAgICBvdXRwdXRbaSA+PiA1XSB8PSAoaW5wdXRbaSAvIDhdICYgMHhmZikgPDwgaSAlIDMyO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qXG4gKiBBZGQgaW50ZWdlcnMsIHdyYXBwaW5nIGF0IDJeMzIuIFRoaXMgdXNlcyAxNi1iaXQgb3BlcmF0aW9ucyBpbnRlcm5hbGx5XG4gKiB0byB3b3JrIGFyb3VuZCBidWdzIGluIHNvbWUgSlMgaW50ZXJwcmV0ZXJzLlxuICovXG5cblxuZnVuY3Rpb24gc2FmZUFkZCh4LCB5KSB7XG4gIGNvbnN0IGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgY29uc3QgbXN3ID0gKHggPj4gMTYpICsgKHkgPj4gMTYpICsgKGxzdyA+PiAxNik7XG4gIHJldHVybiBtc3cgPDwgMTYgfCBsc3cgJiAweGZmZmY7XG59XG4vKlxuICogQml0d2lzZSByb3RhdGUgYSAzMi1iaXQgbnVtYmVyIHRvIHRoZSBsZWZ0LlxuICovXG5cblxuZnVuY3Rpb24gYml0Um90YXRlTGVmdChudW0sIGNudCkge1xuICByZXR1cm4gbnVtIDw8IGNudCB8IG51bSA+Pj4gMzIgLSBjbnQ7XG59XG4vKlxuICogVGhlc2UgZnVuY3Rpb25zIGltcGxlbWVudCB0aGUgZm91ciBiYXNpYyBvcGVyYXRpb25zIHRoZSBhbGdvcml0aG0gdXNlcy5cbiAqL1xuXG5cbmZ1bmN0aW9uIG1kNWNtbihxLCBhLCBiLCB4LCBzLCB0KSB7XG4gIHJldHVybiBzYWZlQWRkKGJpdFJvdGF0ZUxlZnQoc2FmZUFkZChzYWZlQWRkKGEsIHEpLCBzYWZlQWRkKHgsIHQpKSwgcyksIGIpO1xufVxuXG5mdW5jdGlvbiBtZDVmZihhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGMgfCB+YiAmIGQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVnZyhhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiAmIGQgfCBjICYgfmQsIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5mdW5jdGlvbiBtZDVoaChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XG4gIHJldHVybiBtZDVjbW4oYiBeIGMgXiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aWkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGMgXiAoYiB8IH5kKSwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IG1kNTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/md5.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/native.js":
/*!******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/native.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\nconst randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\n/* harmony default export */ __webpack_exports__[\"default\"] = ({\n  randomUUID\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL25hdGl2ZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQSwrREFBZTtBQUNmO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL25hdGl2ZS5qcz9lYTc0Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJhbmRvbVVVSUQgPSB0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCAmJiBjcnlwdG8ucmFuZG9tVVVJRC5iaW5kKGNyeXB0byk7XG5leHBvcnQgZGVmYXVsdCB7XG4gIHJhbmRvbVVVSURcbn07Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/native.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL25pbC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsK0RBQWUsc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzPzg0NTUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgJzAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCc7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/nil.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3BhcnNlLmpzIiwibWFwcGluZ3MiOiI7O0FBQXFDOztBQUVyQztBQUNBLE9BQU8sd0RBQVE7QUFDZjtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrREFBZSxLQUFLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcGFyc2UuanM/OWRhOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdmFsaWRhdGUgZnJvbSAnLi92YWxpZGF0ZS5qcyc7XG5cbmZ1bmN0aW9uIHBhcnNlKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICBsZXQgdjtcbiAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/parse.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JlZ2V4LmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxjQUFjLEVBQUUsVUFBVSxFQUFFLGVBQWUsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEdBQUcseUNBQXlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanM/NTg3YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAvXig/OlswLTlhLWZdezh9LVswLTlhLWZdezR9LVsxLTVdWzAtOWEtZl17M30tWzg5YWJdWzAtOWEtZl17M30tWzAtOWEtZl17MTJ9fDAwMDAwMDAwLTAwMDAtMDAwMC0wMDAwLTAwMDAwMDAwMDAwMCkkL2k7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rng; }\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3JuZy5qcz81Mjc2Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuIEluIHRoZSBicm93c2VyIHdlIHRoZXJlZm9yZVxuLy8gcmVxdWlyZSB0aGUgY3J5cHRvIEFQSSBhbmQgZG8gbm90IHN1cHBvcnQgYnVpbHQtaW4gZmFsbGJhY2sgdG8gbG93ZXIgcXVhbGl0eSByYW5kb20gbnVtYmVyXG4vLyBnZW5lcmF0b3JzIChsaWtlIE1hdGgucmFuZG9tKCkpLlxubGV0IGdldFJhbmRvbVZhbHVlcztcbmNvbnN0IHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm5nKCkge1xuICAvLyBsYXp5IGxvYWQgc28gdGhhdCBlbnZpcm9ubWVudHMgdGhhdCBuZWVkIHRvIHBvbHlmaWxsIGhhdmUgYSBjaGFuY2UgdG8gZG8gc29cbiAgaWYgKCFnZXRSYW5kb21WYWx1ZXMpIHtcbiAgICAvLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG8gaW1wbGVtZW50YXRpb24uXG4gICAgZ2V0UmFuZG9tVmFsdWVzID0gdHlwZW9mIGNyeXB0byAhPT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  const K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  const H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    const msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (let i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  const l = bytes.length / 4 + 2;\n  const N = Math.ceil(l / 16);\n  const M = new Array(N);\n\n  for (let i = 0; i < N; ++i) {\n    const arr = new Uint32Array(16);\n\n    for (let j = 0; j < 16; ++j) {\n      arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];\n    }\n\n    M[i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (let i = 0; i < N; ++i) {\n    const W = new Uint32Array(80);\n\n    for (let t = 0; t < 16; ++t) {\n      W[t] = M[i][t];\n    }\n\n    for (let t = 16; t < 80; ++t) {\n      W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);\n    }\n\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n    let e = H[4];\n\n    for (let t = 0; t < 80; ++t) {\n      const s = Math.floor(t / 20);\n      const T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3NoYTEuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFEQUFxRDs7QUFFckQ7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsT0FBTztBQUN6Qjs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixPQUFPO0FBQ3pCOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUEscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsK0RBQWUsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3NoYTEuanM/MWM1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBBZGFwdGVkIGZyb20gQ2hyaXMgVmVuZXNzJyBTSEExIGNvZGUgYXRcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvc2hhMS5odG1sXG5mdW5jdGlvbiBmKHMsIHgsIHksIHopIHtcbiAgc3dpdGNoIChzKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIHggJiB5IF4gfnggJiB6O1xuXG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIHggXiB5IF4gejtcblxuICAgIGNhc2UgMjpcbiAgICAgIHJldHVybiB4ICYgeSBeIHggJiB6IF4geSAmIHo7XG5cbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuICB9XG59XG5cbmZ1bmN0aW9uIFJPVEwoeCwgbikge1xuICByZXR1cm4geCA8PCBuIHwgeCA+Pj4gMzIgLSBuO1xufVxuXG5mdW5jdGlvbiBzaGExKGJ5dGVzKSB7XG4gIGNvbnN0IEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIGNvbnN0IEggPSBbMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMF07XG5cbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBtc2cgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoYnl0ZXMpKTsgLy8gVVRGOCBlc2NhcGVcblxuICAgIGJ5dGVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1zZy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMucHVzaChtc2cuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KGJ5dGVzKSkge1xuICAgIC8vIENvbnZlcnQgQXJyYXktbGlrZSB0byBBcnJheVxuICAgIGJ5dGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYnl0ZXMpO1xuICB9XG5cbiAgYnl0ZXMucHVzaCgweDgwKTtcbiAgY29uc3QgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICBjb25zdCBOID0gTWF0aC5jZWlsKGwgLyAxNik7XG4gIGNvbnN0IE0gPSBuZXcgQXJyYXkoTik7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBOOyArK2kpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tpICogNjQgKyBqICogNF0gPDwgMjQgfCBieXRlc1tpICogNjQgKyBqICogNCArIDFdIDw8IDE2IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbaSAqIDY0ICsgaiAqIDQgKyAzXTtcbiAgICB9XG5cbiAgICBNW2ldID0gYXJyO1xuICB9XG5cbiAgTVtOIC0gMV1bMTRdID0gKGJ5dGVzLmxlbmd0aCAtIDEpICogOCAvIE1hdGgucG93KDIsIDMyKTtcbiAgTVtOIC0gMV1bMTRdID0gTWF0aC5mbG9vcihNW04gLSAxXVsxNF0pO1xuICBNW04gLSAxXVsxNV0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4ICYgMHhmZmZmZmZmZjtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IE47ICsraSkge1xuICAgIGNvbnN0IFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtpXVt0XTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0ID0gMTY7IHQgPCA4MDsgKyt0KSB7XG4gICAgICBXW3RdID0gUk9UTChXW3QgLSAzXSBeIFdbdCAtIDhdIF4gV1t0IC0gMTRdIF4gV1t0IC0gMTZdLCAxKTtcbiAgICB9XG5cbiAgICBsZXQgYSA9IEhbMF07XG4gICAgbGV0IGIgPSBIWzFdO1xuICAgIGxldCBjID0gSFsyXTtcbiAgICBsZXQgZCA9IEhbM107XG4gICAgbGV0IGUgPSBIWzRdO1xuXG4gICAgZm9yIChsZXQgdCA9IDA7IHQgPCA4MDsgKyt0KSB7XG4gICAgICBjb25zdCBzID0gTWF0aC5mbG9vcih0IC8gMjApO1xuICAgICAgY29uc3QgVCA9IFJPVEwoYSwgNSkgKyBmKHMsIGIsIGMsIGQpICsgZSArIEtbc10gKyBXW3RdID4+PiAwO1xuICAgICAgZSA9IGQ7XG4gICAgICBkID0gYztcbiAgICAgIGMgPSBST1RMKGIsIDMwKSA+Pj4gMDtcbiAgICAgIGIgPSBhO1xuICAgICAgYSA9IFQ7XG4gICAgfVxuXG4gICAgSFswXSA9IEhbMF0gKyBhID4+PiAwO1xuICAgIEhbMV0gPSBIWzFdICsgYiA+Pj4gMDtcbiAgICBIWzJdID0gSFsyXSArIGMgPj4+IDA7XG4gICAgSFszXSA9IEhbM10gKyBkID4+PiAwO1xuICAgIEhbNF0gPSBIWzRdICsgZSA+Pj4gMDtcbiAgfVxuXG4gIHJldHVybiBbSFswXSA+PiAyNCAmIDB4ZmYsIEhbMF0gPj4gMTYgJiAweGZmLCBIWzBdID4+IDggJiAweGZmLCBIWzBdICYgMHhmZiwgSFsxXSA+PiAyNCAmIDB4ZmYsIEhbMV0gPj4gMTYgJiAweGZmLCBIWzFdID4+IDggJiAweGZmLCBIWzFdICYgMHhmZiwgSFsyXSA+PiAyNCAmIDB4ZmYsIEhbMl0gPj4gMTYgJiAweGZmLCBIWzJdID4+IDggJiAweGZmLCBIWzJdICYgMHhmZiwgSFszXSA+PiAyNCAmIDB4ZmYsIEhbM10gPj4gMTYgJiAweGZmLCBIWzNdID4+IDggJiAweGZmLCBIWzNdICYgMHhmZiwgSFs0XSA+PiAyNCAmIDB4ZmYsIEhbNF0gPj4gMTYgJiAweGZmLCBIWzRdID4+IDggJiAweGZmLCBIWzRdICYgMHhmZl07XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNoYTE7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/sha1.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   unsafeStringify: function() { return /* binding */ unsafeStringify; }\n/* harmony export */ });\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nfunction unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3N0cmluZ2lmeS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzPzYzMTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbmNvbnN0IGJ5dGVUb0hleCA9IFtdO1xuXG5mb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleC5wdXNoKChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zbGljZSgxKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIC8vIE5vdGU6IEJlIGNhcmVmdWwgZWRpdGluZyB0aGlzIGNvZGUhICBJdCdzIGJlZW4gdHVuZWQgZm9yIHBlcmZvcm1hbmNlXG4gIC8vIGFuZCB3b3JrcyBpbiB3YXlzIHlvdSBtYXkgbm90IGV4cGVjdC4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS91dWlkanMvdXVpZC9wdWxsLzQzNFxuICByZXR1cm4gKGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDJdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgM11dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDVdXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA3XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDhdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMV1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxM11dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAxNV1dKS50b0xvd2VyQ2FzZSgpO1xufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnkoYXJyLCBvZmZzZXQgPSAwKSB7XG4gIGNvbnN0IHV1aWQgPSB1bnNhZmVTdHJpbmdpZnkoYXJyLCBvZmZzZXQpOyAvLyBDb25zaXN0ZW5jeSBjaGVjayBmb3IgdmFsaWQgVVVJRC4gIElmIHRoaXMgdGhyb3dzLCBpdCdzIGxpa2VseSBkdWUgdG8gb25lXG4gIC8vIG9mIHRoZSBmb2xsb3dpbmc6XG4gIC8vIC0gT25lIG9yIG1vcmUgaW5wdXQgYXJyYXkgdmFsdWVzIGRvbid0IG1hcCB0byBhIGhleCBvY3RldCAobGVhZGluZyB0b1xuICAvLyBcInVuZGVmaW5lZFwiIGluIHRoZSB1dWlkKVxuICAvLyAtIEludmFsaWQgaW5wdXQgdmFsdWVzIGZvciB0aGUgUkZDIGB2ZXJzaW9uYCBvciBgdmFyaWFudGAgZmllbGRzXG5cbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignU3RyaW5naWZpZWQgVVVJRCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICByZXR1cm4gdXVpZDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc3RyaW5naWZ5OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(b);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YxLmpzIiwibWFwcGluZ3MiOiI7OztBQUEyQjtBQUNzQixDQUFDO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxlQUFlOzs7QUFHZjtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBOztBQUVBO0FBQ0Esd0RBQXdELCtDQUFHOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7OztBQUdBLHdFQUF3RTtBQUN4RTs7QUFFQSw0RUFBNEU7O0FBRTVFLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0JBQXdCOztBQUV4QiwyQkFBMkI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QixvQ0FBb0M7O0FBRXBDLDhCQUE4Qjs7QUFFOUIsa0NBQWtDOztBQUVsQyw0QkFBNEI7O0FBRTVCLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7O0FBRUEsZ0JBQWdCLDhEQUFlO0FBQy9COztBQUVBLCtEQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MS5qcz81MGMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbmxldCBfbm9kZUlkO1xuXG5sZXQgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG5sZXQgX2xhc3RNU2VjcyA9IDA7XG5sZXQgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIGxldCBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICBjb25zdCBiID0gYnVmIHx8IG5ldyBBcnJheSgxNik7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsZXQgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICBsZXQgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxOyAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcblxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICBjb25zdCBzZWVkQnl0ZXMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpO1xuXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtzZWVkQnl0ZXNbMF0gfCAweDAxLCBzZWVkQnl0ZXNbMV0sIHNlZWRCeXRlc1syXSwgc2VlZEJ5dGVzWzNdLCBzZWVkQnl0ZXNbNF0sIHNlZWRCeXRlc1s1XV07XG4gICAgfVxuXG4gICAgaWYgKGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjIuMiwgcmFuZG9taXplICgxNCBiaXQpIGNsb2Nrc2VxXG4gICAgICBjbG9ja3NlcSA9IF9jbG9ja3NlcSA9IChzZWVkQnl0ZXNbNl0gPDwgOCB8IHNlZWRCeXRlc1s3XSkgJiAweDNmZmY7XG4gICAgfVxuICB9IC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuXG5cbiAgbGV0IG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IERhdGUubm93KCk7IC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcblxuICBsZXQgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7IC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcblxuICBjb25zdCBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIGNvbnN0IHRsID0gKChtc2VjcyAmIDB4ZmZmZmZmZikgKiAxMDAwMCArIG5zZWNzKSAlIDB4MTAwMDAwMDAwO1xuICBiW2krK10gPSB0bCA+Pj4gMjQgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gMTYgJiAweGZmO1xuICBiW2krK10gPSB0bCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsICYgMHhmZjsgLy8gYHRpbWVfbWlkYFxuXG4gIGNvbnN0IHRtaCA9IG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCAmIDB4ZmZmZmZmZjtcbiAgYltpKytdID0gdG1oID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdG1oICYgMHhmZjsgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcblxuICBiW2krK10gPSB0bWggPj4+IDI0ICYgMHhmIHwgMHgxMDsgLy8gaW5jbHVkZSB2ZXJzaW9uXG5cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7IC8vIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYCAoUGVyIDQuMi4yIC0gaW5jbHVkZSB2YXJpYW50KVxuXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDsgLy8gYGNsb2NrX3NlcV9sb3dgXG5cbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmOyAvLyBgbm9kZWBcblxuICBmb3IgKGxldCBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgfHwgdW5zYWZlU3RyaW5naWZ5KGIpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2MTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/v1.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"./node_modules/uuid/dist/esm-browser/md5.js\");\n\n\nconst v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzLmpzIiwibWFwcGluZ3MiOiI7OztBQUEyQjtBQUNBO0FBQzNCLFdBQVcsbURBQUcsYUFBYSwrQ0FBRztBQUM5QiwrREFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanM/MmVkYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBtZDUgZnJvbSAnLi9tZDUuanMnO1xuY29uc3QgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/v3.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: function() { return /* binding */ DNS; },\n/* harmony export */   URL: function() { return /* binding */ URL; },\n/* harmony export */   \"default\": function() { return /* binding */ v35; }\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nfunction v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__.unsafeStringify)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNsQjs7QUFFL0I7QUFDQSwyQ0FBMkM7O0FBRTNDOztBQUVBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTs7QUFFQTtBQUNBOztBQUVPO0FBQ0E7QUFDUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLHFEQUFLO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFdBQVcsOERBQWU7QUFDMUIsSUFBSTs7O0FBR0o7QUFDQSw4QkFBOEI7QUFDOUIsSUFBSSxlQUFlOzs7QUFHbkI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92MzUuanM/ZDc5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1bnNhZmVTdHJpbmdpZnkgfSBmcm9tICcuL3N0cmluZ2lmeS5qcyc7XG5pbXBvcnQgcGFyc2UgZnJvbSAnLi9wYXJzZS5qcyc7XG5cbmZ1bmN0aW9uIHN0cmluZ1RvQnl0ZXMoc3RyKSB7XG4gIHN0ciA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTsgLy8gVVRGOCBlc2NhcGVcblxuICBjb25zdCBieXRlcyA9IFtdO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gIH1cblxuICByZXR1cm4gYnl0ZXM7XG59XG5cbmV4cG9ydCBjb25zdCBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBjb25zdCBVUkwgPSAnNmJhN2I4MTEtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHYzNShuYW1lLCB2ZXJzaW9uLCBoYXNoZnVuYykge1xuICBmdW5jdGlvbiBnZW5lcmF0ZVVVSUQodmFsdWUsIG5hbWVzcGFjZSwgYnVmLCBvZmZzZXQpIHtcbiAgICB2YXIgX25hbWVzcGFjZTtcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YWx1ZSA9IHN0cmluZ1RvQnl0ZXModmFsdWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmFtZXNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgbmFtZXNwYWNlID0gcGFyc2UobmFtZXNwYWNlKTtcbiAgICB9XG5cbiAgICBpZiAoKChfbmFtZXNwYWNlID0gbmFtZXNwYWNlKSA9PT0gbnVsbCB8fCBfbmFtZXNwYWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfbmFtZXNwYWNlLmxlbmd0aCkgIT09IDE2KSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ05hbWVzcGFjZSBtdXN0IGJlIGFycmF5LWxpa2UgKDE2IGl0ZXJhYmxlIGludGVnZXIgdmFsdWVzLCAwLTI1NSknKTtcbiAgICB9IC8vIENvbXB1dGUgaGFzaCBvZiBuYW1lc3BhY2UgYW5kIHZhbHVlLCBQZXIgNC4zXG4gICAgLy8gRnV0dXJlOiBVc2Ugc3ByZWFkIHN5bnRheCB3aGVuIHN1cHBvcnRlZCBvbiBhbGwgcGxhdGZvcm1zLCBlLmcuIGBieXRlcyA9XG4gICAgLy8gaGFzaGZ1bmMoWy4uLm5hbWVzcGFjZSwgLi4uIHZhbHVlXSlgXG5cblxuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KDE2ICsgdmFsdWUubGVuZ3RoKTtcbiAgICBieXRlcy5zZXQobmFtZXNwYWNlKTtcbiAgICBieXRlcy5zZXQodmFsdWUsIG5hbWVzcGFjZS5sZW5ndGgpO1xuICAgIGJ5dGVzID0gaGFzaGZ1bmMoYnl0ZXMpO1xuICAgIGJ5dGVzWzZdID0gYnl0ZXNbNl0gJiAweDBmIHwgdmVyc2lvbjtcbiAgICBieXRlc1s4XSA9IGJ5dGVzWzhdICYgMHgzZiB8IDB4ODA7XG5cbiAgICBpZiAoYnVmKSB7XG4gICAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgIGJ1ZltvZmZzZXQgKyBpXSA9IGJ5dGVzW2ldO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVmO1xuICAgIH1cblxuICAgIHJldHVybiB1bnNhZmVTdHJpbmdpZnkoYnl0ZXMpO1xuICB9IC8vIEZ1bmN0aW9uI25hbWUgaXMgbm90IHNldHRhYmxlIG9uIHNvbWUgcGxhdGZvcm1zICgjMjcwKVxuXG5cbiAgdHJ5IHtcbiAgICBnZW5lcmF0ZVVVSUQubmFtZSA9IG5hbWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICB9IGNhdGNoIChlcnIpIHt9IC8vIEZvciBDb21tb25KUyBkZWZhdWx0IGV4cG9ydCBzdXBwb3J0XG5cblxuICBnZW5lcmF0ZVVVSUQuRE5TID0gRE5TO1xuICBnZW5lcmF0ZVVVSUQuVVJMID0gVVJMO1xuICByZXR1cm4gZ2VuZXJhdGVVVUlEO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/v35.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _native_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./native.js */ \"./node_modules/uuid/dist/esm-browser/native.js\");\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rng.js */ \"./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stringify.js */ \"./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\n\nfunction v4(options, buf, offset) {\n  if (_native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID && !buf && !options) {\n    return _native_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_2__.unsafeStringify)(rnds);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBaUM7QUFDTjtBQUNzQjs7QUFFakQ7QUFDQSxNQUFNLDZEQUFpQjtBQUN2QixXQUFXLDZEQUFpQjtBQUM1Qjs7QUFFQTtBQUNBLGlEQUFpRCwrQ0FBRyxLQUFLOztBQUV6RDtBQUNBLG1DQUFtQzs7QUFFbkM7QUFDQTs7QUFFQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUyw4REFBZTtBQUN4Qjs7QUFFQSwrREFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanM/ZjA1OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgbmF0aXZlIGZyb20gJy4vbmF0aXZlLmpzJztcbmltcG9ydCBybmcgZnJvbSAnLi9ybmcuanMnO1xuaW1wb3J0IHsgdW5zYWZlU3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuXG5mdW5jdGlvbiB2NChvcHRpb25zLCBidWYsIG9mZnNldCkge1xuICBpZiAobmF0aXZlLnJhbmRvbVVVSUQgJiYgIWJ1ZiAmJiAhb3B0aW9ucykge1xuICAgIHJldHVybiBuYXRpdmUucmFuZG9tVVVJRCgpO1xuICB9XG5cbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIGNvbnN0IHJuZHMgPSBvcHRpb25zLnJhbmRvbSB8fCAob3B0aW9ucy5ybmcgfHwgcm5nKSgpOyAvLyBQZXIgNC40LCBzZXQgYml0cyBmb3IgdmVyc2lvbiBhbmQgYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgXG5cbiAgcm5kc1s2XSA9IHJuZHNbNl0gJiAweDBmIHwgMHg0MDtcbiAgcm5kc1s4XSA9IHJuZHNbOF0gJiAweDNmIHwgMHg4MDsgLy8gQ29weSBieXRlcyB0byBidWZmZXIsIGlmIHByb3ZpZGVkXG5cbiAgaWYgKGJ1Zikge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICBidWZbb2Zmc2V0ICsgaV0gPSBybmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiBidWY7XG4gIH1cblxuICByZXR1cm4gdW5zYWZlU3RyaW5naWZ5KHJuZHMpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2NDsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"./node_modules/uuid/dist/esm-browser/sha1.js\");\n\n\nconst v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y1LmpzIiwibWFwcGluZ3MiOiI7OztBQUEyQjtBQUNFO0FBQzdCLFdBQVcsbURBQUcsYUFBYSxnREFBSTtBQUMvQiwrREFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanM/YTA3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgdjM1IGZyb20gJy4vdjM1LmpzJztcbmltcG9ydCBzaGExIGZyb20gJy4vc2hhMS5qcyc7XG5jb25zdCB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/v5.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZhbGlkYXRlLmpzIiwibWFwcGluZ3MiOiI7O0FBQStCOztBQUUvQjtBQUNBLHFDQUFxQyxzREFBVTtBQUMvQzs7QUFFQSwrREFBZSxRQUFRIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanM/NGU5NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUkVHRVggZnJvbSAnLi9yZWdleC5qcyc7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHV1aWQpIHtcbiAgcmV0dXJuIHR5cGVvZiB1dWlkID09PSAnc3RyaW5nJyAmJiBSRUdFWC50ZXN0KHV1aWQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.slice(14, 15), 16);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3ZlcnNpb24uanMiLCJtYXBwaW5ncyI6Ijs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxPQUFPIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcz84MmYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gdmVyc2lvbih1dWlkKSB7XG4gIGlmICghdmFsaWRhdGUodXVpZCkpIHtcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ0ludmFsaWQgVVVJRCcpO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlSW50KHV1aWQuc2xpY2UoMTQsIDE1KSwgMTYpO1xufVxuXG5leHBvcnQgZGVmYXVsdCB2ZXJzaW9uOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/uuid/dist/esm-browser/version.js\n"));

/***/ }),

/***/ "?f4e8":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/assertThisInitialized.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\nmodule.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanM/MGFmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpIHtcbiAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcihcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFwiKTtcbiAgfVxuICByZXR1cm4gc2VsZjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/asyncToGenerator.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/asyncToGenerator.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hc3luY1RvR2VuZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvci5qcz83YjE1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywga2V5LCBhcmcpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9IGdlbltrZXldKGFyZyk7XG4gICAgdmFyIHZhbHVlID0gaW5mby52YWx1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZWplY3QoZXJyb3IpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoaW5mby5kb25lKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgUHJvbWlzZS5yZXNvbHZlKHZhbHVlKS50aGVuKF9uZXh0LCBfdGhyb3cpO1xuICB9XG59XG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBnZW4gPSBmbi5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgIGZ1bmN0aW9uIF9uZXh0KHZhbHVlKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJuZXh0XCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG4gICAgICBfbmV4dCh1bmRlZmluZWQpO1xuICAgIH0pO1xuICB9O1xufVxubW9kdWxlLmV4cG9ydHMgPSBfYXN5bmNUb0dlbmVyYXRvciwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/asyncToGenerator.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/classCallCheck.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcz8zMzM4Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9jbGFzc0NhbGxDaGVjaywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/classCallCheck.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/createClass.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var toPropertyKey = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxvQkFBb0IsbUJBQU8sQ0FBQyxrRkFBb0I7QUFDaEQ7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jcmVhdGVDbGFzcy5qcz8yYzMzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciB0b1Byb3BlcnR5S2V5ID0gcmVxdWlyZShcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiKTtcbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIHRvUHJvcGVydHlLZXkoZGVzY3JpcHRvci5rZXkpLCBkZXNjcmlwdG9yKTtcbiAgfVxufVxuZnVuY3Rpb24gX2NyZWF0ZUNsYXNzKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICBpZiAocHJvdG9Qcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgaWYgKHN0YXRpY1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29uc3RydWN0b3IsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIHJldHVybiBDb25zdHJ1Y3Rvcjtcbn1cbm1vZHVsZS5leHBvcnRzID0gX2NyZWF0ZUNsYXNzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/createClass.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/getPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _getPrototypeOf(o);\n}\nmodule.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9nZXRQcm90b3R5cGVPZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEVBQUUseUJBQXlCLFNBQVMseUJBQXlCO0FBQ2hFO0FBQ0E7QUFDQSxrQ0FBa0MseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2dldFByb3RvdHlwZU9mLmpzPzRiYzEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9nZXRQcm90b3R5cGVPZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/inherits.js":
/*!*********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var setPrototypeOf = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/setPrototypeOf.js\");\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\nmodule.exports = _inherits, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsbUJBQU8sQ0FBQyxvRkFBcUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QixTQUFTLHlCQUF5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbmhlcml0cy5qcz83NDA0Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBzZXRQcm90b3R5cGVPZiA9IHJlcXVpcmUoXCIuL3NldFByb3RvdHlwZU9mLmpzXCIpO1xuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfaW5oZXJpdHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/inherits.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/interopRequireDefault.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/interopRequireDefault.js ***!
  \**********************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nmodule.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaW50ZXJvcFJlcXVpcmVEZWZhdWx0LmpzPzRlNjQiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/interopRequireDefault.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
  \**************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar assertThisInitialized = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/assertThisInitialized.js\");\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}\nmodule.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuLmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsc0dBQWlDO0FBQy9DLDRCQUE0QixtQkFBTyxDQUFDLGtHQUE0QjtBQUNoRTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4uanM/NjZlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG52YXIgYXNzZXJ0VGhpc0luaXRpYWxpemVkID0gcmVxdWlyZShcIi4vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzXCIpO1xuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkge1xuICBpZiAoY2FsbCAmJiAoX3R5cGVvZihjYWxsKSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/regeneratorRuntime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/regeneratorRuntime.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction _regeneratorRuntime() {\n  \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */\n  module.exports = _regeneratorRuntime = function _regeneratorRuntime() {\n    return exports;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  var exports = {},\n    Op = Object.prototype,\n    hasOwn = Op.hasOwnProperty,\n    defineProperty = Object.defineProperty || function (obj, key, desc) {\n      obj[key] = desc.value;\n    },\n    $Symbol = \"function\" == typeof Symbol ? Symbol : {},\n    iteratorSymbol = $Symbol.iterator || \"@@iterator\",\n    asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\",\n    toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\";\n  function define(obj, key, value) {\n    return Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), obj[key];\n  }\n  try {\n    define({}, \"\");\n  } catch (err) {\n    define = function define(obj, key, value) {\n      return obj[key] = value;\n    };\n  }\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,\n      generator = Object.create(protoGenerator.prototype),\n      context = new Context(tryLocsList || []);\n    return defineProperty(generator, \"_invoke\", {\n      value: makeInvokeMethod(innerFn, self, context)\n    }), generator;\n  }\n  function tryCatch(fn, obj, arg) {\n    try {\n      return {\n        type: \"normal\",\n        arg: fn.call(obj, arg)\n      };\n    } catch (err) {\n      return {\n        type: \"throw\",\n        arg: err\n      };\n    }\n  }\n  exports.wrap = wrap;\n  var ContinueSentinel = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var IteratorPrototype = {};\n  define(IteratorPrototype, iteratorSymbol, function () {\n    return this;\n  });\n  var getProto = Object.getPrototypeOf,\n    NativeIteratorPrototype = getProto && getProto(getProto(values([])));\n  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function (method) {\n      define(prototype, method, function (arg) {\n        return this._invoke(method, arg);\n      });\n    });\n  }\n  function AsyncIterator(generator, PromiseImpl) {\n    function invoke(method, arg, resolve, reject) {\n      var record = tryCatch(generator[method], generator, arg);\n      if (\"throw\" !== record.type) {\n        var result = record.arg,\n          value = result.value;\n        return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) {\n          invoke(\"next\", value, resolve, reject);\n        }, function (err) {\n          invoke(\"throw\", err, resolve, reject);\n        }) : PromiseImpl.resolve(value).then(function (unwrapped) {\n          result.value = unwrapped, resolve(result);\n        }, function (error) {\n          return invoke(\"throw\", error, resolve, reject);\n        });\n      }\n      reject(record.arg);\n    }\n    var previousPromise;\n    defineProperty(this, \"_invoke\", {\n      value: function value(method, arg) {\n        function callInvokeWithMethodAndArg() {\n          return new PromiseImpl(function (resolve, reject) {\n            invoke(method, arg, resolve, reject);\n          });\n        }\n        return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = \"suspendedStart\";\n    return function (method, arg) {\n      if (\"executing\" === state) throw new Error(\"Generator is already running\");\n      if (\"completed\" === state) {\n        if (\"throw\" === method) throw arg;\n        return doneResult();\n      }\n      for (context.method = method, context.arg = arg;;) {\n        var delegate = context.delegate;\n        if (delegate) {\n          var delegateResult = maybeInvokeDelegate(delegate, context);\n          if (delegateResult) {\n            if (delegateResult === ContinueSentinel) continue;\n            return delegateResult;\n          }\n        }\n        if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) {\n          if (\"suspendedStart\" === state) throw state = \"completed\", context.arg;\n          context.dispatchException(context.arg);\n        } else \"return\" === context.method && context.abrupt(\"return\", context.arg);\n        state = \"executing\";\n        var record = tryCatch(innerFn, self, context);\n        if (\"normal\" === record.type) {\n          if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue;\n          return {\n            value: record.arg,\n            done: context.done\n          };\n        }\n        \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(delegate, context) {\n    var methodName = context.method,\n      method = delegate.iterator[methodName];\n    if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel;\n    var record = tryCatch(method, delegate.iterator, context.arg);\n    if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel;\n    var info = record.arg;\n    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel);\n  }\n  function pushTryEntry(locs) {\n    var entry = {\n      tryLoc: locs[0]\n    };\n    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);\n  }\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\", delete record.arg, entry.completion = record;\n  }\n  function Context(tryLocsList) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) return iteratorMethod.call(iterable);\n      if (\"function\" == typeof iterable.next) return iterable;\n      if (!isNaN(iterable.length)) {\n        var i = -1,\n          next = function next() {\n            for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;\n            return next.value = undefined, next.done = !0, next;\n          };\n        return next.next = next;\n      }\n    }\n    return {\n      next: doneResult\n    };\n  }\n  function doneResult() {\n    return {\n      value: undefined,\n      done: !0\n    };\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), defineProperty(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) {\n    var ctor = \"function\" == typeof genFun && genFun.constructor;\n    return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name));\n  }, exports.mark = function (genFun) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun;\n  }, exports.awrap = function (arg) {\n    return {\n      __await: arg\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {\n    return this;\n  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {\n    void 0 === PromiseImpl && (PromiseImpl = Promise);\n    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);\n    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {\n      return result.done ? result.value : iter.next();\n    });\n  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () {\n    return this;\n  }), define(Gp, \"toString\", function () {\n    return \"[object Generator]\";\n  }), exports.keys = function (val) {\n    var object = Object(val),\n      keys = [];\n    for (var key in object) keys.push(key);\n    return keys.reverse(), function next() {\n      for (; keys.length;) {\n        var key = keys.pop();\n        if (key in object) return next.value = key, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, exports.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function reset(skipTempReset) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);\n    },\n    stop: function stop() {\n      this.done = !0;\n      var rootRecord = this.tryEntries[0].completion;\n      if (\"throw\" === rootRecord.type) throw rootRecord.arg;\n      return this.rval;\n    },\n    dispatchException: function dispatchException(exception) {\n      if (this.done) throw exception;\n      var context = this;\n      function handle(loc, caught) {\n        return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught;\n      }\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i],\n          record = entry.completion;\n        if (\"root\" === entry.tryLoc) return handle(\"end\");\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\"),\n            hasFinally = hasOwn.call(entry, \"finallyLoc\");\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);\n          } else {\n            if (!hasFinally) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function abrupt(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n      finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);\n      var record = finallyEntry ? finallyEntry.completion : {};\n      return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);\n    },\n    complete: function complete(record, afterLoc) {\n      if (\"throw\" === record.type) throw record.arg;\n      return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;\n    },\n    finish: function finish(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;\n      }\n    },\n    \"catch\": function _catch(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (\"throw\" === record.type) {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function delegateYield(iterable, resultName, nextLoc) {\n      return this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel;\n    }\n  }, exports;\n}\nmodule.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWUuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxzR0FBaUM7QUFDL0M7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLEdBQUcsRUFBRSx5QkFBeUIsU0FBUyx5QkFBeUI7QUFDaEUsa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtGQUFrRjtBQUNsRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHNCQUFzQjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLCtDQUErQyxRQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0MseUJBQXlCLFNBQVMseUJBQXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3JlZ2VuZXJhdG9yUnVudGltZS5qcz85ZGY1Il0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbmZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gIFwidXNlIHN0cmljdFwiOyAvKiEgcmVnZW5lcmF0b3ItcnVudGltZSAtLSBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy4gLS0gbGljZW5zZSAoTUlUKTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9MSUNFTlNFICovXG4gIG1vZHVsZS5leHBvcnRzID0gX3JlZ2VuZXJhdG9yUnVudGltZSA9IGZ1bmN0aW9uIF9yZWdlbmVyYXRvclJ1bnRpbWUoKSB7XG4gICAgcmV0dXJuIGV4cG9ydHM7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cztcbiAgdmFyIGV4cG9ydHMgPSB7fSxcbiAgICBPcCA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgaGFzT3duID0gT3AuaGFzT3duUHJvcGVydHksXG4gICAgZGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24gKG9iaiwga2V5LCBkZXNjKSB7XG4gICAgICBvYmpba2V5XSA9IGRlc2MudmFsdWU7XG4gICAgfSxcbiAgICAkU3ltYm9sID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCIsXG4gICAgYXN5bmNJdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuYXN5bmNJdGVyYXRvciB8fCBcIkBAYXN5bmNJdGVyYXRvclwiLFxuICAgIHRvU3RyaW5nVGFnU3ltYm9sID0gJFN5bWJvbC50b1N0cmluZ1RhZyB8fCBcIkBAdG9TdHJpbmdUYWdcIjtcbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pLCBvYmpba2V5XTtcbiAgfVxuICB0cnkge1xuICAgIGRlZmluZSh7fSwgXCJcIik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uIGRlZmluZShvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gd3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCkge1xuICAgIHZhciBwcm90b0dlbmVyYXRvciA9IG91dGVyRm4gJiYgb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBvdXRlckZuIDogR2VuZXJhdG9yLFxuICAgICAgZ2VuZXJhdG9yID0gT2JqZWN0LmNyZWF0ZShwcm90b0dlbmVyYXRvci5wcm90b3R5cGUpLFxuICAgICAgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcbiAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoZ2VuZXJhdG9yLCBcIl9pbnZva2VcIiwge1xuICAgICAgdmFsdWU6IG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dClcbiAgICB9KSwgZ2VuZXJhdG9yO1xuICB9XG4gIGZ1bmN0aW9uIHRyeUNhdGNoKGZuLCBvYmosIGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcIm5vcm1hbFwiLFxuICAgICAgICBhcmc6IGZuLmNhbGwob2JqLCBhcmcpXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IGVyclxuICAgICAgfTtcbiAgICB9XG4gIH1cbiAgZXhwb3J0cy53cmFwID0gd3JhcDtcbiAgdmFyIENvbnRpbnVlU2VudGluZWwgPSB7fTtcbiAgZnVuY3Rpb24gR2VuZXJhdG9yKCkge31cbiAgZnVuY3Rpb24gR2VuZXJhdG9yRnVuY3Rpb24oKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSgpIHt9XG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBkZWZpbmUoSXRlcmF0b3JQcm90b3R5cGUsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pO1xuICB2YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YsXG4gICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICYmIE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlICE9PSBPcCAmJiBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpICYmIChJdGVyYXRvclByb3RvdHlwZSA9IE5hdGl2ZUl0ZXJhdG9yUHJvdG90eXBlKTtcbiAgdmFyIEdwID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUucHJvdG90eXBlID0gR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgZGVmaW5lKHByb3RvdHlwZSwgbWV0aG9kLCBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UobWV0aG9kLCBhcmcpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gQXN5bmNJdGVyYXRvcihnZW5lcmF0b3IsIFByb21pc2VJbXBsKSB7XG4gICAgZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChnZW5lcmF0b3JbbWV0aG9kXSwgZ2VuZXJhdG9yLCBhcmcpO1xuICAgICAgaWYgKFwidGhyb3dcIiAhPT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHJlY29yZC5hcmcsXG4gICAgICAgICAgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZSAmJiBcIm9iamVjdFwiID09IF90eXBlb2YodmFsdWUpICYmIGhhc093bi5jYWxsKHZhbHVlLCBcIl9fYXdhaXRcIikgPyBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlLl9fYXdhaXQpLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgfSkgOiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uICh1bndyYXBwZWQpIHtcbiAgICAgICAgICByZXN1bHQudmFsdWUgPSB1bndyYXBwZWQsIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGludm9rZShcInRocm93XCIsIGVycm9yLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICB9XG4gICAgdmFyIHByZXZpb3VzUHJvbWlzZTtcbiAgICBkZWZpbmVQcm9wZXJ0eSh0aGlzLCBcIl9pbnZva2VcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZUltcGwoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgaW52b2tlKG1ldGhvZCwgYXJnLCByZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1Byb21pc2UgPSBwcmV2aW91c1Byb21pc2UgPyBwcmV2aW91c1Byb21pc2UudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpIHtcbiAgICB2YXIgc3RhdGUgPSBcInN1c3BlbmRlZFN0YXJ0XCI7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXRob2QsIGFyZykge1xuICAgICAgaWYgKFwiZXhlY3V0aW5nXCIgPT09IHN0YXRlKSB0aHJvdyBuZXcgRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBydW5uaW5nXCIpO1xuICAgICAgaWYgKFwiY29tcGxldGVkXCIgPT09IHN0YXRlKSB7XG4gICAgICAgIGlmIChcInRocm93XCIgPT09IG1ldGhvZCkgdGhyb3cgYXJnO1xuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuICAgICAgZm9yIChjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZCwgY29udGV4dC5hcmcgPSBhcmc7Oykge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChcIm5leHRcIiA9PT0gY29udGV4dC5tZXRob2QpIGNvbnRleHQuc2VudCA9IGNvbnRleHQuX3NlbnQgPSBjb250ZXh0LmFyZztlbHNlIGlmIChcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB7XG4gICAgICAgICAgaWYgKFwic3VzcGVuZGVkU3RhcnRcIiA9PT0gc3RhdGUpIHRocm93IHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5hcmc7XG4gICAgICAgICAgY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZyk7XG4gICAgICAgIH0gZWxzZSBcInJldHVyblwiID09PSBjb250ZXh0Lm1ldGhvZCAmJiBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIHN0YXRlID0gXCJleGVjdXRpbmdcIjtcbiAgICAgICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuICAgICAgICBpZiAoXCJub3JtYWxcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICBpZiAoc3RhdGUgPSBjb250ZXh0LmRvbmUgPyBcImNvbXBsZXRlZFwiIDogXCJzdXNwZW5kZWRZaWVsZFwiLCByZWNvcmQuYXJnID09PSBDb250aW51ZVNlbnRpbmVsKSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHJlY29yZC5hcmcsXG4gICAgICAgICAgICBkb25lOiBjb250ZXh0LmRvbmVcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUgJiYgKHN0YXRlID0gXCJjb21wbGV0ZWRcIiwgY29udGV4dC5tZXRob2QgPSBcInRocm93XCIsIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZE5hbWUgPSBjb250ZXh0Lm1ldGhvZCxcbiAgICAgIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW21ldGhvZE5hbWVdO1xuICAgIGlmICh1bmRlZmluZWQgPT09IG1ldGhvZCkgcmV0dXJuIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG1ldGhvZE5hbWUgJiYgZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0gJiYgKGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQsIG1heWJlSW52b2tlRGVsZWdhdGUoZGVsZWdhdGUsIGNvbnRleHQpLCBcInRocm93XCIgPT09IGNvbnRleHQubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBtZXRob2ROYW1lICYmIChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBtZXRob2ROYW1lICsgXCInIG1ldGhvZFwiKSksIENvbnRpbnVlU2VudGluZWw7XG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcbiAgICBpZiAoXCJ0aHJvd1wiID09PSByZWNvcmQudHlwZSkgcmV0dXJuIGNvbnRleHQubWV0aG9kID0gXCJ0aHJvd1wiLCBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmcsIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIHZhciBpbmZvID0gcmVjb3JkLmFyZztcbiAgICByZXR1cm4gaW5mbyA/IGluZm8uZG9uZSA/IChjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZSwgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYywgXCJyZXR1cm5cIiAhPT0gY29udGV4dC5tZXRob2QgJiYgKGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCIsIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkKSwgY29udGV4dC5kZWxlZ2F0ZSA9IG51bGwsIENvbnRpbnVlU2VudGluZWwpIDogaW5mbyA6IChjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIiwgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsLCBDb250aW51ZVNlbnRpbmVsKTtcbiAgfVxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkobG9jcykge1xuICAgIHZhciBlbnRyeSA9IHtcbiAgICAgIHRyeUxvYzogbG9jc1swXVxuICAgIH07XG4gICAgMSBpbiBsb2NzICYmIChlbnRyeS5jYXRjaExvYyA9IGxvY3NbMV0pLCAyIGluIGxvY3MgJiYgKGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdLCBlbnRyeS5hZnRlckxvYyA9IGxvY3NbM10pLCB0aGlzLnRyeUVudHJpZXMucHVzaChlbnRyeSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUcnlFbnRyeShlbnRyeSkge1xuICAgIHZhciByZWNvcmQgPSBlbnRyeS5jb21wbGV0aW9uIHx8IHt9O1xuICAgIHJlY29yZC50eXBlID0gXCJub3JtYWxcIiwgZGVsZXRlIHJlY29yZC5hcmcsIGVudHJ5LmNvbXBsZXRpb24gPSByZWNvcmQ7XG4gIH1cbiAgZnVuY3Rpb24gQ29udGV4dCh0cnlMb2NzTGlzdCkge1xuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7XG4gICAgICB0cnlMb2M6IFwicm9vdFwiXG4gICAgfV0sIHRyeUxvY3NMaXN0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHJldHVybiBpdGVyYXRvck1ldGhvZC5jYWxsKGl0ZXJhYmxlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGl0ZXJhYmxlLm5leHQpIHJldHVybiBpdGVyYWJsZTtcbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLFxuICAgICAgICAgIG5leHQgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgZm9yICg7ICsraSA8IGl0ZXJhYmxlLmxlbmd0aDspIGlmIChoYXNPd24uY2FsbChpdGVyYWJsZSwgaSkpIHJldHVybiBuZXh0LnZhbHVlID0gaXRlcmFibGVbaV0sIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgICAgICAgcmV0dXJuIG5leHQudmFsdWUgPSB1bmRlZmluZWQsIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogZG9uZVJlc3VsdFxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIGRvbmU6ICEwXG4gICAgfTtcbiAgfVxuICByZXR1cm4gR2VuZXJhdG9yRnVuY3Rpb24ucHJvdG90eXBlID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZVByb3BlcnR5KEdwLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgZGVmaW5lUHJvcGVydHkoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvbixcbiAgICBjb25maWd1cmFibGU6ICEwXG4gIH0pLCBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGV4cG9ydHMuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uIChnZW5GdW4pIHtcbiAgICB2YXIgY3RvciA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZ2VuRnVuICYmIGdlbkZ1bi5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFjdG9yICYmIChjdG9yID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChjdG9yLmRpc3BsYXlOYW1lIHx8IGN0b3IubmFtZSkpO1xuICB9LCBleHBvcnRzLm1hcmsgPSBmdW5jdGlvbiAoZ2VuRnVuKSB7XG4gICAgcmV0dXJuIE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZihnZW5GdW4sIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKSA6IChnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZShnZW5GdW4sIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApLCBnZW5GdW47XG4gIH0sIGV4cG9ydHMuYXdyYXAgPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIF9fYXdhaXQ6IGFyZ1xuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYXN5bmNJdGVyYXRvclN5bWJvbCwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZXhwb3J0cy5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZXhwb3J0cy5hc3luYyA9IGZ1bmN0aW9uIChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCwgUHJvbWlzZUltcGwpIHtcbiAgICB2b2lkIDAgPT09IFByb21pc2VJbXBsICYmIChQcm9taXNlSW1wbCA9IFByb21pc2UpO1xuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3Iod3JhcChpbm5lckZuLCBvdXRlckZuLCBzZWxmLCB0cnlMb2NzTGlzdCksIFByb21pc2VJbXBsKTtcbiAgICByZXR1cm4gZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uKG91dGVyRm4pID8gaXRlciA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhHcCksIGRlZmluZShHcCwgdG9TdHJpbmdUYWdTeW1ib2wsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoR3AsIGl0ZXJhdG9yU3ltYm9sLCBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0pLCBkZWZpbmUoR3AsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZXhwb3J0cy5rZXlzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciBvYmplY3QgPSBPYmplY3QodmFsKSxcbiAgICAgIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cy5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsga2V5cy5sZW5ndGg7KSB7XG4gICAgICAgIHZhciBrZXkgPSBrZXlzLnBvcCgpO1xuICAgICAgICBpZiAoa2V5IGluIG9iamVjdCkgcmV0dXJuIG5leHQudmFsdWUgPSBrZXksIG5leHQuZG9uZSA9ICExLCBuZXh0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQuZG9uZSA9ICEwLCBuZXh0O1xuICAgIH07XG4gIH0sIGV4cG9ydHMudmFsdWVzID0gdmFsdWVzLCBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcbiAgICByZXNldDogZnVuY3Rpb24gcmVzZXQoc2tpcFRlbXBSZXNldCkge1xuICAgICAgaWYgKHRoaXMucHJldiA9IDAsIHRoaXMubmV4dCA9IDAsIHRoaXMuc2VudCA9IHRoaXMuX3NlbnQgPSB1bmRlZmluZWQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB1bmRlZmluZWQsIHRoaXMudHJ5RW50cmllcy5mb3JFYWNoKHJlc2V0VHJ5RW50cnkpLCAhc2tpcFRlbXBSZXNldCkgZm9yICh2YXIgbmFtZSBpbiB0aGlzKSBcInRcIiA9PT0gbmFtZS5jaGFyQXQoMCkgJiYgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiYgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSAmJiAodGhpc1tuYW1lXSA9IHVuZGVmaW5lZCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgdGhpcy5kb25lID0gITA7XG4gICAgICB2YXIgcm9vdFJlY29yZCA9IHRoaXMudHJ5RW50cmllc1swXS5jb21wbGV0aW9uO1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcm9vdFJlY29yZC50eXBlKSB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIHJldHVybiB0aGlzLnJ2YWw7XG4gICAgfSxcbiAgICBkaXNwYXRjaEV4Y2VwdGlvbjogZnVuY3Rpb24gZGlzcGF0Y2hFeGNlcHRpb24oZXhjZXB0aW9uKSB7XG4gICAgICBpZiAodGhpcy5kb25lKSB0aHJvdyBleGNlcHRpb247XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBoYW5kbGUobG9jLCBjYXVnaHQpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZC50eXBlID0gXCJ0aHJvd1wiLCByZWNvcmQuYXJnID0gZXhjZXB0aW9uLCBjb250ZXh0Lm5leHQgPSBsb2MsIGNhdWdodCAmJiAoY29udGV4dC5tZXRob2QgPSBcIm5leHRcIiwgY29udGV4dC5hcmcgPSB1bmRlZmluZWQpLCAhIWNhdWdodDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldLFxuICAgICAgICAgIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgIGlmIChcInJvb3RcIiA9PT0gZW50cnkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jIDw9IHRoaXMucHJldikge1xuICAgICAgICAgIHZhciBoYXNDYXRjaCA9IGhhc093bi5jYWxsKGVudHJ5LCBcImNhdGNoTG9jXCIpLFxuICAgICAgICAgICAgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG4gICAgICAgICAgaWYgKGhhc0NhdGNoICYmIGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5jYXRjaExvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgITApO1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgfSBlbHNlIGlmIChoYXNDYXRjaCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGVudHJ5LmNhdGNoTG9jLCAhMCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghaGFzRmluYWxseSkgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykgcmV0dXJuIGhhbmRsZShlbnRyeS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gYWJydXB0KHR5cGUsIGFyZykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS50cnlMb2MgPD0gdGhpcy5wcmV2ICYmIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiYgdGhpcy5wcmV2IDwgZW50cnkuZmluYWxseUxvYykge1xuICAgICAgICAgIHZhciBmaW5hbGx5RW50cnkgPSBlbnRyeTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZmluYWxseUVudHJ5ICYmIChcImJyZWFrXCIgPT09IHR5cGUgfHwgXCJjb250aW51ZVwiID09PSB0eXBlKSAmJiBmaW5hbGx5RW50cnkudHJ5TG9jIDw9IGFyZyAmJiBhcmcgPD0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MgJiYgKGZpbmFsbHlFbnRyeSA9IG51bGwpO1xuICAgICAgdmFyIHJlY29yZCA9IGZpbmFsbHlFbnRyeSA/IGZpbmFsbHlFbnRyeS5jb21wbGV0aW9uIDoge307XG4gICAgICByZXR1cm4gcmVjb3JkLnR5cGUgPSB0eXBlLCByZWNvcmQuYXJnID0gYXJnLCBmaW5hbGx5RW50cnkgPyAodGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2MsIENvbnRpbnVlU2VudGluZWwpIDogdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG4gICAgY29tcGxldGU6IGZ1bmN0aW9uIGNvbXBsZXRlKHJlY29yZCwgYWZ0ZXJMb2MpIHtcbiAgICAgIGlmIChcInRocm93XCIgPT09IHJlY29yZC50eXBlKSB0aHJvdyByZWNvcmQuYXJnO1xuICAgICAgcmV0dXJuIFwiYnJlYWtcIiA9PT0gcmVjb3JkLnR5cGUgfHwgXCJjb250aW51ZVwiID09PSByZWNvcmQudHlwZSA/IHRoaXMubmV4dCA9IHJlY29yZC5hcmcgOiBcInJldHVyblwiID09PSByZWNvcmQudHlwZSA/ICh0aGlzLnJ2YWwgPSB0aGlzLmFyZyA9IHJlY29yZC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSByZWNvcmQudHlwZSAmJiBhZnRlckxvYyAmJiAodGhpcy5uZXh0ID0gYWZ0ZXJMb2MpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgIH0sXG4gICAgZmluaXNoOiBmdW5jdGlvbiBmaW5pc2goZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSByZXR1cm4gdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyksIHJlc2V0VHJ5RW50cnkoZW50cnkpLCBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuICAgIH0sXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbiBfY2F0Y2godHJ5TG9jKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA9PT0gdHJ5TG9jKSB7XG4gICAgICAgICAgdmFyIHJlY29yZCA9IGVudHJ5LmNvbXBsZXRpb247XG4gICAgICAgICAgaWYgKFwidGhyb3dcIiA9PT0gcmVjb3JkLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciB0aHJvd24gPSByZWNvcmQuYXJnO1xuICAgICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aHJvd247XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuICAgIGRlbGVnYXRlWWllbGQ6IGZ1bmN0aW9uIGRlbGVnYXRlWWllbGQoaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGl0ZXJhYmxlKSxcbiAgICAgICAgcmVzdWx0TmFtZTogcmVzdWx0TmFtZSxcbiAgICAgICAgbmV4dExvYzogbmV4dExvY1xuICAgICAgfSwgXCJuZXh0XCIgPT09IHRoaXMubWV0aG9kICYmICh0aGlzLmFyZyA9IHVuZGVmaW5lZCksIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuICB9LCBleHBvcnRzO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfcmVnZW5lcmF0b3JSdW50aW1lLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/setPrototypeOf.js":
/*!***************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
  \***************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  return _setPrototypeOf(o, p);\n}\nmodule.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9zZXRQcm90b3R5cGVPZi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsRUFBRSx5QkFBeUIsU0FBUyx5QkFBeUI7QUFDaEU7QUFDQTtBQUNBLGtDQUFrQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvc2V0UHJvdG90eXBlT2YuanM/MzBlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfSwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzO1xuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfc2V0UHJvdG90eXBlT2YsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPrimitive.js":
/*!************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1ByaW1pdGl2ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxjQUFjLHNHQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9QcmltaXRpdmUuanM/Yjk1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCIuL3R5cGVvZi5qc1wiKVtcImRlZmF1bHRcIl07XG5mdW5jdGlvbiBfdG9QcmltaXRpdmUoaW5wdXQsIGhpbnQpIHtcbiAgaWYgKF90eXBlb2YoaW5wdXQpICE9PSBcIm9iamVjdFwiIHx8IGlucHV0ID09PSBudWxsKSByZXR1cm4gaW5wdXQ7XG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHByaW0gIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChfdHlwZW9mKHJlcykgIT09IFwib2JqZWN0XCIpIHJldHVybiByZXM7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICB9XG4gIHJldHVybiAoaGludCA9PT0gXCJzdHJpbmdcIiA/IFN0cmluZyA6IE51bWJlcikoaW5wdXQpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBfdG9QcmltaXRpdmUsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0czsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/toPrimitive.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/toPropertyKey.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
  \**************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var _typeof = (__webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/typeof.js\")[\"default\"]);\nvar toPrimitive = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/toPrimitive.js\");\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b1Byb3BlcnR5S2V5LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsc0dBQWlDO0FBQy9DLGtCQUFrQixtQkFBTyxDQUFDLDhFQUFrQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyx5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdG9Qcm9wZXJ0eUtleS5qcz9hYzRkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfdHlwZW9mID0gcmVxdWlyZShcIi4vdHlwZW9mLmpzXCIpW1wiZGVmYXVsdFwiXTtcbnZhciB0b1ByaW1pdGl2ZSA9IHJlcXVpcmUoXCIuL3RvUHJpbWl0aXZlLmpzXCIpO1xuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICByZXR1cm4gX3R5cGVvZihrZXkpID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IF90b1Byb3BlcnR5S2V5LCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZSwgbW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHM7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/toPropertyKey.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/typeof.js":
/*!*******************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(obj);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90eXBlb2YuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRyxFQUFFLHlCQUF5QixTQUFTLHlCQUF5QjtBQUNoRTtBQUNBLDBCQUEwQix5QkFBeUIsU0FBUyx5QkFBeUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvdHlwZW9mLmpzPzY5YWMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcbiAgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiO1xuXG4gIHJldHVybiAobW9kdWxlLmV4cG9ydHMgPSBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICB9IDogZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmogJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gIH0sIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlLCBtb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cyksIF90eXBlb2Yob2JqKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZiwgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWUsIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/typeof.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/regenerator/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@babel/runtime/regenerator/index.js ***!
  \**********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("// TODO(Babel 8): Remove this file.\n\nvar runtime = __webpack_require__(/*! ../helpers/regeneratorRuntime */ \"./node_modules/@babel/runtime/helpers/regeneratorRuntime.js\")();\nmodule.exports = runtime;\n\n// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=\ntry {\n  regeneratorRuntime = runtime;\n} catch (accidentalStrictMode) {\n  if (typeof globalThis === \"object\") {\n    globalThis.regeneratorRuntime = runtime;\n  } else {\n    Function(\"r\", \"regeneratorRuntime = r\")(runtime);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvcmVnZW5lcmF0b3IvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRUEsY0FBYyxtQkFBTyxDQUFDLGtHQUErQjtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzPzMxNzYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVE9ETyhCYWJlbCA4KTogUmVtb3ZlIHRoaXMgZmlsZS5cblxudmFyIHJ1bnRpbWUgPSByZXF1aXJlKFwiLi4vaGVscGVycy9yZWdlbmVyYXRvclJ1bnRpbWVcIikoKTtcbm1vZHVsZS5leHBvcnRzID0gcnVudGltZTtcblxuLy8gQ29waWVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlZ2VuZXJhdG9yL2Jsb2IvbWFpbi9wYWNrYWdlcy9ydW50aW1lL3J1bnRpbWUuanMjTDczNj1cbnRyeSB7XG4gIHJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG59IGNhdGNoIChhY2NpZGVudGFsU3RyaWN0TW9kZSkge1xuICBpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09IFwib2JqZWN0XCIpIHtcbiAgICBnbG9iYWxUaGlzLnJlZ2VuZXJhdG9yUnVudGltZSA9IHJ1bnRpbWU7XG4gIH0gZWxzZSB7XG4gICAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/regenerator/index.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _arrayLikeToArray; }\n/* harmony export */ });\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlMaWtlVG9BcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanM/MmFlZSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xuICBpZiAobGVuID09IG51bGwgfHwgbGVuID4gYXJyLmxlbmd0aCkgbGVuID0gYXJyLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICByZXR1cm4gYXJyMjtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _arrayWithHoles; }\n/* harmony export */ });\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRoSG9sZXMuanM/ZjkyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _arrayWithoutHoles; }\n/* harmony export */ });\n/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\");\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXJyYXlXaXRob3V0SG9sZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7QUFDdEM7QUFDZixpQ0FBaUMsZ0VBQWdCO0FBQ2pEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcz82OWQzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _assertThisInitialized; }\n/* harmony export */ });\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXNzZXJ0VGhpc0luaXRpYWxpemVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2Fzc2VydFRoaXNJbml0aWFsaXplZC5qcz8yMTNlIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _asyncToGenerator; }\n/* harmony export */ });\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vYXN5bmNUb0dlbmVyYXRvci5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hc3luY1RvR2VuZXJhdG9yLmpzP2FlMmYiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChpbmZvLmRvbmUpIHtcbiAgICByZXNvbHZlKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oX25leHQsIF90aHJvdyk7XG4gIH1cbn1cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hc3luY1RvR2VuZXJhdG9yKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzLFxuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgZnVuY3Rpb24gX25leHQodmFsdWUpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcIm5leHRcIiwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gX3Rocm93KGVycikge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwidGhyb3dcIiwgZXJyKTtcbiAgICAgIH1cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/classCallCheck.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _classCallCheck; }\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NDYWxsQ2hlY2suanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NsYXNzQ2FsbENoZWNrLmpzPzUyOTciXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/classCallCheck.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/construct.js":
/*!**************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/construct.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _construct; }\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n/* harmony import */ var _isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isNativeReflectConstruct.js */ \"./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\");\n\n\nfunction _construct(Parent, args, Class) {\n  if ((0,_isNativeReflectConstruct_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])()) {\n    _construct = Reflect.construct.bind();\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(instance, Class.prototype);\n      return instance;\n    };\n  }\n  return _construct.apply(null, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY29uc3RydWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFpRDtBQUNvQjtBQUN0RDtBQUNmLE1BQU0sd0VBQXdCO0FBQzlCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQWM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY29uc3RydWN0LmpzPzI2MTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5pbXBvcnQgaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0IGZyb20gXCIuL2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NvbnN0cnVjdChQYXJlbnQsIGFyZ3MsIENsYXNzKSB7XG4gIGlmIChpc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSkge1xuICAgIF9jb25zdHJ1Y3QgPSBSZWZsZWN0LmNvbnN0cnVjdC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2NvbnN0cnVjdCA9IGZ1bmN0aW9uIF9jb25zdHJ1Y3QoUGFyZW50LCBhcmdzLCBDbGFzcykge1xuICAgICAgdmFyIGEgPSBbbnVsbF07XG4gICAgICBhLnB1c2guYXBwbHkoYSwgYXJncyk7XG4gICAgICB2YXIgQ29uc3RydWN0b3IgPSBGdW5jdGlvbi5iaW5kLmFwcGx5KFBhcmVudCwgYSk7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgQ29uc3RydWN0b3IoKTtcbiAgICAgIGlmIChDbGFzcykgc2V0UHJvdG90eXBlT2YoaW5zdGFuY2UsIENsYXNzLnByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gaW5zdGFuY2U7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2NvbnN0cnVjdC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/construct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/createClass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/createClass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _createClass; }\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY3JlYXRlQ2xhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFDL0M7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDZEQUFhO0FBQy9DO0FBQ0E7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2NyZWF0ZUNsYXNzLmpzP2RlOGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHRvUHJvcGVydHlLZXkgZnJvbSBcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiO1xuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/createClass.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/defineProperty.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/defineProperty.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\n/* harmony import */ var _toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toPropertyKey.js */ \"./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\");\n\nfunction _defineProperty(obj, key, value) {\n  key = (0,_toPropertyKey_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBK0M7QUFDaEM7QUFDZixRQUFRLDZEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzP2M5NmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHRvUHJvcGVydHlLZXkgZnJvbSBcIi4vdG9Qcm9wZXJ0eUtleS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/defineProperty.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/get.js":
/*!********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/get.js ***!
  \********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _get; }\n/* harmony export */ });\n/* harmony import */ var _superPropBase_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./superPropBase.js */ \"./node_modules/@babel/runtime/helpers/esm/superPropBase.js\");\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = (0,_superPropBase_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0LmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQStDO0FBQ2hDO0FBQ2Y7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGlCQUFpQiw2REFBYTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0LmpzPzNlNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN1cGVyUHJvcEJhc2UgZnJvbSBcIi4vc3VwZXJQcm9wQmFzZS5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2dldCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ICE9PSBcInVuZGVmaW5lZFwiICYmIFJlZmxlY3QuZ2V0KSB7XG4gICAgX2dldCA9IFJlZmxlY3QuZ2V0LmJpbmQoKTtcbiAgfSBlbHNlIHtcbiAgICBfZ2V0ID0gZnVuY3Rpb24gX2dldCh0YXJnZXQsIHByb3BlcnR5LCByZWNlaXZlcikge1xuICAgICAgdmFyIGJhc2UgPSBzdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/get.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _getPrototypeOf; }\n/* harmony export */ });\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZ2V0UHJvdG90eXBlT2YuanM/YjVlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/inherits.js":
/*!*************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/inherits.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _inherits; }\n/* harmony export */ });\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(subClass, superClass);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaW5oZXJpdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBaUQ7QUFDbEM7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSCxrQkFBa0IsOERBQWM7QUFDaEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2luaGVyaXRzLmpzPzMwNWUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcImZ1bmN0aW9uXCIgJiYgc3VwZXJDbGFzcyAhPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgfVxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcbiAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgdmFsdWU6IHN1YkNsYXNzLFxuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3ViQ2xhc3MsIFwicHJvdG90eXBlXCIsIHtcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSk7XG4gIGlmIChzdXBlckNsYXNzKSBzZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/inherits.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _isNativeFunction; }\n/* harmony export */ });\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXNOYXRpdmVGdW5jdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pc05hdGl2ZUZ1bmN0aW9uLmpzPzk3NGYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzTmF0aXZlRnVuY3Rpb24oZm4pIHtcbiAgcmV0dXJuIEZ1bmN0aW9uLnRvU3RyaW5nLmNhbGwoZm4pLmluZGV4T2YoXCJbbmF0aXZlIGNvZGVdXCIpICE9PSAtMTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _isNativeReflectConstruct; }\n/* harmony export */ });\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0ZBQWdGO0FBQ2hGO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0LmpzPzhhYTkiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2lzTmF0aXZlUmVmbGVjdENvbnN0cnVjdCgpIHtcbiAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcInVuZGVmaW5lZFwiIHx8ICFSZWZsZWN0LmNvbnN0cnVjdCkgcmV0dXJuIGZhbHNlO1xuICBpZiAoUmVmbGVjdC5jb25zdHJ1Y3Quc2hhbSkgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIFByb3h5ID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiB0cnVlO1xuICB0cnkge1xuICAgIEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _iterableToArray; }\n/* harmony export */ });\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2l0ZXJhYmxlVG9BcnJheS5qcz8xYmExIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpdGVyW1N5bWJvbC5pdGVyYXRvcl0gIT0gbnVsbCB8fCBpdGVyW1wiQEBpdGVyYXRvclwiXSAhPSBudWxsKSByZXR1cm4gQXJyYXkuZnJvbShpdGVyKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _iterableToArrayLimit; }\n/* harmony export */ });\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLFlBQVksNkVBQTZFO0FBQ2pHLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanM/MDNmNCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XG4gIHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICBpZiAobnVsbCAhPSBfaSkge1xuICAgIHZhciBfcyxcbiAgICAgIF9lLFxuICAgICAgX3gsXG4gICAgICBfcixcbiAgICAgIF9hcnIgPSBbXSxcbiAgICAgIF9uID0gITAsXG4gICAgICBfZCA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoX3ggPSAoX2kgPSBfaS5jYWxsKGFycikpLm5leHQsIDAgPT09IGkpIHtcbiAgICAgICAgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47XG4gICAgICAgIF9uID0gITE7XG4gICAgICB9IGVsc2UgZm9yICg7ICEoX24gPSAoX3MgPSBfeC5jYWxsKF9pKSkuZG9uZSkgJiYgKF9hcnIucHVzaChfcy52YWx1ZSksIF9hcnIubGVuZ3RoICE9PSBpKTsgX24gPSAhMCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBfZCA9ICEwLCBfZSA9IGVycjtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFfbiAmJiBudWxsICE9IF9pW1wicmV0dXJuXCJdICYmIChfciA9IF9pW1wicmV0dXJuXCJdKCksIE9iamVjdChfcikgIT09IF9yKSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9hcnI7XG4gIH1cbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _nonIterableRest; }\n/* harmony export */ });\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL25vbkl0ZXJhYmxlUmVzdC5qcz80MDQ1Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _nonIterableSpread; }\n/* harmony export */ });\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVTcHJlYWQuanM/MmZhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutProperties; }\n/* harmony export */ });\n/* harmony import */ var _objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./objectWithoutPropertiesLoose.js */ \"./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = (0,_objectWithoutPropertiesLoose_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBNkU7QUFDOUQ7QUFDZjtBQUNBLGVBQWUsNEVBQTRCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXMuanM/Njk0MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiLi9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IG9iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _objectWithoutPropertiesLoose; }\n/* harmony export */ });\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZS5qcz9hYTQwIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _possibleConstructorReturn; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./assertThisInitialized.js */ \"./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\");\n\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return (0,_assertThisInitialized_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(self);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDNkI7QUFDaEQ7QUFDZixlQUFlLHNEQUFPO0FBQ3RCO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxTQUFTLHFFQUFxQjtBQUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vcG9zc2libGVDb25zdHJ1Y3RvclJldHVybi5qcz84MDUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuaW1wb3J0IGFzc2VydFRoaXNJbml0aWFsaXplZCBmcm9tIFwiLi9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKF90eXBlb2YoY2FsbCkgPT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGNhbGwgPT09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gY2FsbDtcbiAgfSBlbHNlIGlmIChjYWxsICE9PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRGVyaXZlZCBjb25zdHJ1Y3RvcnMgbWF5IG9ubHkgcmV0dXJuIG9iamVjdCBvciB1bmRlZmluZWRcIik7XG4gIH1cbiAgcmV0dXJuIGFzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _setPrototypeOf; }\n/* harmony export */ });\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2V0UHJvdG90eXBlT2YuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9zZXRQcm90b3R5cGVPZi5qcz81MzdiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _slicedToArray; }\n/* harmony export */ });\n/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ \"./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js\");\n/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ \"./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js\");\n/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\");\n/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ \"./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js\");\n\n\n\n\nfunction _slicedToArray(arr, i) {\n  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFpRDtBQUNZO0FBQ1k7QUFDdEI7QUFDcEM7QUFDZixTQUFTLDhEQUFjLFNBQVMsb0VBQW9CLFlBQVksMEVBQTBCLFlBQVksK0RBQWU7QUFDckgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanM/YTJhYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXJyYXlXaXRoSG9sZXMgZnJvbSBcIi4vYXJyYXlXaXRoSG9sZXMuanNcIjtcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVSZXN0IGZyb20gXCIuL25vbkl0ZXJhYmxlUmVzdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBhcnJheVdpdGhIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBub25JdGVyYWJsZVJlc3QoKTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/slicedToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/superPropBase.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/superPropBase.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _superPropBase; }\n/* harmony export */ });\n/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(object);\n    if (object === null) break;\n  }\n  return object;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc3VwZXJQcm9wQmFzZS5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFpRDtBQUNsQztBQUNmO0FBQ0EsYUFBYSw4REFBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc3VwZXJQcm9wQmFzZS5qcz85OTcwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IGdldFByb3RvdHlwZU9mKG9iamVjdCk7XG4gICAgaWYgKG9iamVjdCA9PT0gbnVsbCkgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIG9iamVjdDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/superPropBase.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _toConsumableArray; }\n/* harmony export */ });\n/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ \"./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js\");\n/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ \"./node_modules/@babel/runtime/helpers/esm/iterableToArray.js\");\n/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ \"./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\");\n/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ \"./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js\");\n\n\n\n\nfunction _toConsumableArray(arr) {\n  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBdUQ7QUFDSjtBQUNzQjtBQUNsQjtBQUN4QztBQUNmLFNBQVMsaUVBQWlCLFNBQVMsK0RBQWUsU0FBUywwRUFBMEIsU0FBUyxpRUFBaUI7QUFDL0ciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3RvQ29uc3VtYWJsZUFycmF5LmpzPzg2NmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPrimitive.js":
/*!****************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPrimitive.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _toPrimitive; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n\nfunction _toPrimitive(input, hint) {\n  if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if ((0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9QcmltaXRpdmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBa0M7QUFDbkI7QUFDZixNQUFNLHNEQUFPO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsUUFBUSxzREFBTztBQUNmO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b1ByaW1pdGl2ZS5qcz8yZGJmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gIGlmIChfdHlwZW9mKGlucHV0KSAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICB2YXIgcHJpbSA9IGlucHV0W1N5bWJvbC50b1ByaW1pdGl2ZV07XG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVzID0gcHJpbS5jYWxsKGlucHV0LCBoaW50IHx8IFwiZGVmYXVsdFwiKTtcbiAgICBpZiAoX3R5cGVvZihyZXMpICE9PSBcIm9iamVjdFwiKSByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _toPropertyKey; }\n/* harmony export */ });\n/* harmony import */ var _typeof_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./typeof.js */ \"./node_modules/@babel/runtime/helpers/esm/typeof.js\");\n/* harmony import */ var _toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toPrimitive.js */ \"./node_modules/@babel/runtime/helpers/esm/toPrimitive.js\");\n\n\nfunction _toPropertyKey(arg) {\n  var key = (0,_toPrimitive_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(arg, \"string\");\n  return (0,_typeof_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(key) === \"symbol\" ? key : String(key);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0M7QUFDUztBQUM1QjtBQUNmLFlBQVksMkRBQVc7QUFDdkIsU0FBUyxzREFBTztBQUNoQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Qcm9wZXJ0eUtleS5qcz9lMTFiIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfdHlwZW9mIGZyb20gXCIuL3R5cGVvZi5qc1wiO1xuaW1wb3J0IHRvUHJpbWl0aXZlIGZyb20gXCIuL3RvUHJpbWl0aXZlLmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdG9Qcm9wZXJ0eUtleShhcmcpIHtcbiAgdmFyIGtleSA9IHRvUHJpbWl0aXZlKGFyZywgXCJzdHJpbmdcIik7XG4gIHJldHVybiBfdHlwZW9mKGtleSkgPT09IFwic3ltYm9sXCIgPyBrZXkgOiBTdHJpbmcoa2V5KTtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/toPropertyKey.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/typeof.js":
/*!***********************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/typeof.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _typeof; }\n/* harmony export */ });\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdHlwZW9mLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3R5cGVvZi5qcz8xYWIzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICByZXR1cm4gX3R5cGVvZiA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gb2JqICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICB9LCBfdHlwZW9mKG9iaik7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/typeof.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _unsupportedIterableToArray; }\n/* harmony export */ });\n/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ \"./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js\");\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(o, minLen);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBcUQ7QUFDdEM7QUFDZjtBQUNBLG9DQUFvQyxnRUFBZ0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0Esc0ZBQXNGLGdFQUFnQjtBQUN0RyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanM/ZDI1YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG4gIHZhciBuID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pLnNsaWNlKDgsIC0xKTtcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgaWYgKG4gPT09IFwiTWFwXCIgfHwgbiA9PT0gXCJTZXRcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XG4gIGlmIChuID09PSBcIkFyZ3VtZW50c1wiIHx8IC9eKD86VWl8SSludCg/Ojh8MTZ8MzIpKD86Q2xhbXBlZCk/QXJyYXkkLy50ZXN0KG4pKSByZXR1cm4gYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js\n"));

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _wrapNativeSuper; }\n/* harmony export */ });\n/* harmony import */ var _getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./getPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\");\n/* harmony import */ var _setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./setPrototypeOf.js */ \"./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js\");\n/* harmony import */ var _isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isNativeFunction.js */ \"./node_modules/@babel/runtime/helpers/esm/isNativeFunction.js\");\n/* harmony import */ var _construct_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./construct.js */ \"./node_modules/@babel/runtime/helpers/esm/construct.js\");\n\n\n\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !(0,_isNativeFunction_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(Class)) return Class;\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n      _cache.set(Class, Wrapper);\n    }\n    function Wrapper() {\n      return (0,_construct_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(Class, arguments, (0,_getPrototypeOf_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this).constructor);\n    }\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return (0,_setPrototypeOf_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Wrapper, Class);\n  };\n  return _wrapNativeSuper(Class);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vd3JhcE5hdGl2ZVN1cGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWlEO0FBQ0E7QUFDSTtBQUNkO0FBQ3hCO0FBQ2Y7QUFDQTtBQUNBLDJCQUEyQixnRUFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEseURBQVMsbUJBQW1CLDhEQUFjO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsV0FBVyw4REFBYztBQUN6QjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3dyYXBOYXRpdmVTdXBlci5qcz8xMDFlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBnZXRQcm90b3R5cGVPZiBmcm9tIFwiLi9nZXRQcm90b3R5cGVPZi5qc1wiO1xuaW1wb3J0IHNldFByb3RvdHlwZU9mIGZyb20gXCIuL3NldFByb3RvdHlwZU9mLmpzXCI7XG5pbXBvcnQgaXNOYXRpdmVGdW5jdGlvbiBmcm9tIFwiLi9pc05hdGl2ZUZ1bmN0aW9uLmpzXCI7XG5pbXBvcnQgY29uc3RydWN0IGZyb20gXCIuL2NvbnN0cnVjdC5qc1wiO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICB2YXIgX2NhY2hlID0gdHlwZW9mIE1hcCA9PT0gXCJmdW5jdGlvblwiID8gbmV3IE1hcCgpIDogdW5kZWZpbmVkO1xuICBfd3JhcE5hdGl2ZVN1cGVyID0gZnVuY3Rpb24gX3dyYXBOYXRpdmVTdXBlcihDbGFzcykge1xuICAgIGlmIChDbGFzcyA9PT0gbnVsbCB8fCAhaXNOYXRpdmVGdW5jdGlvbihDbGFzcykpIHJldHVybiBDbGFzcztcbiAgICBpZiAodHlwZW9mIENsYXNzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvblwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBfY2FjaGUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgIGlmIChfY2FjaGUuaGFzKENsYXNzKSkgcmV0dXJuIF9jYWNoZS5nZXQoQ2xhc3MpO1xuICAgICAgX2NhY2hlLnNldChDbGFzcywgV3JhcHBlcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFdyYXBwZXIoKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0KENsYXNzLCBhcmd1bWVudHMsIGdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgV3JhcHBlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENsYXNzLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IFdyYXBwZXIsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHNldFByb3RvdHlwZU9mKFdyYXBwZXIsIENsYXNzKTtcbiAgfTtcbiAgcmV0dXJuIF93cmFwTmF0aXZlU3VwZXIoQ2xhc3MpO1xufSJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"./node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQzBDO0FBQ3FCO0FBQ1A7QUFDeEQ7QUFDTztBQUNQO0FBQ0E7QUFDQSxnQ0FBZ0Msd0RBQUksWUFBWSxnRUFBVztBQUMzRCxtQkFBbUI7QUFDbkI7QUFDQTtBQUNPO0FBQ1AsNkJBQTZCLHFFQUFXLEdBQUcsK0JBQStCO0FBQzFFLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vX3Nob3J0d191dGlscy5qcz80Y2Y3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IGhtYWMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL2htYWMnO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyB3ZWllcnN0cmFzcyB9IGZyb20gJy4vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMnO1xuLy8gY29ubmVjdHMgbm9ibGUtY3VydmVzIHRvIG5vYmxlLWhhc2hlc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEhhc2goaGFzaCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhc2gsXG4gICAgICAgIGhtYWM6IChrZXksIC4uLm1zZ3MpID0+IGhtYWMoaGFzaCwga2V5LCBjb25jYXRCeXRlcyguLi5tc2dzKSksXG4gICAgICAgIHJhbmRvbUJ5dGVzLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ3VydmUoY3VydmVEZWYsIGRlZkhhc2gpIHtcbiAgICBjb25zdCBjcmVhdGUgPSAoaGFzaCkgPT4gd2VpZXJzdHJhc3MoeyAuLi5jdXJ2ZURlZiwgLi4uZ2V0SGFzaChoYXNoKSB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLmNyZWF0ZShkZWZIYXNoKSwgY3JlYXRlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3Nob3J0d191dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(1) * (Math.ceil( / ) + 1), where:\n         * -  is the window size\n         * -  is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvY3VydmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBO0FBQ0E7QUFDc0Q7QUFDVjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCx5Q0FBeUM7QUFDekMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0EsaUNBQWlDLGtCQUFrQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUCxJQUFJLDBEQUFhO0FBQ2pCLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsV0FBVyxvREFBTztBQUNsQjtBQUNBLGFBQWEsbUJBQW1CO0FBQ2hDLEtBQUs7QUFDTDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcz9lMWFjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIEFiZWxpYW4gZ3JvdXAgdXRpbGl0aWVzXG5pbXBvcnQgeyB2YWxpZGF0ZUZpZWxkLCBuTGVuZ3RoIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IHZhbGlkYXRlT2JqZWN0IH0gZnJvbSAnLi91dGlscy5qcyc7XG5jb25zdCBfMG4gPSBCaWdJbnQoMCk7XG5jb25zdCBfMW4gPSBCaWdJbnQoMSk7XG4vLyBFbGxpcHRpYyBjdXJ2ZSBtdWx0aXBsaWNhdGlvbiBvZiBQb2ludCBieSBzY2FsYXIuIEZyYWdpbGUuXG4vLyBTY2FsYXJzIHNob3VsZCBhbHdheXMgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyOiB0aGlzIHNob3VsZCBiZSBjaGVja2VkIGluc2lkZSBvZiBhIGN1cnZlIGl0c2VsZi5cbi8vIENyZWF0ZXMgcHJlY29tcHV0YXRpb24gdGFibGVzIGZvciBmYXN0IG11bHRpcGxpY2F0aW9uOlxuLy8gLSBwcml2YXRlIHNjYWxhciBpcyBzcGxpdCBieSBmaXhlZCBzaXplIHdpbmRvd3Mgb2YgVyBiaXRzXG4vLyAtIGV2ZXJ5IHdpbmRvdyBwb2ludCBpcyBjb2xsZWN0ZWQgZnJvbSB3aW5kb3cncyB0YWJsZSAmIGFkZGVkIHRvIGFjY3VtdWxhdG9yXG4vLyAtIHNpbmNlIHdpbmRvd3MgYXJlIGRpZmZlcmVudCwgc2FtZSBwb2ludCBpbnNpZGUgdGFibGVzIHdvbid0IGJlIGFjY2Vzc2VkIG1vcmUgdGhhbiBvbmNlIHBlciBjYWxjXG4vLyAtIGVhY2ggbXVsdGlwbGljYXRpb24gaXMgJ01hdGguY2VpbChDVVJWRV9PUkRFUiAvIPCdkYopICsgMScgcG9pbnQgYWRkaXRpb25zIChmaXhlZCBmb3IgYW55IHNjYWxhcilcbi8vIC0gKzEgd2luZG93IGlzIG5lY2Nlc3NhcnkgZm9yIHdOQUZcbi8vIC0gd05BRiByZWR1Y2VzIHRhYmxlIHNpemU6IDJ4IGxlc3MgbWVtb3J5ICsgMnggZmFzdGVyIGdlbmVyYXRpb24sIGJ1dCAxMCUgc2xvd2VyIG11bHRpcGxpY2F0aW9uXG4vLyBUT0RPOiBSZXNlYXJjaCByZXR1cm5pbmcgMmQgSlMgYXJyYXkgb2Ygd2luZG93cywgaW5zdGVhZCBvZiBhIHNpbmdsZSB3aW5kb3cuIFRoaXMgd291bGQgYWxsb3dcbi8vIHdpbmRvd3MgdG8gYmUgaW4gZGlmZmVyZW50IG1lbW9yeSBsb2NhdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiB3TkFGKGMsIGJpdHMpIHtcbiAgICBjb25zdCBjb25zdFRpbWVOZWdhdGUgPSAoY29uZGl0aW9uLCBpdGVtKSA9PiB7XG4gICAgICAgIGNvbnN0IG5lZyA9IGl0ZW0ubmVnYXRlKCk7XG4gICAgICAgIHJldHVybiBjb25kaXRpb24gPyBuZWcgOiBpdGVtO1xuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IChXKSA9PiB7XG4gICAgICAgIGNvbnN0IHdpbmRvd3MgPSBNYXRoLmNlaWwoYml0cyAvIFcpICsgMTsgLy8gKzEsIGJlY2F1c2VcbiAgICAgICAgY29uc3Qgd2luZG93U2l6ZSA9IDIgKiogKFcgLSAxKTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgcmV0dXJuIHsgd2luZG93cywgd2luZG93U2l6ZSB9O1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29uc3RUaW1lTmVnYXRlLFxuICAgICAgICAvLyBub24tY29uc3QgdGltZSBtdWx0aXBsaWNhdGlvbiBsYWRkZXJcbiAgICAgICAgdW5zYWZlTGFkZGVyKGVsbSwgbikge1xuICAgICAgICAgICAgbGV0IHAgPSBjLlpFUk87XG4gICAgICAgICAgICBsZXQgZCA9IGVsbTtcbiAgICAgICAgICAgIHdoaWxlIChuID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKG4gJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBuID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSB3TkFGIHByZWNvbXB1dGF0aW9uIHdpbmRvdy4gVXNlZCBmb3IgY2FjaGluZy5cbiAgICAgICAgICogRGVmYXVsdCB3aW5kb3cgc2l6ZSBpcyBzZXQgYnkgYHV0aWxzLnByZWNvbXB1dGUoKWAgYW5kIGlzIGVxdWFsIHRvIDguXG4gICAgICAgICAqIE51bWJlciBvZiBwcmVjb21wdXRlZCBwb2ludHMgZGVwZW5kcyBvbiB0aGUgY3VydmUgc2l6ZTpcbiAgICAgICAgICogMl4o8J2RiuKIkjEpICogKE1hdGguY2VpbCjwnZGbIC8g8J2RiikgKyAxKSwgd2hlcmU6XG4gICAgICAgICAqIC0g8J2RiiBpcyB0aGUgd2luZG93IHNpemVcbiAgICAgICAgICogLSDwnZGbIGlzIHRoZSBiaXRsZW5ndGggb2YgdGhlIGN1cnZlIG9yZGVyLlxuICAgICAgICAgKiBGb3IgYSAyNTYtYml0IGN1cnZlIGFuZCB3aW5kb3cgc2l6ZSA4LCB0aGUgbnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBpcyAxMjggKiAzMyA9IDQyMjQuXG4gICAgICAgICAqIEByZXR1cm5zIHByZWNvbXB1dGVkIHBvaW50IHRhYmxlcyBmbGF0dGVuZWQgdG8gYSBzaW5nbGUgYXJyYXlcbiAgICAgICAgICovXG4gICAgICAgIHByZWNvbXB1dGVXaW5kb3coZWxtLCBXKSB7XG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXTtcbiAgICAgICAgICAgIGxldCBwID0gZWxtO1xuICAgICAgICAgICAgbGV0IGJhc2UgPSBwO1xuICAgICAgICAgICAgZm9yIChsZXQgd2luZG93ID0gMDsgd2luZG93IDwgd2luZG93czsgd2luZG93KyspIHtcbiAgICAgICAgICAgICAgICBiYXNlID0gcDtcbiAgICAgICAgICAgICAgICBwb2ludHMucHVzaChiYXNlKTtcbiAgICAgICAgICAgICAgICAvLyA9MSwgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8IHdpbmRvd1NpemU7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBiYXNlID0gYmFzZS5hZGQocCk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwID0gYmFzZS5kb3VibGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRzIGVjIG11bHRpcGxpY2F0aW9uIHVzaW5nIHByZWNvbXB1dGVkIHRhYmxlcyBhbmQgdy1hcnkgbm9uLWFkamFjZW50IGZvcm0uXG4gICAgICAgICAqIEBwYXJhbSBXIHdpbmRvdyBzaXplXG4gICAgICAgICAqIEBwYXJhbSBwcmVjb21wdXRlcyBwcmVjb21wdXRlZCB0YWJsZXNcbiAgICAgICAgICogQHBhcmFtIG4gc2NhbGFyICh3ZSBkb24ndCBjaGVjayBoZXJlLCBidXQgc2hvdWxkIGJlIGxlc3MgdGhhbiBjdXJ2ZSBvcmRlcilcbiAgICAgICAgICogQHJldHVybnMgcmVhbCBhbmQgZmFrZSAoZm9yIGNvbnN0LXRpbWUpIHBvaW50c1xuICAgICAgICAgKi9cbiAgICAgICAgd05BRihXLCBwcmVjb21wdXRlcywgbikge1xuICAgICAgICAgICAgLy8gVE9ETzogbWF5YmUgY2hlY2sgdGhhdCBzY2FsYXIgaXMgbGVzcyB0aGFuIGdyb3VwIG9yZGVyPyB3TkFGIGJlaGF2aW91cyBpcyB1bmRlZmluZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBCdXQgbmVlZCB0byBjYXJlZnVsbHkgcmVtb3ZlIG90aGVyIGNoZWNrcyBiZWZvcmUgd05BRi4gT1JERVIgPT0gYml0cyBoZXJlXG4gICAgICAgICAgICBjb25zdCB7IHdpbmRvd3MsIHdpbmRvd1NpemUgfSA9IG9wdHMoVyk7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBmID0gYy5CQVNFO1xuICAgICAgICAgICAgY29uc3QgbWFzayA9IEJpZ0ludCgyICoqIFcgLSAxKTsgLy8gQ3JlYXRlIG1hc2sgd2l0aCBXIG9uZXM6IDBiMTExMSBmb3IgVz00IGV0Yy5cbiAgICAgICAgICAgIGNvbnN0IG1heE51bWJlciA9IDIgKiogVztcbiAgICAgICAgICAgIGNvbnN0IHNoaWZ0QnkgPSBCaWdJbnQoVyk7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9IHdpbmRvdyAqIHdpbmRvd1NpemU7XG4gICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbGV0IHdiaXRzID0gTnVtYmVyKG4gJiBtYXNrKTtcbiAgICAgICAgICAgICAgICAvLyBTaGlmdCBudW1iZXIgYnkgVyBiaXRzLlxuICAgICAgICAgICAgICAgIG4gPj49IHNoaWZ0Qnk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJpdHMgYXJlIGJpZ2dlciB0aGFuIG1heCBzaXplLCB3ZSdsbCBzcGxpdCB0aG9zZS5cbiAgICAgICAgICAgICAgICAvLyArMjI0ID0+IDI1NiAtIDMyXG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID4gd2luZG93U2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB3Yml0cyAtPSBtYXhOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgIG4gKz0gXzFuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNvZGUgd2FzIGZpcnN0IHdyaXR0ZW4gd2l0aCBhc3N1bXB0aW9uIHRoYXQgJ2YnIGFuZCAncCcgd2lsbCBuZXZlciBiZSBpbmZpbml0eSBwb2ludDpcbiAgICAgICAgICAgICAgICAvLyBzaW5jZSBlYWNoIGFkZGl0aW9uIGlzIG11bHRpcGxpZWQgYnkgMiAqKiBXLCBpdCBjYW5ub3QgY2FuY2VsIGVhY2ggb3RoZXIuIEhvd2V2ZXIsXG4gICAgICAgICAgICAgICAgLy8gdGhlcmUgaXMgbmVnYXRlIG5vdzogaXQgaXMgcG9zc2libGUgdGhhdCBuZWdhdGVkIGVsZW1lbnQgZnJvbSBsb3cgdmFsdWVcbiAgICAgICAgICAgICAgICAvLyB3b3VsZCBiZSB0aGUgc2FtZSBhcyBoaWdoIGVsZW1lbnQsIHdoaWNoIHdpbGwgY3JlYXRlIGNhcnJ5IGludG8gbmV4dCB3aW5kb3cuXG4gICAgICAgICAgICAgICAgLy8gSXQncyBub3Qgb2J2aW91cyBob3cgdGhpcyBjYW4gZmFpbCwgYnV0IHN0aWxsIHdvcnRoIGludmVzdGlnYXRpbmcgbGF0ZXIuXG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UncmUgb250byBaZXJvIHBvaW50LlxuICAgICAgICAgICAgICAgIC8vIEFkZCByYW5kb20gcG9pbnQgaW5zaWRlIGN1cnJlbnQgd2luZG93IHRvIGYuXG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0MSA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQyID0gb2Zmc2V0ICsgTWF0aC5hYnMod2JpdHMpIC0gMTsgLy8gLTEgYmVjYXVzZSB3ZSBza2lwIHplcm9cbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMSA9IHdpbmRvdyAlIDIgIT09IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgY29uZDIgPSB3Yml0cyA8IDA7XG4gICAgICAgICAgICAgICAgaWYgKHdiaXRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtb3N0IGltcG9ydGFudCBwYXJ0IGZvciBjb25zdC10aW1lIGdldFB1YmxpY0tleVxuICAgICAgICAgICAgICAgICAgICBmID0gZi5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQxLCBwcmVjb21wdXRlc1tvZmZzZXQxXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGNvbnN0VGltZU5lZ2F0ZShjb25kMiwgcHJlY29tcHV0ZXNbb2Zmc2V0Ml0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBKSVQtY29tcGlsZXIgc2hvdWxkIG5vdCBlbGltaW5hdGUgZiBoZXJlLCBzaW5jZSBpdCB3aWxsIGxhdGVyIGJlIHVzZWQgaW4gbm9ybWFsaXplWigpXG4gICAgICAgICAgICAvLyBFdmVuIGlmIHRoZSB2YXJpYWJsZSBpcyBzdGlsbCB1bnVzZWQsIHRoZXJlIGFyZSBzb21lIGNoZWNrcyB3aGljaCB3aWxsXG4gICAgICAgICAgICAvLyB0aHJvdyBhbiBleGNlcHRpb24sIHNvIGNvbXBpbGVyIG5lZWRzIHRvIHByb3ZlIHRoZXkgd29uJ3QgaGFwcGVuLCB3aGljaCBpcyBoYXJkLlxuICAgICAgICAgICAgLy8gQXQgdGhpcyBwb2ludCB0aGVyZSBpcyBhIHdheSB0byBGIGJlIGluZmluaXR5LXBvaW50IGV2ZW4gaWYgcCBpcyBub3QsXG4gICAgICAgICAgICAvLyB3aGljaCBtYWtlcyBpdCBsZXNzIGNvbnN0LXRpbWU6IGFyb3VuZCAxIGJpZ2ludCBtdWx0aXBseS5cbiAgICAgICAgICAgIHJldHVybiB7IHAsIGYgfTtcbiAgICAgICAgfSxcbiAgICAgICAgd05BRkNhY2hlZChQLCBwcmVjb21wdXRlc01hcCwgbiwgdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBXID0gUC5fV0lORE9XX1NJWkUgfHwgMTtcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwcmVjb21wdXRlcyBvbiBhIGZpcnN0IHJ1biwgcmV1c2UgdGhlbSBhZnRlclxuICAgICAgICAgICAgbGV0IGNvbXAgPSBwcmVjb21wdXRlc01hcC5nZXQoUCk7XG4gICAgICAgICAgICBpZiAoIWNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wID0gdGhpcy5wcmVjb21wdXRlV2luZG93KFAsIFcpO1xuICAgICAgICAgICAgICAgIGlmIChXICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZWNvbXB1dGVzTWFwLnNldChQLCB0cmFuc2Zvcm0oY29tcCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLndOQUYoVywgY29tcCwgbik7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUJhc2ljKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVGaWVsZChjdXJ2ZS5GcCk7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgbjogJ2JpZ2ludCcsXG4gICAgICAgIGg6ICdiaWdpbnQnLFxuICAgICAgICBHeDogJ2ZpZWxkJyxcbiAgICAgICAgR3k6ICdmaWVsZCcsXG4gICAgfSwge1xuICAgICAgICBuQml0TGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIG5CeXRlTGVuZ3RoOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAuLi5uTGVuZ3RoKGN1cnZlLm4sIGN1cnZlLm5CaXRMZW5ndGgpLFxuICAgICAgICAuLi5jdXJ2ZSxcbiAgICAgICAgLi4ueyBwOiBjdXJ2ZS5GcC5PUkRFUiB9LFxuICAgIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3VydmUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/edwards.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: function() { return /* binding */ twistedEdwards; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax + y = 1 + dxy\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax + y = 1 + dxy\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X\n            const Y2 = modP(Y * Y); // Y\n            const Z2 = modP(Z * Z); // Z\n            const Z4 = modP(Z2 * Z2); // Z\n            const aX2 = modP(X2 * a); // aX\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n            // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y - 1\n            const v = modP(d * y2 - a); // v = d y + 1.\n            let { isValid, value: x } = uvRatio(u, v); // (u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNtQztBQUNGO0FBQ1E7QUFDUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlCQUFpQix3REFBYTtBQUM5QixJQUFJLHFEQUFpQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixTQUFTO0FBQ3BDO0FBQ0E7QUFDTztBQUNQO0FBQ0EsWUFBWSw0RkFBNEY7QUFDeEc7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLFNBQVM7QUFDVCw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsR0FBRztBQUNaLDJEQUEyRDtBQUMzRCxtRUFBbUU7QUFDbkUsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksUUFBUSxVQUFVLEVBQUUsRUFBRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBLG9C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QTtBQUNBO0FBQ0Esb0JBQW9CLHNEQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsc0RBQVc7QUFDekI7QUFDQTtBQUNBLHVCQUF1QixzREFBVztBQUNsQyw4REFBOEQ7QUFDOUQsbURBQW1EO0FBQ25ELHNDQUFzQztBQUN0QywwQ0FBMEM7QUFDMUMsK0NBQStDO0FBQy9DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrREFBYztBQUNsQyx5Q0FBeUMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBLDRDQUE0QztBQUM1QyxjQUFjLHNEQUFXO0FBQ3pCO0FBQ0EsZ0NBQWdDO0FBQ2hDLGdCQUFnQiw2QkFBNkI7QUFDN0Msb0VBQW9FO0FBQ3BFLDhDQUE4QztBQUM5QywyRUFBMkU7QUFDM0Usd0NBQXdDO0FBQ3hDLHNCQUFzQjtBQUN0QixvQkFBb0Isa0RBQWMsSUFBSSxzREFBa0I7QUFDeEQsZUFBZSxzREFBVyxrQ0FBa0M7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyw4QkFBOEI7QUFDOUIsY0FBYyxzREFBVyw2QkFBNkI7QUFDdEQsY0FBYyxzREFBVztBQUN6QjtBQUNBLGdDQUFnQztBQUNoQyxrQkFBa0Isc0RBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvZWR3YXJkcy5qcz9iYmFlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZS4gVGhlIGZvcm11bGEgaXM6IGF4wrIgKyB5wrIgPSAxICsgZHjCsnnCslxuaW1wb3J0IHsgbW9kIH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyB2ZXJpZmljYXRpb24gcnVsZSBpcyBlaXRoZXIgemlwMjE1IG9yIHJmYzgwMzIgLyBuaXN0MTg2LTUuIENvbnN1bHQgZnJvbUhleDpcbmNvbnN0IFZFUklGWV9ERUZBVUxUID0geyB6aXAyMTU6IHRydWUgfTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIGNvbnN0IG9wdHMgPSB2YWxpZGF0ZUJhc2ljKGN1cnZlKTtcbiAgICB1dC52YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBoYXNoOiAnZnVuY3Rpb24nLFxuICAgICAgICBhOiAnYmlnaW50JyxcbiAgICAgICAgZDogJ2JpZ2ludCcsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGRvbWFpbjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdXZSYXRpbzogJ2Z1bmN0aW9uJyxcbiAgICAgICAgbWFwVG9DdXJ2ZTogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IC4uLm9wdHMgfSk7XG59XG4vLyBJdCBpcyBub3QgZ2VuZXJpYyB0d2lzdGVkIGN1cnZlIGZvciBub3csIGJ1dCBlZDI1NTE5L2VkNDQ4IGdlbmVyaWMgaW1wbGVtZW50YXRpb25cbmV4cG9ydCBmdW5jdGlvbiB0d2lzdGVkRWR3YXJkcyhjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IEZwLCBuOiBDVVJWRV9PUkRFUiwgcHJlaGFzaDogcHJlaGFzaCwgaGFzaDogY0hhc2gsIHJhbmRvbUJ5dGVzLCBuQnl0ZUxlbmd0aCwgaDogY29mYWN0b3IsIH0gPSBDVVJWRTtcbiAgICBjb25zdCBNQVNLID0gXzJuIDw8IChCaWdJbnQobkJ5dGVMZW5ndGggKiA4KSAtIF8xbik7XG4gICAgY29uc3QgbW9kUCA9IEZwLmNyZWF0ZTsgLy8gRnVuY3Rpb24gb3ZlcnJpZGVzXG4gICAgLy8gc3FydCh1L3YpXG4gICAgY29uc3QgdXZSYXRpbyA9IENVUlZFLnV2UmF0aW8gfHxcbiAgICAgICAgKCh1LCB2KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IHRydWUsIHZhbHVlOiBGcC5zcXJ0KHUgKiBGcC5pbnYodikpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGZhbHNlLCB2YWx1ZTogXzBuIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpOyAvLyBOT09QXG4gICAgY29uc3QgZG9tYWluID0gQ1VSVkUuZG9tYWluIHx8XG4gICAgICAgICgoZGF0YSwgY3R4LCBwaGZsYWcpID0+IHtcbiAgICAgICAgICAgIGlmIChjdHgubGVuZ3RoIHx8IHBoZmxhZylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHRzL3ByZS1oYXNoIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZGF0YTtcbiAgICAgICAgfSk7IC8vIE5PT1BcbiAgICBjb25zdCBpbkJpZyA9IChuKSA9PiB0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbjsgLy8gbiBpbiBbMS4uXVxuICAgIGNvbnN0IGluUmFuZ2UgPSAobiwgbWF4KSA9PiBpbkJpZyhuKSAmJiBpbkJpZyhtYXgpICYmIG4gPCBtYXg7IC8vIG4gaW4gWzEuLm1heC0xXVxuICAgIGNvbnN0IGluME1hc2tSYW5nZSA9IChuKSA9PiBuID09PSBfMG4gfHwgaW5SYW5nZShuLCBNQVNLKTsgLy8gbiBpbiBbMC4uTUFTSy0xXVxuICAgIGZ1bmN0aW9uIGFzc2VydEluUmFuZ2UobiwgbWF4KSB7XG4gICAgICAgIC8vIG4gaW4gWzEuLm1heC0xXVxuICAgICAgICBpZiAoaW5SYW5nZShuLCBtYXgpKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgdmFsaWQgc2NhbGFyIDwgJHttYXh9LCBnb3QgJHt0eXBlb2Ygbn0gJHtufWApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhc3NlcnRHRTAobikge1xuICAgICAgICAvLyBuIGluIFswLi5DVVJWRV9PUkRFUi0xXVxuICAgICAgICByZXR1cm4gbiA9PT0gXzBuID8gbiA6IGFzc2VydEluUmFuZ2UobiwgQ1VSVkVfT1JERVIpOyAvLyBHRSA9IHByaW1lIHN1Ymdyb3VwLCBub3QgZnVsbCBncm91cFxuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGlzUG9pbnQob3RoZXIpIHtcbiAgICAgICAgaWYgKCEob3RoZXIgaW5zdGFuY2VvZiBQb2ludCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4dGVuZGVkUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLy8gRXh0ZW5kZWQgUG9pbnQgd29ya3MgaW4gZXh0ZW5kZWQgY29vcmRpbmF0ZXM6ICh4LCB5LCB6LCB0KSDiiIsgKHg9eC96LCB5PXkveiwgdD14eSkuXG4gICAgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHdpc3RlZF9FZHdhcmRzX2N1cnZlI0V4dGVuZGVkX2Nvb3JkaW5hdGVzXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihleCwgZXksIGV6LCBldCkge1xuICAgICAgICAgICAgdGhpcy5leCA9IGV4O1xuICAgICAgICAgICAgdGhpcy5leSA9IGV5O1xuICAgICAgICAgICAgdGhpcy5leiA9IGV6O1xuICAgICAgICAgICAgdGhpcy5ldCA9IGV0O1xuICAgICAgICAgICAgaWYgKCFpbjBNYXNrUmFuZ2UoZXgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneCByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKCFpbjBNYXNrUmFuZ2UoZXkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneSByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKCFpbjBNYXNrUmFuZ2UoZXopKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigneiByZXF1aXJlZCcpO1xuICAgICAgICAgICAgaWYgKCFpbjBNYXNrUmFuZ2UoZXQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndCByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHRlbmRlZCBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFpbjBNYXNrUmFuZ2UoeCkgfHwgIWluME1hc2tSYW5nZSh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIF8xbiwgbW9kUCh4ICogeSkpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLmV6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3QgcmVxdWlyZWQgZm9yIGZyb21IZXgoKSwgd2hpY2ggYWx3YXlzIGNyZWF0ZXMgdmFsaWQgcG9pbnRzLlxuICAgICAgICAvLyBDb3VsZCBiZSB1c2VmdWwgZm9yIGZyb21BZmZpbmUoKS5cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTsgLy8gVE9ETzogb3B0aW1pemUsIHdpdGggdmFycyBiZWxvdz9cbiAgICAgICAgICAgIC8vIEVxdWF0aW9uIGluIGFmZmluZSBjb29yZGluYXRlczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG4gICAgICAgICAgICAvLyBFcXVhdGlvbiBpbiBwcm9qZWN0aXZlIGNvb3JkaW5hdGVzIChYL1osIFkvWiwgWik6ICAoYVjCsiArIFnCsilawrIgPSBa4oG0ICsgZFjCslnCslxuICAgICAgICAgICAgY29uc3QgeyBleDogWCwgZXk6IFksIGV6OiBaLCBldDogVCB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IFgyID0gbW9kUChYICogWCk7IC8vIFjCslxuICAgICAgICAgICAgY29uc3QgWTIgPSBtb2RQKFkgKiBZKTsgLy8gWcKyXG4gICAgICAgICAgICBjb25zdCBaMiA9IG1vZFAoWiAqIFopOyAvLyBawrJcbiAgICAgICAgICAgIGNvbnN0IFo0ID0gbW9kUChaMiAqIFoyKTsgLy8gWuKBtFxuICAgICAgICAgICAgY29uc3QgYVgyID0gbW9kUChYMiAqIGEpOyAvLyBhWMKyXG4gICAgICAgICAgICBjb25zdCBsZWZ0ID0gbW9kUChaMiAqIG1vZFAoYVgyICsgWTIpKTsgLy8gKGFYwrIgKyBZwrIpWsKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IG1vZFAoWjQgKyBtb2RQKGQgKiBtb2RQKFgyICogWTIpKSk7IC8vIFrigbQgKyBkWMKyWcKyXG4gICAgICAgICAgICBpZiAobGVmdCAhPT0gcmlnaHQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDEpJyk7XG4gICAgICAgICAgICAvLyBJbiBFeHRlbmRlZCBjb29yZGluYXRlcyB3ZSBhbHNvIGhhdmUgVCwgd2hpY2ggaXMgeCp5PVQvWjogY2hlY2sgWCpZID09IFoqVFxuICAgICAgICAgICAgY29uc3QgWFkgPSBtb2RQKFggKiBZKTtcbiAgICAgICAgICAgIGNvbnN0IFpUID0gbW9kUChaICogVCk7XG4gICAgICAgICAgICBpZiAoWFkgIT09IFpUKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0ICgyKScpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICAgICAgaXNQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyLCBlejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgWDFaMiA9IG1vZFAoWDEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBYMloxID0gbW9kUChYMiAqIFoxKTtcbiAgICAgICAgICAgIGNvbnN0IFkxWjIgPSBtb2RQKFkxICogWjIpO1xuICAgICAgICAgICAgY29uc3QgWTJaMSA9IG1vZFAoWTIgKiBaMSk7XG4gICAgICAgICAgICByZXR1cm4gWDFaMiA9PT0gWDJaMSAmJiBZMVoyID09PSBZMloxO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICAvLyBGbGlwcyBwb2ludCBzaWduIHRvIGEgbmVnYXRpdmUgb25lICgteCwgeSBpbiBhZmZpbmUgY29vcmRzKVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChtb2RQKC10aGlzLmV4KSwgdGhpcy5leSwgdGhpcy5leiwgbW9kUCgtdGhpcy5ldCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgZG91YmxpbmcgRXh0ZW5kZWQgUG9pbnQuXG4gICAgICAgIC8vIGh0dHBzOi8vaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXR3aXN0ZWQtZXh0ZW5kZWQuaHRtbCNkb3VibGluZy1kYmwtMjAwOC1od2NkXG4gICAgICAgIC8vIENvc3Q6IDRNICsgNFMgKyAxKmEgKyA2YWRkICsgMSoyLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMSk7IC8vIEEgPSBYMTJcbiAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTEpOyAvLyBCID0gWTEyXG4gICAgICAgICAgICBjb25zdCBDID0gbW9kUChfMm4gKiBtb2RQKFoxICogWjEpKTsgLy8gQyA9IDIqWjEyXG4gICAgICAgICAgICBjb25zdCBEID0gbW9kUChhICogQSk7IC8vIEQgPSBhKkFcbiAgICAgICAgICAgIGNvbnN0IHgxeTEgPSBYMSArIFkxO1xuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAobW9kUCh4MXkxICogeDF5MSkgLSBBIC0gQik7IC8vIEUgPSAoWDErWTEpMi1BLUJcbiAgICAgICAgICAgIGNvbnN0IEcgPSBEICsgQjsgLy8gRyA9IEQrQlxuICAgICAgICAgICAgY29uc3QgRiA9IEcgLSBDOyAvLyBGID0gRy1DXG4gICAgICAgICAgICBjb25zdCBIID0gRCAtIEI7IC8vIEggPSBELUJcbiAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYXN0IGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cy5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2FkZGl0aW9uLWFkZC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogOU0gKyAxKmEgKyAxKmQgKyA3YWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGlzUG9pbnQob3RoZXIpO1xuICAgICAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSwgZXQ6IFQxIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiwgZXo6IFoyLCBldDogVDIgfSA9IG90aGVyO1xuICAgICAgICAgICAgLy8gRmFzdGVyIGFsZ28gZm9yIGFkZGluZyAyIEV4dGVuZGVkIFBvaW50cyB3aGVuIGN1cnZlJ3MgYT0tMS5cbiAgICAgICAgICAgIC8vIGh0dHA6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC0xLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZC00XG4gICAgICAgICAgICAvLyBDb3N0OiA4TSArIDhhZGQgKyAyKjIuXG4gICAgICAgICAgICAvLyBOb3RlOiBJdCBkb2VzIG5vdCBjaGVjayB3aGV0aGVyIHRoZSBgb3RoZXJgIHBvaW50IGlzIHZhbGlkLlxuICAgICAgICAgICAgaWYgKGEgPT09IEJpZ0ludCgtMSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBBID0gbW9kUCgoWTEgLSBYMSkgKiAoWTIgKyBYMikpO1xuICAgICAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKChZMSArIFgxKSAqIChZMiAtIFgyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgRiA9IG1vZFAoQiAtIEEpO1xuICAgICAgICAgICAgICAgIGlmIChGID09PSBfMG4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvdWJsZSgpOyAvLyBTYW1lIHBvaW50LiBUZXN0cyBzYXkgaXQgZG9lc24ndCBhZmZlY3QgdGltaW5nXG4gICAgICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoWjEgKiBfMm4gKiBUMik7XG4gICAgICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoVDEgKiBfMm4gKiBaMik7XG4gICAgICAgICAgICAgICAgY29uc3QgRSA9IEQgKyBDO1xuICAgICAgICAgICAgICAgIGNvbnN0IEcgPSBCICsgQTtcbiAgICAgICAgICAgICAgICBjb25zdCBIID0gRCAtIEM7XG4gICAgICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTtcbiAgICAgICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFQzID0gbW9kUChFICogSCk7XG4gICAgICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKFgxICogWDIpOyAvLyBBID0gWDEqWDJcbiAgICAgICAgICAgIGNvbnN0IEIgPSBtb2RQKFkxICogWTIpOyAvLyBCID0gWTEqWTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKFQxICogZCAqIFQyKTsgLy8gQyA9IFQxKmQqVDJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKFoxICogWjIpOyAvLyBEID0gWjEqWjJcbiAgICAgICAgICAgIGNvbnN0IEUgPSBtb2RQKChYMSArIFkxKSAqIChYMiArIFkyKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkqKFgyK1kyKS1BLUJcbiAgICAgICAgICAgIGNvbnN0IEYgPSBEIC0gQzsgLy8gRiA9IEQtQ1xuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBDOyAvLyBHID0gRCtDXG4gICAgICAgICAgICBjb25zdCBIID0gbW9kUChCIC0gYSAqIEEpOyAvLyBIID0gQi1hKkFcbiAgICAgICAgICAgIGNvbnN0IFgzID0gbW9kUChFICogRik7IC8vIFgzID0gRSpGXG4gICAgICAgICAgICBjb25zdCBZMyA9IG1vZFAoRyAqIEgpOyAvLyBZMyA9IEcqSFxuICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTsgLy8gVDMgPSBFKkhcbiAgICAgICAgICAgIGNvbnN0IFozID0gbW9kUChGICogRyk7IC8vIFozID0gRipHXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMsIFQzKTtcbiAgICAgICAgfVxuICAgICAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkKG90aGVyLm5lZ2F0ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgUG9pbnQubm9ybWFsaXplWik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihhc3NlcnRJblJhbmdlKHNjYWxhciwgQ1VSVkVfT1JERVIpKTtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5ub3JtYWxpemVaKFtwLCBmXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAvLyBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAvLyBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbi5cbiAgICAgICAgLy8gRG9lcyBOT1QgYWxsb3cgc2NhbGFycyBoaWdoZXIgdGhhbiBDVVJWRS5uLlxuICAgICAgICBtdWx0aXBseVVuc2FmZShzY2FsYXIpIHtcbiAgICAgICAgICAgIGxldCBuID0gYXNzZXJ0R0UwKHNjYWxhcik7IC8vIDAgPD0gc2NhbGFyIDwgQ1VSVkUublxuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhJKSB8fCBuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBpZiAodGhpcy5lcXVhbHMoRykpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihuKS5wO1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoZWNrcyBpZiBwb2ludCBpcyBvZiBzbWFsbCBvcmRlci5cbiAgICAgICAgLy8gSWYgeW91IGFkZCBzb21ldGhpbmcgdG8gc21hbGwgb3JkZXIgcG9pbnQsIHlvdSB3aWxsIGhhdmUgXCJkaXJ0eVwiXG4gICAgICAgIC8vIHBvaW50IHdpdGggdG9yc2lvbiBjb21wb25lbnQuXG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY29mYWN0b3IgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIGlzU21hbGxPcmRlcigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aXBsaWVzIHBvaW50IGJ5IGN1cnZlIG9yZGVyIGFuZCBjaGVja3MgaWYgdGhlIHJlc3VsdCBpcyAwLlxuICAgICAgICAvLyBSZXR1cm5zIGBmYWxzZWAgaXMgdGhlIHBvaW50IGlzIGRpcnR5LlxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIENVUlZFX09SREVSKS5pczAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBFeHRlbmRlZCBwb2ludCB0byBkZWZhdWx0ICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiB4LCBleTogeSwgZXo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBfOG4gOiBGcC5pbnYoeik7IC8vIDggd2FzIGNob3NlbiBhcmJpdHJhcmlseVxuICAgICAgICAgICAgY29uc3QgYXggPSBtb2RQKHggKiBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IG1vZFAoeSAqIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gbW9kUCh6ICogaXopO1xuICAgICAgICAgICAgaWYgKGlzMClcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4OiBfMG4sIHk6IF8xbiB9O1xuICAgICAgICAgICAgaWYgKHp6ICE9PSBfMW4pXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKGNvZmFjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBoYXNoIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFBvaW50LlxuICAgICAgICAvLyBVc2VzIGFsZ28gZnJvbSBSRkM4MDMyIDUuMS4zLlxuICAgICAgICBzdGF0aWMgZnJvbUhleChoZXgsIHppcDIxNSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCB7IGQsIGEgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7XG4gICAgICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncG9pbnRIZXgnLCBoZXgsIGxlbik7IC8vIGNvcHkgaGV4IHRvIGEgbmV3IGFycmF5XG4gICAgICAgICAgICBjb25zdCBub3JtZWQgPSBoZXguc2xpY2UoKTsgLy8gY29weSBhZ2Fpbiwgd2UnbGwgbWFuaXB1bGF0ZSBpdFxuICAgICAgICAgICAgY29uc3QgbGFzdEJ5dGUgPSBoZXhbbGVuIC0gMV07IC8vIHNlbGVjdCBsYXN0IGJ5dGVcbiAgICAgICAgICAgIG5vcm1lZFtsZW4gLSAxXSA9IGxhc3RCeXRlICYgfjB4ODA7IC8vIGNsZWFyIGxhc3QgYml0XG4gICAgICAgICAgICBjb25zdCB5ID0gdXQuYnl0ZXNUb051bWJlckxFKG5vcm1lZCk7XG4gICAgICAgICAgICBpZiAoeSA9PT0gXzBuKSB7XG4gICAgICAgICAgICAgICAgLy8geT0wIGlzIGFsbG93ZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFJGQzgwMzIgcHJvaGliaXRzID49IHAsIGJ1dCBaSVAyMTUgZG9lc24ndFxuICAgICAgICAgICAgICAgIGlmICh6aXAyMTUpXG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEluUmFuZ2UoeSwgTUFTSyk7IC8vIHppcDIxNT10cnVlIFsxLi5QLTFdICgyXjI1NS0xOS0xIGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW5SYW5nZSh5LCBGcC5PUkRFUik7IC8vIHppcDIxNT1mYWxzZSBbMS4uTUFTSy0xXSAoMl4yNTYtMSBmb3IgZWQyNTUxOSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVkMjU1MTk6IHjCsiA9ICh5wrItMSkvKGR5wrIrMSkgbW9kIHAuIEVkNDQ4OiB4wrIgPSAoecKyLTEpLyhkecKyLTEpIG1vZCBwLiBHZW5lcmljIGNhc2U6XG4gICAgICAgICAgICAvLyBheMKyK3nCsj0xK2R4wrJ5wrIgPT4gecKyLTE9ZHjCsnnCsi1heMKyID0+IHnCsi0xPXjCsihkecKyLWEpID0+IHjCsj0oecKyLTEpLyhkecKyLWEpXG4gICAgICAgICAgICBjb25zdCB5MiA9IG1vZFAoeSAqIHkpOyAvLyBkZW5vbWluYXRvciBpcyBhbHdheXMgbm9uLTAgbW9kIHAuXG4gICAgICAgICAgICBjb25zdCB1ID0gbW9kUCh5MiAtIF8xbik7IC8vIHUgPSB5wrIgLSAxXG4gICAgICAgICAgICBjb25zdCB2ID0gbW9kUChkICogeTIgLSBhKTsgLy8gdiA9IGQgecKyICsgMS5cbiAgICAgICAgICAgIGxldCB7IGlzVmFsaWQsIHZhbHVlOiB4IH0gPSB1dlJhdGlvKHUsIHYpOyAvLyDiiJoodS92KVxuICAgICAgICAgICAgaWYgKCFpc1ZhbGlkKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQuZnJvbUhleDogaW52YWxpZCB5IGNvb3JkaW5hdGUnKTtcbiAgICAgICAgICAgIGNvbnN0IGlzWE9kZCA9ICh4ICYgXzFuKSA9PT0gXzFuOyAvLyBUaGVyZSBhcmUgMiBzcXVhcmUgcm9vdHMuIFVzZSB4XzAgYml0IHRvIHNlbGVjdCBwcm9wZXJcbiAgICAgICAgICAgIGNvbnN0IGlzTGFzdEJ5dGVPZGQgPSAobGFzdEJ5dGUgJiAweDgwKSAhPT0gMDsgLy8geF8wLCBsYXN0IGJpdFxuICAgICAgICAgICAgaWYgKCF6aXAyMTUgJiYgeCA9PT0gXzBuICYmIGlzTGFzdEJ5dGVPZGQpXG4gICAgICAgICAgICAgICAgLy8gaWYgeD0wIGFuZCB4XzAgPSAxLCBmYWlsXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludC5mcm9tSGV4OiB4PTAgYW5kIHhfMD0xJyk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0Qnl0ZU9kZCAhPT0gaXNYT2RkKVxuICAgICAgICAgICAgICAgIHggPSBtb2RQKC14KTsgLy8gaWYgeF8wICE9IHggbW9kIDIsIHNldCB4ID0gcC14XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuZnJvbUFmZmluZSh7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KS5wb2ludDtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnRvQWZmaW5lKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHV0Lm51bWJlclRvQnl0ZXNMRSh5LCBGcC5CWVRFUyk7IC8vIGVhY2ggeSBoYXMgMiB4IHZhbHVlcyAoeCwgLXkpXG4gICAgICAgICAgICBieXRlc1tieXRlcy5sZW5ndGggLSAxXSB8PSB4ICYgXzFuID8gMHg4MCA6IDA7IC8vIHdoZW4gY29tcHJlc3NpbmcsIGl0J3MgZW5vdWdoIHRvIHN0b3JlIHlcbiAgICAgICAgICAgIHJldHVybiBieXRlczsgLy8gYW5kIHVzZSB0aGUgbGFzdCBieXRlIHRvIGVuY29kZSBzaWduIG9mIHhcbiAgICAgICAgfVxuICAgICAgICB0b0hleCgpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTsgLy8gU2FtZSBhcyB0b1Jhd0J5dGVzLCBidXQgcmV0dXJucyBzdHJpbmcuXG4gICAgICAgIH1cbiAgICB9XG4gICAgUG9pbnQuQkFTRSA9IG5ldyBQb2ludChDVVJWRS5HeCwgQ1VSVkUuR3ksIF8xbiwgbW9kUChDVVJWRS5HeCAqIENVUlZFLkd5KSk7XG4gICAgUG9pbnQuWkVSTyA9IG5ldyBQb2ludChfMG4sIF8xbiwgXzFuLCBfMG4pOyAvLyAwLCAxLCAxLCAwXG4gICAgY29uc3QgeyBCQVNFOiBHLCBaRVJPOiBJIH0gPSBQb2ludDtcbiAgICBjb25zdCB3bmFmID0gd05BRihQb2ludCwgbkJ5dGVMZW5ndGggKiA4KTtcbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIC8vIExpdHRsZS1lbmRpYW4gU0hBNTEyIHdpdGggbW9kdWxvIG5cbiAgICBmdW5jdGlvbiBtb2ROX0xFKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIG1vZE4odXQuYnl0ZXNUb051bWJlckxFKGhhc2gpKTtcbiAgICB9XG4gICAgLyoqIENvbnZlbmllbmNlIG1ldGhvZCB0aGF0IGNyZWF0ZXMgcHVibGljIGtleSBhbmQgb3RoZXIgc3R1ZmYuIFJGQzgwMzIgNS4xLjUgKi9cbiAgICBmdW5jdGlvbiBnZXRFeHRlbmRlZFB1YmxpY0tleShrZXkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gbkJ5dGVMZW5ndGg7XG4gICAgICAgIGtleSA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbGVuKTtcbiAgICAgICAgLy8gSGFzaCBwcml2YXRlIGtleSB3aXRoIGN1cnZlJ3MgaGFzaCBmdW5jdGlvbiB0byBwcm9kdWNlIHVuaWZvcm1pbmdseSByYW5kb20gaW5wdXRcbiAgICAgICAgLy8gQ2hlY2sgYnl0ZSBsZW5ndGhzOiBlbnN1cmUoNjQsIGgoZW5zdXJlKDMyLCBrZXkpKSlcbiAgICAgICAgY29uc3QgaGFzaGVkID0gZW5zdXJlQnl0ZXMoJ2hhc2hlZCBwcml2YXRlIGtleScsIGNIYXNoKGtleSksIDIgKiBsZW4pO1xuICAgICAgICBjb25zdCBoZWFkID0gYWRqdXN0U2NhbGFyQnl0ZXMoaGFzaGVkLnNsaWNlKDAsIGxlbikpOyAvLyBjbGVhciBmaXJzdCBoYWxmIGJpdHMsIHByb2R1Y2UgRkVcbiAgICAgICAgY29uc3QgcHJlZml4ID0gaGFzaGVkLnNsaWNlKGxlbiwgMiAqIGxlbik7IC8vIHNlY29uZCBoYWxmIGlzIGNhbGxlZCBrZXkgcHJlZml4ICg1LjEuNilcbiAgICAgICAgY29uc3Qgc2NhbGFyID0gbW9kTl9MRShoZWFkKTsgLy8gVGhlIGFjdHVhbCBwcml2YXRlIHNjYWxhclxuICAgICAgICBjb25zdCBwb2ludCA9IEcubXVsdGlwbHkoc2NhbGFyKTsgLy8gUG9pbnQgb24gRWR3YXJkcyBjdXJ2ZSBha2EgcHVibGljIGtleVxuICAgICAgICBjb25zdCBwb2ludEJ5dGVzID0gcG9pbnQudG9SYXdCeXRlcygpOyAvLyBVaW50OEFycmF5IHJlcHJlc2VudGF0aW9uXG4gICAgICAgIHJldHVybiB7IGhlYWQsIHByZWZpeCwgc2NhbGFyLCBwb2ludCwgcG9pbnRCeXRlcyB9O1xuICAgIH1cbiAgICAvLyBDYWxjdWxhdGVzIEVkRFNBIHB1YiBrZXkuIFJGQzgwMzIgNS4xLjUuIFByaXZrZXkgaXMgaGFzaGVkLiBVc2UgZmlyc3QgaGFsZiB3aXRoIDMgYml0cyBjbGVhcmVkXG4gICAgZnVuY3Rpb24gZ2V0UHVibGljS2V5KHByaXZLZXkpIHtcbiAgICAgICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpLnBvaW50Qnl0ZXM7XG4gICAgfVxuICAgIC8vIGludCgnTEUnLCBTSEE1MTIoZG9tMihGLCBDKSB8fCBtc2dzKSkgbW9kIE5cbiAgICBmdW5jdGlvbiBoYXNoRG9tYWluVG9TY2FsYXIoY29udGV4dCA9IG5ldyBVaW50OEFycmF5KCksIC4uLm1zZ3MpIHtcbiAgICAgICAgY29uc3QgbXNnID0gdXQuY29uY2F0Qnl0ZXMoLi4ubXNncyk7XG4gICAgICAgIHJldHVybiBtb2ROX0xFKGNIYXNoKGRvbWFpbihtc2csIGVuc3VyZUJ5dGVzKCdjb250ZXh0JywgY29udGV4dCksICEhcHJlaGFzaCkpKTtcbiAgICB9XG4gICAgLyoqIFNpZ25zIG1lc3NhZ2Ugd2l0aCBwcml2YXRlS2V5LiBSRkM4MDMyIDUuMS42ICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2csIHByaXZLZXksIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoIGV0Yy5cbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHNjYWxhciwgcG9pbnRCeXRlcyB9ID0gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSk7XG4gICAgICAgIGNvbnN0IHIgPSBoYXNoRG9tYWluVG9TY2FsYXIob3B0aW9ucy5jb250ZXh0LCBwcmVmaXgsIG1zZyk7IC8vIHIgPSBkb20yKEYsIEMpIHx8IHByZWZpeCB8fCBQSChNKVxuICAgICAgICBjb25zdCBSID0gRy5tdWx0aXBseShyKS50b1Jhd0J5dGVzKCk7IC8vIFIgPSByR1xuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKG9wdGlvbnMuY29udGV4dCwgUiwgcG9pbnRCeXRlcywgbXNnKTsgLy8gUiB8fCBBIHx8IFBIKE0pXG4gICAgICAgIGNvbnN0IHMgPSBtb2ROKHIgKyBrICogc2NhbGFyKTsgLy8gUyA9IChyICsgayAqIHMpIG1vZCBMXG4gICAgICAgIGFzc2VydEdFMChzKTsgLy8gMCA8PSBzIDwgbFxuICAgICAgICBjb25zdCByZXMgPSB1dC5jb25jYXRCeXRlcyhSLCB1dC5udW1iZXJUb0J5dGVzTEUocywgRnAuQllURVMpKTtcbiAgICAgICAgcmV0dXJuIGVuc3VyZUJ5dGVzKCdyZXN1bHQnLCByZXMsIG5CeXRlTGVuZ3RoICogMik7IC8vIDY0LWJ5dGUgc2lnbmF0dXJlXG4gICAgfVxuICAgIGNvbnN0IHZlcmlmeU9wdHMgPSBWRVJJRllfREVGQVVMVDtcbiAgICBmdW5jdGlvbiB2ZXJpZnkoc2lnLCBtc2csIHB1YmxpY0tleSwgb3B0aW9ucyA9IHZlcmlmeU9wdHMpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZXh0LCB6aXAyMTUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGxlbiA9IEZwLkJZVEVTOyAvLyBWZXJpZmllcyBFZERTQSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGFuZCBwdWJsaWMga2V5LiBSRkM4MDMyIDUuMS43LlxuICAgICAgICBzaWcgPSBlbnN1cmVCeXRlcygnc2lnbmF0dXJlJywgc2lnLCAyICogbGVuKTsgLy8gQW4gZXh0ZW5kZWQgZ3JvdXAgZXF1YXRpb24gaXMgY2hlY2tlZC5cbiAgICAgICAgbXNnID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtc2cpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZyA9IHByZWhhc2gobXNnKTsgLy8gZm9yIGVkMjU1MTlwaCwgZXRjXG4gICAgICAgIGNvbnN0IHMgPSB1dC5ieXRlc1RvTnVtYmVyTEUoc2lnLnNsaWNlKGxlbiwgMiAqIGxlbikpO1xuICAgICAgICAvLyB6aXAyMTU6IHRydWUgaXMgZ29vZCBmb3IgY29uc2Vuc3VzLWNyaXRpY2FsIGFwcHMgYW5kIGFsbG93cyBwb2ludHMgPCAyXjI1NlxuICAgICAgICAvLyB6aXAyMTU6IGZhbHNlIGZvbGxvd3MgUkZDODAzMiAvIE5JU1QxODYtNSBhbmQgcmVzdHJpY3RzIHBvaW50cyB0byBDVVJWRS5wXG4gICAgICAgIGxldCBBLCBSLCBTQjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIEEgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0tleSwgemlwMjE1KTtcbiAgICAgICAgICAgIFIgPSBQb2ludC5mcm9tSGV4KHNpZy5zbGljZSgwLCBsZW4pLCB6aXAyMTUpO1xuICAgICAgICAgICAgU0IgPSBHLm11bHRpcGx5VW5zYWZlKHMpOyAvLyAwIDw9IHMgPCBsIGlzIGRvbmUgaW5zaWRlXG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF6aXAyMTUgJiYgQS5pc1NtYWxsT3JkZXIoKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgayA9IGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0LCBSLnRvUmF3Qnl0ZXMoKSwgQS50b1Jhd0J5dGVzKCksIG1zZyk7XG4gICAgICAgIGNvbnN0IFJrQSA9IFIuYWRkKEEubXVsdGlwbHlVbnNhZmUoaykpO1xuICAgICAgICAvLyBbOF1bU11CID0gWzhdUiArIFs4XVtrXUEnXG4gICAgICAgIHJldHVybiBSa0Euc3VidHJhY3QoU0IpLmNsZWFyQ29mYWN0b3IoKS5lcXVhbHMoUG9pbnQuWkVSTyk7XG4gICAgfVxuICAgIEcuX3NldFdpbmRvd1NpemUoOCk7IC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgZ2V0RXh0ZW5kZWRQdWJsaWNLZXksXG4gICAgICAgIC8vIGVkMjU1MTkgcHJpdmF0ZSBrZXlzIGFyZSB1bmlmb3JtIDMyYi4gTm8gbmVlZCB0byBjaGVjayBmb3IgbW9kdWxvIGJpYXMsIGxpa2UgaW4gc2VjcDI1NmsxLlxuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiByYW5kb21CeXRlcyhGcC5CWVRFUyksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSdyZSBkb2luZyBzY2FsYXIgbXVsdGlwbGljYXRpb24gKHVzZWQgaW4gZ2V0UHVibGljS2V5IGV0Yykgd2l0aCBwcmVjb21wdXRlZCBCQVNFX1BPSU5UXG4gICAgICAgICAqIHZhbHVlcy4gVGhpcyBzbG93cyBkb3duIGZpcnN0IGdldFB1YmxpY0tleSgpIGJ5IG1pbGxpc2Vjb25kcyAoc2VlIFNwZWVkIHNlY3Rpb24pLFxuICAgICAgICAgKiBidXQgYWxsb3dzIHRvIHNwZWVkLXVwIHN1YnNlcXVlbnQgZ2V0UHVibGljS2V5KCkgY2FsbHMgdXAgdG8gMjB4LlxuICAgICAgICAgKiBAcGFyYW0gd2luZG93U2l6ZSAyLCA0LCA4LCAxNlxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgZ2V0UHVibGljS2V5LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIEV4dGVuZGVkUG9pbnQ6IFBvaW50LFxuICAgICAgICB1dGlscyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWR3YXJkcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/edwards.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\nfunction validateDST(dst) {\n    if (dst instanceof Uint8Array)\n        return dst;\n    if (typeof dst === 'string')\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(dst);\n    throw new Error('DST must be Uint8Array or string');\n}\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction isBytes(item) {\n    if (!(item instanceof Uint8Array))\n        throw new Error('Uint8Array expected');\n}\nfunction isNum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.4.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    isBytes(msg);\n    isBytes(DST);\n    isNum(lenInBytes);\n    // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-11#section-5.3\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(options, {\n        DST: 'string',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    isBytes(msg);\n    isNum(count);\n    const DST = validateDST(_DST);\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-hash-to-curve-16#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1DO0FBQ29EO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzREFBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBVyxDQUFDLHNEQUFXO0FBQ3ZDLFlBQVksOENBQThDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGtCQUFrQixzREFBVztBQUM3QixhQUFhLHNEQUFXO0FBQ3hCLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsaUJBQWlCLHNEQUFXO0FBQzVCO0FBQ0EsZ0NBQWdDLHNEQUFXO0FBQzNDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLE9BQU8sU0FBUyxzREFBVztBQUNwRDtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2RUFBNkU7QUFDakc7QUFDQTtBQUNPO0FBQ1AsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksbUNBQW1DO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQSxtQkFBbUIsZ0RBQUc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsaURBQWlEO0FBQ2pELGlCQUFpQjtBQUNqQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsa0NBQWtDO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDQUE4Qyx3Q0FBd0M7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcz9lOGJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IG1vZCB9IGZyb20gJy4vbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlRFNUKGRzdCkge1xuICAgIGlmIChkc3QgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICByZXR1cm4gZHN0O1xuICAgIGlmICh0eXBlb2YgZHN0ID09PSAnc3RyaW5nJylcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKGRzdCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdEU1QgbXVzdCBiZSBVaW50OEFycmF5IG9yIHN0cmluZycpO1xufVxuLy8gT2N0ZXQgU3RyZWFtIHRvIEludGVnZXIuIFwic3BlY1wiIGltcGxlbWVudGF0aW9uIG9mIG9zMmlwIGlzIDIuNXggc2xvd2VyIHZzIGJ5dGVzVG9OdW1iZXJCRS5cbmNvbnN0IG9zMmlwID0gYnl0ZXNUb051bWJlckJFO1xuLy8gSW50ZWdlciB0byBPY3RldCBTdHJlYW0gKG51bWJlclRvQnl0ZXNCRSlcbmZ1bmN0aW9uIGkyb3NwKHZhbHVlLCBsZW5ndGgpIHtcbiAgICBpZiAodmFsdWUgPCAwIHx8IHZhbHVlID49IDEgPDwgKDggKiBsZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYmFkIEkyT1NQIGNhbGw6IHZhbHVlPSR7dmFsdWV9IGxlbmd0aD0ke2xlbmd0aH1gKTtcbiAgICB9XG4gICAgY29uc3QgcmVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aCB9KS5maWxsKDApO1xuICAgIGZvciAobGV0IGkgPSBsZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICByZXNbaV0gPSB2YWx1ZSAmIDB4ZmY7XG4gICAgICAgIHZhbHVlID4+Pj0gODtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHJlcyk7XG59XG5mdW5jdGlvbiBzdHJ4b3IoYSwgYikge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KGEubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYVtpXSBeIGJbaV07XG4gICAgfVxuICAgIHJldHVybiBhcnI7XG59XG5mdW5jdGlvbiBpc0J5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIShpdGVtIGluc3RhbmNlb2YgVWludDhBcnJheSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gaXNOdW0oaXRlbSkge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbnVtYmVyIGV4cGVjdGVkJyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYSBjcnlwdG9ncmFwaGljIGhhc2ggZnVuY3Rpb24gSCB0aGF0IG91dHB1dHMgYiBiaXRzXG4vLyBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1oYXNoLXRvLWN1cnZlLTExI3NlY3Rpb24tNS40LjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi01LjMuM1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KVxuICAgICAgICBEU1QgPSBIKGNvbmNhdEJ5dGVzKHV0ZjhUb0J5dGVzKCdIMkMtT1ZFUlNJWkUtRFNULScpLCBEU1QpKTtcbiAgICBjb25zdCB7IG91dHB1dExlbjogYl9pbl9ieXRlcywgYmxvY2tMZW46IHJfaW5fYnl0ZXMgfSA9IEg7XG4gICAgY29uc3QgZWxsID0gTWF0aC5jZWlsKGxlbkluQnl0ZXMgLyBiX2luX2J5dGVzKTtcbiAgICBpZiAoZWxsID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgeG1kIGxlbmd0aCcpO1xuICAgIGNvbnN0IERTVF9wcmltZSA9IGNvbmNhdEJ5dGVzKERTVCwgaTJvc3AoRFNULmxlbmd0aCwgMSkpO1xuICAgIGNvbnN0IFpfcGFkID0gaTJvc3AoMCwgcl9pbl9ieXRlcyk7XG4gICAgY29uc3QgbF9pX2Jfc3RyID0gaTJvc3AobGVuSW5CeXRlcywgMik7IC8vIGxlbl9pbl9ieXRlc19zdHJcbiAgICBjb25zdCBiID0gbmV3IEFycmF5KGVsbCk7XG4gICAgY29uc3QgYl8wID0gSChjb25jYXRCeXRlcyhaX3BhZCwgbXNnLCBsX2lfYl9zdHIsIGkyb3NwKDAsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBiWzBdID0gSChjb25jYXRCeXRlcyhiXzAsIGkyb3NwKDEsIDEpLCBEU1RfcHJpbWUpKTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8PSBlbGw7IGkrKykge1xuICAgICAgICBjb25zdCBhcmdzID0gW3N0cnhvcihiXzAsIGJbaSAtIDFdKSwgaTJvc3AoaSArIDEsIDEpLCBEU1RfcHJpbWVdO1xuICAgICAgICBiW2ldID0gSChjb25jYXRCeXRlcyguLi5hcmdzKSk7XG4gICAgfVxuICAgIGNvbnN0IHBzZXVkb19yYW5kb21fYnl0ZXMgPSBjb25jYXRCeXRlcyguLi5iKTtcbiAgICByZXR1cm4gcHNldWRvX3JhbmRvbV9ieXRlcy5zbGljZSgwLCBsZW5JbkJ5dGVzKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94b2YobXNnLCBEU1QsIGxlbkluQnl0ZXMsIGssIEgpIHtcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNCeXRlcyhEU1QpO1xuICAgIGlzTnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTYjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xMSNzZWN0aW9uLTUuM1xuICogQHBhcmFtIG1zZyBhIGJ5dGUgc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgdG8gaGFzaFxuICogQHBhcmFtIGNvdW50IHRoZSBudW1iZXIgb2YgZWxlbWVudHMgb2YgRiB0byBvdXRwdXRcbiAqIEBwYXJhbSBvcHRpb25zIGB7RFNUOiBzdHJpbmcsIHA6IGJpZ2ludCwgbTogbnVtYmVyLCBrOiBudW1iZXIsIGV4cGFuZDogJ3htZCcgfCAneG9mJywgaGFzaDogSH1gLCBzZWUgYWJvdmVcbiAqIEByZXR1cm5zIFt1XzAsIC4uLiwgdV8oY291bnQgLSAxKV0sIGEgbGlzdCBvZiBmaWVsZCBlbGVtZW50cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hfdG9fZmllbGQobXNnLCBjb3VudCwgb3B0aW9ucykge1xuICAgIHZhbGlkYXRlT2JqZWN0KG9wdGlvbnMsIHtcbiAgICAgICAgRFNUOiAnc3RyaW5nJyxcbiAgICAgICAgcDogJ2JpZ2ludCcsXG4gICAgICAgIG06ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgazogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgfSk7XG4gICAgY29uc3QgeyBwLCBrLCBtLCBoYXNoLCBleHBhbmQsIERTVDogX0RTVCB9ID0gb3B0aW9ucztcbiAgICBpc0J5dGVzKG1zZyk7XG4gICAgaXNOdW0oY291bnQpO1xuICAgIGNvbnN0IERTVCA9IHZhbGlkYXRlRFNUKF9EU1QpO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmVcbiAgICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNiNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvaHRtbC9kcmFmdC1pcnRmLWNmcmctaGFzaC10by1jdXJ2ZS0xNiNzZWN0aW9uLTNcbiAgICAgICAgZW5jb2RlVG9DdXJ2ZShtc2csIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IHUgPSBoYXNoX3RvX2ZpZWxkKG1zZywgMSwgeyAuLi5kZWYsIERTVDogZGVmLmVuY29kZURTVCwgLi4ub3B0aW9ucyB9KTtcbiAgICAgICAgICAgIGNvbnN0IFAgPSBQb2ludC5mcm9tQWZmaW5lKG1hcFRvQ3VydmUodVswXSkpLmNsZWFyQ29mYWN0b3IoKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1oYXNoLXRvLWN1cnZlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n// Tonelli-Shanks algorithm\n// Paper 1: https://eprint.iacr.org/2012/685.pdf (page 12)\n// Paper 2: Square Roots from 1; 24, 51, 10 to Dan Shanks\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p)  1    if a is a square (mod p)\n    // (a | p)  -1   if a is not a square (mod p)\n    // (a | p)  0    if a  0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P  3 (mod 4)\n    // n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P  9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n// 0 is non-invertible: non-batched version will throw on 0\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a galois field over prime. Non-primes are not supported for now.\n * Do not init in loop: slow. Very fragile: always run a benchmark on change.\n * Major performance gains:\n * a) non-normalized operations like mulN instead of mul\n * b) `Object.freeze`\n * c) Same object shape: never add or remove keys\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Fp ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * FIPS 186 B.4.1-compliant \"constant-time\" private key generation utility.\n * Can take (n+8) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 40 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. curveFn.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9kdWxhci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ3VJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxxRUFBcUUsUUFBUSxNQUFNLE9BQU87QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLHNEQUFzRDtBQUN0RCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHlEQUFjO0FBQ3pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sc0RBQXNEO0FBQzdEO0FBQ0Esc0RBQXNELE1BQU07QUFDNUQsWUFBWSx1Q0FBdUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsV0FBVztBQUMxRiw4Q0FBOEM7QUFDOUMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwREFBZSxlQUFlLDBEQUFlO0FBQy9FO0FBQ0E7QUFDQSwwREFBMEQsTUFBTSxRQUFRLGFBQWE7QUFDckYsMEJBQTBCLDBEQUFlLFVBQVUsMERBQWU7QUFDbEUsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxzREFBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsT0FBTyw0QkFBNEIsUUFBUTtBQUNwRyx1QkFBdUIsMERBQWUsU0FBUywwREFBZTtBQUM5RDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/NzI1NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG1cbi8vIFBhcGVyIDE6IGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMilcbi8vIFBhcGVyIDI6IFNxdWFyZSBSb290cyBmcm9tIDE7IDI0LCA1MSwgMTAgdG8gRGFuIFNoYW5rc1xuZXhwb3J0IGZ1bmN0aW9uIHRvbmVsbGlTaGFua3MoUCkge1xuICAgIC8vIExlZ2VuZHJlIGNvbnN0YW50OiB1c2VkIHRvIGNhbGN1bGF0ZSBMZWdlbmRyZSBzeW1ib2wgKGEgfCBwKSxcbiAgICAvLyB3aGljaCBkZW5vdGVzIHRoZSB2YWx1ZSBvZiBhXigocC0xKS8yKSAobW9kIHApLlxuICAgIC8vIChhIHwgcCkg4omhIDEgICAgaWYgYSBpcyBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgLTEgICBpZiBhIGlzIG5vdCBhIHNxdWFyZSAobW9kIHApXG4gICAgLy8gKGEgfCBwKSDiiaEgMCAgICBpZiBhIOKJoSAwIChtb2QgcClcbiAgICBjb25zdCBsZWdlbmRyZUMgPSAoUCAtIF8xbikgLyBfMm47XG4gICAgbGV0IFEsIFMsIFo7XG4gICAgLy8gU3RlcCAxOiBCeSBmYWN0b3Jpbmcgb3V0IHBvd2VycyBvZiAyIGZyb20gcCAtIDEsXG4gICAgLy8gZmluZCBxIGFuZCBzIHN1Y2ggdGhhdCBwIC0gMSA9IHEqKDJecykgd2l0aCBxIG9kZFxuICAgIGZvciAoUSA9IFAgLSBfMW4sIFMgPSAwOyBRICUgXzJuID09PSBfMG47IFEgLz0gXzJuLCBTKyspXG4gICAgICAgIDtcbiAgICAvLyBTdGVwIDI6IFNlbGVjdCBhIG5vbi1zcXVhcmUgeiBzdWNoIHRoYXQgKHogfCBwKSDiiaEgLTEgYW5kIHNldCBjIOKJoSB6cVxuICAgIGZvciAoWiA9IF8ybjsgWiA8IFAgJiYgcG93KFosIGxlZ2VuZHJlQywgUCkgIT09IFAgLSBfMW47IForKylcbiAgICAgICAgO1xuICAgIC8vIEZhc3QtcGF0aFxuICAgIGlmIChTID09PSAxKSB7XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlGYXN0KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAucG93KG4sIHAxZGl2NCk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBTbG93LXBhdGhcbiAgICBjb25zdCBRMWRpdjIgPSAoUSArIF8xbikgLyBfMm47XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHRvbmVsbGlTbG93KEZwLCBuKSB7XG4gICAgICAgIC8vIFN0ZXAgMDogQ2hlY2sgdGhhdCBuIGlzIGluZGVlZCBhIHNxdWFyZTogKG4gfCBwKSBzaG91bGQgbm90IGJlIOKJoSAtMVxuICAgICAgICBpZiAoRnAucG93KG4sIGxlZ2VuZHJlQykgPT09IEZwLm5lZyhGcC5PTkUpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICBsZXQgciA9IFM7XG4gICAgICAgIC8vIFRPRE86IHdpbGwgZmFpbCBhdCBGcDIvZXRjXG4gICAgICAgIGxldCBnID0gRnAucG93KEZwLm11bChGcC5PTkUsIFopLCBRKTsgLy8gd2lsbCB1cGRhdGUgYm90aCB4IGFuZCBiXG4gICAgICAgIGxldCB4ID0gRnAucG93KG4sIFExZGl2Mik7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBzcXVhcmUgcm9vdFxuICAgICAgICBsZXQgYiA9IEZwLnBvdyhuLCBRKTsgLy8gZmlyc3QgZ3Vlc3MgYXQgdGhlIGZ1ZGdlIGZhY3RvclxuICAgICAgICB3aGlsZSAoIUZwLmVxbChiLCBGcC5PTkUpKSB7XG4gICAgICAgICAgICBpZiAoRnAuZXFsKGIsIEZwLlpFUk8pKVxuICAgICAgICAgICAgICAgIHJldHVybiBGcC5aRVJPOyAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ub25lbGxpJUUyJTgwJTkzU2hhbmtzX2FsZ29yaXRobSAoNC4gSWYgdCA9IDAsIHJldHVybiByID0gMClcbiAgICAgICAgICAgIC8vIEZpbmQgbSBzdWNoIGJeKDJebSk9PTFcbiAgICAgICAgICAgIGxldCBtID0gMTtcbiAgICAgICAgICAgIGZvciAobGV0IHQyID0gRnAuc3FyKGIpOyBtIDwgcjsgbSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKEZwLmVxbCh0MiwgRnAuT05FKSlcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgdDIgPSBGcC5zcXIodDIpOyAvLyB0MiAqPSB0MlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTk9URTogci1tLTEgY2FuIGJlIGJpZ2dlciB0aGFuIDMyLCBuZWVkIHRvIGNvbnZlcnQgdG8gYmlnaW50IGJlZm9yZSBzaGlmdCwgb3RoZXJ3aXNlIHRoZXJlIHdpbGwgYmUgb3ZlcmZsb3dcbiAgICAgICAgICAgIGNvbnN0IGdlID0gRnAucG93KGcsIF8xbiA8PCBCaWdJbnQociAtIG0gLSAxKSk7IC8vIGdlID0gMl4oci1tLTEpXG4gICAgICAgICAgICBnID0gRnAuc3FyKGdlKTsgLy8gZyA9IGdlICogZ2VcbiAgICAgICAgICAgIHggPSBGcC5tdWwoeCwgZ2UpOyAvLyB4ICo9IGdlXG4gICAgICAgICAgICBiID0gRnAubXVsKGIsIGcpOyAvLyBiICo9IGdcbiAgICAgICAgICAgIHIgPSBtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0KFApIHtcbiAgICAvLyBOT1RFOiBkaWZmZXJlbnQgYWxnb3JpdGhtcyBjYW4gZ2l2ZSBkaWZmZXJlbnQgcm9vdHMsIGl0IGlzIHVwIHRvIHVzZXIgdG8gZGVjaWRlIHdoaWNoIG9uZSB0aGV5IHdhbnQuXG4gICAgLy8gRm9yIGV4YW1wbGUgdGhlcmUgaXMgRnBTcXJ0T2RkL0ZwU3FydEV2ZW4gdG8gY2hvaWNlIHJvb3QgYmFzZWQgb24gb2RkbmVzcyAodXNlZCBmb3IgaGFzaC10by1jdXJ2ZSkuXG4gICAgLy8gUCDiiaEgMyAobW9kIDQpXG4gICAgLy8g4oiabiA9IG5eKChQKzEpLzQpXG4gICAgaWYgKFAgJSBfNG4gPT09IF8zbikge1xuICAgICAgICAvLyBOb3QgYWxsIHJvb3RzIHBvc3NpYmxlIVxuICAgICAgICAvLyBjb25zdCBPUkRFUiA9XG4gICAgICAgIC8vICAgMHgxYTAxMTFlYTM5N2ZlNjlhNGIxYmE3YjY0MzRiYWNkNzY0Nzc0Yjg0ZjM4NTEyYmY2NzMwZDJhMGY2YjBmNjI0MWVhYmZmZmViMTUzZmZmZmI5ZmVmZmZmZmZmZmFhYWJuO1xuICAgICAgICAvLyBjb25zdCBOVU0gPSA3MjA1NzU5NDAzNzkyNzgxNm47XG4gICAgICAgIGNvbnN0IHAxZGl2NCA9IChQICsgXzFuKSAvIF80bjtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHNxcnQzbW9kNChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgLy8gVGhyb3cgaWYgcm9vdCoqMiAhPSBuXG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBBdGtpbiBhbGdvcml0aG0gZm9yIHEg4omhIDUgKG1vZCA4KSwgaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxMi82ODUucGRmIChwYWdlIDEwKVxuICAgIGlmIChQICUgXzhuID09PSBfNW4pIHtcbiAgICAgICAgY29uc3QgYzEgPSAoUCAtIF81bikgLyBfOG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0NW1vZDgoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IG4yID0gRnAubXVsKG4sIF8ybik7XG4gICAgICAgICAgICBjb25zdCB2ID0gRnAucG93KG4yLCBjMSk7XG4gICAgICAgICAgICBjb25zdCBudiA9IEZwLm11bChuLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IGkgPSBGcC5tdWwoRnAubXVsKG52LCBfMm4pLCB2KTtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5tdWwobnYsIEZwLnN1YihpLCBGcC5PTkUpKTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKEZwLnNxcihyb290KSwgbikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgICAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFAg4omhIDkgKG1vZCAxNilcbiAgICBpZiAoUCAlIF8xNm4gPT09IF85bikge1xuICAgICAgICAvLyBOT1RFOiB0b25lbGxpIGlzIHRvbyBzbG93IGZvciBibHMtRnAyIGNhbGN1bGF0aW9ucyBldmVuIG9uIHN0YXJ0XG4gICAgICAgIC8vIE1lYW5zIHdlIGNhbm5vdCB1c2Ugc3FydCBmb3IgY29uc3RhbnRzIGF0IGFsbCFcbiAgICAgICAgLy9cbiAgICAgICAgLy8gY29uc3QgYzEgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShGcC5PTkUpKTsgLy8gIDEuIGMxID0gc3FydCgtMSkgaW4gRiwgaS5lLiwgKGMxXjIpID09IC0xIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzIgPSBGcC5zcXJ0KGMxKTsgICAgICAgICAgICAgICAgLy8gIDIuIGMyID0gc3FydChjMSkgaW4gRiwgaS5lLiwgKGMyXjIpID09IGMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzMgPSBGcC5zcXJ0KEZwLm5lZ2F0ZShjMSkpOyAgICAgLy8gIDMuIGMzID0gc3FydCgtYzEpIGluIEYsIGkuZS4sIChjM14yKSA9PSAtYzEgaW4gRlxuICAgICAgICAvLyBjb25zdCBjNCA9IChQICsgXzduKSAvIF8xNm47ICAgICAgICAgICAvLyAgNC4gYzQgPSAocSArIDcpIC8gMTYgICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG4gICAgICAgIC8vIHNxcnQgPSAoeCkgPT4ge1xuICAgICAgICAvLyAgIGxldCB0djEgPSBGcC5wb3coeCwgYzQpOyAgICAgICAgICAgICAvLyAgMS4gdHYxID0geF5jNFxuICAgICAgICAvLyAgIGxldCB0djIgPSBGcC5tdWwoYzEsIHR2MSk7ICAgICAgICAgICAvLyAgMi4gdHYyID0gYzEgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCB0djMgPSBGcC5tdWwoYzIsIHR2MSk7ICAgICAgICAgLy8gIDMuIHR2MyA9IGMyICogdHYxXG4gICAgICAgIC8vICAgbGV0IHR2NCA9IEZwLm11bChjMywgdHYxKTsgICAgICAgICAgIC8vICA0LiB0djQgPSBjMyAqIHR2MVxuICAgICAgICAvLyAgIGNvbnN0IGUxID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDUuICBlMSA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUyID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djMpLCB4KTsgLy8gIDYuICBlMiA9ICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIHR2MSA9IEZwLmNtb3YodHYxLCB0djIsIGUxKTsgLy8gIDcuIHR2MSA9IENNT1YodHYxLCB0djIsIGUxKSAgIyBTZWxlY3QgdHYyIGlmICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHR2MiA9IEZwLmNtb3YodHY0LCB0djMsIGUyKTsgLy8gIDguIHR2MiA9IENNT1YodHY0LCB0djMsIGUyKSAgIyBTZWxlY3QgdHYzIGlmICh0djNeMikgPT0geFxuICAgICAgICAvLyAgIGNvbnN0IGUzID0gRnAuZXF1YWxzKEZwLnNxdWFyZSh0djIpLCB4KTsgLy8gIDkuICBlMyA9ICh0djJeMikgPT0geFxuICAgICAgICAvLyAgIHJldHVybiBGcC5jbW92KHR2MSwgdHYyLCBlMyk7IC8vICAxMC4gIHogPSBDTU9WKHR2MSwgdHYyLCBlMykgICMgU2VsZWN0IHRoZSBzcXJ0IGZyb20gdHYxIGFuZCB0djJcbiAgICAgICAgLy8gfVxuICAgIH1cbiAgICAvLyBPdGhlciBjYXNlczogVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtXG4gICAgcmV0dXJuIHRvbmVsbGlTaGFua3MoUCk7XG59XG4vLyBMaXR0bGUtZW5kaWFuIGNoZWNrIGZvciBmaXJzdCBMRSBiaXQgKGxhc3QgQkUgYml0KTtcbmV4cG9ydCBjb25zdCBpc05lZ2F0aXZlTEUgPSAobnVtLCBtb2R1bG8pID0+IChtb2QobnVtLCBtb2R1bG8pICYgXzFuKSA9PT0gXzFuO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBGSUVMRF9GSUVMRFMgPSBbXG4gICAgJ2NyZWF0ZScsICdpc1ZhbGlkJywgJ2lzMCcsICduZWcnLCAnaW52JywgJ3NxcnQnLCAnc3FyJyxcbiAgICAnZXFsJywgJ2FkZCcsICdzdWInLCAnbXVsJywgJ3BvdycsICdkaXYnLFxuICAgICdhZGROJywgJ3N1Yk4nLCAnbXVsTicsICdzcXJOJ1xuXTtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUZpZWxkKGZpZWxkKSB7XG4gICAgY29uc3QgaW5pdGlhbCA9IHtcbiAgICAgICAgT1JERVI6ICdiaWdpbnQnLFxuICAgICAgICBNQVNLOiAnYmlnaW50JyxcbiAgICAgICAgQllURVM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgQklUUzogJ2lzU2FmZUludGVnZXInLFxuICAgIH07XG4gICAgY29uc3Qgb3B0cyA9IEZJRUxEX0ZJRUxEUy5yZWR1Y2UoKG1hcCwgdmFsKSA9PiB7XG4gICAgICAgIG1hcFt2YWxdID0gJ2Z1bmN0aW9uJztcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9LCBpbml0aWFsKTtcbiAgICByZXR1cm4gdmFsaWRhdGVPYmplY3QoZmllbGQsIG9wdHMpO1xufVxuLy8gR2VuZXJpYyBmaWVsZCBmdW5jdGlvbnNcbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLy8gMCBpcyBub24taW52ZXJ0aWJsZTogbm9uLWJhdGNoZWQgdmVyc2lvbiB3aWxsIHRocm93IG9uIDBcbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBnYWxvaXMgZmllbGQgb3ZlciBwcmltZS4gTm9uLXByaW1lcyBhcmUgbm90IHN1cHBvcnRlZCBmb3Igbm93LlxuICogRG8gbm90IGluaXQgaW4gbG9vcDogc2xvdy4gVmVyeSBmcmFnaWxlOiBhbHdheXMgcnVuIGEgYmVuY2htYXJrIG9uIGNoYW5nZS5cbiAqIE1ham9yIHBlcmZvcm1hbmNlIGdhaW5zOlxuICogYSkgbm9uLW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqIGIpIGBPYmplY3QuZnJlZXplYFxuICogYykgU2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogQHBhcmFtIE9SREVSIHByaW1lIHBvc2l0aXZlIGJpZ2ludFxuICogQHBhcmFtIGJpdExlbiBob3cgbWFueSBiaXRzIHRoZSBmaWVsZCBjb25zdW1lc1xuICogQHBhcmFtIGlzTEUgKGRlZjogZmFsc2UpIGlmIGVuY29kaW5nIC8gZGVjb2Rpbmcgc2hvdWxkIGJlIGluIGxpdHRsZS1lbmRpYW5cbiAqIEBwYXJhbSByZWRlZiBvcHRpb25hbCBmYXN0ZXIgcmVkZWZpbml0aW9ucyBvZiBzcXJ0IGFuZCBvdGhlciBtZXRob2RzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGaWVsZChPUkRFUiwgYml0TGVuLCBpc0xFID0gZmFsc2UsIHJlZGVmID0ge30pIHtcbiAgICBpZiAoT1JERVIgPD0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIEZwIE9SREVSID4gMCwgZ290ICR7T1JERVJ9YCk7XG4gICAgY29uc3QgeyBuQml0TGVuZ3RoOiBCSVRTLCBuQnl0ZUxlbmd0aDogQllURVMgfSA9IG5MZW5ndGgoT1JERVIsIGJpdExlbik7XG4gICAgaWYgKEJZVEVTID4gMjA0OClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaWVsZCBsZW5ndGhzIG92ZXIgMjA0OCBieXRlcyBhcmUgbm90IHN1cHBvcnRlZCcpO1xuICAgIGNvbnN0IHNxcnRQID0gRnBTcXJ0KE9SREVSKTtcbiAgICBjb25zdCBmID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIE9SREVSLFxuICAgICAgICBCSVRTLFxuICAgICAgICBCWVRFUyxcbiAgICAgICAgTUFTSzogYml0TWFzayhCSVRTKSxcbiAgICAgICAgWkVSTzogXzBuLFxuICAgICAgICBPTkU6IF8xbixcbiAgICAgICAgY3JlYXRlOiAobnVtKSA9PiBtb2QobnVtLCBPUkRFUiksXG4gICAgICAgIGlzVmFsaWQ6IChudW0pID0+IHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmllbGQgZWxlbWVudDogZXhwZWN0ZWQgYmlnaW50LCBnb3QgJHt0eXBlb2YgbnVtfWApO1xuICAgICAgICAgICAgcmV0dXJuIF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVI7IC8vIDAgaXMgdmFsaWQgZWxlbWVudCwgYnV0IGl0J3Mgbm90IGludmVydGlibGVcbiAgICAgICAgfSxcbiAgICAgICAgaXMwOiAobnVtKSA9PiBudW0gPT09IF8wbixcbiAgICAgICAgaXNPZGQ6IChudW0pID0+IChudW0gJiBfMW4pID09PSBfMW4sXG4gICAgICAgIG5lZzogKG51bSkgPT4gbW9kKC1udW0sIE9SREVSKSxcbiAgICAgICAgZXFsOiAobGhzLCByaHMpID0+IGxocyA9PT0gcmhzLFxuICAgICAgICBzcXI6IChudW0pID0+IG1vZChudW0gKiBudW0sIE9SREVSKSxcbiAgICAgICAgYWRkOiAobGhzLCByaHMpID0+IG1vZChsaHMgKyByaHMsIE9SREVSKSxcbiAgICAgICAgc3ViOiAobGhzLCByaHMpID0+IG1vZChsaHMgLSByaHMsIE9SREVSKSxcbiAgICAgICAgbXVsOiAobGhzLCByaHMpID0+IG1vZChsaHMgKiByaHMsIE9SREVSKSxcbiAgICAgICAgcG93OiAobnVtLCBwb3dlcikgPT4gRnBQb3coZiwgbnVtLCBwb3dlciksXG4gICAgICAgIGRpdjogKGxocywgcmhzKSA9PiBtb2QobGhzICogaW52ZXJ0KHJocywgT1JERVIpLCBPUkRFUiksXG4gICAgICAgIC8vIFNhbWUgYXMgYWJvdmUsIGJ1dCBkb2Vzbid0IG5vcm1hbGl6ZVxuICAgICAgICBzcXJOOiAobnVtKSA9PiBudW0gKiBudW0sXG4gICAgICAgIGFkZE46IChsaHMsIHJocykgPT4gbGhzICsgcmhzLFxuICAgICAgICBzdWJOOiAobGhzLCByaHMpID0+IGxocyAtIHJocyxcbiAgICAgICAgbXVsTjogKGxocywgcmhzKSA9PiBsaHMgKiByaHMsXG4gICAgICAgIGludjogKG51bSkgPT4gaW52ZXJ0KG51bSwgT1JERVIpLFxuICAgICAgICBzcXJ0OiByZWRlZi5zcXJ0IHx8ICgobikgPT4gc3FydFAoZiwgbikpLFxuICAgICAgICBpbnZlcnRCYXRjaDogKGxzdCkgPT4gRnBJbnZlcnRCYXRjaChmLCBsc3QpLFxuICAgICAgICAvLyBUT0RPOiBkbyB3ZSByZWFsbHkgbmVlZCBjb25zdGFudCBjbW92P1xuICAgICAgICAvLyBXZSBkb24ndCBoYXZlIGNvbnN0LXRpbWUgYmlnaW50cyBhbnl3YXksIHNvIHByb2JhYmx5IHdpbGwgYmUgbm90IHZlcnkgdXNlZnVsXG4gICAgICAgIGNtb3Y6IChhLCBiLCBjKSA9PiAoYyA/IGIgOiBhKSxcbiAgICAgICAgdG9CeXRlczogKG51bSkgPT4gKGlzTEUgPyBudW1iZXJUb0J5dGVzTEUobnVtLCBCWVRFUykgOiBudW1iZXJUb0J5dGVzQkUobnVtLCBCWVRFUykpLFxuICAgICAgICBmcm9tQnl0ZXM6IChieXRlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gQllURVMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGcC5mcm9tQnl0ZXM6IGV4cGVjdGVkICR7QllURVN9LCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgICAgICByZXR1cm4gaXNMRSA/IGJ5dGVzVG9OdW1iZXJMRShieXRlcykgOiBieXRlc1RvTnVtYmVyQkUoYnl0ZXMpO1xuICAgICAgICB9LFxuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKGYpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydE9kZChGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IHJvb3QgOiBGcC5uZWcocm9vdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0RXZlbihGcCwgZWxtKSB7XG4gICAgaWYgKCFGcC5pc09kZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGaWVsZCBkb2Vzbid0IGhhdmUgaXNPZGRgKTtcbiAgICBjb25zdCByb290ID0gRnAuc3FydChlbG0pO1xuICAgIHJldHVybiBGcC5pc09kZChyb290KSA/IEZwLm5lZyhyb290KSA6IHJvb3Q7XG59XG4vKipcbiAqIEZJUFMgMTg2IEIuNC4xLWNvbXBsaWFudCBcImNvbnN0YW50LXRpbWVcIiBwcml2YXRlIGtleSBnZW5lcmF0aW9uIHV0aWxpdHkuXG4gKiBDYW4gdGFrZSAobis4KSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQwIGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBAcGFyYW0gaGFzaCBoYXNoIG91dHB1dCBmcm9tIFNIQTMgb3IgYSBzaW1pbGFyIGZ1bmN0aW9uXG4gKiBAcGFyYW0gZ3JvdXBPcmRlciBzaXplIG9mIHN1Ymdyb3VwIC0gKGUuZy4gY3VydmVGbi5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gaGFzaFRvUHJpdmF0ZVNjYWxhcihoYXNoLCBncm91cE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBoYXNoID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGVIYXNoJywgaGFzaCk7XG4gICAgY29uc3QgaGFzaExlbiA9IGhhc2gubGVuZ3RoO1xuICAgIGNvbnN0IG1pbkxlbiA9IG5MZW5ndGgoZ3JvdXBPcmRlcikubkJ5dGVMZW5ndGggKyA4O1xuICAgIGlmIChtaW5MZW4gPCAyNCB8fCBoYXNoTGVuIDwgbWluTGVuIHx8IGhhc2hMZW4gPiAxMDI0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGhhc2hUb1ByaXZhdGVTY2FsYXI6IGV4cGVjdGVkICR7bWluTGVufS0xMDI0IGJ5dGVzIG9mIGlucHV0LCBnb3QgJHtoYXNoTGVufWApO1xuICAgIGNvbnN0IG51bSA9IGlzTEUgPyBieXRlc1RvTnVtYmVyTEUoaGFzaCkgOiBieXRlc1RvTnVtYmVyQkUoaGFzaCk7XG4gICAgcmV0dXJuIG1vZChudW0sIGdyb3VwT3JkZXIgLSBfMW4pICsgXzFuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kdWxhci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!***************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: function() { return /* binding */ montgomery; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === 'bigint' && _0n <= n && n < P)\n            return n;\n        throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        // This is very ugly way, but it works because fieldLen-1 is outside of bounds for X448, so this becomes NOOP\n        // fieldLen - scalaryBytes = 1 for X448 and = 0 for X25519\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n        // u[fieldLen-1] crashes QuickJS (TypeError: out-of-bound numeric index)\n        if (fieldLen === montgomeryBytes)\n            u[fieldLen - 1] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('scalar', n);\n        if (bytes.length !== montgomeryBytes && bytes.length !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${bytes.length}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUN3QztBQUNtRDtBQUMzRjtBQUNBO0FBQ0E7QUFDQSxJQUFJLHlEQUFjO0FBQ2xCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLElBQUk7QUFDaEIsd0JBQXdCLGdEQUFHO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdEQUFHO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFVBQVU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSwwREFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0RBQVc7QUFDN0I7QUFDQTtBQUNBLG9DQUFvQztBQUNwQyxlQUFlLDBEQUFlO0FBQzlCO0FBQ0E7QUFDQSxzQkFBc0Isc0RBQVc7QUFDakM7QUFDQSx3Q0FBd0MsaUJBQWlCLEtBQUssVUFBVSxhQUFhLGFBQWE7QUFDbEcsZUFBZSwwREFBZTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsOERBQThEO0FBQy9FO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzP2QyZjIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgbW9kLCBwb3cgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB2YWxpZGF0ZU9iamVjdCB9IGZyb20gJy4vdXRpbHMuanMnO1xuY29uc3QgXzBuID0gQmlnSW50KDApO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgdmFsaWRhdGVPYmplY3QoY3VydmUsIHtcbiAgICAgICAgYTogJ2JpZ2ludCcsXG4gICAgfSwge1xuICAgICAgICBtb250Z29tZXJ5Qml0czogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBuQnl0ZUxlbmd0aDogJ2lzU2FmZUludGVnZXInLFxuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICBwb3dQbWludXMyOiAnZnVuY3Rpb24nLFxuICAgICAgICBHdTogJ2JpZ2ludCcsXG4gICAgfSk7XG4gICAgLy8gU2V0IGRlZmF1bHRzXG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5jdXJ2ZSB9KTtcbn1cbi8vIE5PVEU6IG5vdCByZWFsbHkgbW9udGdvbWVyeSBjdXJ2ZSwganVzdCBidW5jaCBvZiB2ZXJ5IHNwZWNpZmljIG1ldGhvZHMgZm9yIFgyNTUxOS9YNDQ4IChSRkMgNzc0OCwgaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzc3NDgpXG4vLyBVc2VzIG9ubHkgb25lIGNvb3JkaW5hdGUgaW5zdGVhZCBvZiB0d29cbmV4cG9ydCBmdW5jdGlvbiBtb250Z29tZXJ5KGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgUCB9ID0gQ1VSVkU7XG4gICAgY29uc3QgbW9kUCA9IChuKSA9PiBtb2QobiwgUCk7XG4gICAgY29uc3QgbW9udGdvbWVyeUJpdHMgPSBDVVJWRS5tb250Z29tZXJ5Qml0cztcbiAgICBjb25zdCBtb250Z29tZXJ5Qnl0ZXMgPSBNYXRoLmNlaWwobW9udGdvbWVyeUJpdHMgLyA4KTtcbiAgICBjb25zdCBmaWVsZExlbiA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgIGNvbnN0IGFkanVzdFNjYWxhckJ5dGVzID0gQ1VSVkUuYWRqdXN0U2NhbGFyQnl0ZXMgfHwgKChieXRlcykgPT4gYnl0ZXMpO1xuICAgIGNvbnN0IHBvd1BtaW51czIgPSBDVVJWRS5wb3dQbWludXMyIHx8ICgoeCkgPT4gcG93KHgsIFAgLSBCaWdJbnQoMiksIFApKTtcbiAgICAvLyBjc3dhcCBmcm9tIFJGQzc3NDguIEJ1dCBpdCBpcyBub3QgZnJvbSBSRkM3NzQ4IVxuICAgIC8qXG4gICAgICBjc3dhcChzd2FwLCB4XzIsIHhfMyk6XG4gICAgICAgICAgIGR1bW15ID0gbWFzayhzd2FwKSBBTkQgKHhfMiBYT1IgeF8zKVxuICAgICAgICAgICB4XzIgPSB4XzIgWE9SIGR1bW15XG4gICAgICAgICAgIHhfMyA9IHhfMyBYT1IgZHVtbXlcbiAgICAgICAgICAgUmV0dXJuICh4XzIsIHhfMylcbiAgICBXaGVyZSBtYXNrKHN3YXApIGlzIHRoZSBhbGwtMSBvciBhbGwtMCB3b3JkIG9mIHRoZSBzYW1lIGxlbmd0aCBhcyB4XzJcbiAgICAgYW5kIHhfMywgY29tcHV0ZWQsIGUuZy4sIGFzIG1hc2soc3dhcCkgPSAwIC0gc3dhcC5cbiAgICAqL1xuICAgIGZ1bmN0aW9uIGNzd2FwKHN3YXAsIHhfMiwgeF8zKSB7XG4gICAgICAgIGNvbnN0IGR1bW15ID0gbW9kUChzd2FwICogKHhfMiAtIHhfMykpO1xuICAgICAgICB4XzIgPSBtb2RQKHhfMiAtIGR1bW15KTtcbiAgICAgICAgeF8zID0gbW9kUCh4XzMgKyBkdW1teSk7XG4gICAgICAgIHJldHVybiBbeF8yLCB4XzNdO1xuICAgIH1cbiAgICAvLyBBY2NlcHRzIDAgYXMgd2VsbFxuICAgIGZ1bmN0aW9uIGFzc2VydEZpZWxkRWxlbWVudChuKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbiA9PT0gJ2JpZ2ludCcgJiYgXzBuIDw9IG4gJiYgbiA8IFApXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBzY2FsYXIgMCA8IHNjYWxhciA8IENVUlZFLlAnKTtcbiAgICB9XG4gICAgLy8geDI1NTE5IGZyb20gNFxuICAgIC8vIFRoZSBjb25zdGFudCBhMjQgaXMgKDQ4NjY2MiAtIDIpIC8gNCA9IDEyMTY2NSBmb3IgY3VydmUyNTUxOS9YMjU1MTlcbiAgICBjb25zdCBhMjQgPSAoQ1VSVkUuYSAtIEJpZ0ludCgyKSkgLyBCaWdJbnQoNCk7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9pbnRVIHUgY29vcmRpbmF0ZSAoeCkgb24gTW9udGdvbWVyeSBDdXJ2ZSAyNTUxOVxuICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgKiBAcmV0dXJucyBuZXcgUG9pbnQgb24gTW9udGdvbWVyeSBjdXJ2ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBzY2FsYXIpIHtcbiAgICAgICAgY29uc3QgdSA9IGFzc2VydEZpZWxkRWxlbWVudChwb2ludFUpO1xuICAgICAgICAvLyBTZWN0aW9uIDU6IEltcGxlbWVudGF0aW9ucyBNVVNUIGFjY2VwdCBub24tY2Fub25pY2FsIHZhbHVlcyBhbmQgcHJvY2VzcyB0aGVtIGFzXG4gICAgICAgIC8vIGlmIHRoZXkgaGFkIGJlZW4gcmVkdWNlZCBtb2R1bG8gdGhlIGZpZWxkIHByaW1lLlxuICAgICAgICBjb25zdCBrID0gYXNzZXJ0RmllbGRFbGVtZW50KHNjYWxhcik7XG4gICAgICAgIGNvbnN0IHhfMSA9IHU7XG4gICAgICAgIGxldCB4XzIgPSBfMW47XG4gICAgICAgIGxldCB6XzIgPSBfMG47XG4gICAgICAgIGxldCB4XzMgPSB1O1xuICAgICAgICBsZXQgel8zID0gXzFuO1xuICAgICAgICBsZXQgc3dhcCA9IF8wbjtcbiAgICAgICAgbGV0IHN3O1xuICAgICAgICBmb3IgKGxldCB0ID0gQmlnSW50KG1vbnRnb21lcnlCaXRzIC0gMSk7IHQgPj0gXzBuOyB0LS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGtfdCA9IChrID4+IHQpICYgXzFuO1xuICAgICAgICAgICAgc3dhcCBePSBrX3Q7XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgICAgIHhfMiA9IHN3WzBdO1xuICAgICAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHpfMiwgel8zKTtcbiAgICAgICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgICAgICBzd2FwID0ga190O1xuICAgICAgICAgICAgY29uc3QgQSA9IHhfMiArIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEFBID0gbW9kUChBICogQSk7XG4gICAgICAgICAgICBjb25zdCBCID0geF8yIC0gel8yO1xuICAgICAgICAgICAgY29uc3QgQkIgPSBtb2RQKEIgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IEUgPSBBQSAtIEJCO1xuICAgICAgICAgICAgY29uc3QgQyA9IHhfMyArIHpfMztcbiAgICAgICAgICAgIGNvbnN0IEQgPSB4XzMgLSB6XzM7XG4gICAgICAgICAgICBjb25zdCBEQSA9IG1vZFAoRCAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQ0IgPSBtb2RQKEMgKiBCKTtcbiAgICAgICAgICAgIGNvbnN0IGRhY2IgPSBEQSArIENCO1xuICAgICAgICAgICAgY29uc3QgZGFfY2IgPSBEQSAtIENCO1xuICAgICAgICAgICAgeF8zID0gbW9kUChkYWNiICogZGFjYik7XG4gICAgICAgICAgICB6XzMgPSBtb2RQKHhfMSAqIG1vZFAoZGFfY2IgKiBkYV9jYikpO1xuICAgICAgICAgICAgeF8yID0gbW9kUChBQSAqIEJCKTtcbiAgICAgICAgICAgIHpfMiA9IG1vZFAoRSAqIChBQSArIG1vZFAoYTI0ICogRSkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyAoeF8yLCB4XzMpID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgeF8yLCB4XzMpO1xuICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgeF8zID0gc3dbMV07XG4gICAgICAgIC8vICh6XzIsIHpfMykgPSBjc3dhcChzd2FwLCB6XzIsIHpfMylcbiAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgIHpfMiA9IHN3WzBdO1xuICAgICAgICB6XzMgPSBzd1sxXTtcbiAgICAgICAgLy8gel8yXihwIC0gMilcbiAgICAgICAgY29uc3QgejIgPSBwb3dQbWludXMyKHpfMik7XG4gICAgICAgIC8vIFJldHVybiB4XzIgKiAoel8yXihwIC0gMikpXG4gICAgICAgIHJldHVybiBtb2RQKHhfMiAqIHoyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlVUNvb3JkaW5hdGUodSkge1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKG1vZFAodSksIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVVDb29yZGluYXRlKHVFbmMpIHtcbiAgICAgICAgLy8gU2VjdGlvbiA1OiBXaGVuIHJlY2VpdmluZyBzdWNoIGFuIGFycmF5LCBpbXBsZW1lbnRhdGlvbnMgb2YgWDI1NTE5XG4gICAgICAgIC8vIE1VU1QgbWFzayB0aGUgbW9zdCBzaWduaWZpY2FudCBiaXQgaW4gdGhlIGZpbmFsIGJ5dGUuXG4gICAgICAgIC8vIFRoaXMgaXMgdmVyeSB1Z2x5IHdheSwgYnV0IGl0IHdvcmtzIGJlY2F1c2UgZmllbGRMZW4tMSBpcyBvdXRzaWRlIG9mIGJvdW5kcyBmb3IgWDQ0OCwgc28gdGhpcyBiZWNvbWVzIE5PT1BcbiAgICAgICAgLy8gZmllbGRMZW4gLSBzY2FsYXJ5Qnl0ZXMgPSAxIGZvciBYNDQ4IGFuZCA9IDAgZm9yIFgyNTUxOVxuICAgICAgICBjb25zdCB1ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHVFbmMsIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgICAgIC8vIHVbZmllbGRMZW4tMV0gY3Jhc2hlcyBRdWlja0pTIChUeXBlRXJyb3I6IG91dC1vZi1ib3VuZCBudW1lcmljIGluZGV4KVxuICAgICAgICBpZiAoZmllbGRMZW4gPT09IG1vbnRnb21lcnlCeXRlcylcbiAgICAgICAgICAgIHVbZmllbGRMZW4gLSAxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyTEUodSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihuKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoJ3NjYWxhcicsIG4pO1xuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBtb250Z29tZXJ5Qnl0ZXMgJiYgYnl0ZXMubGVuZ3RoICE9PSBmaWVsZExlbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgJHttb250Z29tZXJ5Qnl0ZXN9IG9yICR7ZmllbGRMZW59IGJ5dGVzLCBnb3QgJHtieXRlcy5sZW5ndGh9YCk7XG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyTEUoYWRqdXN0U2NhbGFyQnl0ZXMoYnl0ZXMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdChzY2FsYXIsIHUpIHtcbiAgICAgICAgY29uc3QgcG9pbnRVID0gZGVjb2RlVUNvb3JkaW5hdGUodSk7XG4gICAgICAgIGNvbnN0IF9zY2FsYXIgPSBkZWNvZGVTY2FsYXIoc2NhbGFyKTtcbiAgICAgICAgY29uc3QgcHUgPSBtb250Z29tZXJ5TGFkZGVyKHBvaW50VSwgX3NjYWxhcik7XG4gICAgICAgIC8vIFRoZSByZXN1bHQgd2FzIG5vdCBjb250cmlidXRvcnlcbiAgICAgICAgLy8gaHR0cHM6Ly9jci55cC50by9lY2RoLmh0bWwjdmFsaWRhdGVcbiAgICAgICAgaWYgKHB1ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcHJpdmF0ZSBvciBwdWJsaWMga2V5IHJlY2VpdmVkJyk7XG4gICAgICAgIHJldHVybiBlbmNvZGVVQ29vcmRpbmF0ZShwdSk7XG4gICAgfVxuICAgIC8vIENvbXB1dGVzIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlLiBCeSBkb2luZyBzY2FsYXIgbXVsdGlwbGljYXRpb24gb2YgYmFzZSBwb2ludC5cbiAgICBjb25zdCBHdUJ5dGVzID0gZW5jb2RlVUNvb3JkaW5hdGUoQ1VSVkUuR3UpO1xuICAgIGZ1bmN0aW9uIHNjYWxhck11bHRCYXNlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gc2NhbGFyTXVsdChzY2FsYXIsIEd1Qnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzY2FsYXJNdWx0LFxuICAgICAgICBzY2FsYXJNdWx0QmFzZSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0OiAocHJpdmF0ZUtleSwgcHVibGljS2V5KSA9PiBzY2FsYXJNdWx0KHByaXZhdGVLZXksIHB1YmxpY0tleSksXG4gICAgICAgIGdldFB1YmxpY0tleTogKHByaXZhdGVLZXkpID0+IHNjYWxhck11bHRCYXNlKHByaXZhdGVLZXkpLFxuICAgICAgICB1dGlsczogeyByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiBDVVJWRS5yYW5kb21CeXRlcyhDVVJWRS5uQnl0ZUxlbmd0aCkgfSxcbiAgICAgICAgR3VCeXRlczogR3VCeXRlcyxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9udGdvbWVyeS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/montgomery.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst u8a = (a) => a instanceof Uint8Array;\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (u8a(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\nfunction equalBytes(b1, b2) {\n    // We don't care about timing attacks here\n    if (b1.length !== b2.length)\n        return false;\n    for (let i = 0; i < b1.length; i++)\n        if (b1[i] !== b2[i])\n            return false;\n    return true;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nconst bitSet = (n, pos, value) => {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n};\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDRCQUE0QjtBQUNuRDtBQUNPO0FBQ1A7QUFDQSw0Q0FBNEM7QUFDNUMsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDBCQUEwQjtBQUMxQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzP2U1MTUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IHU4YSA9IChhKSA9PiBhIGluc3RhbmNlb2YgVWludDhBcnJheTtcbmNvbnN0IGhleGVzID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sICh2LCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGlmICghdThhKGJ5dGVzKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0hleFVucGFkZGVkKG51bSkge1xuICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgcmV0dXJuIGhleC5sZW5ndGggJiAxID8gYDAke2hleH1gIDogaGV4O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleFRvTnVtYmVyKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIC8vIEJpZyBFbmRpYW5cbiAgICByZXR1cm4gQmlnSW50KGhleCA9PT0gJycgPyAnMCcgOiBgMHgke2hleH1gKTtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBsZW4gPSBoZXgubGVuZ3RoO1xuICAgIGlmIChsZW4gJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgbGVuKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGxlbiAvIDIpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaiA9IGkgKiAyO1xuICAgICAgICBjb25zdCBoZXhCeXRlID0gaGV4LnNsaWNlKGosIGogKyAyKTtcbiAgICAgICAgY29uc3QgYnl0ZSA9IE51bWJlci5wYXJzZUludChoZXhCeXRlLCAxNik7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oYnl0ZSkgfHwgYnl0ZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYnl0ZSBzZXF1ZW5jZScpO1xuICAgICAgICBhcnJheVtpXSA9IGJ5dGU7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHU4YShoZXgpKSB7XG4gICAgICAgIC8vIFVpbnQ4QXJyYXkuZnJvbSgpIGluc3RlYWQgb2YgaGFzaC5zbGljZSgpIGJlY2F1c2Ugbm9kZS5qcyBCdWZmZXJcbiAgICAgICAgLy8gaXMgaW5zdGFuY2Ugb2YgVWludDhBcnJheSwgYW5kIGl0cyBzbGljZSgpIGNyZWF0ZXMgKiptdXRhYmxlKiogY29weVxuICAgICAgICByZXMgPSBVaW50OEFycmF5LmZyb20oaGV4KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHt0aXRsZX0gbXVzdCBiZSBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlgKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gcmVzLmxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGV4cGVjdGVkTGVuZ3RoID09PSAnbnVtYmVyJyAmJiBsZW4gIT09IGV4cGVjdGVkTGVuZ3RoKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IGV4cGVjdGVkICR7ZXhwZWN0ZWRMZW5ndGh9IGJ5dGVzLCBnb3QgJHtsZW59YCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogQ29waWVzIHNldmVyYWwgVWludDhBcnJheXMgaW50byBvbmUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyguLi5hcnJheXMpIHtcbiAgICBjb25zdCByID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlzLnJlZHVjZSgoc3VtLCBhKSA9PiBzdW0gKyBhLmxlbmd0aCwgMCkpO1xuICAgIGxldCBwYWQgPSAwOyAvLyB3YWxrIHRocm91Z2ggZWFjaCBpdGVtLCBlbnN1cmUgdGhleSBoYXZlIHByb3BlciB0eXBlXG4gICAgYXJyYXlzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgaWYgKCF1OGEoYSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAgICAgci5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiByO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVxdWFsQnl0ZXMoYjEsIGIyKSB7XG4gICAgLy8gV2UgZG9uJ3QgY2FyZSBhYm91dCB0aW1pbmcgYXR0YWNrcyBoZXJlXG4gICAgaWYgKGIxLmxlbmd0aCAhPT0gYjIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiMS5sZW5ndGg7IGkrKylcbiAgICAgICAgaWYgKGIxW2ldICE9PSBiMltpXSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgY29uc3QgYml0U2V0ID0gKG4sIHBvcywgdmFsdWUpID0+IHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn07XG4vKipcbiAqIENhbGN1bGF0ZSBtYXNrIGZvciBOIGJpdHMuIE5vdCB1c2luZyAqKiBvcGVyYXRvciB3aXRoIGJpZ2ludHMgYmVjYXVzZSBvZiBvbGQgZW5naW5lcy5cbiAqIFNhbWUgYXMgQmlnSW50KGAwYiR7QXJyYXkoaSkuZmlsbCgnMScpLmpvaW4oJycpfWApXG4gKi9cbmV4cG9ydCBjb25zdCBiaXRNYXNrID0gKG4pID0+IChfMm4gPDwgQmlnSW50KG4gLSAxKSkgLSBfMW47XG4vLyBEUkJHXG5jb25zdCB1OG4gPSAoZGF0YSkgPT4gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7IC8vIGNyZWF0ZXMgVWludDhBcnJheVxuY29uc3QgdThmciA9IChhcnIpID0+IFVpbnQ4QXJyYXkuZnJvbShhcnIpOyAvLyBhbm90aGVyIHNob3J0Y3V0XG4vKipcbiAqIE1pbmltYWwgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAqIEByZXR1cm5zIGZ1bmN0aW9uIHRoYXQgd2lsbCBjYWxsIERSQkcgdW50aWwgMm5kIGFyZyByZXR1cm5zIHNvbWV0aGluZyBtZWFuaW5nZnVsXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBkcmJnID0gY3JlYXRlSG1hY0RSQkc8S2V5PigzMiwgMzIsIGhtYWMpO1xuICogICBkcmJnKHNlZWQsIGJ5dGVzVG9LZXkpOyAvLyBieXRlc1RvS2V5IG11c3QgcmV0dXJuIEtleSBvciB1bmRlZmluZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUhtYWNEcmJnKGhhc2hMZW4sIHFCeXRlTGVuLCBobWFjRm4pIHtcbiAgICBpZiAodHlwZW9mIGhhc2hMZW4gIT09ICdudW1iZXInIHx8IGhhc2hMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hhc2hMZW4gbXVzdCBiZSBhIG51bWJlcicpO1xuICAgIGlmICh0eXBlb2YgcUJ5dGVMZW4gIT09ICdudW1iZXInIHx8IHFCeXRlTGVuIDwgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdxQnl0ZUxlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBobWFjRm4gIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaG1hY0ZuIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgIC8vIFN0ZXAgQiwgU3RlcCBDOiBzZXQgaGFzaExlbiB0byA4KmNlaWwoaGxlbi84KVxuICAgIGxldCB2ID0gdThuKGhhc2hMZW4pOyAvLyBNaW5pbWFsIG5vbi1mdWxsLXNwZWMgSE1BQy1EUkJHIGZyb20gTklTVCA4MDAtOTAgZm9yIFJGQzY5Nzkgc2lncy5cbiAgICBsZXQgayA9IHU4bihoYXNoTGVuKTsgLy8gU3RlcHMgQiBhbmQgQyBvZiBSRkM2OTc5IDMuMjogc2V0IGhhc2hMZW4sIGluIG91ciBjYXNlIGFsd2F5cyBzYW1lXG4gICAgbGV0IGkgPSAwOyAvLyBJdGVyYXRpb25zIGNvdW50ZXIsIHdpbGwgdGhyb3cgd2hlbiBvdmVyIDEwMDBcbiAgICBjb25zdCByZXNldCA9ICgpID0+IHtcbiAgICAgICAgdi5maWxsKDEpO1xuICAgICAgICBrLmZpbGwoMCk7XG4gICAgICAgIGkgPSAwO1xuICAgIH07XG4gICAgY29uc3QgaCA9ICguLi5iKSA9PiBobWFjRm4oaywgdiwgLi4uYik7IC8vIGhtYWMoaykodiwgLi4udmFsdWVzKVxuICAgIGNvbnN0IHJlc2VlZCA9IChzZWVkID0gdThuKCkpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIHJlc2VlZCgpIGZ1bmN0aW9uLiBTdGVwcyBELUdcbiAgICAgICAgayA9IGgodThmcihbMHgwMF0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDAgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgICAgICBpZiAoc2VlZC5sZW5ndGggPT09IDApXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGsgPSBoKHU4ZnIoWzB4MDFdKSwgc2VlZCk7IC8vIGsgPSBobWFjKGsgfHwgdiB8fCAweDAxIHx8IHNlZWQpXG4gICAgICAgIHYgPSBoKCk7IC8vIHYgPSBobWFjKGsgfHwgdilcbiAgICB9O1xuICAgIGNvbnN0IGdlbiA9ICgpID0+IHtcbiAgICAgICAgLy8gSE1BQy1EUkJHIGdlbmVyYXRlKCkgZnVuY3Rpb25cbiAgICAgICAgaWYgKGkrKyA+PSAxMDAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkcmJnOiB0cmllZCAxMDAwIHZhbHVlcycpO1xuICAgICAgICBsZXQgbGVuID0gMDtcbiAgICAgICAgY29uc3Qgb3V0ID0gW107XG4gICAgICAgIHdoaWxlIChsZW4gPCBxQnl0ZUxlbikge1xuICAgICAgICAgICAgdiA9IGgoKTtcbiAgICAgICAgICAgIGNvbnN0IHNsID0gdi5zbGljZSgpO1xuICAgICAgICAgICAgb3V0LnB1c2goc2wpO1xuICAgICAgICAgICAgbGVuICs9IHYubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb25jYXRCeXRlcyguLi5vdXQpO1xuICAgIH07XG4gICAgY29uc3QgZ2VuVW50aWwgPSAoc2VlZCwgcHJlZCkgPT4ge1xuICAgICAgICByZXNldCgpO1xuICAgICAgICByZXNlZWQoc2VlZCk7IC8vIFN0ZXBzIEQtR1xuICAgICAgICBsZXQgcmVzID0gdW5kZWZpbmVkOyAvLyBTdGVwIEg6IGdyaW5kIHVudGlsIGsgaXMgaW4gWzEuLm4tMV1cbiAgICAgICAgd2hpbGUgKCEocmVzID0gcHJlZChnZW4oKSkpKVxuICAgICAgICAgICAgcmVzZWVkKCk7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfTtcbiAgICByZXR1cm4gZ2VuVW50aWw7XG59XG4vLyBWYWxpZGF0aW5nIGN1cnZlcyBhbmQgZmllbGRzXG5jb25zdCB2YWxpZGF0b3JGbnMgPSB7XG4gICAgYmlnaW50OiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYmlnaW50JyxcbiAgICBmdW5jdGlvbjogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcbiAgICBib29sZWFuOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnYm9vbGVhbicsXG4gICAgc3RyaW5nOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJyxcbiAgICBpc1NhZmVJbnRlZ2VyOiAodmFsKSA9PiBOdW1iZXIuaXNTYWZlSW50ZWdlcih2YWwpLFxuICAgIGFycmF5OiAodmFsKSA9PiBBcnJheS5pc0FycmF5KHZhbCksXG4gICAgZmllbGQ6ICh2YWwsIG9iamVjdCkgPT4gb2JqZWN0LkZwLmlzVmFsaWQodmFsKSxcbiAgICBoYXNoOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nICYmIE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbC5vdXRwdXRMZW4pLFxufTtcbi8vIHR5cGUgUmVjb3JkPEsgZXh0ZW5kcyBzdHJpbmcgfCBudW1iZXIgfCBzeW1ib2wsIFQ+ID0geyBbUCBpbiBLXTogVDsgfVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0KG9iamVjdCwgdmFsaWRhdG9ycywgb3B0VmFsaWRhdG9ycyA9IHt9KSB7XG4gICAgY29uc3QgY2hlY2tGaWVsZCA9IChmaWVsZE5hbWUsIHR5cGUsIGlzT3B0aW9uYWwpID0+IHtcbiAgICAgICAgY29uc3QgY2hlY2tWYWwgPSB2YWxpZGF0b3JGbnNbdHlwZV07XG4gICAgICAgIGlmICh0eXBlb2YgY2hlY2tWYWwgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsaWRhdG9yIFwiJHt0eXBlfVwiLCBleHBlY3RlZCBmdW5jdGlvbmApO1xuICAgICAgICBjb25zdCB2YWwgPSBvYmplY3RbZmllbGROYW1lXTtcbiAgICAgICAgaWYgKGlzT3B0aW9uYWwgJiYgdmFsID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICghY2hlY2tWYWwodmFsLCBvYmplY3QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcGFyYW0gJHtTdHJpbmcoZmllbGROYW1lKX09JHt2YWx9ICgke3R5cGVvZiB2YWx9KSwgZXhwZWN0ZWQgJHt0eXBlfWApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIHR5cGVdIG9mIE9iamVjdC5lbnRyaWVzKHZhbGlkYXRvcnMpKVxuICAgICAgICBjaGVja0ZpZWxkKGZpZWxkTmFtZSwgdHlwZSwgZmFsc2UpO1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXMob3B0VmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCB0cnVlKTtcbiAgICByZXR1cm4gb2JqZWN0O1xufVxuLy8gdmFsaWRhdGUgdHlwZSB0ZXN0c1xuLy8gY29uc3QgbzogeyBhOiBudW1iZXI7IGI6IG51bWJlcjsgYzogbnVtYmVyIH0gPSB7IGE6IDEsIGI6IDUsIGM6IDYgfTtcbi8vIGNvbnN0IHowID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnaXNTYWZlSW50ZWdlcicgfSwgeyBjOiAnYmlnaW50JyB9KTsgLy8gT2shXG4vLyAvLyBTaG91bGQgZmFpbCB0eXBlLWNoZWNrXG4vLyBjb25zdCB6MSA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ3RtcCcgfSwgeyBjOiAnenonIH0pO1xuLy8gY29uc3QgejIgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MyA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgdGVzdDogJ2Jvb2xlYW4nLCB6OiAnYnVnJyB9KTtcbi8vIGNvbnN0IHo0ID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./curve.js */ \"./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y = x + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        if (!(data instanceof Uint8Array))\n            throw new Error('ui8a expected');\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((c, point, isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y = x + ax + b: Short weierstrass curve formula\n     * @returns y\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (key instanceof Uint8Array)\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_0__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            // Zero is valid point too!\n            if (this.is0()) {\n                if (CURVE.allowInfinityPoint)\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y\n            const right = weierstrassEquation(x); // x + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z)  (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_2__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_0__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_0__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y = x + ax + b\n                let y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size (nBitLength+64)\n         * as per FIPS 186 B.4.1 with modulo bias being neglible.\n         */\n        randomPrivateKey: () => {\n            const rand = CURVE.randomBytes(Fp.BYTES + 8);\n            const num = _modular_js__WEBPACK_IMPORTED_MODULE_0__.hashToPrivateScalar(rand, CURVE_ORDER);\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = item instanceof Uint8Array;\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e, Fp.BYTES)); // check for being of size BYTES\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G  k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1G - U2P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || sg instanceof Uint8Array) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * From draft-irtf-cfrg-hash-to-curve-16\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3Qvd2VpZXJzdHJhc3MuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ29DO0FBQ0g7QUFDUTtBQUNRO0FBQ2pEO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNBLFFBQVEsd0NBQXdDLEVBQUUsc0NBQUU7QUFDN0M7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiwwQ0FBMEM7QUFDM0QsS0FBSztBQUNMO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsa0RBQWM7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LFNBQVM7QUFDbEMsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsNkNBQTZDO0FBQzdDLG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLHlDQUF5QztBQUN6QywwQ0FBMEM7QUFDMUM7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDLHVDQUF1QztBQUN2QztBQUNBLGlDQUFpQztBQUNqQyxzQ0FBc0M7QUFDdEMsb0NBQW9DO0FBQ3BDLHNDQUFzQztBQUN0QyxrQ0FBa0M7QUFDbEMsdUNBQXVDO0FBQ3ZDLCtDQUErQyxrQkFBa0I7QUFDakUseUNBQXlDO0FBQ3pDLDJDQUEyQztBQUMzQyxxQkFBcUIsMkJBQTJCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxzREFBaUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQixnQ0FBZ0M7QUFDaEMsbUNBQW1DO0FBQ25DLG1DQUFtQztBQUNuQyxtRUFBbUU7QUFDbkUsbUNBQW1DO0FBQ25DLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsbUNBQW1DO0FBQ25DLGdDQUFnQztBQUNoQyxnQ0FBZ0M7QUFDaEMsZ0NBQWdDO0FBQ2hDLG1DQUFtQztBQUNuQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdCQUFnQixpQkFBaUIsdUJBQXVCO0FBQ3hELDRCQUE0QjtBQUM1Qiw4QkFBOEI7QUFDOUIsc0NBQXNDO0FBQ3RDLHdDQUF3QztBQUN4QyxnREFBZ0Q7QUFDaEQsdUNBQXVDO0FBQ3ZDLDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz84Zjk3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIGlmICghKGRhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndWk4YSBleHBlY3RlZCcpO1xuICAgICAgICBsZXQgbCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobCA8IDIgfHwgZGF0YVswXSAhPSAweDMwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIHRhZycpO1xuICAgICAgICBpZiAoZGF0YVsxXSAhPT0gbCAtIDIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGluY29ycmVjdCBsZW5ndGgnKTtcbiAgICAgICAgY29uc3QgeyBkOiByLCBsOiBzQnl0ZXMgfSA9IERFUi5fcGFyc2VJbnQoZGF0YS5zdWJhcnJheSgyKSk7XG4gICAgICAgIGNvbnN0IHsgZDogcywgbDogckJ5dGVzTGVmdCB9ID0gREVSLl9wYXJzZUludChzQnl0ZXMpO1xuICAgICAgICBpZiAockJ5dGVzTGVmdC5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmU6IGxlZnQgYnl0ZXMgYWZ0ZXIgcGFyc2luZycpO1xuICAgICAgICByZXR1cm4geyByLCBzIH07XG4gICAgfSxcbiAgICBoZXhGcm9tU2lnKHNpZykge1xuICAgICAgICAvLyBBZGQgbGVhZGluZyB6ZXJvIGlmIGZpcnN0IGJ5dGUgaGFzIG5lZ2F0aXZlIGJpdCBlbmFibGVkLiBNb3JlIGRldGFpbHMgaW4gJ19wYXJzZUludCdcbiAgICAgICAgY29uc3Qgc2xpY2UgPSAocykgPT4gKE51bWJlci5wYXJzZUludChzWzBdLCAxNikgJiAwYjEwMDAgPyAnMDAnICsgcyA6IHMpO1xuICAgICAgICBjb25zdCBoID0gKG51bSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gbnVtLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcyA9IHNsaWNlKGgoc2lnLnMpKTtcbiAgICAgICAgY29uc3QgciA9IHNsaWNlKGgoc2lnLnIpKTtcbiAgICAgICAgY29uc3Qgc2hsID0gcy5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCByaGwgPSByLmxlbmd0aCAvIDI7XG4gICAgICAgIGNvbnN0IHNsID0gaChzaGwpO1xuICAgICAgICBjb25zdCBybCA9IGgocmhsKTtcbiAgICAgICAgcmV0dXJuIGAzMCR7aChyaGwgKyBzaGwgKyA0KX0wMiR7cmx9JHtyfTAyJHtzbH0ke3N9YDtcbiAgICB9LFxufTtcbi8vIEJlIGZyaWVuZGx5IHRvIGJhZCBFQ01BU2NyaXB0IHBhcnNlcnMgYnkgbm90IHVzaW5nIGJpZ2ludCBsaXRlcmFsc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyksIF80biA9IEJpZ0ludCg0KTtcbmV4cG9ydCBmdW5jdGlvbiB3ZWllcnN0cmFzc1BvaW50cyhvcHRzKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZVBvaW50T3B0cyhvcHRzKTtcbiAgICBjb25zdCB7IEZwIH0gPSBDVVJWRTsgLy8gQWxsIGN1cnZlcyBoYXMgc2FtZSBmaWVsZCAvIGdyb3VwIGxlbmd0aCBhcyBmb3Igbm93LCBidXQgdGhleSBjYW4gZGlmZmVyXG4gICAgY29uc3QgdG9CeXRlcyA9IENVUlZFLnRvQnl0ZXMgfHxcbiAgICAgICAgKChjLCBwb2ludCwgaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmIChrZXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KVxuICAgICAgICAgICAgICAgIGtleSA9IHV0LmJ5dGVzVG9IZXgoa2V5KTtcbiAgICAgICAgICAgIC8vIE5vcm1hbGl6ZSB0byBoZXggc3RyaW5nLCBwYWQuIEUuZy4gUDUyMSB3b3VsZCBub3JtIDEzMC0xMzIgY2hhciBoZXggdG8gMTMyLWNoYXIgYnl0ZXNcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJyB8fCAhbGVuZ3Rocy5pbmNsdWRlcyhrZXkubGVuZ3RoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQga2V5Jyk7XG4gICAgICAgICAgICBrZXkgPSBrZXkucGFkU3RhcnQobkJ5dGVMZW5ndGggKiAyLCAnMCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBudW0gPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBrZXkgPT09ICdiaWdpbnQnXG4gICAgICAgICAgICAgICAgICAgID8ga2V5XG4gICAgICAgICAgICAgICAgICAgIDogdXQuYnl0ZXNUb051bWJlckJFKGVuc3VyZUJ5dGVzKCdwcml2YXRlIGtleScsIGtleSwgbkJ5dGVMZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgcHJpdmF0ZSBrZXkgbXVzdCBiZSAke25CeXRlTGVuZ3RofSBieXRlcywgaGV4IG9yIGJpZ2ludCwgbm90ICR7dHlwZW9mIGtleX1gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcFByaXZhdGVLZXkpXG4gICAgICAgICAgICBudW0gPSBtb2QubW9kKG51bSwgbik7IC8vIGRpc2FibGVkIGJ5IGRlZmF1bHQsIGVuYWJsZWQgZm9yIEJMU1xuICAgICAgICBhc3NlcnRHRShudW0pOyAvLyBudW0gaW4gcmFuZ2UgWzEuLk4tMV1cbiAgICAgICAgcmV0dXJuIG51bTtcbiAgICB9XG4gICAgY29uc3QgcG9pbnRQcmVjb21wdXRlcyA9IG5ldyBNYXAoKTtcbiAgICBmdW5jdGlvbiBhc3NlcnRQcmpQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdGl2ZVBvaW50IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2plY3RpdmUgUG9pbnQgd29ya3MgaW4gM2QgLyBwcm9qZWN0aXZlIChob21vZ2VuZW91cykgY29vcmRpbmF0ZXM6ICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgKiBEZWZhdWx0IFBvaW50IHdvcmtzIGluIDJkIC8gYWZmaW5lIGNvb3JkaW5hdGVzOiAoeCwgeSlcbiAgICAgKiBXZSdyZSBkb2luZyBjYWxjdWxhdGlvbnMgaW4gcHJvamVjdGl2ZSwgYmVjYXVzZSBpdHMgb3BlcmF0aW9ucyBkb24ndCByZXF1aXJlIGNvc3RseSBpbnZlcnNpb24uXG4gICAgICovXG4gICAgY2xhc3MgUG9pbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcihweCwgcHksIHB6KSB7XG4gICAgICAgICAgICB0aGlzLnB4ID0gcHg7XG4gICAgICAgICAgICB0aGlzLnB5ID0gcHk7XG4gICAgICAgICAgICB0aGlzLnB6ID0gcHo7XG4gICAgICAgICAgICBpZiAocHggPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHkgPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAocHogPT0gbnVsbCB8fCAhRnAuaXNWYWxpZChweikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9lcyBub3QgdmFsaWRhdGUgaWYgdGhlIHBvaW50IGlzIG9uLWN1cnZlLlxuICAgICAgICAvLyBVc2UgZnJvbUhleCBpbnN0ZWFkLCBvciBjYWxsIGFzc2VydFZhbGlkaXR5KCkgbGF0ZXIuXG4gICAgICAgIHN0YXRpYyBmcm9tQWZmaW5lKHApIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcCB8fCB7fTtcbiAgICAgICAgICAgIGlmICghcCB8fCAhRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYWZmaW5lIHBvaW50Jyk7XG4gICAgICAgICAgICBpZiAocCBpbnN0YW5jZW9mIFBvaW50KVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvamVjdGl2ZSBwb2ludCBub3QgYWxsb3dlZCcpO1xuICAgICAgICAgICAgY29uc3QgaXMwID0gKGkpID0+IEZwLmVxbChpLCBGcC5aRVJPKTtcbiAgICAgICAgICAgIC8vIGZyb21BZmZpbmUoeDowLCB5OjApIHdvdWxkIHByb2R1Y2UgKHg6MCwgeTowLCB6OjEpLCBidXQgd2UgbmVlZCAoeDowLCB5OjEsIHo6MClcbiAgICAgICAgICAgIGlmIChpczAoeCkgJiYgaXMwKHkpKVxuICAgICAgICAgICAgICAgIHJldHVybiBQb2ludC5aRVJPO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh4LCB5LCBGcC5PTkUpO1xuICAgICAgICB9XG4gICAgICAgIGdldCB4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS54O1xuICAgICAgICB9XG4gICAgICAgIGdldCB5KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9BZmZpbmUoKS55O1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhIGJ1bmNoIG9mIFByb2plY3RpdmUgUG9pbnRzIGJ1dCBleGVjdXRlcyBvbmx5IG9uZVxuICAgICAgICAgKiBpbnZlcnNpb24gb24gYWxsIG9mIHRoZW0uIEludmVyc2lvbiBpcyB2ZXJ5IHNsb3cgb3BlcmF0aW9uLFxuICAgICAgICAgKiBzbyB0aGlzIGltcHJvdmVzIHBlcmZvcm1hbmNlIG1hc3NpdmVseS5cbiAgICAgICAgICogT3B0aW1pemF0aW9uOiBjb252ZXJ0cyBhIGxpc3Qgb2YgcHJvamVjdGl2ZSBwb2ludHMgdG8gYSBsaXN0IG9mIGlkZW50aWNhbCBwb2ludHMgd2l0aCBaPTEuXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgbm9ybWFsaXplWihwb2ludHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2gocG9pbnRzLm1hcCgocCkgPT4gcC5weikpO1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgICAqIEBwYXJhbSBoZXggc2hvcnQvbG9uZyBFQ0RTQSBoZXhcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICAgICAgY29uc3QgUCA9IFBvaW50LmZyb21BZmZpbmUoZnJvbUJ5dGVzKGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCkpKTtcbiAgICAgICAgICAgIFAuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBQO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgZ2VuZXJhdG9yIHBvaW50IGJ5IHByaXZhdGVLZXkuXG4gICAgICAgIHN0YXRpYyBmcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gUG9pbnQuQkFTRS5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBcIlByaXZhdGUgbWV0aG9kXCIsIGRvbid0IHVzZSBpdCBkaXJlY3RseVxuICAgICAgICBfc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9XSU5ET1dfU0laRSA9IHdpbmRvd1NpemU7XG4gICAgICAgICAgICBwb2ludFByZWNvbXB1dGVzLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBIHBvaW50IG9uIGN1cnZlIGlzIHZhbGlkIGlmIGl0IGNvbmZvcm1zIHRvIGVxdWF0aW9uLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIC8vIFplcm8gaXMgdmFsaWQgcG9pbnQgdG9vIVxuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoQ1VSVkUuYWxsb3dJbmZpbml0eVBvaW50KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IFpFUk8nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvbWUgM3JkLXBhcnR5IHRlc3QgdmVjdG9ycyByZXF1aXJlIGRpZmZlcmVudCB3b3JkaW5nIGJldHdlZW4gaGVyZSAmIGBmcm9tQ29tcHJlc3NlZEhleGBcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgeCwgeSBhcmUgdmFsaWQgZmllbGQgZWxlbWVudHNcbiAgICAgICAgICAgIGlmICghRnAuaXNWYWxpZCh4KSB8fCAhRnAuaXNWYWxpZCh5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogeCBvciB5IG5vdCBGRScpO1xuICAgICAgICAgICAgY29uc3QgbGVmdCA9IEZwLnNxcih5KTsgLy8gecKyXG4gICAgICAgICAgICBjb25zdCByaWdodCA9IHdlaWVyc3RyYXNzRXF1YXRpb24oeCk7IC8vIHjCsyArIGF4ICsgYlxuICAgICAgICAgICAgaWYgKCFGcC5lcWwobGVmdCwgcmlnaHQpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBlcXVhdGlvbiBsZWZ0ICE9IHJpZ2h0Jyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUb3JzaW9uRnJlZSgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBub3QgaW4gcHJpbWUtb3JkZXIgc3ViZ3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBoYXNFdmVuWSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgeSB9ID0gdGhpcy50b0FmZmluZSgpO1xuICAgICAgICAgICAgaWYgKEZwLmlzT2RkKVxuICAgICAgICAgICAgICAgIHJldHVybiAhRnAuaXNPZGQoeSk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGaWVsZCBkb2Vzbid0IHN1cHBvcnQgaXNPZGRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgICAgICAqL1xuICAgICAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBVMSA9IEZwLmVxbChGcC5tdWwoWDEsIFoyKSwgRnAubXVsKFgyLCBaMSkpO1xuICAgICAgICAgICAgY29uc3QgVTIgPSBGcC5lcWwoRnAubXVsKFkxLCBaMiksIEZwLm11bChZMiwgWjEpKTtcbiAgICAgICAgICAgIHJldHVybiBVMSAmJiBVMjtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRmxpcHMgcG9pbnQgdG8gb25lIGNvcnJlc3BvbmRpbmcgdG8gKHgsIC15KSBpbiBBZmZpbmUgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqL1xuICAgICAgICBuZWdhdGUoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHRoaXMucHgsIEZwLm5lZyh0aGlzLnB5KSwgdGhpcy5weik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGRvdWJsaW5nIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gM1xuICAgICAgICAvLyBDb3N0OiA4TSArIDNTICsgMyphICsgMipiMyArIDE1YWRkLlxuICAgICAgICBkb3VibGUoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGIgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgYjMgPSBGcC5tdWwoYiwgXzNuKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGxldCBYMyA9IEZwLlpFUk8sIFkzID0gRnAuWkVSTywgWjMgPSBGcC5aRVJPOyAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgICAgIGxldCB0MCA9IEZwLm11bChYMSwgWDEpOyAvLyBzdGVwIDFcbiAgICAgICAgICAgIGxldCB0MSA9IEZwLm11bChZMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQyID0gRnAubXVsKFoxLCBaMSk7XG4gICAgICAgICAgICBsZXQgdDMgPSBGcC5tdWwoWDEsIFkxKTtcbiAgICAgICAgICAgIHQzID0gRnAuYWRkKHQzLCB0Myk7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgWjMgPSBGcC5tdWwoWDEsIFoxKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCBaMyk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChhLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChiMywgdDIpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWDMsIFkzKTsgLy8gc3RlcCAxMFxuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFkzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWTMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKGIzLCBaMyk7IC8vIHN0ZXAgMTVcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQwLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLm11bChhLCB0Myk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgWjMpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgdDAgPSBGcC5hZGQoWjMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKHQwLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MCwgdDMpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKFkxLCBaMSk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQyID0gRnAuYWRkKHQyLCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MiwgdDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIoWDMsIHQwKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQyLCB0MSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpOyAvLyBzdGVwIDMwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChYMywgWTMsIFozKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5lcy1Db3N0ZWxsby1CYXRpbmEgZXhjZXB0aW9uLWZyZWUgYWRkaXRpb24gZm9ybXVsYS5cbiAgICAgICAgLy8gVGhlcmUgaXMgMzAlIGZhc3RlciBKYWNvYmlhbiBmb3JtdWxhLCBidXQgaXQgaXMgbm90IGNvbXBsZXRlLlxuICAgICAgICAvLyBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDE1LzEwNjAsIGFsZ29yaXRobSAxXG4gICAgICAgIC8vIENvc3Q6IDEyTSArIDBTICsgMyphICsgMypiMyArIDIzYWRkLlxuICAgICAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgICAgIGFzc2VydFByalBvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgxLCBweTogWTEsIHB6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IFgyLCBweTogWTIsIHB6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBhID0gQ1VSVkUuYTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKENVUlZFLmIsIF8zbik7XG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgyKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkyKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjIpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAuYWRkKFgxLCBZMSk7XG4gICAgICAgICAgICBsZXQgdDQgPSBGcC5hZGQoWDIsIFkyKTsgLy8gc3RlcCA1XG4gICAgICAgICAgICB0MyA9IEZwLm11bCh0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDAsIHQxKTtcbiAgICAgICAgICAgIHQzID0gRnAuc3ViKHQzLCB0NCk7XG4gICAgICAgICAgICB0NCA9IEZwLmFkZChYMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQ1ID0gRnAuYWRkKFgyLCBaMik7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5zdWIodDQsIHQ1KTtcbiAgICAgICAgICAgIHQ1ID0gRnAuYWRkKFkxLCBaMSk7XG4gICAgICAgICAgICBYMyA9IEZwLmFkZChZMiwgWjIpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0NSA9IEZwLm11bCh0NSwgWDMpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQ1ID0gRnAuc3ViKHQ1LCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChhLCB0NCk7XG4gICAgICAgICAgICBYMyA9IEZwLm11bChiMywgdDIpOyAvLyBzdGVwIDIwXG4gICAgICAgICAgICBaMyA9IEZwLmFkZChYMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5zdWIodDEsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQxLCBaMyk7XG4gICAgICAgICAgICBZMyA9IEZwLm11bChYMywgWjMpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDAsIHQwKTsgLy8gc3RlcCAyNVxuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQwKTtcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAubXVsKGIzLCB0NCk7XG4gICAgICAgICAgICB0MSA9IEZwLmFkZCh0MSwgdDIpO1xuICAgICAgICAgICAgdDIgPSBGcC5zdWIodDAsIHQyKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgdDIgPSBGcC5tdWwoYSwgdDIpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQodDQsIHQyKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQxLCB0NCk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZChZMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDUsIHQ0KTsgLy8gc3RlcCAzNVxuICAgICAgICAgICAgWDMgPSBGcC5tdWwodDMsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MywgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwodDUsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKFozLCB0MCk7IC8vIHN0ZXAgNDBcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VidHJhY3Qob3RoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZChvdGhlci5uZWdhdGUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCAoY29tcCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvSW52ID0gRnAuaW52ZXJ0QmF0Y2goY29tcC5tYXAoKHApID0+IHAucHopKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5tYXAoKHAsIGkpID0+IHAudG9BZmZpbmUodG9JbnZbaV0pKS5tYXAoUG9pbnQuZnJvbUFmZmluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogTm9uLWNvbnN0YW50LXRpbWUgbXVsdGlwbGljYXRpb24uIFVzZXMgZG91YmxlLWFuZC1hZGQgYWxnb3JpdGhtLlxuICAgICAgICAgKiBJdCdzIGZhc3RlciwgYnV0IHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB5b3UgZG9uJ3QgY2FyZSBhYm91dFxuICAgICAgICAgKiBhbiBleHBvc2VkIHByaXZhdGUga2V5IGUuZy4gc2lnIHZlcmlmaWNhdGlvbiwgd2hpY2ggd29ya3Mgb3ZlciAqcHVibGljKiBrZXlzLlxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlVbnNhZmUobikge1xuICAgICAgICAgICAgY29uc3QgSSA9IFBvaW50LlpFUk87XG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgYXNzZXJ0R0Uobik7IC8vIFdpbGwgdGhyb3cgb24gMFxuICAgICAgICAgICAgaWYgKG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoIWVuZG8pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHduYWYudW5zYWZlTGFkZGVyKHRoaXMsIG4pO1xuICAgICAgICAgICAgLy8gQXBwbHkgZW5kb21vcnBoaXNtXG4gICAgICAgICAgICBsZXQgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgIGxldCBrMXAgPSBJO1xuICAgICAgICAgICAgbGV0IGsycCA9IEk7XG4gICAgICAgICAgICBsZXQgZCA9IHRoaXM7XG4gICAgICAgICAgICB3aGlsZSAoazEgPiBfMG4gfHwgazIgPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAoazEgJiBfMW4pXG4gICAgICAgICAgICAgICAgICAgIGsxcCA9IGsxcC5hZGQoZCk7XG4gICAgICAgICAgICAgICAgaWYgKGsyICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMnAgPSBrMnAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIGsxID4+PSBfMW47XG4gICAgICAgICAgICAgICAgazIgPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChrMW5lZylcbiAgICAgICAgICAgICAgICBrMXAgPSBrMXAubmVnYXRlKCk7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazJwID0gazJwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgIHJldHVybiBrMXAuYWRkKGsycCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0YW50IHRpbWUgbXVsdGlwbGljYXRpb24uXG4gICAgICAgICAqIFVzZXMgd05BRiBtZXRob2QuIFdpbmRvd2VkIG1ldGhvZCBtYXkgYmUgMTAlIGZhc3RlcixcbiAgICAgICAgICogYnV0IHRha2VzIDJ4IGxvbmdlciB0byBnZW5lcmF0ZSBhbmQgY29uc3VtZXMgMnggbWVtb3J5LlxuICAgICAgICAgKiBVc2VzIHByZWNvbXB1dGVzIHdoZW4gYXZhaWxhYmxlLlxuICAgICAgICAgKiBVc2VzIGVuZG9tb3JwaGlzbSBmb3IgS29ibGl0eiBjdXJ2ZXMuXG4gICAgICAgICAqIEBwYXJhbSBzY2FsYXIgYnkgd2hpY2ggdGhlIHBvaW50IHdvdWxkIGJlIG11bHRpcGxpZWRcbiAgICAgICAgICogQHJldHVybnMgTmV3IHBvaW50XG4gICAgICAgICAqL1xuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGFzc2VydEdFKHNjYWxhcik7XG4gICAgICAgICAgICBsZXQgbiA9IHNjYWxhcjtcbiAgICAgICAgICAgIGxldCBwb2ludCwgZmFrZTsgLy8gRmFrZSBwb2ludCBpcyB1c2VkIHRvIGNvbnN0LXRpbWUgbXVsdFxuICAgICAgICAgICAgY29uc3QgeyBlbmRvIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChlbmRvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrMW5lZywgazEsIGsybmVnLCBrMiB9ID0gZW5kby5zcGxpdFNjYWxhcihuKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMXAsIGY6IGYxcCB9ID0gdGhpcy53TkFGKGsxKTtcbiAgICAgICAgICAgICAgICBsZXQgeyBwOiBrMnAsIGY6IGYycCB9ID0gdGhpcy53TkFGKGsyKTtcbiAgICAgICAgICAgICAgICBrMXAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMW5lZywgazFwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSB3bmFmLmNvbnN0VGltZU5lZ2F0ZShrMm5lZywgazJwKTtcbiAgICAgICAgICAgICAgICBrMnAgPSBuZXcgUG9pbnQoRnAubXVsKGsycC5weCwgZW5kby5iZXRhKSwgazJwLnB5LCBrMnAucHopO1xuICAgICAgICAgICAgICAgIHBvaW50ID0gazFwLmFkZChrMnApO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmMXAuYWRkKGYycCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHAsIGYgfSA9IHRoaXMud05BRihuKTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IHA7XG4gICAgICAgICAgICAgICAgZmFrZSA9IGY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOb3JtYWxpemUgYHpgIGZvciBib3RoIHBvaW50cywgYnV0IHJldHVybiBvbmx5IHJlYWwgb25lXG4gICAgICAgICAgICByZXR1cm4gUG9pbnQubm9ybWFsaXplWihbcG9pbnQsIGZha2VdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogRWZmaWNpZW50bHkgY2FsY3VsYXRlIGBhUCArIGJRYC4gVW5zYWZlLCBjYW4gZXhwb3NlIHByaXZhdGUga2V5LCBpZiB1c2VkIGluY29ycmVjdGx5LlxuICAgICAgICAgKiBOb3QgdXNpbmcgU3RyYXVzcy1TaGFtaXIgdHJpY2s6IHByZWNvbXB1dGF0aW9uIHRhYmxlcyBhcmUgZmFzdGVyLlxuICAgICAgICAgKiBUaGUgdHJpY2sgY291bGQgYmUgdXNlZnVsIGlmIGJvdGggUCBhbmQgUSBhcmUgbm90IEcgKG5vdCBpbiBvdXIgY2FzZSkuXG4gICAgICAgICAqIEByZXR1cm5zIG5vbi16ZXJvIGFmZmluZSBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYikge1xuICAgICAgICAgICAgY29uc3QgRyA9IFBvaW50LkJBU0U7IC8vIE5vIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiB3ZSBoYXZlIDEwJSBmYXN0ZXIgRyBwcmVjb21wdXRlc1xuICAgICAgICAgICAgY29uc3QgbXVsID0gKFAsIGEgLy8gU2VsZWN0IGZhc3RlciBtdWx0aXBseSgpIG1ldGhvZFxuICAgICAgICAgICAgKSA9PiAoYSA9PT0gXzBuIHx8IGEgPT09IF8xbiB8fCAhUC5lcXVhbHMoRykgPyBQLm11bHRpcGx5VW5zYWZlKGEpIDogUC5tdWx0aXBseShhKSk7XG4gICAgICAgICAgICBjb25zdCBzdW0gPSBtdWwodGhpcywgYSkuYWRkKG11bChRLCBiKSk7XG4gICAgICAgICAgICByZXR1cm4gc3VtLmlzMCgpID8gdW5kZWZpbmVkIDogc3VtO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIFByb2plY3RpdmUgcG9pbnQgdG8gYWZmaW5lICh4LCB5KSBjb29yZGluYXRlcy5cbiAgICAgICAgLy8gQ2FuIGFjY2VwdCBwcmVjb21wdXRlZCBaXi0xIC0gZm9yIGV4YW1wbGUsIGZyb20gaW52ZXJ0QmF0Y2guXG4gICAgICAgIC8vICh4LCB5LCB6KSDiiIsgKHg9eC96LCB5PXkveilcbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHg6IHgsIHB5OiB5LCBwejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICAvLyBJZiBpbnZaIHdhcyAwLCB3ZSByZXR1cm4gemVybyBwb2ludC4gSG93ZXZlciB3ZSBzdGlsbCB3YW50IHRvIGV4ZWN1dGVcbiAgICAgICAgICAgIC8vIGFsbCBvcGVyYXRpb25zLCBzbyB3ZSByZXBsYWNlIGludlogd2l0aCBhIHJhbmRvbSBudW1iZXIsIDEuXG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IEZwLk9ORSA6IEZwLmludih6KTtcbiAgICAgICAgICAgIGNvbnN0IGF4ID0gRnAubXVsKHgsIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gRnAubXVsKHksIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IHp6ID0gRnAubXVsKHosIGl6KTtcbiAgICAgICAgICAgIGlmIChpczApXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeDogRnAuWkVSTywgeTogRnAuWkVSTyB9O1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoenosIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZaIHdhcyBpbnZhbGlkJyk7XG4gICAgICAgICAgICByZXR1cm4geyB4OiBheCwgeTogYXkgfTtcbiAgICAgICAgfVxuICAgICAgICBpc1RvcnNpb25GcmVlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgaXNUb3JzaW9uRnJlZSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gTm8gc3ViZ3JvdXBzLCBhbHdheXMgdG9yc2lvbi1mcmVlXG4gICAgICAgICAgICBpZiAoaXNUb3JzaW9uRnJlZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNUb3JzaW9uRnJlZShQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lzVG9yc2lvbkZyZWUoKSBoYXMgbm90IGJlZW4gZGVjbGFyZWQgZm9yIHRoZSBlbGxpcHRpYyBjdXJ2ZScpO1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yLCBjbGVhckNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzOyAvLyBGYXN0LXBhdGhcbiAgICAgICAgICAgIGlmIChjbGVhckNvZmFjdG9yKVxuICAgICAgICAgICAgICAgIHJldHVybiBjbGVhckNvZmFjdG9yKFBvaW50LCB0aGlzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm11bHRpcGx5VW5zYWZlKENVUlZFLmgpO1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRvQnl0ZXMoUG9pbnQsIHRoaXMsIGlzQ29tcHJlc3NlZCk7XG4gICAgICAgIH1cbiAgICAgICAgdG9IZXgoaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFBvaW50LkJBU0UgPSBuZXcgUG9pbnQoQ1VSVkUuR3gsIENVUlZFLkd5LCBGcC5PTkUpO1xuICAgIFBvaW50LlpFUk8gPSBuZXcgUG9pbnQoRnAuWkVSTywgRnAuT05FLCBGcC5aRVJPKTtcbiAgICBjb25zdCBfYml0cyA9IENVUlZFLm5CaXRMZW5ndGg7XG4gICAgY29uc3Qgd25hZiA9IHdOQUYoUG9pbnQsIENVUlZFLmVuZG8gPyBNYXRoLmNlaWwoX2JpdHMgLyAyKSA6IF9iaXRzKTtcbiAgICAvLyBWYWxpZGF0ZSBpZiBnZW5lcmF0b3IgcG9pbnQgaXMgb24gY3VydmVcbiAgICByZXR1cm4ge1xuICAgICAgICBDVVJWRSxcbiAgICAgICAgUHJvamVjdGl2ZVBvaW50OiBQb2ludCxcbiAgICAgICAgbm9ybVByaXZhdGVLZXlUb1NjYWxhcixcbiAgICAgICAgd2VpZXJzdHJhc3NFcXVhdGlvbixcbiAgICAgICAgaXNXaXRoaW5DdXJ2ZU9yZGVyLFxuICAgIH07XG59XG5mdW5jdGlvbiB2YWxpZGF0ZU9wdHMoY3VydmUpIHtcbiAgICBjb25zdCBvcHRzID0gdmFsaWRhdGVCYXNpYyhjdXJ2ZSk7XG4gICAgdXQudmFsaWRhdGVPYmplY3Qob3B0cywge1xuICAgICAgICBoYXNoOiAnaGFzaCcsXG4gICAgICAgIGhtYWM6ICdmdW5jdGlvbicsXG4gICAgICAgIHJhbmRvbUJ5dGVzOiAnZnVuY3Rpb24nLFxuICAgIH0sIHtcbiAgICAgICAgYml0czJpbnQ6ICdmdW5jdGlvbicsXG4gICAgICAgIGJpdHMyaW50X21vZE46ICdmdW5jdGlvbicsXG4gICAgICAgIGxvd1M6ICdib29sZWFuJyxcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7IGxvd1M6IHRydWUsIC4uLm9wdHMgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3MoY3VydmVEZWYpIHtcbiAgICBjb25zdCBDVVJWRSA9IHZhbGlkYXRlT3B0cyhjdXJ2ZURlZik7XG4gICAgY29uc3QgeyBGcCwgbjogQ1VSVkVfT1JERVIgfSA9IENVUlZFO1xuICAgIGNvbnN0IGNvbXByZXNzZWRMZW4gPSBGcC5CWVRFUyArIDE7IC8vIGUuZy4gMzMgZm9yIDMyXG4gICAgY29uc3QgdW5jb21wcmVzc2VkTGVuID0gMiAqIEZwLkJZVEVTICsgMTsgLy8gZS5nLiA2NSBmb3IgMzJcbiAgICBmdW5jdGlvbiBpc1ZhbGlkRmllbGRFbGVtZW50KG51bSkge1xuICAgICAgICByZXR1cm4gXzBuIDwgbnVtICYmIG51bSA8IEZwLk9SREVSOyAvLyAwIGlzIGJhbm5lZCBzaW5jZSBpdCdzIG5vdCBpbnZlcnRpYmxlIEZFXG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLm1vZChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludk4oYSkge1xuICAgICAgICByZXR1cm4gbW9kLmludmVydChhLCBDVVJWRV9PUkRFUik7XG4gICAgfVxuICAgIGNvbnN0IHsgUHJvamVjdGl2ZVBvaW50OiBQb2ludCwgbm9ybVByaXZhdGVLZXlUb1NjYWxhciwgd2VpZXJzdHJhc3NFcXVhdGlvbiwgaXNXaXRoaW5DdXJ2ZU9yZGVyLCB9ID0gd2VpZXJzdHJhc3NQb2ludHMoe1xuICAgICAgICAuLi5DVVJWRSxcbiAgICAgICAgdG9CeXRlcyhjLCBwb2ludCwgaXNDb21wcmVzc2VkKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC50b0J5dGVzKGEueCk7XG4gICAgICAgICAgICBjb25zdCBjYXQgPSB1dC5jb25jYXRCeXRlcztcbiAgICAgICAgICAgIGlmIChpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbcG9pbnQuaGFzRXZlblkoKSA/IDB4MDIgOiAweDAzXSksIHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhdChVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgeCwgRnAudG9CeXRlcyhhLnkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZnJvbUJ5dGVzKGJ5dGVzKSB7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gYnl0ZXNbMF07XG4gICAgICAgICAgICBjb25zdCB0YWlsID0gYnl0ZXMuc3ViYXJyYXkoMSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFzc2VydFZhbGlkaXR5KCkgaXMgZG9uZSBpbnNpZGUgb2YgZnJvbUhleFxuICAgICAgICAgICAgaWYgKGxlbiA9PT0gY29tcHJlc3NlZExlbiAmJiAoaGVhZCA9PT0gMHgwMiB8fCBoZWFkID09PSAweDAzKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB1dC5ieXRlc1RvTnVtYmVyQkUodGFpbCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1ZhbGlkRmllbGRFbGVtZW50KHgpKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50IGlzIG5vdCBvbiBjdXJ2ZScpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gd2VpZXJzdHJhc3NFcXVhdGlvbih4KTsgLy8gecKyID0geMKzICsgYXggKyBiXG4gICAgICAgICAgICAgICAgbGV0IHkgPSBGcC5zcXJ0KHkyKTsgLy8geSA9IHnCsiBeIChwKzEpLzRcbiAgICAgICAgICAgICAgICBjb25zdCBpc1lPZGQgPSAoeSAmIF8xbikgPT09IF8xbjtcbiAgICAgICAgICAgICAgICAvLyBFQ0RTQVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzSGVhZE9kZCA9IChoZWFkICYgMSkgPT09IDE7XG4gICAgICAgICAgICAgICAgaWYgKGlzSGVhZE9kZCAhPT0gaXNZT2RkKVxuICAgICAgICAgICAgICAgICAgICB5ID0gRnAubmVnKHkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGxlbiA9PT0gdW5jb21wcmVzc2VkTGVuICYmIGhlYWQgPT09IDB4MDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoMCwgRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICBjb25zdCB5ID0gRnAuZnJvbUJ5dGVzKHRhaWwuc3ViYXJyYXkoRnAuQllURVMsIDIgKiBGcC5CWVRFUykpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUG9pbnQgb2YgbGVuZ3RoICR7bGVufSB3YXMgaW52YWxpZC4gRXhwZWN0ZWQgJHtjb21wcmVzc2VkTGVufSBjb21wcmVzc2VkIGJ5dGVzIG9yICR7dW5jb21wcmVzc2VkTGVufSB1bmNvbXByZXNzZWQgYnl0ZXNgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBudW1Ub05CeXRlU3RyID0gKG51bSkgPT4gdXQuYnl0ZXNUb0hleCh1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCkpO1xuICAgIGZ1bmN0aW9uIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihudW1iZXIpIHtcbiAgICAgICAgY29uc3QgSEFMRiA9IENVUlZFX09SREVSID4+IF8xbjtcbiAgICAgICAgcmV0dXJuIG51bWJlciA+IEhBTEY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZVMocykge1xuICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHMpID8gbW9kTigtcykgOiBzO1xuICAgIH1cbiAgICAvLyBzbGljZSBieXRlcyBudW1cbiAgICBjb25zdCBzbGNOdW0gPSAoYiwgZnJvbSwgdG8pID0+IHV0LmJ5dGVzVG9OdW1iZXJCRShiLnNsaWNlKGZyb20sIHRvKSk7XG4gICAgLyoqXG4gICAgICogRUNEU0Egc2lnbmF0dXJlIHdpdGggaXRzIChyLCBzKSBwcm9wZXJ0aWVzLiBTdXBwb3J0cyBERVIgJiBjb21wYWN0IHJlcHJlc2VudGF0aW9ucy5cbiAgICAgKi9cbiAgICBjbGFzcyBTaWduYXR1cmUge1xuICAgICAgICBjb25zdHJ1Y3RvcihyLCBzLCByZWNvdmVyeSkge1xuICAgICAgICAgICAgdGhpcy5yID0gcjtcbiAgICAgICAgICAgIHRoaXMucyA9IHM7XG4gICAgICAgICAgICB0aGlzLnJlY292ZXJ5ID0gcmVjb3Zlcnk7XG4gICAgICAgICAgICB0aGlzLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFpciAoYnl0ZXMgb2YgciwgYnl0ZXMgb2YgcylcbiAgICAgICAgc3RhdGljIGZyb21Db21wYWN0KGhleCkge1xuICAgICAgICAgICAgY29uc3QgbCA9IENVUlZFLm5CeXRlTGVuZ3RoO1xuICAgICAgICAgICAgaGV4ID0gZW5zdXJlQnl0ZXMoJ2NvbXBhY3RTaWduYXR1cmUnLCBoZXgsIGwgKiAyKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHNsY051bShoZXgsIDAsIGwpLCBzbGNOdW0oaGV4LCBsLCAyICogbCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUiBlbmNvZGVkIEVDRFNBIHNpZ25hdHVyZVxuICAgICAgICAvLyBodHRwczovL2JpdGNvaW4uc3RhY2tleGNoYW5nZS5jb20vcXVlc3Rpb25zLzU3NjQ0L3doYXQtYXJlLXRoZS1wYXJ0cy1vZi1hLWJpdGNvaW4tdHJhbnNhY3Rpb24taW5wdXQtc2NyaXB0XG4gICAgICAgIHN0YXRpYyBmcm9tREVSKGhleCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzIH0gPSBERVIudG9TaWcoZW5zdXJlQnl0ZXMoJ0RFUicsIGhleCkpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgcyk7XG4gICAgICAgIH1cbiAgICAgICAgYXNzZXJ0VmFsaWRpdHkoKSB7XG4gICAgICAgICAgICAvLyBjYW4gdXNlIGFzc2VydEdFIGhlcmVcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKHRoaXMucikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyIG11c3QgYmUgMCA8IHIgPCBDVVJWRS5uJyk7XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncyBtdXN0IGJlIDAgPCBzIDwgQ1VSVkUubicpO1xuICAgICAgICB9XG4gICAgICAgIGFkZFJlY292ZXJ5Qml0KHJlY292ZXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIHRoaXMucywgcmVjb3ZlcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJlY292ZXJQdWJsaWNLZXkobXNnSGFzaCkge1xuICAgICAgICAgICAgY29uc3QgeyByLCBzLCByZWNvdmVyeTogcmVjIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4oZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKSk7IC8vIFRydW5jYXRlIGhhc2hcbiAgICAgICAgICAgIGlmIChyZWMgPT0gbnVsbCB8fCAhWzAsIDEsIDIsIDNdLmluY2x1ZGVzKHJlYykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNvdmVyeSBpZCBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCByYWRqID0gcmVjID09PSAyIHx8IHJlYyA9PT0gMyA/IHIgKyBDVVJWRS5uIDogcjtcbiAgICAgICAgICAgIGlmIChyYWRqID49IEZwLk9SREVSKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgMiBvciAzIGludmFsaWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZWZpeCA9IChyZWMgJiAxKSA9PT0gMCA/ICcwMicgOiAnMDMnO1xuICAgICAgICAgICAgY29uc3QgUiA9IFBvaW50LmZyb21IZXgocHJlZml4ICsgbnVtVG9OQnl0ZVN0cihyYWRqKSk7XG4gICAgICAgICAgICBjb25zdCBpciA9IGludk4ocmFkaik7IC8vIHJeLTFcbiAgICAgICAgICAgIGNvbnN0IHUxID0gbW9kTigtaCAqIGlyKTsgLy8gLWhyXi0xXG4gICAgICAgICAgICBjb25zdCB1MiA9IG1vZE4ocyAqIGlyKTsgLy8gc3JeLTFcbiAgICAgICAgICAgIGNvbnN0IFEgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFIsIHUxLCB1Mik7IC8vIChzcl4tMSlSLShocl4tMSlHID0gLShocl4tMSlHICsgKHNyXi0xKVxuICAgICAgICAgICAgaWYgKCFRKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncG9pbnQgYXQgaW5maW5pZnknKTsgLy8gdW5zYWZlIGlzIGZpbmU6IG5vIHByaXYgZGF0YSBsZWFrZWRcbiAgICAgICAgICAgIFEuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiBRO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNpZ25hdHVyZXMgc2hvdWxkIGJlIGxvdy1zLCB0byBwcmV2ZW50IG1hbGxlYWJpbGl0eS5cbiAgICAgICAgaGFzSGlnaFMoKSB7XG4gICAgICAgICAgICByZXR1cm4gaXNCaWdnZXJUaGFuSGFsZk9yZGVyKHRoaXMucyk7XG4gICAgICAgIH1cbiAgICAgICAgbm9ybWFsaXplUygpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhhc0hpZ2hTKCkgPyBuZXcgU2lnbmF0dXJlKHRoaXMuciwgbW9kTigtdGhpcy5zKSwgdGhpcy5yZWNvdmVyeSkgOiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIC8vIERFUi1lbmNvZGVkXG4gICAgICAgIHRvREVSUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvREVSSGV4KCkpO1xuICAgICAgICB9XG4gICAgICAgIHRvREVSSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIERFUi5oZXhGcm9tU2lnKHsgcjogdGhpcy5yLCBzOiB0aGlzLnMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGFkZGVkIGJ5dGVzIG9mIHIsIHRoZW4gcGFkZGVkIGJ5dGVzIG9mIHNcbiAgICAgICAgdG9Db21wYWN0UmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdXQuaGV4VG9CeXRlcyh0aGlzLnRvQ29tcGFjdEhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0NvbXBhY3RIZXgoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtVG9OQnl0ZVN0cih0aGlzLnIpICsgbnVtVG9OQnl0ZVN0cih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBpc1ZhbGlkUHJpdmF0ZUtleShwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXI6IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBQcm9kdWNlcyBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHJpdmF0ZSBrZXkgZnJvbSByYW5kb20gb2Ygc2l6ZSAobkJpdExlbmd0aCs2NClcbiAgICAgICAgICogYXMgcGVyIEZJUFMgMTg2IEIuNC4xIHdpdGggbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlibGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByYW5kID0gQ1VSVkUucmFuZG9tQnl0ZXMoRnAuQllURVMgKyA4KTtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9IG1vZC5oYXNoVG9Qcml2YXRlU2NhbGFyKHJhbmQsIENVUlZFX09SREVSKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IGl0ZW0gaW5zdGFuY2VvZiBVaW50OEFycmF5O1xuICAgICAgICBjb25zdCBzdHIgPSB0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGNvbnN0IGxlbiA9IChhcnIgfHwgc3RyKSAmJiBpdGVtLmxlbmd0aDtcbiAgICAgICAgaWYgKGFycilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IGNvbXByZXNzZWRMZW4gfHwgbGVuID09PSB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChzdHIpXG4gICAgICAgICAgICByZXR1cm4gbGVuID09PSAyICogY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IDIgKiB1bmNvbXByZXNzZWRMZW47XG4gICAgICAgIGlmIChpdGVtIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFQ0RIIChFbGxpcHRpYyBDdXJ2ZSBEaWZmaWUgSGVsbG1hbikuXG4gICAgICogQ29tcHV0ZXMgc2hhcmVkIHB1YmxpYyBrZXkgZnJvbSBwcml2YXRlIGtleSBhbmQgcHVibGljIGtleS5cbiAgICAgKiBDaGVja3M6IDEpIHByaXZhdGUga2V5IHZhbGlkaXR5IDIpIHNoYXJlZCBrZXkgaXMgb24tY3VydmUuXG4gICAgICogRG9lcyBOT1QgaGFzaCB0aGUgcmVzdWx0LlxuICAgICAqIEBwYXJhbSBwcml2YXRlQSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBwdWJsaWNCIGRpZmZlcmVudCBwdWJsaWMga2V5XG4gICAgICogQHBhcmFtIGlzQ29tcHJlc3NlZCB3aGV0aGVyIHRvIHJldHVybiBjb21wYWN0IChkZWZhdWx0KSwgb3IgZnVsbCBrZXlcbiAgICAgKiBAcmV0dXJucyBzaGFyZWQgcHVibGljIGtleVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFNoYXJlZFNlY3JldChwcml2YXRlQSwgcHVibGljQiwgaXNDb21wcmVzc2VkID0gdHJ1ZSkge1xuICAgICAgICBpZiAoaXNQcm9iUHViKHByaXZhdGVBKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJnIG11c3QgYmUgcHJpdmF0ZSBrZXknKTtcbiAgICAgICAgaWYgKCFpc1Byb2JQdWIocHVibGljQikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NlY29uZCBhcmcgbXVzdCBiZSBwdWJsaWMga2V5Jyk7XG4gICAgICAgIGNvbnN0IGIgPSBQb2ludC5mcm9tSGV4KHB1YmxpY0IpOyAvLyBjaGVjayBmb3IgYmVpbmcgb24tY3VydmVcbiAgICAgICAgcmV0dXJuIGIubXVsdGlwbHkobm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlQSkpLnRvUmF3Qnl0ZXMoaXNDb21wcmVzc2VkKTtcbiAgICB9XG4gICAgLy8gUkZDNjk3OTogZW5zdXJlIEVDRFNBIG1zZyBpcyBYIGJ5dGVzIGFuZCA8IE4uIFJGQyBzdWdnZXN0cyBvcHRpb25hbCB0cnVuY2F0aW5nIHZpYSBiaXRzMm9jdGV0cy5cbiAgICAvLyBGSVBTIDE4Ni00IDQuNiBzdWdnZXN0cyB0aGUgbGVmdG1vc3QgbWluKG5CaXRMZW4sIG91dExlbikgYml0cywgd2hpY2ggbWF0Y2hlcyBiaXRzMmludC5cbiAgICAvLyBiaXRzMmludCBjYW4gcHJvZHVjZSByZXM+Tiwgd2UgY2FuIGRvIG1vZChyZXMsIE4pIHNpbmNlIHRoZSBiaXRMZW4gaXMgdGhlIHNhbWUuXG4gICAgLy8gaW50Mm9jdGV0cyBjYW4ndCBiZSB1c2VkOyBwYWRzIHNtYWxsIG1zZ3Mgd2l0aCAwOiB1bmFjY2VwdGF0YmxlIGZvciB0cnVuYyBhcyBwZXIgUkZDIHZlY3RvcnNcbiAgICBjb25zdCBiaXRzMmludCA9IENVUlZFLmJpdHMyaW50IHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgLy8gRm9yIGN1cnZlcyB3aXRoIG5CaXRMZW5ndGggJSA4ICE9PSAwOiBiaXRzMm9jdGV0cyhiaXRzMm9jdGV0cyhtKSkgIT09IGJpdHMyb2N0ZXRzKG0pXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBjYXNlcywgc2luY2UgYnl0ZXMubGVuZ3RoICogOCBpcyBub3QgYWN0dWFsIGJpdExlbmd0aC5cbiAgICAgICAgICAgIGNvbnN0IG51bSA9IHV0LmJ5dGVzVG9OdW1iZXJCRShieXRlcyk7IC8vIGNoZWNrIGZvciA9PSB1OCBkb25lIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gYnl0ZXMubGVuZ3RoICogOCAtIENVUlZFLm5CaXRMZW5ndGg7IC8vIHRydW5jYXRlIHRvIG5CaXRMZW5ndGggbGVmdG1vc3QgYml0c1xuICAgICAgICAgICAgcmV0dXJuIGRlbHRhID4gMCA/IG51bSA+PiBCaWdJbnQoZGVsdGEpIDogbnVtO1xuICAgICAgICB9O1xuICAgIGNvbnN0IGJpdHMyaW50X21vZE4gPSBDVVJWRS5iaXRzMmludF9tb2ROIHx8XG4gICAgICAgIGZ1bmN0aW9uIChieXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIG1vZE4oYml0czJpbnQoYnl0ZXMpKTsgLy8gY2FuJ3QgdXNlIGJ5dGVzVG9OdW1iZXJCRSBoZXJlXG4gICAgICAgIH07XG4gICAgLy8gTk9URTogcGFkcyBvdXRwdXQgd2l0aCB6ZXJvIGFzIHBlciBzcGVjXG4gICAgY29uc3QgT1JERVJfTUFTSyA9IHV0LmJpdE1hc2soQ1VSVkUubkJpdExlbmd0aCk7XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdG8gYnl0ZXMuIENoZWNrcyBpZiBudW0gaW4gYFswLi5PUkRFUl9NQVNLLTFdYCBlLmcuOiBgWzAuLjJeMjU2LTFdYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnQyb2N0ZXRzKG51bSkge1xuICAgICAgICBpZiAodHlwZW9mIG51bSAhPT0gJ2JpZ2ludCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JpZ2ludCBleHBlY3RlZCcpO1xuICAgICAgICBpZiAoIShfMG4gPD0gbnVtICYmIG51bSA8IE9SREVSX01BU0spKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBiaWdpbnQgZXhwZWN0ZWQgPCAyXiR7Q1VSVkUubkJpdExlbmd0aH1gKTtcbiAgICAgICAgLy8gd29ya3Mgd2l0aCBvcmRlciwgY2FuIGhhdmUgZGlmZmVyZW50IHNpemUgdGhhbiBudW1Ub0ZpZWxkIVxuICAgICAgICByZXR1cm4gdXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpO1xuICAgIH1cbiAgICAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yXG4gICAgLy8gQ3JlYXRlcyBSRkM2OTc5IHNlZWQ7IGNvbnZlcnRzIG1zZy9wcml2S2V5IHRvIG51bWJlcnMuXG4gICAgLy8gVXNlZCBvbmx5IGluIHNpZ24sIG5vdCBpbiB2ZXJpZnkuXG4gICAgLy8gTk9URTogd2UgY2Fubm90IGFzc3VtZSBoZXJlIHRoYXQgbXNnSGFzaCBoYXMgc2FtZSBhbW91bnQgb2YgYnl0ZXMgYXMgY3VydmUgb3JkZXIsIHRoaXMgd2lsbCBiZSB3cm9uZyBhdCBsZWFzdCBmb3IgUDUyMS5cbiAgICAvLyBBbHNvIGl0IGNhbiBiZSBiaWdnZXIgZm9yIFAyMjQgKyBTSEEyNTZcbiAgICBmdW5jdGlvbiBwcmVwU2lnKG1zZ0hhc2gsIHByaXZhdGVLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBpZiAoWydyZWNvdmVyZWQnLCAnY2Fub25pY2FsJ10uc29tZSgoaykgPT4gayBpbiBvcHRzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbigpIGxlZ2FjeSBvcHRpb25zIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgY29uc3QgeyBoYXNoLCByYW5kb21CeXRlcyB9ID0gQ1VSVkU7XG4gICAgICAgIGxldCB7IGxvd1MsIHByZWhhc2gsIGV4dHJhRW50cm9weTogZW50IH0gPSBvcHRzOyAvLyBnZW5lcmF0ZXMgbG93LXMgc2lncyBieSBkZWZhdWx0XG4gICAgICAgIGlmIChsb3dTID09IG51bGwpXG4gICAgICAgICAgICBsb3dTID0gdHJ1ZTsgLy8gUkZDNjk3OSAzLjI6IHdlIHNraXAgc3RlcCBBLCBiZWNhdXNlIHdlIGFscmVhZHkgcHJvdmlkZSBoYXNoXG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBpZiAocHJlaGFzaClcbiAgICAgICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygncHJlaGFzaGVkIG1zZ0hhc2gnLCBoYXNoKG1zZ0hhc2gpKTtcbiAgICAgICAgLy8gV2UgY2FuJ3QgbGF0ZXIgY2FsbCBiaXRzMm9jdGV0cywgc2luY2UgbmVzdGVkIGJpdHMyaW50IGlzIGJyb2tlbiBmb3IgY3VydmVzXG4gICAgICAgIC8vIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDAuIEJlY2F1c2Ugb2YgdGhhdCwgd2UgdW53cmFwIGl0IGhlcmUgYXMgaW50Mm9jdGV0cyBjYWxsLlxuICAgICAgICAvLyBjb25zdCBiaXRzMm9jdGV0cyA9IChiaXRzKSA9PiBpbnQyb2N0ZXRzKGJpdHMyaW50X21vZE4oYml0cykpXG4gICAgICAgIGNvbnN0IGgxaW50ID0gYml0czJpbnRfbW9kTihtc2dIYXNoKTtcbiAgICAgICAgY29uc3QgZCA9IG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSk7IC8vIHZhbGlkYXRlIHByaXZhdGUga2V5LCBjb252ZXJ0IHRvIGJpZ2ludFxuICAgICAgICBjb25zdCBzZWVkQXJncyA9IFtpbnQyb2N0ZXRzKGQpLCBpbnQyb2N0ZXRzKGgxaW50KV07XG4gICAgICAgIC8vIGV4dHJhRW50cm9weS4gUkZDNjk3OSAzLjY6IGFkZGl0aW9uYWwgaycgKG9wdGlvbmFsKS5cbiAgICAgICAgaWYgKGVudCAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBLID0gSE1BQ19LKFYgfHwgMHgwMCB8fCBpbnQyb2N0ZXRzKHgpIHx8IGJpdHMyb2N0ZXRzKGgxKSB8fCBrJylcbiAgICAgICAgICAgIGNvbnN0IGUgPSBlbnQgPT09IHRydWUgPyByYW5kb21CeXRlcyhGcC5CWVRFUykgOiBlbnQ7IC8vIGdlbmVyYXRlIHJhbmRvbSBieXRlcyBPUiBwYXNzIGFzLWlzXG4gICAgICAgICAgICBzZWVkQXJncy5wdXNoKGVuc3VyZUJ5dGVzKCdleHRyYUVudHJvcHknLCBlLCBGcC5CWVRFUykpOyAvLyBjaGVjayBmb3IgYmVpbmcgb2Ygc2l6ZSBCWVRFU1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlZWQgPSB1dC5jb25jYXRCeXRlcyguLi5zZWVkQXJncyk7IC8vIFN0ZXAgRCBvZiBSRkM2OTc5IDMuMlxuICAgICAgICBjb25zdCBtID0gaDFpbnQ7IC8vIE5PVEU6IG5vIG5lZWQgdG8gY2FsbCBiaXRzMmludCBzZWNvbmQgdGltZSBoZXJlLCBpdCBpcyBpbnNpZGUgdHJ1bmNhdGVIYXNoIVxuICAgICAgICAvLyBDb252ZXJ0cyBzaWduYXR1cmUgcGFyYW1zIGludG8gcG9pbnQgdyByL3MsIGNoZWNrcyByZXN1bHQgZm9yIHZhbGlkaXR5LlxuICAgICAgICBmdW5jdGlvbiBrMnNpZyhrQnl0ZXMpIHtcbiAgICAgICAgICAgIC8vIFJGQyA2OTc5IFNlY3Rpb24gMy4yLCBzdGVwIDM6IGsgPSBiaXRzMmludChUKVxuICAgICAgICAgICAgY29uc3QgayA9IGJpdHMyaW50KGtCeXRlcyk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgICAgIGlmICghaXNXaXRoaW5DdXJ2ZU9yZGVyKGspKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSW1wb3J0YW50OiBhbGwgbW9kKCkgY2FsbHMgaGVyZSBtdXN0IGJlIGRvbmUgb3ZlciBOXG4gICAgICAgICAgICBjb25zdCBpayA9IGludk4oayk7IC8vIGteLTEgbW9kIG5cbiAgICAgICAgICAgIGNvbnN0IHEgPSBQb2ludC5CQVNFLm11bHRpcGx5KGspLnRvQWZmaW5lKCk7IC8vIHEgPSBHa1xuICAgICAgICAgICAgY29uc3QgciA9IG1vZE4ocS54KTsgLy8gciA9IHEueCBtb2QgblxuICAgICAgICAgICAgaWYgKHIgPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBDYW4gdXNlIHNjYWxhciBibGluZGluZyBiXi0xKGJtICsgYmRyKSB3aGVyZSBiIOKIiCBbMSxx4oiSMV0gYWNjb3JkaW5nIHRvXG4gICAgICAgICAgICAvLyBodHRwczovL3RjaGVzLmlhY3Iub3JnL2luZGV4LnBocC9UQ0hFUy9hcnRpY2xlL3ZpZXcvNzMzNy82NTA5LiBXZSd2ZSBkZWNpZGVkIGFnYWluc3QgaXQ6XG4gICAgICAgICAgICAvLyBhKSBkZXBlbmRlbmN5IG9uIENTUFJORyBiKSAxNSUgc2xvd2Rvd24gYykgZG9lc24ndCByZWFsbHkgaGVscCBzaW5jZSBiaWdpbnRzIGFyZSBub3QgQ1RcbiAgICAgICAgICAgIGNvbnN0IHMgPSBtb2ROKGlrICogbW9kTihtICsgciAqIGQpKTsgLy8gTm90IHVzaW5nIGJsaW5kaW5nIGhlcmVcbiAgICAgICAgICAgIGlmIChzID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHJlY292ZXJ5ID0gKHEueCA9PT0gciA/IDAgOiAyKSB8IE51bWJlcihxLnkgJiBfMW4pOyAvLyByZWNvdmVyeSBiaXQgKDIgb3IgMywgd2hlbiBxLnggPiBuKVxuICAgICAgICAgICAgbGV0IG5vcm1TID0gcztcbiAgICAgICAgICAgIGlmIChsb3dTICYmIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSkge1xuICAgICAgICAgICAgICAgIG5vcm1TID0gbm9ybWFsaXplUyhzKTsgLy8gaWYgbG93UyB3YXMgcGFzc2VkLCBlbnN1cmUgcyBpcyBhbHdheXNcbiAgICAgICAgICAgICAgICByZWNvdmVyeSBePSAxOyAvLyAvLyBpbiB0aGUgYm90dG9tIGhhbGYgb2YgTlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUociwgbm9ybVMsIHJlY292ZXJ5KTsgLy8gdXNlIG5vcm1TLCBub3Qgc1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNlZWQsIGsyc2lnIH07XG4gICAgfVxuICAgIGNvbnN0IGRlZmF1bHRTaWdPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIGNvbnN0IGRlZmF1bHRWZXJPcHRzID0geyBsb3dTOiBDVVJWRS5sb3dTLCBwcmVoYXNoOiBmYWxzZSB9O1xuICAgIC8qKlxuICAgICAqIFNpZ25zIG1lc3NhZ2UgaGFzaCB3aXRoIGEgcHJpdmF0ZSBrZXkuXG4gICAgICogYGBgXG4gICAgICogc2lnbihtLCBkLCBrKSB3aGVyZVxuICAgICAqICAgKHgsIHkpID0gRyDDlyBrXG4gICAgICogICByID0geCBtb2QgblxuICAgICAqICAgcyA9IChtICsgZHIpL2sgbW9kIG5cbiAgICAgKiBgYGBcbiAgICAgKiBAcGFyYW0gbXNnSGFzaCBOT1QgbWVzc2FnZS4gbXNnIG5lZWRzIHRvIGJlIGhhc2hlZCB0byBgbXNnSGFzaGAsIG9yIHVzZSBgcHJlaGFzaGAuXG4gICAgICogQHBhcmFtIHByaXZLZXkgcHJpdmF0ZSBrZXlcbiAgICAgKiBAcGFyYW0gb3B0cyBsb3dTIGZvciBub24tbWFsbGVhYmxlIHNpZ3MuIGV4dHJhRW50cm9weSBmb3IgbWl4aW5nIHJhbmRvbW5lc3MgaW50byBrLiBwcmVoYXNoIHdpbGwgaGFzaCBmaXJzdCBhcmcuXG4gICAgICogQHJldHVybnMgc2lnbmF0dXJlIHdpdGggcmVjb3ZlcnkgcGFyYW1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMgPSBkZWZhdWx0U2lnT3B0cykge1xuICAgICAgICBjb25zdCB7IHNlZWQsIGsyc2lnIH0gPSBwcmVwU2lnKG1zZ0hhc2gsIHByaXZLZXksIG9wdHMpOyAvLyBTdGVwcyBBLCBEIG9mIFJGQzY5NzkgMy4yLlxuICAgICAgICBjb25zdCBDID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IGRyYmcgPSB1dC5jcmVhdGVIbWFjRHJiZyhDLmhhc2gub3V0cHV0TGVuLCBDLm5CeXRlTGVuZ3RoLCBDLmhtYWMpO1xuICAgICAgICByZXR1cm4gZHJiZyhzZWVkLCBrMnNpZyk7IC8vIFN0ZXBzIEIsIEMsIEQsIEUsIEYsIEdcbiAgICB9XG4gICAgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIFBvaW50LkJBU0UuX3NldFdpbmRvd1NpemUoOCk7XG4gICAgLy8gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuQkFTRSlcbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgaGFzaCBhbmQgcHVibGljIGtleS5cbiAgICAgKiBSZWplY3RzIGxvd1Mgc2lnbmF0dXJlcyBieSBkZWZhdWx0OiB0byBvdmVycmlkZSxcbiAgICAgKiBzcGVjaWZ5IG9wdGlvbiBge2xvd1M6IGZhbHNlfWAuIEltcGxlbWVudHMgc2VjdGlvbiA0LjEuNCBmcm9tIGh0dHBzOi8vd3d3LnNlY2cub3JnL3NlYzEtdjIucGRmOlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogdmVyaWZ5KHIsIHMsIGgsIFApIHdoZXJlXG4gICAgICogICBVMSA9IGhzXi0xIG1vZCBuXG4gICAgICogICBVMiA9IHJzXi0xIG1vZCBuXG4gICAgICogICBSID0gVTHii4VHIC0gVTLii4VQXG4gICAgICogICBtb2QoUi54LCBuKSA9PSByXG4gICAgICogYGBgXG4gICAgICovXG4gICAgZnVuY3Rpb24gdmVyaWZ5KHNpZ25hdHVyZSwgbXNnSGFzaCwgcHVibGljS2V5LCBvcHRzID0gZGVmYXVsdFZlck9wdHMpIHtcbiAgICAgICAgY29uc3Qgc2cgPSBzaWduYXR1cmU7XG4gICAgICAgIG1zZ0hhc2ggPSBlbnN1cmVCeXRlcygnbXNnSGFzaCcsIG1zZ0hhc2gpO1xuICAgICAgICBwdWJsaWNLZXkgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5KTtcbiAgICAgICAgaWYgKCdzdHJpY3QnIGluIG9wdHMpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuc3RyaWN0IHdhcyByZW5hbWVkIHRvIGxvd1MnKTtcbiAgICAgICAgY29uc3QgeyBsb3dTLCBwcmVoYXNoIH0gPSBvcHRzO1xuICAgICAgICBsZXQgX3NpZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgbGV0IFA7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNnID09PSAnc3RyaW5nJyB8fCBzZyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIEZyb20gZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUtMTZcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIG9wdHMpIHtcbiAgICBtb2QudmFsaWRhdGVGaWVsZChGcCk7XG4gICAgaWYgKCFGcC5pc1ZhbGlkKG9wdHMuQSkgfHwgIUZwLmlzVmFsaWQob3B0cy5CKSB8fCAhRnAuaXNWYWxpZChvcHRzLlopKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcFRvQ3VydmVTaW1wbGVTV1U6IGludmFsaWQgb3B0cycpO1xuICAgIGNvbnN0IHNxcnRSYXRpbyA9IFNXVUZwU3FydFJhdGlvKEZwLCBvcHRzLlopO1xuICAgIGlmICghRnAuaXNPZGQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRnAuaXNPZGQgaXMgbm90IGltcGxlbWVudGVkIScpO1xuICAgIC8vIElucHV0OiB1LCBhbiBlbGVtZW50IG9mIEYuXG4gICAgLy8gT3V0cHV0OiAoeCwgeSksIGEgcG9pbnQgb24gRS5cbiAgICByZXR1cm4gKHUpID0+IHtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGxldCB0djEsIHR2MiwgdHYzLCB0djQsIHR2NSwgdHY2LCB4LCB5O1xuICAgICAgICB0djEgPSBGcC5zcXIodSk7IC8vIDEuICB0djEgPSB1XjJcbiAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgb3B0cy5aKTsgLy8gMi4gIHR2MSA9IFogKiB0djFcbiAgICAgICAgdHYyID0gRnAuc3FyKHR2MSk7IC8vIDMuICB0djIgPSB0djFeMlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djEpOyAvLyA0LiAgdHYyID0gdHYyICsgdHYxXG4gICAgICAgIHR2MyA9IEZwLmFkZCh0djIsIEZwLk9ORSk7IC8vIDUuICB0djMgPSB0djIgKyAxXG4gICAgICAgIHR2MyA9IEZwLm11bCh0djMsIG9wdHMuQik7IC8vIDYuICB0djMgPSBCICogdHYzXG4gICAgICAgIHR2NCA9IEZwLmNtb3Yob3B0cy5aLCBGcC5uZWcodHYyKSwgIUZwLmVxbCh0djIsIEZwLlpFUk8pKTsgLy8gNy4gIHR2NCA9IENNT1YoWiwgLXR2MiwgdHYyICE9IDApXG4gICAgICAgIHR2NCA9IEZwLm11bCh0djQsIG9wdHMuQSk7IC8vIDguICB0djQgPSBBICogdHY0XG4gICAgICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyA5LiAgdHYyID0gdHYzXjJcbiAgICAgICAgdHY2ID0gRnAuc3FyKHR2NCk7IC8vIDEwLiB0djYgPSB0djReMlxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkEpOyAvLyAxMS4gdHY1ID0gQSAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxMi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHR2MiA9IEZwLm11bCh0djIsIHR2Myk7IC8vIDEzLiB0djIgPSB0djIgKiB0djNcbiAgICAgICAgdHY2ID0gRnAubXVsKHR2NiwgdHY0KTsgLy8gMTQuIHR2NiA9IHR2NiAqIHR2NFxuICAgICAgICB0djUgPSBGcC5tdWwodHY2LCBvcHRzLkIpOyAvLyAxNS4gdHY1ID0gQiAqIHR2NlxuICAgICAgICB0djIgPSBGcC5hZGQodHYyLCB0djUpOyAvLyAxNi4gdHYyID0gdHYyICsgdHY1XG4gICAgICAgIHggPSBGcC5tdWwodHYxLCB0djMpOyAvLyAxNy4gICB4ID0gdHYxICogdHYzXG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWUgfSA9IHNxcnRSYXRpbyh0djIsIHR2Nik7IC8vIDE4LiAoaXNfZ3gxX3NxdWFyZSwgeTEpID0gc3FydF9yYXRpbyh0djIsIHR2NilcbiAgICAgICAgeSA9IEZwLm11bCh0djEsIHUpOyAvLyAxOS4gICB5ID0gdHYxICogdSAgLT4gWiAqIHVeMyAqIHkxXG4gICAgICAgIHkgPSBGcC5tdWwoeSwgdmFsdWUpOyAvLyAyMC4gICB5ID0geSAqIHkxXG4gICAgICAgIHggPSBGcC5jbW92KHgsIHR2MywgaXNWYWxpZCk7IC8vIDIxLiAgIHggPSBDTU9WKHgsIHR2MywgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgeSA9IEZwLmNtb3YoeSwgdmFsdWUsIGlzVmFsaWQpOyAvLyAyMi4gICB5ID0gQ01PVih5LCB5MSwgaXNfZ3gxX3NxdWFyZSlcbiAgICAgICAgY29uc3QgZTEgPSBGcC5pc09kZCh1KSA9PT0gRnAuaXNPZGQoeSk7IC8vIDIzLiAgZTEgPSBzZ24wKHUpID09IHNnbjAoeSlcbiAgICAgICAgeSA9IEZwLmNtb3YoRnAubmVnKHkpLCB5LCBlMSk7IC8vIDI0LiAgIHkgPSBDTU9WKC15LCB5LCBlMSlcbiAgICAgICAgeCA9IEZwLmRpdih4LCB0djQpOyAvLyAyNS4gICB4ID0geCAvIHR2NFxuICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdlaWVyc3RyYXNzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/ed25519.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/curves/esm/ed25519.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: function() { return /* binding */ ED25519_TORSION_SUBGROUP; },\n/* harmony export */   RistrettoPoint: function() { return /* binding */ RistrettoPoint; },\n/* harmony export */   ed25519: function() { return /* binding */ ed25519; },\n/* harmony export */   ed25519ctx: function() { return /* binding */ ed25519ctx; },\n/* harmony export */   ed25519ph: function() { return /* binding */ ed25519ph; },\n/* harmony export */   edwardsToMontgomery: function() { return /* binding */ edwardsToMontgomery; },\n/* harmony export */   edwardsToMontgomeryPriv: function() { return /* binding */ edwardsToMontgomeryPriv; },\n/* harmony export */   edwardsToMontgomeryPub: function() { return /* binding */ edwardsToMontgomeryPub; },\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   hash_to_ristretto255: function() { return /* binding */ hash_to_ristretto255; },\n/* harmony export */   x25519: function() { return /* binding */ x25519; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"./node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/edwards.js */ \"./node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"./node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(v * v * v, P); // v\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(v3 * v3 * v, P); // v\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(v * x * x, P); // vx\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(x, P))\n        x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.Field)(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1),\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_0__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n};\nconst ed25519 = (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nconst ed25519ctx = (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)({ ...ed25519Defaults, domain: ed25519_domain });\nconst ed25519ph = (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_2__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_0__.sha512,\n});\nconst x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_3__.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255,\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_0__.sha512,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_4__.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_5__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// https://datatracker.ietf.org/doc/draft-irtf-cfrg-hash-to-curve/14/\n// Appendix B.  Hashing to ristretto255\nconst hash_to_ristretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_6__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_0__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vZWQyNTUxOS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDOEI7QUFDckI7QUFDRDtBQUM2QjtBQUMwQjtBQUM5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixnQkFBZ0IsMERBQUksd0JBQXdCO0FBQzVDLGdCQUFnQiwwREFBSSx1QkFBdUI7QUFDM0MsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLHVCQUF1QiwwREFBSTtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBRyxnQkFBZ0I7QUFDbEMsZUFBZSx5REFBRyxrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLFlBQVkseURBQUcsbUJBQW1CO0FBQ2xDLGdCQUFnQix5REFBRyxnQkFBZ0I7QUFDbkMscUJBQXFCO0FBQ3JCLGtCQUFrQix5REFBRywwQkFBMEI7QUFDL0MsZ0NBQWdDO0FBQ2hDLDZCQUE2Qix5REFBRyxTQUFTO0FBQ3pDLDJCQUEyQix5REFBRywyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVEsa0VBQVk7QUFDcEIsWUFBWSx5REFBRztBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJEQUFLO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxnQkFBZ0Isb0VBQWM7QUFDckM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnRUFBVyxDQUFDLGdFQUFXO0FBQ2xDO0FBQ08sbUJBQW1CLG9FQUFjLEdBQUcsNENBQTRDO0FBQ2hGLGtCQUFrQixvRUFBYztBQUN2QztBQUNBO0FBQ0EsYUFBYSx3REFBTTtBQUNuQixDQUFDO0FBQ00sc0NBQXNDLG1FQUFVO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLGVBQWUseURBQUcsQ0FBQywwREFBSTtBQUN2QixLQUFLO0FBQ0w7QUFDQSxlQUFlO0FBQ2YsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQTtBQUNPLG9EQUFvRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELHNDQUFzQztBQUN0Qyx5Q0FBeUM7QUFDekMsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qiw0QkFBNEI7QUFDNUIsa0NBQWtDO0FBQ2xDLDhCQUE4QjtBQUM5QiwwQkFBMEI7QUFDMUIsK0JBQStCO0FBQy9CLG1DQUFtQztBQUNuQyw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLDRCQUE0QjtBQUM1QiwyQkFBMkI7QUFDM0IsdUJBQXVCO0FBQ3ZCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNEJBQTRCO0FBQzVCLG9DQUFvQztBQUNwQyw0QkFBNEI7QUFDNUIsb0NBQW9DO0FBQ3BDLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxnQ0FBZ0M7QUFDaEMsOEJBQThCO0FBQzlCLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsZ0NBQWdDO0FBQ2hDLHVCQUF1QjtBQUN2Qiw0QkFBNEI7QUFDNUIsK0JBQStCO0FBQy9CLG9DQUFvQztBQUNwQyxzQkFBc0I7QUFDdEIsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQixvQ0FBb0M7QUFDcEMsaUNBQWlDO0FBQ2pDLDBCQUEwQjtBQUMxQiwwQ0FBMEM7QUFDMUMsYUFBYSxzQ0FBc0M7QUFDbkQ7QUFDQSx3QkFBd0IsZ0VBQVUsOEJBQThCO0FBQ2hFO0FBQ0EsWUFBWSxxQkFBcUIseUNBQXlDO0FBQzFFO0FBQ0EsK0JBQStCO0FBQy9CLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0IsK0JBQStCO0FBQy9CLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUIsa0NBQWtDO0FBQ2xDLGtDQUFrQztBQUNsQyxpQ0FBaUM7QUFDakMsaUNBQWlDO0FBQ2pDLGlDQUFpQztBQUNqQywwQ0FBMEM7QUFDMUMsYUFBYSxnREFBZ0Q7QUFDN0Q7QUFDQSxtQ0FBbUMsd0VBQVk7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsbUVBQWU7QUFDN0U7QUFDQTtBQUNBO0FBQ0EsWUFBWSxJQUFJO0FBQ2hCO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsZ0RBQWdEO0FBQ2hELHdCQUF3QjtBQUN4Qiw2Q0FBNkM7QUFDN0MsVUFBVSxnQ0FBZ0Msa0JBQWtCO0FBQzVELDBCQUEwQjtBQUMxQixTQUFTLGtFQUFZO0FBQ3JCO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxlQUFlO0FBQ2Ysd0RBQXdEO0FBQ3hEO0FBQ0EsaUNBQWlDO0FBQ2pDLDRDQUE0QztBQUM1Qyw4QkFBOEI7QUFDOUIsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtEQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSw4REFBVSxDQUFDLG1FQUFlLGlCQUFpQixrRUFBWTtBQUNwRTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDLGdCQUFnQixvQkFBb0IsNkJBQTZCO0FBQ2pFLGdDQUFnQztBQUNoQyxvQ0FBb0M7QUFDcEMsbUNBQW1DO0FBQ25DLFlBQVksa0VBQVk7QUFDeEIseUJBQXlCO0FBQ3pCLGdDQUFnQztBQUNoQyw4QkFBOEI7QUFDOUIsd0JBQXdCLGtFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QjtBQUMzQztBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQiw4QkFBOEI7QUFDL0Qsc0NBQXNDO0FBQ3RDLHNDQUFzQztBQUN0Qyx1Q0FBdUM7QUFDdkMsZUFBZTtBQUNmLFlBQVksa0VBQVk7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxZQUFZLGtFQUFZO0FBQ3hCLHlCQUF5QjtBQUN6QixrQ0FBa0M7QUFDbEMsWUFBWSxrRUFBWTtBQUN4QjtBQUNBLGVBQWUsbUVBQWUsU0FBUztBQUN2QztBQUNBO0FBQ0EsZUFBZSw4REFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNPO0FBQ1A7QUFDQSx3Q0FBd0MsZ0VBQVc7QUFDbkQsMEJBQTBCLDhFQUFrQixlQUFlLHdEQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzP2Q2MDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGE1MTInO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgdHdpc3RlZEVkd2FyZHMgfSBmcm9tICcuL2Fic3RyYWN0L2Vkd2FyZHMuanMnO1xuaW1wb3J0IHsgbW9udGdvbWVyeSB9IGZyb20gJy4vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgRnBTcXJ0RXZlbiwgaXNOZWdhdGl2ZUxFLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKi9cbmNvbnN0IEVEMjU1MTlfUCA9IEJpZ0ludCgnNTc4OTYwNDQ2MTg2NTgwOTc3MTE3ODU0OTI1MDQzNDM5NTM5MjY2MzQ5OTIzMzI4MjAyODIwMTk3Mjg3OTIwMDM5NTY1NjQ4MTk5NDknKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IEVEMjU1MTlfU1FSVF9NMSA9IEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzVuID0gQmlnSW50KDUpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMTBuID0gQmlnSW50KDEwKSwgXzIwbiA9IEJpZ0ludCgyMCksIF80MG4gPSBCaWdJbnQoNDApLCBfODBuID0gQmlnSW50KDgwKTtcbmZ1bmN0aW9uIGVkMjU1MTlfcG93XzJfMjUyXzMoeCkge1xuICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgY29uc3QgeDIgPSAoeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGI0ID0gKHBvdzIoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuLCBQKSAqIHgpICUgUDsgLy8geF4zMVxuICAgIGNvbnN0IGIxMCA9IChwb3cyKGI1LCBfNW4sIFApICogYjUpICUgUDtcbiAgICBjb25zdCBiMjAgPSAocG93MihiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCBfMjBuLCBQKSAqIGIyMCkgJSBQO1xuICAgIGNvbnN0IGI4MCA9IChwb3cyKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcbiAgICBjb25zdCBiMTYwID0gKHBvdzIoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNDAgPSAocG93MihiMTYwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNTAgPSAocG93MihiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IHBvd19wXzVfOCA9IChwb3cyKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gICAgLy8gXiBUbyBwb3cgdG8gKHArMykvOCwgbXVsdGlwbHkgaXQgYnkgeC5cbiAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG59XG5mdW5jdGlvbiBhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykge1xuICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcbiAgICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgICBieXRlc1swXSAmPSAyNDg7IC8vIDBiMTExMV8xMDAwXG4gICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuICAgIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgLy8gc2V0IHRoZSBzZWNvbmQgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSB0byAxXG4gICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIHJldHVybiBieXRlcztcbn1cbi8vIHNxcnQodS92KVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB2MyA9IG1vZCh2ICogdiAqIHYsIFApOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9IG1vZCh2MyAqIHYzICogdiwgUCk7IC8vIHbigbdcbiAgICAvLyAocCszKS84IGFuZCAocC01KS84XG4gICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcbiAgICBsZXQgeCA9IG1vZCh1ICogdjMgKiBwb3csIFApOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBtb2QodiAqIHggKiB4LCBQKTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9IG1vZCh4ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3QgdXNlUm9vdDEgPSB2eDIgPT09IHU7IC8vIElmIHZ4wrIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSBtb2QoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImigtMSlcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgeCA9IG1vZCgteCwgUCk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59XG4vLyBKdXN0IGluIGNhc2VcbmV4cG9ydCBjb25zdCBFRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBbXG4gICAgJzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwMzdhJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjMDUnLFxuICAgICdlY2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwM2ZhJyxcbl07XG5jb25zdCBGcCA9IEZpZWxkKEVEMjU1MTlfUCwgdW5kZWZpbmVkLCB0cnVlKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IHtcbiAgICAvLyBQYXJhbTogYVxuICAgIGE6IEJpZ0ludCgtMSksXG4gICAgLy8gZCBpcyBlcXVhbCB0byAtMTIxNjY1LzEyMTY2NiBvdmVyIGZpbml0ZSBmaWVsZC5cbiAgICAvLyBOZWdhdGl2ZSBudW1iZXIgaXMgUCAtIG51bWJlciwgYW5kIGRpdmlzaW9uIGlzIGludmVydChudW1iZXIsIFApXG4gICAgZDogQmlnSW50KCczNzA5NTcwNTkzNDY2OTQzOTM0MzEzODA4MzUwODc1NDU2NTE4OTU0MjExMzg3OTg0MzIxOTAxNjM4ODc4NTUzMzA4NTk0MDI4MzU1NScpLFxuICAgIC8vIEZpbml0ZSBmaWVsZCDwnZS9cCBvdmVyIHdoaWNoIHdlJ2xsIGRvIGNhbGN1bGF0aW9uczsgMm4qKjI1NW4gLSAxOW5cbiAgICBGcCxcbiAgICAvLyBTdWJncm91cCBvcmRlcjogaG93IG1hbnkgcG9pbnRzIGN1cnZlIGhhc1xuICAgIC8vIDJuKioyNTJuICsgMjc3NDIzMTc3NzczNzIzNTM1MzU4NTE5Mzc3OTA4ODM2NDg0OTNuO1xuICAgIG46IEJpZ0ludCgnNzIzNzAwNTU3NzMzMjI2MjIxMzk3MzE4NjU2MzA0Mjk5NDI0MDg1NzExNjM1OTM3OTkwNzYwNjAwMTk1MDkzODI4NTQ1NDI1MDk4OScpLFxuICAgIC8vIENvZmFjdG9yXG4gICAgaDogQmlnSW50KDgpLFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCcxNTExMjIyMTM0OTUzNTQwMDc3MjUwMTE1MTQwOTU4ODUzMTUxMTQ1NDAxMjY5MzA0MTg1NzIwNjA0NjExMzI4Mzk0OTg0Nzc2MjIwMicpLFxuICAgIEd5OiBCaWdJbnQoJzQ2MzE2ODM1Njk0OTI2NDc4MTY5NDI4Mzk0MDAzNDc1MTYzMTQxMzA3OTkzODY2MjU2MjI1NjE1NzgzMDMzNjAzMTY1MjUxODU1OTYwJyksXG4gICAgaGFzaDogc2hhNTEyLFxuICAgIHJhbmRvbUJ5dGVzLFxuICAgIGFkanVzdFNjYWxhckJ5dGVzLFxuICAgIC8vIGRvbTJcbiAgICAvLyBSYXRpbyBvZiB1IHRvIHYuIEFsbG93cyB1cyB0byBjb21iaW5lIGludmVyc2lvbiBhbmQgc3F1YXJlIHJvb3QuIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgLy8gQ29uc3RhbnQtdGltZSwgdS/iiJp2XG4gICAgdXZSYXRpbyxcbn07XG5leHBvcnQgY29uc3QgZWQyNTUxOSA9IHR3aXN0ZWRFZHdhcmRzKGVkMjU1MTlEZWZhdWx0cyk7XG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhLCBjdHgsIHBoZmxhZykge1xuICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgaXMgdG9vIGJpZycpO1xuICAgIHJldHVybiBjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMnKSwgbmV3IFVpbnQ4QXJyYXkoW3BoZmxhZyA/IDEgOiAwLCBjdHgubGVuZ3RoXSksIGN0eCwgZGF0YSk7XG59XG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IHR3aXN0ZWRFZHdhcmRzKHsgLi4uZWQyNTUxOURlZmF1bHRzLCBkb21haW46IGVkMjU1MTlfZG9tYWluIH0pO1xuZXhwb3J0IGNvbnN0IGVkMjU1MTlwaCA9IHR3aXN0ZWRFZHdhcmRzKHtcbiAgICAuLi5lZDI1NTE5RGVmYXVsdHMsXG4gICAgZG9tYWluOiBlZDI1NTE5X2RvbWFpbixcbiAgICBwcmVoYXNoOiBzaGE1MTIsXG59KTtcbmV4cG9ydCBjb25zdCB4MjU1MTkgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1vbnRnb21lcnkoe1xuICAgIFA6IEVEMjU1MTlfUCxcbiAgICBhOiBCaWdJbnQoNDg2NjYyKSxcbiAgICBtb250Z29tZXJ5Qml0czogMjU1LFxuICAgIG5CeXRlTGVuZ3RoOiAzMixcbiAgICBHdTogQmlnSW50KDkpLFxuICAgIHBvd1BtaW51czI6ICh4KSA9PiB7XG4gICAgICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgICAgIC8vIHheKHAtMikgYWthIHheKDJeMjU1LTIxKVxuICAgICAgICBjb25zdCB7IHBvd19wXzVfOCwgYjIgfSA9IGVkMjU1MTlfcG93XzJfMjUyXzMoeCk7XG4gICAgICAgIHJldHVybiBtb2QocG93Mihwb3dfcF81XzgsIEJpZ0ludCgzKSwgUCkgKiBiMiwgUCk7XG4gICAgfSxcbiAgICBhZGp1c3RTY2FsYXJCeXRlcyxcbiAgICByYW5kb21CeXRlcyxcbn0pKSgpO1xuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHB1YmxpYyBrZXkgdG8geDI1NTE5IHB1YmxpYyBrZXkuIFVzZXMgZm9ybXVsYTpcbiAqICogYCh1LCB2KSA9ICgoMSt5KS8oMS15KSwgc3FydCgtNDg2NjY0KSp1L3gpYFxuICogKiBgKHgsIHkpID0gKHNxcnQoLTQ4NjY2NCkqdS92LCAodS0xKS8odSsxKSlgXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IGVkMjU1MTkuZ2V0UHVibGljS2V5KGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpKTtcbiAqICAgY29uc3QgYVByaXYgPSB4MjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGFQcml2LCBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKHNvbWVvbmVzUHViKSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQdWIoZWR3YXJkc1B1Yikge1xuICAgIGNvbnN0IHsgeSB9ID0gZWQyNTUxOS5FeHRlbmRlZFBvaW50LmZyb21IZXgoZWR3YXJkc1B1Yik7XG4gICAgY29uc3QgXzFuID0gQmlnSW50KDEpO1xuICAgIHJldHVybiBGcC50b0J5dGVzKEZwLmNyZWF0ZSgoXzFuICsgeSkgKiBGcC5pbnYoXzFuIC0geSkpKTtcbn1cbmV4cG9ydCBjb25zdCBlZHdhcmRzVG9Nb250Z29tZXJ5ID0gZWR3YXJkc1RvTW9udGdvbWVyeVB1YjsgLy8gZGVwcmVjYXRlZFxuLyoqXG4gKiBDb252ZXJ0cyBlZDI1NTE5IHNlY3JldCBrZXkgdG8geDI1NTE5IHNlY3JldCBrZXkuXG4gKiBAZXhhbXBsZVxuICogICBjb25zdCBzb21lb25lc1B1YiA9IHgyNTUxOS5nZXRQdWJsaWNLZXkoeDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gKiAgIGNvbnN0IGFQcml2ID0gZWQyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCk7XG4gKiAgIHgyNTUxOS5nZXRTaGFyZWRTZWNyZXQoZWR3YXJkc1RvTW9udGdvbWVyeVByaXYoYVByaXYpLCBzb21lb25lc1B1YilcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGVkd2FyZHNQcml2KSB7XG4gICAgY29uc3QgaGFzaGVkID0gZWQyNTUxOURlZmF1bHRzLmhhc2goZWR3YXJkc1ByaXYuc3ViYXJyYXkoMCwgMzIpKTtcbiAgICByZXR1cm4gZWQyNTUxOURlZmF1bHRzLmFkanVzdFNjYWxhckJ5dGVzKGhhc2hlZCkuc3ViYXJyYXkoMCwgMzIpO1xufVxuLy8gSGFzaCBUbyBDdXJ2ZSBFbGxpZ2F0b3IyIE1hcCAoTk9URTogZGlmZmVyZW50IGZyb20gcmlzdHJldHRvMjU1IGVsbGlnYXRvcilcbi8vIE5PVEU6IHZlcnkgaW1wb3J0YW50IHBhcnQgaXMgdXNhZ2Ugb2YgRnBTcXJ0RXZlbiBmb3IgRUxMMl9DMV9FRFdBUkRTLCBzaW5jZVxuLy8gU2FnZU1hdGggcmV0dXJucyBkaWZmZXJlbnQgcm9vdCBmaXJzdCBhbmQgZXZlcnl0aGluZyBmYWxscyBhcGFydFxuY29uc3QgRUxMMl9DMSA9IChGcC5PUkRFUiArIEJpZ0ludCgzKSkgLyBCaWdJbnQoOCk7IC8vIDEuIGMxID0gKHEgKyAzKSAvIDggICAgICAgIyBJbnRlZ2VyIGFyaXRobWV0aWNcbmNvbnN0IEVMTDJfQzIgPSBGcC5wb3coXzJuLCBFTEwyX0MxKTsgLy8gMi4gYzIgPSAyXmMxXG5jb25zdCBFTEwyX0MzID0gRnAuc3FydChGcC5uZWcoRnAuT05FKSk7IC8vIDMuIGMzID0gc3FydCgtMSlcbmNvbnN0IEVMTDJfQzQgPSAoRnAuT1JERVIgLSBCaWdJbnQoNSkpIC8gQmlnSW50KDgpOyAvLyA0LiBjNCA9IChxIC0gNSkgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0ogPSBCaWdJbnQoNDg2NjYyKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KSB7XG4gICAgbGV0IHR2MSA9IEZwLnNxcih1KTsgLy8gIDEuICB0djEgPSB1XjJcbiAgICB0djEgPSBGcC5tdWwodHYxLCBfMm4pOyAvLyAgMi4gIHR2MSA9IDIgKiB0djFcbiAgICBsZXQgeGQgPSBGcC5hZGQodHYxLCBGcC5PTkUpOyAvLyAgMy4gICB4ZCA9IHR2MSArIDEgICAgICAgICAjIE5vbnplcm86IC0xIGlzIHNxdWFyZSAobW9kIHApLCB0djEgaXMgbm90XG4gICAgbGV0IHgxbiA9IEZwLm5lZyhFTEwyX0opOyAvLyAgNC4gIHgxbiA9IC1KICAgICAgICAgICAgICAjIHgxID0geDFuIC8geGQgPSAtSiAvICgxICsgMiAqIHVeMilcbiAgICBsZXQgdHYyID0gRnAuc3FyKHhkKTsgLy8gIDUuICB0djIgPSB4ZF4yXG4gICAgbGV0IGd4ZCA9IEZwLm11bCh0djIsIHhkKTsgLy8gIDYuICBneGQgPSB0djIgKiB4ZCAgICAgICAgIyBneGQgPSB4ZF4zXG4gICAgbGV0IGd4MSA9IEZwLm11bCh0djEsIEVMTDJfSik7IC8vICA3LiAgZ3gxID0gSiAqIHR2MSAgICAgICAgICMgeDFuICsgSiAqIHhkXG4gICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDguICBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMiArIEogKiB4MW4gKiB4ZFxuICAgIGd4MSA9IEZwLmFkZChneDEsIHR2Mik7IC8vICA5LiAgZ3gxID0gZ3gxICsgdHYyICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGQgKyB4ZF4yXG4gICAgZ3gxID0gRnAubXVsKGd4MSwgeDFuKTsgLy8gIDEwLiBneDEgPSBneDEgKiB4MW4gICAgICAgIyB4MW5eMyArIEogKiB4MW5eMiAqIHhkICsgeDFuICogeGReMlxuICAgIGxldCB0djMgPSBGcC5zcXIoZ3hkKTsgLy8gIDExLiB0djMgPSBneGReMlxuICAgIHR2MiA9IEZwLnNxcih0djMpOyAvLyAgMTIuIHR2MiA9IHR2M14yICAgICAgICAgICAjIGd4ZF40XG4gICAgdHYzID0gRnAubXVsKHR2MywgZ3hkKTsgLy8gIDEzLiB0djMgPSB0djMgKiBneGQgICAgICAgIyBneGReM1xuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4MSk7IC8vICAxNC4gdHYzID0gdHYzICogZ3gxICAgICAgICMgZ3gxICogZ3hkXjNcbiAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAgMTUuIHR2MiA9IHR2MiAqIHR2MyAgICAgICAjIGd4MSAqIGd4ZF43XG4gICAgbGV0IHkxMSA9IEZwLnBvdyh0djIsIEVMTDJfQzQpOyAvLyAgMTYuIHkxMSA9IHR2Ml5jNCAgICAgICAgIyAoZ3gxICogZ3hkXjcpXigocCAtIDUpIC8gOClcbiAgICB5MTEgPSBGcC5tdWwoeTExLCB0djMpOyAvLyAgMTcuIHkxMSA9IHkxMSAqIHR2MyAgICAgICAjIGd4MSpneGReMyooZ3gxKmd4ZF43KV4oKHAtNSkvOClcbiAgICBsZXQgeTEyID0gRnAubXVsKHkxMSwgRUxMMl9DMyk7IC8vICAxOC4geTEyID0geTExICogYzNcbiAgICB0djIgPSBGcC5zcXIoeTExKTsgLy8gIDE5LiB0djIgPSB5MTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAyMC4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUxID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDIxLiAgZTEgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHkxID0gRnAuY21vdih5MTIsIHkxMSwgZTEpOyAvLyAgMjIuICB5MSA9IENNT1YoeTEyLCB5MTEsIGUxKSAgIyBJZiBnKHgxKSBpcyBzcXVhcmUsIHRoaXMgaXMgaXRzIHNxcnRcbiAgICBsZXQgeDJuID0gRnAubXVsKHgxbiwgdHYxKTsgLy8gIDIzLiB4Mm4gPSB4MW4gKiB0djEgICAgICAgIyB4MiA9IHgybiAvIHhkID0gMiAqIHVeMiAqIHgxbiAvIHhkXG4gICAgbGV0IHkyMSA9IEZwLm11bCh5MTEsIHUpOyAvLyAgMjQuIHkyMSA9IHkxMSAqIHVcbiAgICB5MjEgPSBGcC5tdWwoeTIxLCBFTEwyX0MyKTsgLy8gIDI1LiB5MjEgPSB5MjEgKiBjMlxuICAgIGxldCB5MjIgPSBGcC5tdWwoeTIxLCBFTEwyX0MzKTsgLy8gIDI2LiB5MjIgPSB5MjEgKiBjM1xuICAgIGxldCBneDIgPSBGcC5tdWwoZ3gxLCB0djEpOyAvLyAgMjcuIGd4MiA9IGd4MSAqIHR2MSAgICAgICAjIGcoeDIpID0gZ3gyIC8gZ3hkID0gMiAqIHVeMiAqIGcoeDEpXG4gICAgdHYyID0gRnAuc3FyKHkyMSk7IC8vICAyOC4gdHYyID0geTIxXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjkuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMiA9IEZwLmVxbCh0djIsIGd4Mik7IC8vICAzMC4gIGUyID0gdHYyID09IGd4MlxuICAgIGxldCB5MiA9IEZwLmNtb3YoeTIyLCB5MjEsIGUyKTsgLy8gIDMxLiAgeTIgPSBDTU9WKHkyMiwgeTIxLCBlMikgICMgSWYgZyh4MikgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgdHYyID0gRnAuc3FyKHkxKTsgLy8gIDMyLiB0djIgPSB5MV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDMzLiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTMgPSBGcC5lcWwodHYyLCBneDEpOyAvLyAgMzQuICBlMyA9IHR2MiA9PSBneDFcbiAgICBsZXQgeG4gPSBGcC5jbW92KHgybiwgeDFuLCBlMyk7IC8vICAzNS4gIHhuID0gQ01PVih4Mm4sIHgxbiwgZTMpICAjIElmIGUzLCB4ID0geDEsIGVsc2UgeCA9IHgyXG4gICAgbGV0IHkgPSBGcC5jbW92KHkyLCB5MSwgZTMpOyAvLyAgMzYuICAgeSA9IENNT1YoeTIsIHkxLCBlMykgICAgIyBJZiBlMywgeSA9IHkxLCBlbHNlIHkgPSB5MlxuICAgIGxldCBlNCA9IEZwLmlzT2RkKHkpOyAvLyAgMzcuICBlNCA9IHNnbjAoeSkgPT0gMSAgICAgICAgIyBGaXggc2lnbiBvZiB5XG4gICAgeSA9IEZwLmNtb3YoeSwgRnAubmVnKHkpLCBlMyAhPT0gZTQpOyAvLyAgMzguICAgeSA9IENNT1YoeSwgLXksIGUzIFhPUiBlNClcbiAgICByZXR1cm4geyB4TW46IHhuLCB4TWQ6IHhkLCB5TW46IHksIHlNZDogXzFuIH07IC8vICAzOS4gcmV0dXJuICh4biwgeGQsIHksIDEpXG59XG5jb25zdCBFTEwyX0MxX0VEV0FSRFMgPSBGcFNxcnRFdmVuKEZwLCBGcC5uZWcoQmlnSW50KDQ4NjY2NCkpKTsgLy8gc2duMChjMSkgTVVTVCBlcXVhbCAwXG5mdW5jdGlvbiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkodSkge1xuICAgIGNvbnN0IHsgeE1uLCB4TWQsIHlNbiwgeU1kIH0gPSBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpOyAvLyAgMS4gICh4TW4sIHhNZCwgeU1uLCB5TWQpID1cbiAgICAvLyBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9jdXJ2ZTI1NTE5KHUpXG4gICAgbGV0IHhuID0gRnAubXVsKHhNbiwgeU1kKTsgLy8gIDIuICB4biA9IHhNbiAqIHlNZFxuICAgIHhuID0gRnAubXVsKHhuLCBFTEwyX0MxX0VEV0FSRFMpOyAvLyAgMy4gIHhuID0geG4gKiBjMVxuICAgIGxldCB4ZCA9IEZwLm11bCh4TWQsIHlNbik7IC8vICA0LiAgeGQgPSB4TWQgKiB5TW4gICAgIyB4biAvIHhkID0gYzEgKiB4TSAvIHlNXG4gICAgbGV0IHluID0gRnAuc3ViKHhNbiwgeE1kKTsgLy8gIDUuICB5biA9IHhNbiAtIHhNZFxuICAgIGxldCB5ZCA9IEZwLmFkZCh4TW4sIHhNZCk7IC8vICA2LiAgeWQgPSB4TW4gKyB4TWQgICAgIyAobiAvIGQgLSAxKSAvIChuIC8gZCArIDEpID0gKG4gLSBkKSAvIChuICsgZClcbiAgICBsZXQgdHYxID0gRnAubXVsKHhkLCB5ZCk7IC8vICA3LiB0djEgPSB4ZCAqIHlkXG4gICAgbGV0IGUgPSBGcC5lcWwodHYxLCBGcC5aRVJPKTsgLy8gIDguICAgZSA9IHR2MSA9PSAwXG4gICAgeG4gPSBGcC5jbW92KHhuLCBGcC5aRVJPLCBlKTsgLy8gIDkuICB4biA9IENNT1YoeG4sIDAsIGUpXG4gICAgeGQgPSBGcC5jbW92KHhkLCBGcC5PTkUsIGUpOyAvLyAgMTAuIHhkID0gQ01PVih4ZCwgMSwgZSlcbiAgICB5biA9IEZwLmNtb3YoeW4sIEZwLk9ORSwgZSk7IC8vICAxMS4geW4gPSBDTU9WKHluLCAxLCBlKVxuICAgIHlkID0gRnAuY21vdih5ZCwgRnAuT05FLCBlKTsgLy8gIDEyLiB5ZCA9IENNT1YoeWQsIDEsIGUpXG4gICAgY29uc3QgaW52ID0gRnAuaW52ZXJ0QmF0Y2goW3hkLCB5ZF0pOyAvLyBiYXRjaCBkaXZpc2lvblxuICAgIHJldHVybiB7IHg6IEZwLm11bCh4biwgaW52WzBdKSwgeTogRnAubXVsKHluLCBpbnZbMV0pIH07IC8vICAxMy4gcmV0dXJuICh4biwgeGQsIHluLCB5ZClcbn1cbmNvbnN0IGh0ZiA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gY3JlYXRlSGFzaGVyKGVkMjU1MTkuRXh0ZW5kZWRQb2ludCwgKHNjYWxhcnMpID0+IG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2Vkd2FyZHMyNTUxOShzY2FsYXJzWzBdKSwge1xuICAgIERTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX1JPXycsXG4gICAgZW5jb2RlRFNUOiAnZWR3YXJkczI1NTE5X1hNRDpTSEEtNTEyX0VMTDJfTlVfJyxcbiAgICBwOiBGcC5PUkRFUixcbiAgICBtOiAxLFxuICAgIGs6IDEyOCxcbiAgICBleHBhbmQ6ICd4bWQnLFxuICAgIGhhc2g6IHNoYTUxMixcbn0pKSgpO1xuZXhwb3J0IGNvbnN0IGhhc2hUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuaGFzaFRvQ3VydmUpKCk7XG5leHBvcnQgY29uc3QgZW5jb2RlVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmVuY29kZVRvQ3VydmUpKCk7XG5mdW5jdGlvbiBhc3NlcnRSc3RQb2ludChvdGhlcikge1xuICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUmlzdFBvaW50KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSaXN0cmV0dG9Qb2ludCBleHBlY3RlZCcpO1xufVxuLy8g4oiaKC0xKSBha2Eg4oiaKGEpIGFrYSAyXigocC0xKS80KVxuY29uc3QgU1FSVF9NMSA9IEVEMjU1MTlfU1FSVF9NMTtcbi8vIOKImihhZCAtIDEpXG5jb25zdCBTUVJUX0FEX01JTlVTX09ORSA9IEJpZ0ludCgnMjUwNjMwNjg5NTMzODQ2MjM0NzQxMTE0MTQxNTg3MDIxNTI3MDEyNDQ1MzE1MDI0OTI2NTY0NjAwNzkyMTA0ODI2MTA0MzA3NTAyMzUnKTtcbi8vIDEgLyDiiJooYS1kKVxuY29uc3QgSU5WU1FSVF9BX01JTlVTX0QgPSBCaWdJbnQoJzU0NDY5MzA3MDA4OTA5MzE2OTIwOTk1ODEzODY4NzQ1MTQxNjA1MzkzNTk3MjkyOTI3NDU2OTIxMjA1MzEyODk2MzExNzIxMDE3NTc4Jyk7XG4vLyAxLWTCslxuY29uc3QgT05FX01JTlVTX0RfU1EgPSBCaWdJbnQoJzExNTk4NDMwMjE2Njg3Nzk4NzkxOTM3NzU1MjE4NTU1ODY2NDc5MzczNTc3NTk3MTU0MTc2NTQ0Mzk4Nzk3MjA4NzYxMTE4MDY4MzgnKTtcbi8vIChkLTEpwrJcbmNvbnN0IERfTUlOVVNfT05FX1NRID0gQmlnSW50KCc0MDQ0MDgzNDM0NjMwODUzNjg1ODEwMTA0MjQ2OTMyMzE5MDgyNjI0ODM5OTE0NjIzODcwODM1MjI0MDEzMzIyMDg2NTEzNzI2NTk1MicpO1xuLy8gQ2FsY3VsYXRlcyAxL+KImihudW1iZXIpXG5jb25zdCBpbnZlcnRTcXJ0ID0gKG51bWJlcikgPT4gdXZSYXRpbyhfMW4sIG51bWJlcik7XG5jb25zdCBNQVhfMjU1QiA9IEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmJyk7XG5jb25zdCBieXRlczI1NVRvTnVtYmVyTEUgPSAoYnl0ZXMpID0+IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlKGJ5dGVzVG9OdW1iZXJMRShieXRlcykgJiBNQVhfMjU1Qik7XG4vLyBDb21wdXRlcyBFbGxpZ2F0b3IgbWFwIGZvciBSaXN0cmV0dG9cbi8vIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG5mdW5jdGlvbiBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIwKSB7XG4gICAgY29uc3QgeyBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgIGNvbnN0IHIgPSBtb2QoU1FSVF9NMSAqIHIwICogcjApOyAvLyAxXG4gICAgY29uc3QgTnMgPSBtb2QoKHIgKyBfMW4pICogT05FX01JTlVTX0RfU1EpOyAvLyAyXG4gICAgbGV0IGMgPSBCaWdJbnQoLTEpOyAvLyAzXG4gICAgY29uc3QgRCA9IG1vZCgoYyAtIGQgKiByKSAqIG1vZChyICsgZCkpOyAvLyA0XG4gICAgbGV0IHsgaXNWYWxpZDogTnNfRF9pc19zcSwgdmFsdWU6IHMgfSA9IHV2UmF0aW8oTnMsIEQpOyAvLyA1XG4gICAgbGV0IHNfID0gbW9kKHMgKiByMCk7IC8vIDZcbiAgICBpZiAoIWlzTmVnYXRpdmVMRShzXywgUCkpXG4gICAgICAgIHNfID0gbW9kKC1zXyk7XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBzID0gc187IC8vIDdcbiAgICBpZiAoIU5zX0RfaXNfc3EpXG4gICAgICAgIGMgPSByOyAvLyA4XG4gICAgY29uc3QgTnQgPSBtb2QoYyAqIChyIC0gXzFuKSAqIERfTUlOVVNfT05FX1NRIC0gRCk7IC8vIDlcbiAgICBjb25zdCBzMiA9IHMgKiBzO1xuICAgIGNvbnN0IFcwID0gbW9kKChzICsgcykgKiBEKTsgLy8gMTBcbiAgICBjb25zdCBXMSA9IG1vZChOdCAqIFNRUlRfQURfTUlOVVNfT05FKTsgLy8gMTFcbiAgICBjb25zdCBXMiA9IG1vZChfMW4gLSBzMik7IC8vIDEyXG4gICAgY29uc3QgVzMgPSBtb2QoXzFuICsgczIpOyAvLyAxM1xuICAgIHJldHVybiBuZXcgZWQyNTUxOS5FeHRlbmRlZFBvaW50KG1vZChXMCAqIFczKSwgbW9kKFcyICogVzEpLCBtb2QoVzEgKiBXMyksIG1vZChXMCAqIFcyKSk7XG59XG4vKipcbiAqIEVhY2ggZWQyNTUxOS9FeHRlbmRlZFBvaW50IGhhcyA4IGRpZmZlcmVudCBlcXVpdmFsZW50IHBvaW50cy4gVGhpcyBjYW4gYmVcbiAqIGEgc291cmNlIG9mIGJ1Z3MgZm9yIHByb3RvY29scyBsaWtlIHJpbmcgc2lnbmF0dXJlcy4gUmlzdHJldHRvIHdhcyBjcmVhdGVkIHRvIHNvbHZlIHRoaXMuXG4gKiBSaXN0cmV0dG8gcG9pbnQgb3BlcmF0ZXMgaW4gWDpZOlo6VCBleHRlbmRlZCBjb29yZGluYXRlcyBsaWtlIEV4dGVuZGVkUG9pbnQsXG4gKiBidXQgaXQgc2hvdWxkIHdvcmsgaW4gaXRzIG93biBuYW1lc3BhY2U6IGRvIG5vdCBjb21iaW5lIHRob3NlIHR3by5cbiAqIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvZHJhZnQtaXJ0Zi1jZnJnLXJpc3RyZXR0bzI1NS1kZWNhZjQ0OFxuICovXG5jbGFzcyBSaXN0UG9pbnQge1xuICAgIC8vIFByaXZhdGUgcHJvcGVydHkgdG8gZGlzY291cmFnZSBjb21iaW5pbmcgRXh0ZW5kZWRQb2ludCArIFJpc3RyZXR0b1BvaW50XG4gICAgLy8gQWx3YXlzIHVzZSBSaXN0cmV0dG8gZW5jb2RpbmcvZGVjb2RpbmcgaW5zdGVhZC5cbiAgICBjb25zdHJ1Y3RvcihlcCkge1xuICAgICAgICB0aGlzLmVwID0gZXA7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQWZmaW5lKGFwKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tQWZmaW5lKGFwKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRha2VzIHVuaWZvcm0gb3V0cHV0IG9mIDY0LWJ5dGUgaGFzaCBmdW5jdGlvbiBsaWtlIHNoYTUxMiBhbmQgY29udmVydHMgaXQgdG8gYFJpc3RyZXR0b1BvaW50YC5cbiAgICAgKiBUaGUgaGFzaC10by1ncm91cCBvcGVyYXRpb24gYXBwbGllcyBFbGxpZ2F0b3IgdHdpY2UgYW5kIGFkZHMgdGhlIHJlc3VsdHMuXG4gICAgICogKipOb3RlOioqIHRoaXMgaXMgb25lLXdheSBtYXAsIHRoZXJlIGlzIG5vIGNvbnZlcnNpb24gZnJvbSBwb2ludCB0byBoYXNoLlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2VsbGlnYXRvci5odG1sXG4gICAgICogQHBhcmFtIGhleCA2NC1ieXRlIG91dHB1dCBvZiBhIGhhc2ggZnVuY3Rpb25cbiAgICAgKi9cbiAgICBzdGF0aWMgaGFzaFRvQ3VydmUoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IYXNoJywgaGV4LCA2NCk7XG4gICAgICAgIGNvbnN0IHIxID0gYnl0ZXMyNTVUb051bWJlckxFKGhleC5zbGljZSgwLCAzMikpO1xuICAgICAgICBjb25zdCBSMSA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjEpO1xuICAgICAgICBjb25zdCByMiA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMzIsIDY0KSk7XG4gICAgICAgIGNvbnN0IFIyID0gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KFIxLmFkZChSMikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyByaXN0cmV0dG8tZW5jb2RlZCBzdHJpbmcgdG8gcmlzdHJldHRvIHBvaW50LlxuICAgICAqIGh0dHBzOi8vcmlzdHJldHRvLmdyb3VwL2Zvcm11bGFzL2RlY29kaW5nLmh0bWxcbiAgICAgKiBAcGFyYW0gaGV4IFJpc3RyZXR0by1lbmNvZGVkIDMyIGJ5dGVzLiBOb3QgZXZlcnkgMzItYnl0ZSBzdHJpbmcgaXMgdmFsaWQgcmlzdHJldHRvIGVuY29kaW5nXG4gICAgICovXG4gICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdyaXN0cmV0dG9IZXgnLCBoZXgsIDMyKTtcbiAgICAgICAgY29uc3QgeyBhLCBkIH0gPSBlZDI1NTE5LkNVUlZFO1xuICAgICAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IGVtc2cgPSAnUmlzdHJldHRvUG9pbnQuZnJvbUhleDogdGhlIGhleCBpcyBub3QgdmFsaWQgZW5jb2Rpbmcgb2YgUmlzdHJldHRvUG9pbnQnO1xuICAgICAgICBjb25zdCBzID0gYnl0ZXMyNTVUb051bWJlckxFKGhleCk7XG4gICAgICAgIC8vIDEuIENoZWNrIHRoYXQgc19ieXRlcyBpcyB0aGUgY2Fub25pY2FsIGVuY29kaW5nIG9mIGEgZmllbGQgZWxlbWVudCwgb3IgZWxzZSBhYm9ydC5cbiAgICAgICAgLy8gMy4gQ2hlY2sgdGhhdCBzIGlzIG5vbi1uZWdhdGl2ZSwgb3IgZWxzZSBhYm9ydFxuICAgICAgICBpZiAoIWVxdWFsQnl0ZXMobnVtYmVyVG9CeXRlc0xFKHMsIDMyKSwgaGV4KSB8fCBpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIGNvbnN0IHMyID0gbW9kKHMgKiBzKTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QoXzFuICsgYSAqIHMyKTsgLy8gNCAoYSBpcyAtMSlcbiAgICAgICAgY29uc3QgdTIgPSBtb2QoXzFuIC0gYSAqIHMyKTsgLy8gNVxuICAgICAgICBjb25zdCB1MV8yID0gbW9kKHUxICogdTEpO1xuICAgICAgICBjb25zdCB1Ml8yID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB2ID0gbW9kKGEgKiBkICogdTFfMiAtIHUyXzIpOyAvLyA2XG4gICAgICAgIGNvbnN0IHsgaXNWYWxpZCwgdmFsdWU6IEkgfSA9IGludmVydFNxcnQobW9kKHYgKiB1Ml8yKSk7IC8vIDdcbiAgICAgICAgY29uc3QgRHggPSBtb2QoSSAqIHUyKTsgLy8gOFxuICAgICAgICBjb25zdCBEeSA9IG1vZChJICogRHggKiB2KTsgLy8gOVxuICAgICAgICBsZXQgeCA9IG1vZCgocyArIHMpICogRHgpOyAvLyAxMFxuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHgsIFApKVxuICAgICAgICAgICAgeCA9IG1vZCgteCk7IC8vIDEwXG4gICAgICAgIGNvbnN0IHkgPSBtb2QodTEgKiBEeSk7IC8vIDExXG4gICAgICAgIGNvbnN0IHQgPSBtb2QoeCAqIHkpOyAvLyAxMlxuICAgICAgICBpZiAoIWlzVmFsaWQgfHwgaXNOZWdhdGl2ZUxFKHQsIFApIHx8IHkgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbXNnKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQobmV3IGVkMjU1MTkuRXh0ZW5kZWRQb2ludCh4LCB5LCBfMW4sIHQpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlcyByaXN0cmV0dG8gcG9pbnQgdG8gVWludDhBcnJheS5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbmNvZGluZy5odG1sXG4gICAgICovXG4gICAgdG9SYXdCeXRlcygpIHtcbiAgICAgICAgbGV0IHsgZXg6IHgsIGV5OiB5LCBlejogeiwgZXQ6IHQgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IFAgPSBlZDI1NTE5LkNVUlZFLkZwLk9SREVSO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgY29uc3QgdTEgPSBtb2QobW9kKHogKyB5KSAqIG1vZCh6IC0geSkpOyAvLyAxXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKHggKiB5KTsgLy8gMlxuICAgICAgICAvLyBTcXVhcmUgcm9vdCBhbHdheXMgZXhpc3RzXG4gICAgICAgIGNvbnN0IHUyc3EgPSBtb2QodTIgKiB1Mik7XG4gICAgICAgIGNvbnN0IHsgdmFsdWU6IGludnNxcnQgfSA9IGludmVydFNxcnQobW9kKHUxICogdTJzcSkpOyAvLyAzXG4gICAgICAgIGNvbnN0IEQxID0gbW9kKGludnNxcnQgKiB1MSk7IC8vIDRcbiAgICAgICAgY29uc3QgRDIgPSBtb2QoaW52c3FydCAqIHUyKTsgLy8gNVxuICAgICAgICBjb25zdCB6SW52ID0gbW9kKEQxICogRDIgKiB0KTsgLy8gNlxuICAgICAgICBsZXQgRDsgLy8gN1xuICAgICAgICBpZiAoaXNOZWdhdGl2ZUxFKHQgKiB6SW52LCBQKSkge1xuICAgICAgICAgICAgbGV0IF94ID0gbW9kKHkgKiBTUVJUX00xKTtcbiAgICAgICAgICAgIGxldCBfeSA9IG1vZCh4ICogU1FSVF9NMSk7XG4gICAgICAgICAgICB4ID0gX3g7XG4gICAgICAgICAgICB5ID0gX3k7XG4gICAgICAgICAgICBEID0gbW9kKEQxICogSU5WU1FSVF9BX01JTlVTX0QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgRCA9IEQyOyAvLyA4XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4ICogekludiwgUCkpXG4gICAgICAgICAgICB5ID0gbW9kKC15KTsgLy8gOVxuICAgICAgICBsZXQgcyA9IG1vZCgoeiAtIHkpICogRCk7IC8vIDEwIChjaGVjayBmb290ZXIncyBub3RlLCBubyBzcXJ0KC1hKSlcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRShzLCBQKSlcbiAgICAgICAgICAgIHMgPSBtb2QoLXMpO1xuICAgICAgICByZXR1cm4gbnVtYmVyVG9CeXRlc0xFKHMsIDMyKTsgLy8gMTFcbiAgICB9XG4gICAgdG9IZXgoKSB7XG4gICAgICAgIHJldHVybiBieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcygpKTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvSGV4KCk7XG4gICAgfVxuICAgIC8vIENvbXBhcmUgb25lIHBvaW50IHRvIGFub3RoZXIuXG4gICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSB9ID0gdGhpcy5lcDtcbiAgICAgICAgY29uc3QgeyBleDogWDIsIGV5OiBZMiB9ID0gb3RoZXIuZXA7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICAvLyAoeDEgKiB5MiA9PSB5MSAqIHgyKSB8ICh5MSAqIHkyID09IHgxICogeDIpXG4gICAgICAgIGNvbnN0IG9uZSA9IG1vZChYMSAqIFkyKSA9PT0gbW9kKFkxICogWDIpO1xuICAgICAgICBjb25zdCB0d28gPSBtb2QoWTEgKiBZMikgPT09IG1vZChYMSAqIFgyKTtcbiAgICAgICAgcmV0dXJuIG9uZSB8fCB0d287XG4gICAgfVxuICAgIGFkZChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuYWRkKG90aGVyLmVwKSk7XG4gICAgfVxuICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgIGFzc2VydFJzdFBvaW50KG90aGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5zdWJ0cmFjdChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSaXN0UG9pbnQodGhpcy5lcC5tdWx0aXBseShzY2FsYXIpKTtcbiAgICB9XG4gICAgbXVsdGlwbHlVbnNhZmUoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHlVbnNhZmUoc2NhbGFyKSk7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IFJpc3RyZXR0b1BvaW50ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gICAgaWYgKCFSaXN0UG9pbnQuQkFTRSlcbiAgICAgICAgUmlzdFBvaW50LkJBU0UgPSBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5CQVNFKTtcbiAgICBpZiAoIVJpc3RQb2ludC5aRVJPKVxuICAgICAgICBSaXN0UG9pbnQuWkVSTyA9IG5ldyBSaXN0UG9pbnQoZWQyNTUxOS5FeHRlbmRlZFBvaW50LlpFUk8pO1xuICAgIHJldHVybiBSaXN0UG9pbnQ7XG59KSgpO1xuLy8gaHR0cHM6Ly9kYXRhdHJhY2tlci5pZXRmLm9yZy9kb2MvZHJhZnQtaXJ0Zi1jZnJnLWhhc2gtdG8tY3VydmUvMTQvXG4vLyBBcHBlbmRpeCBCLiAgSGFzaGluZyB0byByaXN0cmV0dG8yNTVcbmV4cG9ydCBjb25zdCBoYXNoX3RvX3Jpc3RyZXR0bzI1NSA9IChtc2csIG9wdGlvbnMpID0+IHtcbiAgICBjb25zdCBkID0gb3B0aW9ucy5EU1Q7XG4gICAgY29uc3QgRFNUID0gdHlwZW9mIGQgPT09ICdzdHJpbmcnID8gdXRmOFRvQnl0ZXMoZCkgOiBkO1xuICAgIGNvbnN0IHVuaWZvcm1fYnl0ZXMgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIDY0LCBzaGE1MTIpO1xuICAgIGNvbnN0IFAgPSBSaXN0UG9pbnQuaGFzaFRvQ3VydmUodW5pZm9ybV9ieXRlcyk7XG4gICAgcmV0dXJuIFA7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWQyNTUxOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/ed25519.js\n"));

/***/ }),

/***/ "./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"./node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"./node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/modular.js */ \"./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/utils.js */ \"./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_shortw_utils.js */ \"./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_6__.createCurve)({\n    a: BigInt(0),\n    b: BigInt(7),\n    Fp,\n    n: secp256k1N,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1),\n    lowS: true,\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x  p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_4__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_3__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_0__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vc2VjcDI1NmsxLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDSTtBQUNPO0FBQ087QUFDaUM7QUFDMUI7QUFDdEI7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLGtDQUFrQztBQUNsQyxnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGtCQUFrQiwwREFBSTtBQUN0QixnQkFBZ0IsMERBQUk7QUFDcEIsZ0JBQWdCLDBEQUFJO0FBQ3BCLGlCQUFpQiwwREFBSTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkRBQUsscUNBQXFDLGVBQWU7QUFDN0Qsa0JBQWtCLDZEQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQix5REFBRztBQUN4QixxQkFBcUIseURBQUc7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLFNBQVM7QUFDVCxLQUFLO0FBQ0wsQ0FBQyxFQUFFLHdEQUFNO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsNERBQU07QUFDM0IsZUFBZSwrREFBVztBQUMxQjtBQUNBO0FBQ0EsV0FBVyw0REFBTSxDQUFDLCtEQUFXO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtRUFBZTtBQUN2QyxvQkFBb0IseURBQUc7QUFDdkIsb0JBQW9CLHlEQUFHO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNELHNDQUFzQyxhQUFhO0FBQ25EO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0Esd0NBQXdDO0FBQ3hDLHdCQUF3QjtBQUN4QjtBQUNBLHNCQUFzQjtBQUN0QixvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdFQUFXO0FBQy9ELGNBQWMsK0RBQVc7QUFDekIsWUFBWSx1QkFBdUIsbUNBQW1DO0FBQ3RFLGNBQWMsK0RBQVcsMEJBQTBCO0FBQ25ELDJCQUEyQixtRUFBZSxpQ0FBaUM7QUFDM0Usd0RBQXdEO0FBQ3hELG9CQUFvQixtRUFBZSxTQUFTO0FBQzVDO0FBQ0EsbURBQW1EO0FBQ25ELFlBQVksdUJBQXVCLDJCQUEyQjtBQUM5RCxvQ0FBb0M7QUFDcEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrREFBVztBQUMzQixjQUFjLCtEQUFXO0FBQ3pCLGdCQUFnQiwrREFBVztBQUMzQjtBQUNBLHlCQUF5QixtRUFBZSxRQUFRLHdCQUF3QjtBQUN4RSxrQkFBa0IsbUVBQWUsdUJBQXVCLDJCQUEyQjtBQUNuRjtBQUNBO0FBQ0Esa0JBQWtCLG1FQUFlLHdCQUF3Qiw0QkFBNEI7QUFDckY7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RCwyQ0FBMkM7QUFDM0M7QUFDQSwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLHVCQUF1QjtBQUN2QjtBQUNBLFdBQVc7QUFDWCxLQUFLO0FBQ0wsQ0FBQztBQUNELHNDQUFzQyxzRUFBVTtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyw2RUFBbUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELG1DQUFtQyx3RUFBWTtBQUMvQyxZQUFZLE9BQU87QUFDbkI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSx3REFBTTtBQUNoQixDQUFDO0FBQ007QUFDQTtBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanM/NTQ3OCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgRmllbGQsIG1vZCwgcG93MiB9IGZyb20gJy4vYWJzdHJhY3QvbW9kdWxhci5qcyc7XG5pbXBvcnQgeyBtYXBUb0N1cnZlU2ltcGxlU1dVIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG5pbXBvcnQgeyBieXRlc1RvTnVtYmVyQkUsIGNvbmNhdEJ5dGVzLCBlbnN1cmVCeXRlcywgbnVtYmVyVG9CeXRlc0JFIH0gZnJvbSAnLi9hYnN0cmFjdC91dGlscy5qcyc7XG5pbXBvcnQgeyBjcmVhdGVIYXNoZXIsIGlzb2dlbnlNYXAgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuaW1wb3J0IHsgY3JlYXRlQ3VydmUgfSBmcm9tICcuL19zaG9ydHdfdXRpbHMuanMnO1xuY29uc3Qgc2VjcDI1NmsxUCA9IEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZWZmZmZmYzJmJyk7XG5jb25zdCBzZWNwMjU2azFOID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDEnKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IGRpdk5lYXJlc3QgPSAoYSwgYikgPT4gKGEgKyBiIC8gXzJuKSAvIGI7XG4vKipcbiAqIOKImm4gPSBuXigocCsxKS80KSBmb3IgZmllbGRzIHAgPSAzIG1vZCA0LiBXZSB1bndyYXAgdGhlIGxvb3AgYW5kIG11bHRpcGx5IGJpdC1ieS1iaXQuXG4gKiAoUCsxbi80bikudG9TdHJpbmcoMikgd291bGQgcHJvZHVjZSBiaXRzIFsyMjN4IDEsIDAsIDIyeCAxLCA0eCAwLCAxMSwgMDBdXG4gKi9cbmZ1bmN0aW9uIHNxcnRNb2QoeSkge1xuICAgIGNvbnN0IFAgPSBzZWNwMjU2azFQO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGNvbnN0IF8zbiA9IEJpZ0ludCgzKSwgXzZuID0gQmlnSW50KDYpLCBfMTFuID0gQmlnSW50KDExKSwgXzIybiA9IEJpZ0ludCgyMik7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzIzbiA9IEJpZ0ludCgyMyksIF80NG4gPSBCaWdJbnQoNDQpLCBfODhuID0gQmlnSW50KDg4KTtcbiAgICBjb25zdCBiMiA9ICh5ICogeSAqIHkpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGIzID0gKGIyICogYjIgKiB5KSAlIFA7IC8vIHheN1xuICAgIGNvbnN0IGI2ID0gKHBvdzIoYjMsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGI5ID0gKHBvdzIoYjYsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IGIxMSA9IChwb3cyKGI5LCBfMm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCBiMjIgPSAocG93MihiMTEsIF8xMW4sIFApICogYjExKSAlIFA7XG4gICAgY29uc3QgYjQ0ID0gKHBvdzIoYjIyLCBfMjJuLCBQKSAqIGIyMikgJSBQO1xuICAgIGNvbnN0IGI4OCA9IChwb3cyKGI0NCwgXzQ0biwgUCkgKiBiNDQpICUgUDtcbiAgICBjb25zdCBiMTc2ID0gKHBvdzIoYjg4LCBfODhuLCBQKSAqIGI4OCkgJSBQO1xuICAgIGNvbnN0IGIyMjAgPSAocG93MihiMTc2LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIyMjMgPSAocG93MihiMjIwLCBfM24sIFApICogYjMpICUgUDtcbiAgICBjb25zdCB0MSA9IChwb3cyKGIyMjMsIF8yM24sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgdDIgPSAocG93Mih0MSwgXzZuLCBQKSAqIGIyKSAlIFA7XG4gICAgY29uc3Qgcm9vdCA9IHBvdzIodDIsIF8ybiwgUCk7XG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCB5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmluZCBzcXVhcmUgcm9vdCcpO1xuICAgIHJldHVybiByb290O1xufVxuY29uc3QgRnAgPSBGaWVsZChzZWNwMjU2azFQLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgeyBzcXJ0OiBzcXJ0TW9kIH0pO1xuZXhwb3J0IGNvbnN0IHNlY3AyNTZrMSA9IGNyZWF0ZUN1cnZlKHtcbiAgICBhOiBCaWdJbnQoMCksXG4gICAgYjogQmlnSW50KDcpLFxuICAgIEZwLFxuICAgIG46IHNlY3AyNTZrMU4sXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzU1MDY2MjYzMDIyMjc3MzQzNjY5NTc4NzE4ODk1MTY4NTM0MzI2MjUwNjAzNDUzNzc3NTk0MTc1NTAwMTg3MzYwMzg5MTE2NzI5MjQwJyksXG4gICAgR3k6IEJpZ0ludCgnMzI2NzA1MTAwMjA3NTg4MTY5NzgwODMwODUxMzA1MDcwNDMxODQ0NzEyNzMzODA2NTkyNDMyNzU5Mzg5MDQzMzU3NTczMzc0ODI0MjQnKSxcbiAgICBoOiBCaWdJbnQoMSksXG4gICAgbG93UzogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_assert.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_assert.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`Wrong positive integer: ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`Expected boolean, not ${b}`);\n}\nfunction bytes(b, ...lengths) {\n    if (!(b instanceof Uint8Array))\n        throw new Error('Expected Uint8Array');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(hash) {\n    if (typeof hash !== 'function' || typeof hash.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(hash.outputLen);\n    number(hash.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\nconst assert = {\n    number,\n    bool,\n    bytes,\n    hash,\n    exists,\n    output,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBTztBQUNQO0FBQ0EsbURBQW1ELEVBQUU7QUFDckQ7QUFDTztBQUNQO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLE1BQU0sRUFBQztBQUN0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcz8yNmY4Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBmdW5jdGlvbiBudW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikgfHwgbiA8IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgV3JvbmcgcG9zaXRpdmUgaW50ZWdlcjogJHtufWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGJvb2woYikge1xuICAgIGlmICh0eXBlb2YgYiAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEV4cGVjdGVkIGJvb2xlYW4sIG5vdCAke2J9YCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5Jyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgVWludDhBcnJheSBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc2goaGFzaCkge1xuICAgIGlmICh0eXBlb2YgaGFzaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaGFzaC5jcmVhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBzaG91bGQgYmUgd3JhcHBlZCBieSB1dGlscy53cmFwQ29uc3RydWN0b3InKTtcbiAgICBudW1iZXIoaGFzaC5vdXRwdXRMZW4pO1xuICAgIG51bWJlcihoYXNoLmJsb2NrTGVuKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuY29uc3QgYXNzZXJ0ID0ge1xuICAgIG51bWJlcixcbiAgICBib29sLFxuICAgIGJ5dGVzLFxuICAgIGhhc2gsXG4gICAgZXhpc3RzLFxuICAgIG91dHB1dCxcbn07XG5leHBvcnQgZGVmYXVsdCBhc3NlcnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fYXNzZXJ0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_sha2.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_sha2.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA2: function() { return /* binding */ SHA2; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Base SHA2 class (RFC 6234)\nclass SHA2 extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(this.buffer);\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_sha2.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWtDO0FBQ3FCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixnQkFBZ0IseUJBQXlCO0FBQ3pDLGVBQWUsa0RBQU87QUFDdEI7QUFDQSwwQkFBMEIsVUFBVTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMscURBQVU7QUFDM0MsdUJBQXVCLHVCQUF1QjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixjQUFjO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixxREFBVTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG9CQUFvQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFxRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3NoYTIuanM/NmFjYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQmFzZSBTSEEyIGNsYXNzIChSRkMgNjIzNClcbmV4cG9ydCBjbGFzcyBTSEEyIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoYmxvY2tMZW4sIG91dHB1dExlbiwgcGFkT2Zmc2V0LCBpc0xFKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRoaXMucGFkT2Zmc2V0ID0gcGFkT2Zmc2V0O1xuICAgICAgICB0aGlzLmlzTEUgPSBpc0xFO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGJsb2NrTGVuKTtcbiAgICAgICAgdGhpcy52aWV3ID0gY3JlYXRlVmlldyh0aGlzLmJ1ZmZlcik7XG4gICAgfVxuICAgIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGFzc2VydC5leGlzdHModGhpcyk7XG4gICAgICAgIGFzc2VydC5vdXRwdXQob3V0LCB0aGlzKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIC8vIFBhZGRpbmdcbiAgICAgICAgLy8gV2UgY2FuIGF2b2lkIGFsbG9jYXRpb24gb2YgYnVmZmVyIGZvciBwYWRkaW5nIGNvbXBsZXRlbHkgaWYgaXRcbiAgICAgICAgLy8gd2FzIHByZXZpb3VzbHkgbm90IGFsbG9jYXRlZCBoZXJlLiBCdXQgaXQgd29uJ3QgY2hhbmdlIHBlcmZvcm1hbmNlLlxuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgdmlldywgYmxvY2tMZW4sIGlzTEUgfSA9IHRoaXM7XG4gICAgICAgIGxldCB7IHBvcyB9ID0gdGhpcztcbiAgICAgICAgLy8gYXBwZW5kIHRoZSBiaXQgJzEnIHRvIHRoZSBtZXNzYWdlXG4gICAgICAgIGJ1ZmZlcltwb3MrK10gPSAwYjEwMDAwMDAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdWJhcnJheShwb3MpLmZpbGwoMCk7XG4gICAgICAgIC8vIHdlIGhhdmUgbGVzcyB0aGFuIHBhZE9mZnNldCBsZWZ0IGluIGJ1ZmZlciwgc28gd2UgY2Fubm90IHB1dCBsZW5ndGggaW4gY3VycmVudCBibG9jaywgbmVlZCBwcm9jZXNzIGl0IGFuZCBwYWQgYWdhaW5cbiAgICAgICAgaWYgKHRoaXMucGFkT2Zmc2V0ID4gYmxvY2tMZW4gLSBwb3MpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgICAgIHBvcyA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGFkIHVudGlsIGZ1bGwgYmxvY2sgYnl0ZSB3aXRoIHplcm9zXG4gICAgICAgIGZvciAobGV0IGkgPSBwb3M7IGkgPCBibG9ja0xlbjsgaSsrKVxuICAgICAgICAgICAgYnVmZmVyW2ldID0gMDtcbiAgICAgICAgLy8gTm90ZTogc2hhNTEyIHJlcXVpcmVzIGxlbmd0aCB0byBiZSAxMjhiaXQgaW50ZWdlciwgYnV0IGxlbmd0aCBpbiBKUyB3aWxsIG92ZXJmbG93IGJlZm9yZSB0aGF0XG4gICAgICAgIC8vIFlvdSBuZWVkIHRvIHdyaXRlIGFyb3VuZCAyIGV4YWJ5dGVzICh1NjRfbWF4IC8gOCAvICgxMDI0Kio2KSkgZm9yIHRoaXMgdG8gaGFwcGVuLlxuICAgICAgICAvLyBTbyB3ZSBqdXN0IHdyaXRlIGxvd2VzdCA2NCBiaXRzIG9mIHRoYXQgdmFsdWUuXG4gICAgICAgIHNldEJpZ1VpbnQ2NCh2aWV3LCBibG9ja0xlbiAtIDgsIEJpZ0ludCh0aGlzLmxlbmd0aCAqIDgpLCBpc0xFKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICBjb25zdCBvdmlldyA9IGNyZWF0ZVZpZXcob3V0KTtcbiAgICAgICAgY29uc3QgbGVuID0gdGhpcy5vdXRwdXRMZW47XG4gICAgICAgIC8vIE5PVEU6IHdlIGRvIGRpdmlzaW9uIGJ5IDQgbGF0ZXIsIHdoaWNoIHNob3VsZCBiZSBmdXNlZCBpbiBzaW5nbGUgb3Agd2l0aCBtb2R1bG8gYnkgSklUXG4gICAgICAgIGlmIChsZW4gJSA0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIHNob3VsZCBiZSBhbGlnbmVkIHRvIDMyYml0Jyk7XG4gICAgICAgIGNvbnN0IG91dExlbiA9IGxlbiAvIDQ7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXQoKTtcbiAgICAgICAgaWYgKG91dExlbiA+IHN0YXRlLmxlbmd0aClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBiaWdnZXIgdGhhbiBzdGF0ZScpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExlbjsgaSsrKVxuICAgICAgICAgICAgb3ZpZXcuc2V0VWludDMyKDQgKiBpLCBzdGF0ZVtpXSwgaXNMRSk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3QgeyBidWZmZXIsIG91dHB1dExlbiB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5kaWdlc3RJbnRvKGJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlcyA9IGJ1ZmZlci5zbGljZSgwLCBvdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgdG8uc2V0KC4uLnRoaXMuZ2V0KCkpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBidWZmZXIsIGxlbmd0aCwgZmluaXNoZWQsIGRlc3Ryb3llZCwgcG9zIH0gPSB0aGlzO1xuICAgICAgICB0by5sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRvLnBvcyA9IHBvcztcbiAgICAgICAgdG8uZmluaXNoZWQgPSBmaW5pc2hlZDtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gZGVzdHJveWVkO1xuICAgICAgICBpZiAobGVuZ3RoICUgYmxvY2tMZW4pXG4gICAgICAgICAgICB0by5idWZmZXIuc2V0KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hhMi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/_sha2.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/_u64.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/_u64.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = BigInt(2 ** 32 - 1);\nconst _32n = BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (h, l) => l;\nconst rotr32L = (h, l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\n// Removing \"export\" has 5% perf penalty -_-\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX3U2NC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/MmI3MSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gQmlnSW50KDIgKiogMzIgLSAxKTtcbmNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZXhwb3J0IGZ1bmN0aW9uIGZyb21CaWcobiwgbGUgPSBmYWxzZSkge1xuICAgIGlmIChsZSlcbiAgICAgICAgcmV0dXJuIHsgaDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSwgbDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfTtcbiAgICByZXR1cm4geyBoOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB8IDAsIGw6IE51bWJlcihuICYgVTMyX01BU0s2NCkgfCAwIH07XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5leHBvcnQgY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBsLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChoLCBsKSA9PiBsO1xuY29uc3Qgcm90cjMyTCA9IChoLCBsKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuLy8gUmVtb3ZpbmcgXCJleHBvcnRcIiBoYXMgNSUgcGVyZiBwZW5hbHR5IC1fLVxuZXhwb3J0IGZ1bmN0aW9uIGFkZChBaCwgQWwsIEJoLCBCbCkge1xuICAgIGNvbnN0IGwgPSAoQWwgPj4+IDApICsgKEJsID4+PiAwKTtcbiAgICByZXR1cm4geyBoOiAoQWggKyBCaCArICgobCAvIDIgKiogMzIpIHwgMCkpIHwgMCwgbDogbCB8IDAgfTtcbn1cbi8vIEFkZGl0aW9uIHdpdGggbW9yZSB0aGFuIDIgZWxlbWVudHNcbmNvbnN0IGFkZDNMID0gKEFsLCBCbCwgQ2wpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKTtcbmNvbnN0IGFkZDNIID0gKGxvdywgQWgsIEJoLCBDaCkgPT4gKEFoICsgQmggKyBDaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNEwgPSAoQWwsIEJsLCBDbCwgRGwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCk7XG5jb25zdCBhZGQ0SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDVMID0gKEFsLCBCbCwgQ2wsIERsLCBFbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKSArIChFbCA+Pj4gMCk7XG5jb25zdCBhZGQ1SCA9IChsb3csIEFoLCBCaCwgQ2gsIERoLCBFaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgRWggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/crypto.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/crypto.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vY3J5cHRvLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanM/NTI2MSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/hmac.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/hmac.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].hash(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vaG1hYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQWtDO0FBQ1M7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVEQUFXO0FBQ25CLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQixRQUFRLHdEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzPzA3NjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGFzc2VydCBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gSE1BQyAoUkZDIDIxMDQpXG5leHBvcnQgY2xhc3MgSE1BQyBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIF9rZXkpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICBhc3NlcnQuaGFzaChoYXNoKTtcbiAgICAgICAgY29uc3Qga2V5ID0gdG9CeXRlcyhfa2V5KTtcbiAgICAgICAgdGhpcy5pSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5pSGFzaC51cGRhdGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGluc3RhbmNlIG9mIGNsYXNzIHdoaWNoIGV4dGVuZHMgdXRpbHMuSGFzaCcpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gdGhpcy5pSGFzaC5ibG9ja0xlbjtcbiAgICAgICAgdGhpcy5vdXRwdXRMZW4gPSB0aGlzLmlIYXNoLm91dHB1dExlbjtcbiAgICAgICAgY29uc3QgYmxvY2tMZW4gPSB0aGlzLmJsb2NrTGVuO1xuICAgICAgICBjb25zdCBwYWQgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIC8vIGJsb2NrTGVuIGNhbiBiZSBiaWdnZXIgdGhhbiBvdXRwdXRMZW5cbiAgICAgICAgcGFkLnNldChrZXkubGVuZ3RoID4gYmxvY2tMZW4gPyBoYXNoLmNyZWF0ZSgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpIDoga2V5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYWQubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBwYWRbaV0gXj0gMHgzNjtcbiAgICAgICAgdGhpcy5pSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgLy8gQnkgZG9pbmcgdXBkYXRlIChwcm9jZXNzaW5nIG9mIGZpcnN0IGJsb2NrKSBvZiBvdXRlciBoYXNoIGhlcmUgd2UgY2FuIHJlLXVzZSBpdCBiZXR3ZWVuIG11bHRpcGxlIGNhbGxzIHZpYSBjbG9uZVxuICAgICAgICB0aGlzLm9IYXNoID0gaGFzaC5jcmVhdGUoKTtcbiAgICAgICAgLy8gVW5kbyBpbnRlcm5hbCBYT1IgJiYgYXBwbHkgb3V0ZXIgWE9SXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzYgXiAweDVjO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShwYWQpO1xuICAgICAgICBwYWQuZmlsbCgwKTtcbiAgICB9XG4gICAgdXBkYXRlKGJ1Zikge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0LmV4aXN0cyh0aGlzKTtcbiAgICAgICAgYXNzZXJ0LmJ5dGVzKG91dCwgdGhpcy5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pSGFzaC5kaWdlc3RJbnRvKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2gudXBkYXRlKG91dCk7XG4gICAgICAgIHRoaXMub0hhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCBvdXQgPSBuZXcgVWludDhBcnJheSh0aGlzLm9IYXNoLm91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhvdXQpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgaW5zdGFuY2Ugd2l0aG91dCBjYWxsaW5nIGNvbnN0cnVjdG9yIHNpbmNlIGtleSBhbHJlYWR5IGluIHN0YXRlIGFuZCB3ZSBkb24ndCBrbm93IGl0LlxuICAgICAgICB0byB8fCAodG8gPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSwge30pKTtcbiAgICAgICAgY29uc3QgeyBvSGFzaCwgaUhhc2gsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIGJsb2NrTGVuLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRvID0gdG87XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgdG8uYmxvY2tMZW4gPSBibG9ja0xlbjtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5vSGFzaCA9IG9IYXNoLl9jbG9uZUludG8odG8ub0hhc2gpO1xuICAgICAgICB0by5pSGFzaCA9IGlIYXNoLl9jbG9uZUludG8odG8uaUhhc2gpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5vSGFzaC5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMuaUhhc2guZGVzdHJveSgpO1xuICAgIH1cbn1cbi8qKlxuICogSE1BQzogUkZDMjEwNCBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUuXG4gKiBAcGFyYW0gaGFzaCAtIGZ1bmN0aW9uIHRoYXQgd291bGQgYmUgdXNlZCBlLmcuIHNoYTI1NlxuICogQHBhcmFtIGtleSAtIG1lc3NhZ2Uga2V5XG4gKiBAcGFyYW0gbWVzc2FnZSAtIG1lc3NhZ2UgZGF0YVxuICovXG5leHBvcnQgY29uc3QgaG1hYyA9IChoYXNoLCBrZXksIG1lc3NhZ2UpID0+IG5ldyBITUFDKGhhc2gsIGtleSkudXBkYXRlKG1lc3NhZ2UpLmRpZ2VzdCgpO1xuaG1hYy5jcmVhdGUgPSAoaGFzaCwga2V5KSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aG1hYy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha256.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha256.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n// prettier-ignore\nconst IV = new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = new Uint32Array(64);\nclass SHA256 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = IV[0] | 0;\n        this.B = IV[1] | 0;\n        this.C = IV[2] | 0;\n        this.D = IV[3] | 0;\n        this.E = IV[4] | 0;\n        this.F = IV[5] | 0;\n        this.G = IV[6] | 0;\n        this.H = IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + Maj(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBa0M7QUFDaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMENBQUk7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix5QkFBeUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUMsdUJBQXVCLCtDQUFJLFdBQVcsK0NBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5QkFBeUI7QUFDdkMsd0JBQXdCLFFBQVE7QUFDaEMsMkJBQTJCLCtDQUFJLFNBQVMsK0NBQUksVUFBVSwrQ0FBSTtBQUMxRDtBQUNBLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZUFBZSwwREFBZTtBQUM5QixlQUFlLDBEQUFlO0FBQ3JDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanM/OGNlOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTSEEyIH0gZnJvbSAnLi9fc2hhMi5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIENob2ljZTogYSA/IGIgOiBjXG5jb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuY29uc3QgTWFqID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAoYSAmIGMpIF4gKGIgJiBjKTtcbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IElWID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDZhMDllNjY3LCAweGJiNjdhZTg1LCAweDNjNmVmMzcyLCAweGE1NGZmNTNhLCAweDUxMGU1MjdmLCAweDliMDU2ODhjLCAweDFmODNkOWFiLCAweDViZTBjZDE5XG5dKTtcbi8vIFRlbXBvcmFyeSBidWZmZXIsIG5vdCB1c2VkIHRvIHN0b3JlIGFueXRoaW5nIGJldHdlZW4gcnVuc1xuLy8gTmFtZWQgdGhpcyB3YXkgYmVjYXVzZSBpdCBtYXRjaGVzIHNwZWNpZmljYXRpb24uXG5jb25zdCBTSEEyNTZfVyA9IG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBTSEEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoNjQsIDMyLCA4LCBmYWxzZSk7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgYXJyYXkgaGVyZSBzaW5jZSBhcnJheSBhbGxvd3MgaW5kZXhpbmcgYnkgdmFyaWFibGVcbiAgICAgICAgLy8gd2hpY2ggbWVhbnMgb3B0aW1pemVyL2NvbXBpbGVyIGNhbm5vdCB1c2UgcmVnaXN0ZXJzLlxuICAgICAgICB0aGlzLkEgPSBJVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IElWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gSVZbMl0gfCAwO1xuICAgICAgICB0aGlzLkQgPSBJVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IElWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gSVZbNV0gfCAwO1xuICAgICAgICB0aGlzLkcgPSBJVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IElWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjU2KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTIyNCA9IHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha3.js":
/*!************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha3.js ***!
  \************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: function() { return /* binding */ Keccak; },\n/* harmony export */   keccakP: function() { return /* binding */ keccakP; },\n/* harmony export */   keccak_224: function() { return /* binding */ keccak_224; },\n/* harmony export */   keccak_256: function() { return /* binding */ keccak_256; },\n/* harmony export */   keccak_384: function() { return /* binding */ keccak_384; },\n/* harmony export */   keccak_512: function() { return /* binding */ keccak_512; },\n/* harmony export */   sha3_224: function() { return /* binding */ sha3_224; },\n/* harmony export */   sha3_256: function() { return /* binding */ sha3_256; },\n/* harmony export */   sha3_384: function() { return /* binding */ sha3_384; },\n/* harmony export */   sha3_512: function() { return /* binding */ sha3_512; },\n/* harmony export */   shake128: function() { return /* binding */ shake128; },\n/* harmony export */   shake256: function() { return /* binding */ shake256; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"./node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Various per round constants calculations\nconst [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst _7n = BigInt(7);\nconst _256n = BigInt(256);\nconst _0x71n = BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].split(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => s > 32 ? _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlBH(h, l, s) : _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlSH(h, l, s);\nconst rotlL = (h, l, s) => s > 32 ? _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlBL(h, l, s) : _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotlSL(h, l, s);\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta \n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho () and Pi ()\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi ()\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota ()\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_2__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.u32)(this.state);\n    }\n    keccak() {\n        keccakP(this.state32, this.rounds);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].exists(this, false);\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].bytes(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].number(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        _assert_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].output(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = gen(0x06, 136, 256 / 8);\nconst sha3_384 = gen(0x06, 104, 384 / 8);\nconst sha3_512 = gen(0x06, 72, 512 / 8);\nconst keccak_224 = gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = gen(0x01, 136, 256 / 8);\nconst keccak_384 = gen(0x01, 104, 384 / 8);\nconst keccak_512 = gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = genShake(0x1f, 168, 128 / 8);\nconst shake256 = genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNrRTtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscURBQVM7QUFDNUM7QUFDQSxvQ0FBb0Msc0RBQVUsWUFBWSxzREFBVTtBQUNwRSxvQ0FBb0Msc0RBQVUsWUFBWSxzREFBVTtBQUNwRTtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDJDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx5REFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBRztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsZ0JBQWdCLGtCQUFrQjtBQUNsQyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckIsUUFBUSx3REFBWTtBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCLFdBQVc7QUFDM0IsNENBQTRDLFVBQVU7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlEQUFhO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLFFBQVEseURBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QywwREFBZTtBQUNyRDtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ0E7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ0E7QUFDQTtBQUNQLGtEQUFrRCxxRUFBMEIsV0FBVztBQUNoRjtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanM/Mjc0MSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYXNzZXJ0IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgdTY0IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBWYXJpb3VzIHBlciByb3VuZCBjb25zdGFudHMgY2FsY3VsYXRpb25zXG5jb25zdCBbU0hBM19QSSwgU0hBM19ST1RMLCBfU0hBM19JT1RBXSA9IFtbXSwgW10sIFtdXTtcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmNvbnN0IF83biA9IEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gQmlnSW50KDI1Nik7XG5jb25zdCBfMHg3MW4gPSBCaWdJbnQoMHg3MSk7XG5mb3IgKGxldCByb3VuZCA9IDAsIFIgPSBfMW4sIHggPSAxLCB5ID0gMDsgcm91bmQgPCAyNDsgcm91bmQrKykge1xuICAgIC8vIFBpXG4gICAgW3gsIHldID0gW3ksICgyICogeCArIDMgKiB5KSAlIDVdO1xuICAgIFNIQTNfUEkucHVzaCgyICogKDUgKiB5ICsgeCkpO1xuICAgIC8vIFJvdGF0aW9uYWxcbiAgICBTSEEzX1JPVEwucHVzaCgoKChyb3VuZCArIDEpICogKHJvdW5kICsgMikpIC8gMikgJSA2NCk7XG4gICAgLy8gSW90YVxuICAgIGxldCB0ID0gXzBuO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgNzsgaisrKSB7XG4gICAgICAgIFIgPSAoKFIgPDwgXzFuKSBeICgoUiA+PiBfN24pICogXzB4NzFuKSkgJSBfMjU2bjtcbiAgICAgICAgaWYgKFIgJiBfMm4pXG4gICAgICAgICAgICB0IF49IF8xbiA8PCAoKF8xbiA8PCBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSB1NjQuc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IHMgPiAzMiA/IHU2NC5yb3RsQkgoaCwgbCwgcykgOiB1NjQucm90bFNIKGgsIGwsIHMpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gcyA+IDMyID8gdTY0LnJvdGxCTChoLCBsLCBzKSA6IHU2NC5yb3RsU0woaCwgbCwgcyk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBhc3NlcnQubnVtYmVyKG91dHB1dExlbik7XG4gICAgICAgIC8vIDE2MDAgPSA1eDUgbWF0cml4IG9mIDY0Yml0LiAgMTYwMCBiaXRzID09PSAyMDAgYnl0ZXNcbiAgICAgICAgaWYgKDAgPj0gdGhpcy5ibG9ja0xlbiB8fCB0aGlzLmJsb2NrTGVuID49IDIwMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2hhMyBzdXBwb3J0cyBvbmx5IGtlY2Nhay1mMTYwMCBmdW5jdGlvbicpO1xuICAgICAgICB0aGlzLnN0YXRlID0gbmV3IFVpbnQ4QXJyYXkoMjAwKTtcbiAgICAgICAgdGhpcy5zdGF0ZTMyID0gdTMyKHRoaXMuc3RhdGUpO1xuICAgIH1cbiAgICBrZWNjYWsoKSB7XG4gICAgICAgIGtlY2Nha1AodGhpcy5zdGF0ZTMyLCB0aGlzLnJvdW5kcyk7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdGF0ZSB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGFrZTsgaSsrKVxuICAgICAgICAgICAgICAgIHN0YXRlW3RoaXMucG9zKytdIF49IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgaWYgKHRoaXMucG9zID09PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBzdGF0ZSwgc3VmZml4LCBwb3MsIGJsb2NrTGVuIH0gPSB0aGlzO1xuICAgICAgICAvLyBEbyB0aGUgcGFkZGluZ1xuICAgICAgICBzdGF0ZVtwb3NdIF49IHN1ZmZpeDtcbiAgICAgICAgaWYgKChzdWZmaXggJiAweDgwKSAhPT0gMCAmJiBwb3MgPT09IGJsb2NrTGVuIC0gMSlcbiAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIHN0YXRlW2Jsb2NrTGVuIC0gMV0gXj0gMHg4MDtcbiAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICB9XG4gICAgd3JpdGVJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQuZXhpc3RzKHRoaXMsIGZhbHNlKTtcbiAgICAgICAgYXNzZXJ0LmJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBhc3NlcnQubnVtYmVyKGJ5dGVzKTtcbiAgICAgICAgcmV0dXJuIHRoaXMueG9mSW50byhuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBhc3NlcnQub3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmZpbmlzaGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdkaWdlc3QoKSB3YXMgYWxyZWFkeSBjYWxsZWQnKTtcbiAgICAgICAgdGhpcy53cml0ZUludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlnZXN0SW50byhuZXcgVWludDhBcnJheSh0aGlzLm91dHB1dExlbikpO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc3RhdGUuZmlsbCgwKTtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICBjb25zdCB7IGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgcm91bmRzLCBlbmFibGVYT0YgfSA9IHRoaXM7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuLCBlbmFibGVYT0YsIHJvdW5kcykpO1xuICAgICAgICB0by5zdGF0ZTMyLnNldCh0aGlzLnN0YXRlMzIpO1xuICAgICAgICB0by5wb3MgPSB0aGlzLnBvcztcbiAgICAgICAgdG8ucG9zT3V0ID0gdGhpcy5wb3NPdXQ7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gdGhpcy5maW5pc2hlZDtcbiAgICAgICAgdG8ucm91bmRzID0gcm91bmRzO1xuICAgICAgICAvLyBTdWZmaXggY2FuIGNoYW5nZSBpbiBjU0hBS0VcbiAgICAgICAgdG8uc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0by5vdXRwdXRMZW4gPSBvdXRwdXRMZW47XG4gICAgICAgIHRvLmVuYWJsZVhPRiA9IGVuYWJsZVhPRjtcbiAgICAgICAgdG8uZGVzdHJveWVkID0gdGhpcy5kZXN0cm95ZWQ7XG4gICAgICAgIHJldHVybiB0bztcbiAgICB9XG59XG5jb25zdCBnZW4gPSAoc3VmZml4LCBibG9ja0xlbiwgb3V0cHV0TGVuKSA9PiB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IEtlY2NhayhibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4pKTtcbmV4cG9ydCBjb25zdCBzaGEzXzIyNCA9IGdlbigweDA2LCAxNDQsIDIyNCAvIDgpO1xuLyoqXG4gKiBTSEEzLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEzXzI1NiA9IGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gZ2VuKDB4MDYsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hhM181MTIgPSBnZW4oMHgwNiwgNzIsIDUxMiAvIDgpO1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yMjQgPSBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSBnZW4oMHgwMSwgMTM2LCAyNTYgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfMzg0ID0gZ2VuKDB4MDEsIDEwNCwgMzg0IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzUxMiA9IGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gZ2VuU2hha2UoMHgxZiwgMTY4LCAxMjggLyA4KTtcbmV4cG9ydCBjb25zdCBzaGFrZTI1NiA9IGdlblNoYWtlKDB4MWYsIDEzNiwgMjU2IC8gOCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/sha512.js":
/*!**************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/sha512.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: function() { return /* binding */ SHA512; },\n/* harmony export */   sha384: function() { return /* binding */ sha384; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; },\n/* harmony export */   sha512_224: function() { return /* binding */ sha512_224; },\n/* harmony export */   sha512_256: function() { return /* binding */ sha512_256; }\n/* harmony export */ });\n/* harmony import */ var _sha2_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_sha2.js */ \"./node_modules/@noble/hashes/esm/_sha2.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_u64.js */ \"./node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"./node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n)));\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = new Uint32Array(80);\nconst SHA512_W_L = new Uint32Array(80);\nclass SHA512 extends _sha2_js__WEBPACK_IMPORTED_MODULE_0__.SHA2 {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtDO0FBQ047QUFDaUI7QUFDN0M7QUFDQTtBQUNBLCtCQUErQixxREFBUztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMENBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUVBQWlFO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6Rix3QkFBd0Isc0RBQVUsa0JBQWtCLHNEQUFVLGtCQUFrQixxREFBUztBQUN6RjtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2Rix3QkFBd0Isc0RBQVUsaUJBQWlCLHNEQUFVLGlCQUFpQixxREFBUztBQUN2RjtBQUNBLHlCQUF5QixxREFBUztBQUNsQyx5QkFBeUIscURBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsY0FBYyxpRUFBaUU7QUFDL0U7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEYsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHdCQUF3QixxREFBUztBQUNqQztBQUNBO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGVBQWUsRUFBRSxtREFBTztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscURBQVM7QUFDakMsaUJBQWlCLHFEQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DLFdBQVcsZUFBZSxFQUFFLG1EQUFPO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxlQUFlLDBEQUFlO0FBQzlCLG1CQUFtQiwwREFBZTtBQUNsQyxtQkFBbUIsMERBQWU7QUFDbEMsZUFBZSwwREFBZTtBQUNyQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzP2ZiNTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU0hBMiB9IGZyb20gJy4vX3NoYTIuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSB1NjQuc3BsaXQoW1xuICAgICcweDQyOGEyZjk4ZDcyOGFlMjInLCAnMHg3MTM3NDQ5MTIzZWY2NWNkJywgJzB4YjVjMGZiY2ZlYzRkM2IyZicsICcweGU5YjVkYmE1ODE4OWRiYmMnLFxuICAgICcweDM5NTZjMjViZjM0OGI1MzgnLCAnMHg1OWYxMTFmMWI2MDVkMDE5JywgJzB4OTIzZjgyYTRhZjE5NGY5YicsICcweGFiMWM1ZWQ1ZGE2ZDgxMTgnLFxuICAgICcweGQ4MDdhYTk4YTMwMzAyNDInLCAnMHgxMjgzNWIwMTQ1NzA2ZmJlJywgJzB4MjQzMTg1YmU0ZWU0YjI4YycsICcweDU1MGM3ZGMzZDVmZmI0ZTInLFxuICAgICcweDcyYmU1ZDc0ZjI3Yjg5NmYnLCAnMHg4MGRlYjFmZTNiMTY5NmIxJywgJzB4OWJkYzA2YTcyNWM3MTIzNScsICcweGMxOWJmMTc0Y2Y2OTI2OTQnLFxuICAgICcweGU0OWI2OWMxOWVmMTRhZDInLCAnMHhlZmJlNDc4NjM4NGYyNWUzJywgJzB4MGZjMTlkYzY4YjhjZDViNScsICcweDI0MGNhMWNjNzdhYzljNjUnLFxuICAgICcweDJkZTkyYzZmNTkyYjAyNzUnLCAnMHg0YTc0ODRhYTZlYTZlNDgzJywgJzB4NWNiMGE5ZGNiZDQxZmJkNCcsICcweDc2Zjk4OGRhODMxMTUzYjUnLFxuICAgICcweDk4M2U1MTUyZWU2NmRmYWInLCAnMHhhODMxYzY2ZDJkYjQzMjEwJywgJzB4YjAwMzI3Yzg5OGZiMjEzZicsICcweGJmNTk3ZmM3YmVlZjBlZTQnLFxuICAgICcweGM2ZTAwYmYzM2RhODhmYzInLCAnMHhkNWE3OTE0NzkzMGFhNzI1JywgJzB4MDZjYTYzNTFlMDAzODI2ZicsICcweDE0MjkyOTY3MGEwZTZlNzAnLFxuICAgICcweDI3YjcwYTg1NDZkMjJmZmMnLCAnMHgyZTFiMjEzODVjMjZjOTI2JywgJzB4NGQyYzZkZmM1YWM0MmFlZCcsICcweDUzMzgwZDEzOWQ5NWIzZGYnLFxuICAgICcweDY1MGE3MzU0OGJhZjYzZGUnLCAnMHg3NjZhMGFiYjNjNzdiMmE4JywgJzB4ODFjMmM5MmU0N2VkYWVlNicsICcweDkyNzIyYzg1MTQ4MjM1M2InLFxuICAgICcweGEyYmZlOGExNGNmMTAzNjQnLCAnMHhhODFhNjY0YmJjNDIzMDAxJywgJzB4YzI0YjhiNzBkMGY4OTc5MScsICcweGM3NmM1MWEzMDY1NGJlMzAnLFxuICAgICcweGQxOTJlODE5ZDZlZjUyMTgnLCAnMHhkNjk5MDYyNDU1NjVhOTEwJywgJzB4ZjQwZTM1ODU1NzcxMjAyYScsICcweDEwNmFhMDcwMzJiYmQxYjgnLFxuICAgICcweDE5YTRjMTE2YjhkMmQwYzgnLCAnMHgxZTM3NmMwODUxNDFhYjUzJywgJzB4Mjc0ODc3NGNkZjhlZWI5OScsICcweDM0YjBiY2I1ZTE5YjQ4YTgnLFxuICAgICcweDM5MWMwY2IzYzVjOTVhNjMnLCAnMHg0ZWQ4YWE0YWUzNDE4YWNiJywgJzB4NWI5Y2NhNGY3NzYzZTM3MycsICcweDY4MmU2ZmYzZDZiMmI4YTMnLFxuICAgICcweDc0OGY4MmVlNWRlZmIyZmMnLCAnMHg3OGE1NjM2ZjQzMTcyZjYwJywgJzB4ODRjODc4MTRhMWYwYWI3MicsICcweDhjYzcwMjA4MWE2NDM5ZWMnLFxuICAgICcweDkwYmVmZmZhMjM2MzFlMjgnLCAnMHhhNDUwNmNlYmRlODJiZGU5JywgJzB4YmVmOWEzZjdiMmM2NzkxNScsICcweGM2NzE3OGYyZTM3MjUzMmInLFxuICAgICcweGNhMjczZWNlZWEyNjYxOWMnLCAnMHhkMTg2YjhjNzIxYzBjMjA3JywgJzB4ZWFkYTdkZDZjZGUwZWIxZScsICcweGY1N2Q0ZjdmZWU2ZWQxNzgnLFxuICAgICcweDA2ZjA2N2FhNzIxNzZmYmEnLCAnMHgwYTYzN2RjNWEyYzg5OGE2JywgJzB4MTEzZjk4MDRiZWY5MGRhZScsICcweDFiNzEwYjM1MTMxYzQ3MWInLFxuICAgICcweDI4ZGI3N2Y1MjMwNDdkODQnLCAnMHgzMmNhYWI3YjQwYzcyNDkzJywgJzB4M2M5ZWJlMGExNWM5YmViYycsICcweDQzMWQ2N2M0OWMxMDBkNGMnLFxuICAgICcweDRjYzVkNGJlY2IzZTQyYjYnLCAnMHg1OTdmMjk5Y2ZjNjU3ZTJhJywgJzB4NWZjYjZmYWIzYWQ2ZmFlYycsICcweDZjNDQxOThjNGE0NzU4MTcnXG5dLm1hcChuID0+IEJpZ0ludChuKSkpO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG5jb25zdCBTSEE1MTJfV19IID0gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSBuZXcgVWludDMyQXJyYXkoODApO1xuZXhwb3J0IGNsYXNzIFNIQTUxMiBleHRlbmRzIFNIQTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMigpKTtcbmV4cG9ydCBjb25zdCBzaGE1MTJfMjI0ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTJfMjI0KCkpO1xuZXhwb3J0IGNvbnN0IHNoYTUxMl8yNTYgPSB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEzODQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGE1MTIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "./node_modules/@noble/hashes/esm/utils.js":
/*!*************************************************!*\
  !*** ./node_modules/@noble/hashes/esm/utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/crypto */ \"./node_modules/@noble/hashes/esm/crypto.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated, we can just drop the import.\n\nconst u8a = (a) => a instanceof Uint8Array;\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// big-endian hardware is rare. Just in case someone still decides to run hashes:\n// early-throw an error because we don't support BE yet.\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\nif (!isLE)\n    throw new Error('Non little-endian hardware is not supported');\nconst hexes = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    if (!u8a(bytes))\n        throw new Error('Uint8Array expected');\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const len = hex.length;\n    if (len % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + len);\n    const array = new Uint8Array(len / 2);\n    for (let i = 0; i < array.length; i++) {\n        const j = i * 2;\n        const hexByte = hex.slice(j, j + 2);\n        const byte = Number.parseInt(hexByte, 16);\n        if (Number.isNaN(byte) || byte < 0)\n            throw new Error('Invalid byte sequence');\n        array[i] = byte;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    if (!u8a(data))\n        throw new Error(`expected Uint8Array, got ${typeof data}`);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n    let pad = 0; // walk through each item, ensure they have proper type\n    arrays.forEach((a) => {\n        if (!u8a(a))\n            throw new Error('Uint8Array expected');\n        r.set(a, pad);\n        pad += a.length;\n    });\n    return r;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\n// Check if object doens't have custom constructor (like Uint8Array/Array)\nconst isPlainObject = (obj) => Object.prototype.toString.call(obj) === '[object Object]' && obj.constructor === Object;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && (typeof opts !== 'object' || !isPlainObject(opts)))\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_0__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQzhDO0FBQzlDO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsMkJBQTJCLGFBQWE7QUFDeEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFlBQVk7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzPzM3NTAiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWhhc2hlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gV2UgdXNlIFdlYkNyeXB0byBha2EgZ2xvYmFsVGhpcy5jcnlwdG8sIHdoaWNoIGV4aXN0cyBpbiBicm93c2VycyBhbmQgbm9kZS5qcyAxNisuXG4vLyBub2RlLmpzIHZlcnNpb25zIGVhcmxpZXIgdGhhbiB2MTkgZG9uJ3QgZGVjbGFyZSBpdCBpbiBnbG9iYWwgc2NvcGUuXG4vLyBGb3Igbm9kZS5qcywgcGFja2FnZS5qc29uI2V4cG9ydHMgZmllbGQgbWFwcGluZyByZXdyaXRlcyBpbXBvcnRcbi8vIGZyb20gYGNyeXB0b2AgdG8gYGNyeXB0b05vZGVgLCB3aGljaCBpbXBvcnRzIG5hdGl2ZSBtb2R1bGUuXG4vLyBNYWtlcyB0aGUgdXRpbHMgdW4taW1wb3J0YWJsZSBpbiBicm93c2VycyB3aXRob3V0IGEgYnVuZGxlci5cbi8vIE9uY2Ugbm9kZS5qcyAxOCBpcyBkZXByZWNhdGVkLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5jb25zdCB1OGEgPSAoYSkgPT4gYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXk7XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gYmlnLWVuZGlhbiBoYXJkd2FyZSBpcyByYXJlLiBKdXN0IGluIGNhc2Ugc29tZW9uZSBzdGlsbCBkZWNpZGVzIHRvIHJ1biBoYXNoZXM6XG4vLyBlYXJseS10aHJvdyBhbiBlcnJvciBiZWNhdXNlIHdlIGRvbid0IHN1cHBvcnQgQkUgeWV0LlxuZXhwb3J0IGNvbnN0IGlzTEUgPSBuZXcgVWludDhBcnJheShuZXcgVWludDMyQXJyYXkoWzB4MTEyMjMzNDRdKS5idWZmZXIpWzBdID09PSAweDQ0O1xuaWYgKCFpc0xFKVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uIGxpdHRsZS1lbmRpYW4gaGFyZHdhcmUgaXMgbm90IHN1cHBvcnRlZCcpO1xuY29uc3QgaGV4ZXMgPSBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKHYsIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgaWYgKCF1OGEoYnl0ZXMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGxlbiA9IGhleC5sZW5ndGg7XG4gICAgaWYgKGxlbiAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBsZW4pO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkobGVuIC8gMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBqID0gaSAqIDI7XG4gICAgICAgIGNvbnN0IGhleEJ5dGUgPSBoZXguc2xpY2UoaiwgaiArIDIpO1xuICAgICAgICBjb25zdCBieXRlID0gTnVtYmVyLnBhcnNlSW50KGhleEJ5dGUsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTihieXRlKSB8fCBieXRlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBieXRlIHNlcXVlbmNlJyk7XG4gICAgICAgIGFycmF5W2ldID0gYnl0ZTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgaWYgKCF1OGEoZGF0YSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgVWludDhBcnJheSwgZ290ICR7dHlwZW9mIGRhdGF9YCk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGFycmF5cy5yZWR1Y2UoKHN1bSwgYSkgPT4gc3VtICsgYS5sZW5ndGgsIDApKTtcbiAgICBsZXQgcGFkID0gMDsgLy8gd2FsayB0aHJvdWdoIGVhY2ggaXRlbSwgZW5zdXJlIHRoZXkgaGF2ZSBwcm9wZXIgdHlwZVxuICAgIGFycmF5cy5mb3JFYWNoKChhKSA9PiB7XG4gICAgICAgIGlmICghdThhKGEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgICAgIHIuc2V0KGEsIHBhZCk7XG4gICAgICAgIHBhZCArPSBhLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcjtcbn1cbi8vIEZvciBydW50aW1lIGNoZWNrIGlmIGNsYXNzIGltcGxlbWVudHMgaW50ZXJmYWNlXG5leHBvcnQgY2xhc3MgSGFzaCB7XG4gICAgLy8gU2FmZSB2ZXJzaW9uIHRoYXQgY2xvbmVzIGludGVybmFsIHN0YXRlXG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9uZUludG8oKTtcbiAgICB9XG59XG4vLyBDaGVjayBpZiBvYmplY3QgZG9lbnMndCBoYXZlIGN1c3RvbSBjb25zdHJ1Y3RvciAobGlrZSBVaW50OEFycmF5L0FycmF5KVxuY29uc3QgaXNQbGFpbk9iamVjdCA9IChvYmopID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJyAmJiBvYmouY29uc3RydWN0b3IgPT09IE9iamVjdDtcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmICh0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcgfHwgIWlzUGxhaW5PYmplY3Qob3B0cykpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "./node_modules/@stitches/core/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/@stitches/core/dist/index.mjs ***!
  \****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createStitches: function() { return /* binding */ X; },\n/* harmony export */   createTheme: function() { return /* binding */ q; },\n/* harmony export */   css: function() { return /* binding */ _; },\n/* harmony export */   defaultThemeMap: function() { return /* binding */ i; },\n/* harmony export */   globalCss: function() { return /* binding */ K; },\n/* harmony export */   keyframes: function() { return /* binding */ Q; }\n/* harmony export */ });\nvar e,t=\"colors\",n=\"sizes\",r=\"space\",i={gap:r,gridGap:r,columnGap:r,gridColumnGap:r,rowGap:r,gridRowGap:r,inset:r,insetBlock:r,insetBlockEnd:r,insetBlockStart:r,insetInline:r,insetInlineEnd:r,insetInlineStart:r,margin:r,marginTop:r,marginRight:r,marginBottom:r,marginLeft:r,marginBlock:r,marginBlockEnd:r,marginBlockStart:r,marginInline:r,marginInlineEnd:r,marginInlineStart:r,padding:r,paddingTop:r,paddingRight:r,paddingBottom:r,paddingLeft:r,paddingBlock:r,paddingBlockEnd:r,paddingBlockStart:r,paddingInline:r,paddingInlineEnd:r,paddingInlineStart:r,top:r,right:r,bottom:r,left:r,scrollMargin:r,scrollMarginTop:r,scrollMarginRight:r,scrollMarginBottom:r,scrollMarginLeft:r,scrollMarginX:r,scrollMarginY:r,scrollMarginBlock:r,scrollMarginBlockEnd:r,scrollMarginBlockStart:r,scrollMarginInline:r,scrollMarginInlineEnd:r,scrollMarginInlineStart:r,scrollPadding:r,scrollPaddingTop:r,scrollPaddingRight:r,scrollPaddingBottom:r,scrollPaddingLeft:r,scrollPaddingX:r,scrollPaddingY:r,scrollPaddingBlock:r,scrollPaddingBlockEnd:r,scrollPaddingBlockStart:r,scrollPaddingInline:r,scrollPaddingInlineEnd:r,scrollPaddingInlineStart:r,fontSize:\"fontSizes\",background:t,backgroundColor:t,backgroundImage:t,borderImage:t,border:t,borderBlock:t,borderBlockEnd:t,borderBlockStart:t,borderBottom:t,borderBottomColor:t,borderColor:t,borderInline:t,borderInlineEnd:t,borderInlineStart:t,borderLeft:t,borderLeftColor:t,borderRight:t,borderRightColor:t,borderTop:t,borderTopColor:t,caretColor:t,color:t,columnRuleColor:t,fill:t,outline:t,outlineColor:t,stroke:t,textDecorationColor:t,fontFamily:\"fonts\",fontWeight:\"fontWeights\",lineHeight:\"lineHeights\",letterSpacing:\"letterSpacings\",blockSize:n,minBlockSize:n,maxBlockSize:n,inlineSize:n,minInlineSize:n,maxInlineSize:n,width:n,minWidth:n,maxWidth:n,height:n,minHeight:n,maxHeight:n,flexBasis:n,gridTemplateColumns:n,gridTemplateRows:n,borderWidth:\"borderWidths\",borderTopWidth:\"borderWidths\",borderRightWidth:\"borderWidths\",borderBottomWidth:\"borderWidths\",borderLeftWidth:\"borderWidths\",borderStyle:\"borderStyles\",borderTopStyle:\"borderStyles\",borderRightStyle:\"borderStyles\",borderBottomStyle:\"borderStyles\",borderLeftStyle:\"borderStyles\",borderRadius:\"radii\",borderTopLeftRadius:\"radii\",borderTopRightRadius:\"radii\",borderBottomRightRadius:\"radii\",borderBottomLeftRadius:\"radii\",boxShadow:\"shadows\",textShadow:\"shadows\",transition:\"transitions\",zIndex:\"zIndices\"},o=(e,t)=>\"function\"==typeof t?{\"()\":Function.prototype.toString.call(t)}:t,l=()=>{const e=Object.create(null);return(t,n,...r)=>{const i=(e=>JSON.stringify(e,o))(t);return i in e?e[i]:e[i]=n(t,...r)}},s=Symbol.for(\"sxs.internal\"),a=(e,t)=>Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)),c=e=>{for(const t in e)return!0;return!1},{hasOwnProperty:d}=Object.prototype,g=e=>e.includes(\"-\")?e:e.replace(/[A-Z]/g,(e=>\"-\"+e.toLowerCase())),p=/\\s+(?![^()]*\\))/,u=e=>t=>e(...\"string\"==typeof t?String(t).split(p):[t]),h={appearance:e=>({WebkitAppearance:e,appearance:e}),backfaceVisibility:e=>({WebkitBackfaceVisibility:e,backfaceVisibility:e}),backdropFilter:e=>({WebkitBackdropFilter:e,backdropFilter:e}),backgroundClip:e=>({WebkitBackgroundClip:e,backgroundClip:e}),boxDecorationBreak:e=>({WebkitBoxDecorationBreak:e,boxDecorationBreak:e}),clipPath:e=>({WebkitClipPath:e,clipPath:e}),content:e=>({content:e.includes('\"')||e.includes(\"'\")||/^([A-Za-z]+\\([^]*|[^]*-quote|inherit|initial|none|normal|revert|unset)$/.test(e)?e:`\"${e}\"`}),hyphens:e=>({WebkitHyphens:e,hyphens:e}),maskImage:e=>({WebkitMaskImage:e,maskImage:e}),maskSize:e=>({WebkitMaskSize:e,maskSize:e}),tabSize:e=>({MozTabSize:e,tabSize:e}),textSizeAdjust:e=>({WebkitTextSizeAdjust:e,textSizeAdjust:e}),userSelect:e=>({WebkitUserSelect:e,userSelect:e}),marginBlock:u(((e,t)=>({marginBlockStart:e,marginBlockEnd:t||e}))),marginInline:u(((e,t)=>({marginInlineStart:e,marginInlineEnd:t||e}))),maxSize:u(((e,t)=>({maxBlockSize:e,maxInlineSize:t||e}))),minSize:u(((e,t)=>({minBlockSize:e,minInlineSize:t||e}))),paddingBlock:u(((e,t)=>({paddingBlockStart:e,paddingBlockEnd:t||e}))),paddingInline:u(((e,t)=>({paddingInlineStart:e,paddingInlineEnd:t||e})))},f=/([\\d.]+)([^]*)/,m=(e,t)=>e.length?e.reduce(((e,n)=>(e.push(...t.map((e=>e.includes(\"&\")?e.replace(/&/g,/[ +>|~]/.test(n)&&/&.*&/.test(e)?`:is(${n})`:n):n+\" \"+e))),e)),[]):t,b=(e,t)=>e in S&&\"string\"==typeof t?t.replace(/^((?:[^]*[^\\w-])?)(fit-content|stretch)((?:[^\\w-][^]*)?)$/,((t,n,r,i)=>n+(\"stretch\"===r?`-moz-available${i};${g(e)}:${n}-webkit-fill-available`:`-moz-fit-content${i};${g(e)}:${n}fit-content`)+i)):String(t),S={blockSize:1,height:1,inlineSize:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,width:1},k=e=>e?e+\"-\":\"\",y=(e,t,n)=>e.replace(/([+-])?((?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:[Ee][+-]?\\d+)?)?(\\$|--)([$\\w-]+)/g,((e,r,i,o,l)=>\"$\"==o==!!i?e:(r||\"--\"==o?\"calc(\":\"\")+\"var(--\"+(\"$\"===o?k(t)+(l.includes(\"$\")?\"\":k(n))+l.replace(/\\$/g,\"-\"):l)+\")\"+(r||\"--\"==o?\"*\"+(r||\"\")+(i||\"1\")+\")\":\"\"))),B=/\\s*,\\s*(?![^()]*\\))/,$=Object.prototype.toString,x=(e,t,n,r,i)=>{let o,l,s;const a=(e,t,n)=>{let c,d;const p=e=>{for(c in e){const x=64===c.charCodeAt(0),z=x&&Array.isArray(e[c])?e[c]:[e[c]];for(d of z){const e=/[A-Z]/.test(S=c)?S:S.replace(/-[^]/g,(e=>e[1].toUpperCase())),z=\"object\"==typeof d&&d&&d.toString===$&&(!r.utils[e]||!t.length);if(e in r.utils&&!z){const t=r.utils[e];if(t!==l){l=t,p(t(d)),l=null;continue}}else if(e in h){const t=h[e];if(t!==s){s=t,p(t(d)),s=null;continue}}if(x&&(u=c.slice(1)in r.media?\"@media \"+r.media[c.slice(1)]:c,c=u.replace(/\\(\\s*([\\w-]+)\\s*(=|<|<=|>|>=)\\s*([\\w-]+)\\s*(?:(<|<=|>|>=)\\s*([\\w-]+)\\s*)?\\)/g,((e,t,n,r,i,o)=>{const l=f.test(t),s=.0625*(l?-1:1),[a,c]=l?[r,t]:[t,r];return\"(\"+(\"=\"===n[0]?\"\":\">\"===n[0]===l?\"max-\":\"min-\")+a+\":\"+(\"=\"!==n[0]&&1===n.length?c.replace(f,((e,t,r)=>Number(t)+s*(\">\"===n?1:-1)+r)):c)+(i?\") and (\"+(\">\"===i[0]?\"min-\":\"max-\")+a+\":\"+(1===i.length?o.replace(f,((e,t,n)=>Number(t)+s*(\">\"===i?-1:1)+n)):o):\"\")+\")\"}))),z){const e=x?n.concat(c):[...n],r=x?[...t]:m(t,c.split(B));void 0!==o&&i(I(...o)),o=void 0,a(d,r,e)}else void 0===o&&(o=[[],t,n]),c=x||36!==c.charCodeAt(0)?c:`--${k(r.prefix)}${c.slice(1).replace(/\\$/g,\"-\")}`,d=z?d:\"number\"==typeof d?d&&e in R?String(d)+\"px\":String(d):y(b(e,null==d?\"\":d),r.prefix,r.themeMap[e]),o[0].push(`${x?`${c} `:`${g(c)}:`}${d}`)}}var u,S};p(e),void 0!==o&&i(I(...o)),o=void 0};a(e,t,n)},I=(e,t,n)=>`${n.map((e=>`${e}{`)).join(\"\")}${t.length?`${t.join(\",\")}{`:\"\"}${e.join(\";\")}${t.length?\"}\":\"\"}${Array(n.length?n.length+1:0).join(\"}\")}`,R={animationDelay:1,animationDuration:1,backgroundSize:1,blockSize:1,border:1,borderBlock:1,borderBlockEnd:1,borderBlockEndWidth:1,borderBlockStart:1,borderBlockStartWidth:1,borderBlockWidth:1,borderBottom:1,borderBottomLeftRadius:1,borderBottomRightRadius:1,borderBottomWidth:1,borderEndEndRadius:1,borderEndStartRadius:1,borderInlineEnd:1,borderInlineEndWidth:1,borderInlineStart:1,borderInlineStartWidth:1,borderInlineWidth:1,borderLeft:1,borderLeftWidth:1,borderRadius:1,borderRight:1,borderRightWidth:1,borderSpacing:1,borderStartEndRadius:1,borderStartStartRadius:1,borderTop:1,borderTopLeftRadius:1,borderTopRightRadius:1,borderTopWidth:1,borderWidth:1,bottom:1,columnGap:1,columnRule:1,columnRuleWidth:1,columnWidth:1,containIntrinsicSize:1,flexBasis:1,fontSize:1,gap:1,gridAutoColumns:1,gridAutoRows:1,gridTemplateColumns:1,gridTemplateRows:1,height:1,inlineSize:1,inset:1,insetBlock:1,insetBlockEnd:1,insetBlockStart:1,insetInline:1,insetInlineEnd:1,insetInlineStart:1,left:1,letterSpacing:1,margin:1,marginBlock:1,marginBlockEnd:1,marginBlockStart:1,marginBottom:1,marginInline:1,marginInlineEnd:1,marginInlineStart:1,marginLeft:1,marginRight:1,marginTop:1,maxBlockSize:1,maxHeight:1,maxInlineSize:1,maxWidth:1,minBlockSize:1,minHeight:1,minInlineSize:1,minWidth:1,offsetDistance:1,offsetRotate:1,outline:1,outlineOffset:1,outlineWidth:1,overflowClipMargin:1,padding:1,paddingBlock:1,paddingBlockEnd:1,paddingBlockStart:1,paddingBottom:1,paddingInline:1,paddingInlineEnd:1,paddingInlineStart:1,paddingLeft:1,paddingRight:1,paddingTop:1,perspective:1,right:1,rowGap:1,scrollMargin:1,scrollMarginBlock:1,scrollMarginBlockEnd:1,scrollMarginBlockStart:1,scrollMarginBottom:1,scrollMarginInline:1,scrollMarginInlineEnd:1,scrollMarginInlineStart:1,scrollMarginLeft:1,scrollMarginRight:1,scrollMarginTop:1,scrollPadding:1,scrollPaddingBlock:1,scrollPaddingBlockEnd:1,scrollPaddingBlockStart:1,scrollPaddingBottom:1,scrollPaddingInline:1,scrollPaddingInlineEnd:1,scrollPaddingInlineStart:1,scrollPaddingLeft:1,scrollPaddingRight:1,scrollPaddingTop:1,shapeMargin:1,textDecoration:1,textDecorationThickness:1,textIndent:1,textUnderlineOffset:1,top:1,transitionDelay:1,transitionDuration:1,verticalAlign:1,width:1,wordSpacing:1},z=e=>String.fromCharCode(e+(e>25?39:97)),W=e=>(e=>{let t,n=\"\";for(t=Math.abs(e);t>52;t=t/52|0)n=z(t%52)+n;return z(t%52)+n})(((e,t)=>{let n=t.length;for(;n;)e=33*e^t.charCodeAt(--n);return e})(5381,JSON.stringify(e))>>>0),j=[\"themed\",\"global\",\"styled\",\"onevar\",\"resonevar\",\"allvar\",\"inline\"],E=e=>{if(e.href&&!e.href.startsWith(location.origin))return!1;try{return!!e.cssRules}catch(e){return!1}},T=e=>{let t;const n=()=>{const{cssRules:e}=t.sheet;return[].map.call(e,((n,r)=>{const{cssText:i}=n;let o=\"\";if(i.startsWith(\"--sxs\"))return\"\";if(e[r-1]&&(o=e[r-1].cssText).startsWith(\"--sxs\")){if(!n.cssRules.length)return\"\";for(const e in t.rules)if(t.rules[e].group===n)return`--sxs{--sxs:${[...t.rules[e].cache].join(\" \")}}${i}`;return n.cssRules.length?`${o}${i}`:\"\"}return i})).join(\"\")},r=()=>{if(t){const{rules:e,sheet:n}=t;if(!n.deleteRule){for(;3===Object(Object(n.cssRules)[0]).type;)n.cssRules.splice(0,1);n.cssRules=[]}for(const t in e)delete e[t]}const i=Object(e).styleSheets||[];for(const e of i)if(E(e)){for(let i=0,o=e.cssRules;o[i];++i){const l=Object(o[i]);if(1!==l.type)continue;const s=Object(o[i+1]);if(4!==s.type)continue;++i;const{cssText:a}=l;if(!a.startsWith(\"--sxs\"))continue;const c=a.slice(14,-3).trim().split(/\\s+/),d=j[c[0]];d&&(t||(t={sheet:e,reset:r,rules:{},toString:n}),t.rules[d]={group:s,index:i,cache:new Set(c)})}if(t)break}if(!t){const i=(e,t)=>({type:t,cssRules:[],insertRule(e,t){this.cssRules.splice(t,0,i(e,{import:3,undefined:1}[(e.toLowerCase().match(/^@([a-z]+)/)||[])[1]]||4))},get cssText(){return\"@media{}\"===e?`@media{${[].map.call(this.cssRules,(e=>e.cssText)).join(\"\")}}`:e}});t={sheet:e?(e.head||e).appendChild(document.createElement(\"style\")).sheet:i(\"\",\"text/css\"),rules:{},reset:r,toString:n}}const{sheet:o,rules:l}=t;for(let e=j.length-1;e>=0;--e){const t=j[e];if(!l[t]){const n=j[e+1],r=l[n]?l[n].index:o.cssRules.length;o.insertRule(\"@media{}\",r),o.insertRule(`--sxs{--sxs:${e}}`,r),l[t]={group:o.cssRules[r+1],index:r,cache:new Set([e])}}v(l[t])}};return r(),t},v=e=>{const t=e.group;let n=t.cssRules.length;e.apply=e=>{try{t.insertRule(e,n),++n}catch(e){}}},M=Symbol(),w=l(),C=(e,t)=>w(e,(()=>(...n)=>{let r={type:null,composers:new Set};for(const t of n)if(null!=t)if(t[s]){null==r.type&&(r.type=t[s].type);for(const e of t[s].composers)r.composers.add(e)}else t.constructor!==Object||t.$$typeof?null==r.type&&(r.type=t):r.composers.add(P(t,e));return null==r.type&&(r.type=\"span\"),r.composers.size||r.composers.add([\"PJLV\",{},[],[],{},[]]),L(e,r,t)})),P=({variants:e,compoundVariants:t,defaultVariants:n,...r},i)=>{const o=`${k(i.prefix)}c-${W(r)}`,l=[],s=[],a=Object.create(null),g=[];for(const e in n)a[e]=String(n[e]);if(\"object\"==typeof e&&e)for(const t in e){p=a,u=t,d.call(p,u)||(a[t]=\"undefined\");const n=e[t];for(const e in n){const r={[t]:String(e)};\"undefined\"===String(e)&&g.push(t);const i=n[e],o=[r,i,!c(i)];l.push(o)}}var p,u;if(\"object\"==typeof t&&t)for(const e of t){let{css:t,...n}=e;t=\"object\"==typeof t&&t||{};for(const e in n)n[e]=String(n[e]);const r=[n,t,!c(t)];s.push(r)}return[o,r,l,s,a,g]},L=(e,t,n)=>{const[r,i,o,l]=O(t.composers),c=\"function\"==typeof t.type||t.type.$$typeof?(e=>{function t(){for(let n=0;n<t[M].length;n++){const[r,i]=t[M][n];e.rules[r].apply(i)}return t[M]=[],null}return t[M]=[],t.rules={},j.forEach((e=>t.rules[e]={apply:n=>t[M].push([e,n])})),t})(n):null,d=(c||n).rules,g=`.${r}${i.length>1?`:where(.${i.slice(1).join(\".\")})`:\"\"}`,p=s=>{s=\"object\"==typeof s&&s||D;const{css:a,...p}=s,u={};for(const e in o)if(delete p[e],e in s){let t=s[e];\"object\"==typeof t&&t?u[e]={\"@initial\":o[e],...t}:(t=String(t),u[e]=\"undefined\"!==t||l.has(e)?t:o[e])}else u[e]=o[e];const h=new Set([...i]);for(const[r,i,o,l]of t.composers){n.rules.styled.cache.has(r)||(n.rules.styled.cache.add(r),x(i,[`.${r}`],[],e,(e=>{d.styled.apply(e)})));const t=A(o,u,e.media),s=A(l,u,e.media,!0);for(const i of t)if(void 0!==i)for(const[t,o,l]of i){const i=`${r}-${W(o)}-${t}`;h.add(i);const s=(l?n.rules.resonevar:n.rules.onevar).cache,a=l?d.resonevar:d.onevar;s.has(i)||(s.add(i),x(o,[`.${i}`],[],e,(e=>{a.apply(e)})))}for(const t of s)if(void 0!==t)for(const[i,o]of t){const t=`${r}-${W(o)}-${i}`;h.add(t),n.rules.allvar.cache.has(t)||(n.rules.allvar.cache.add(t),x(o,[`.${t}`],[],e,(e=>{d.allvar.apply(e)})))}}if(\"object\"==typeof a&&a){const t=`${r}-i${W(a)}-css`;h.add(t),n.rules.inline.cache.has(t)||(n.rules.inline.cache.add(t),x(a,[`.${t}`],[],e,(e=>{d.inline.apply(e)})))}for(const e of String(s.className||\"\").trim().split(/\\s+/))e&&h.add(e);const f=p.className=[...h].join(\" \");return{type:t.type,className:f,selector:g,props:p,toString:()=>f,deferredInjector:c}};return a(p,{className:r,selector:g,[s]:t,toString:()=>(n.rules.styled.cache.has(r)||p(),r)})},O=e=>{let t=\"\";const n=[],r={},i=[];for(const[o,,,,l,s]of e){\"\"===t&&(t=o),n.push(o),i.push(...s);for(const e in l){const t=l[e];(void 0===r[e]||\"undefined\"!==t||s.includes(t))&&(r[e]=t)}}return[t,n,r,new Set(i)]},A=(e,t,n,r)=>{const i=[];e:for(let[o,l,s]of e){if(s)continue;let e,a=0,c=!1;for(e in o){const r=o[e];let i=t[e];if(i!==r){if(\"object\"!=typeof i||!i)continue e;{let e,t,o=0;for(const l in i){if(r===String(i[l])){if(\"@initial\"!==l){const e=l.slice(1);(t=t||[]).push(e in n?n[e]:l.replace(/^@media ?/,\"\")),c=!0}a+=o,e=!0}++o}if(t&&t.length&&(l={[\"@media \"+t.join(\", \")]:l}),!e)continue e}}}(i[a]=i[a]||[]).push([r?\"cv\":`${e}-${o[e]}`,l,c])}return i},D={},H=l(),N=(e,t)=>H(e,(()=>(...n)=>{const r=()=>{for(let r of n){r=\"object\"==typeof r&&r||{};let n=W(r);if(!t.rules.global.cache.has(n)){if(t.rules.global.cache.add(n),\"@import\"in r){let e=[].indexOf.call(t.sheet.cssRules,t.rules.themed.group)-1;for(let n of[].concat(r[\"@import\"]))n=n.includes('\"')||n.includes(\"'\")?n:`\"${n}\"`,t.sheet.insertRule(`@import ${n};`,e++);delete r[\"@import\"]}x(r,[],[],e,(e=>{t.rules.global.apply(e)}))}}return\"\"};return a(r,{toString:r})})),V=l(),G=(e,t)=>V(e,(()=>n=>{const r=`${k(e.prefix)}k-${W(n)}`,i=()=>{if(!t.rules.global.cache.has(r)){t.rules.global.cache.add(r);const i=[];x(n,[],[],e,(e=>i.push(e)));const o=`@keyframes ${r}{${i.join(\"\")}}`;t.rules.global.apply(o)}return r};return a(i,{get name(){return i()},toString:i})})),F=class{constructor(e,t,n,r){this.token=null==e?\"\":String(e),this.value=null==t?\"\":String(t),this.scale=null==n?\"\":String(n),this.prefix=null==r?\"\":String(r)}get computedValue(){return\"var(\"+this.variable+\")\"}get variable(){return\"--\"+k(this.prefix)+k(this.scale)+this.token}toString(){return this.computedValue}},J=l(),U=(e,t)=>J(e,(()=>(n,r)=>{r=\"object\"==typeof n&&n||Object(r);const i=`.${n=(n=\"string\"==typeof n?n:\"\")||`${k(e.prefix)}t-${W(r)}`}`,o={},l=[];for(const t in r){o[t]={};for(const n in r[t]){const i=`--${k(e.prefix)}${t}-${n}`,s=y(String(r[t][n]),e.prefix,t);o[t][n]=new F(n,s,t,e.prefix),l.push(`${i}:${s}`)}}const s=()=>{if(l.length&&!t.rules.themed.cache.has(n)){t.rules.themed.cache.add(n);const i=`${r===e.theme?\":root,\":\"\"}.${n}{${l.join(\";\")}}`;t.rules.themed.apply(i)}return n};return{...o,get className(){return s()},selector:i,toString:s}})),Z=l(),X=e=>{let t=!1;const n=Z(e,(e=>{t=!0;const n=\"prefix\"in(e=\"object\"==typeof e&&e||{})?String(e.prefix):\"\",r=\"object\"==typeof e.media&&e.media||{},o=\"object\"==typeof e.root?e.root||null:globalThis.document||null,l=\"object\"==typeof e.theme&&e.theme||{},s={prefix:n,media:r,theme:l,themeMap:\"object\"==typeof e.themeMap&&e.themeMap||{...i},utils:\"object\"==typeof e.utils&&e.utils||{}},a=T(o),c={css:C(s,a),globalCss:N(s,a),keyframes:G(s,a),createTheme:U(s,a),reset(){a.reset(),c.theme.toString()},theme:{},sheet:a,config:s,prefix:n,getCssText:a.toString,toString:a.toString};return String(c.theme=c.createTheme(l)),c}));return t||n.reset(),n},Y=()=>e||(e=X()),q=(...e)=>Y().createTheme(...e),K=(...e)=>Y().globalCss(...e),Q=(...e)=>Y().keyframes(...e),_=(...e)=>Y().css(...e);\n//# sourceMappingUrl=index.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN0aXRjaGVzL2NvcmUvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsd0NBQXdDLHV6RUFBdXpFLGdDQUFnQyx5Q0FBeUMsVUFBVSw0QkFBNEIsbUJBQW1CLG9DQUFvQyxtQ0FBbUMsNEdBQTRHLDBCQUEwQixTQUFTLEVBQUUsaUJBQWlCLHFLQUFxSyxnQkFBZ0IsZ0NBQWdDLDBCQUEwQixnREFBZ0Qsc0JBQXNCLHdDQUF3QyxzQkFBc0Isd0NBQXdDLDBCQUEwQixnREFBZ0QsZ0JBQWdCLDRCQUE0QixlQUFlLGtJQUFrSSxFQUFFLEdBQUcsZUFBZSwwQkFBMEIsaUJBQWlCLDhCQUE4QixnQkFBZ0IsNEJBQTRCLGVBQWUsdUJBQXVCLHNCQUFzQix3Q0FBd0Msa0JBQWtCLGdDQUFnQywwQkFBMEIsdUNBQXVDLDZCQUE2Qix5Q0FBeUMsd0JBQXdCLGtDQUFrQyx3QkFBd0Isa0NBQWtDLDZCQUE2Qix5Q0FBeUMsOEJBQThCLDJDQUEyQyxJQUFJLG9KQUFvSixFQUFFLG1MQUFtTCxHQUFHLEVBQUUsS0FBSyxHQUFHLEVBQUUsMkNBQTJDLEdBQUcsRUFBRSxLQUFLLEdBQUcsRUFBRSwrQkFBK0Isc0pBQXNKLDRWQUE0VixVQUFVLGtCQUFrQixRQUFRLFlBQVksWUFBWSxrRUFBa0UsWUFBWSx5SUFBeUkscUJBQXFCLG1CQUFtQixVQUFVLG1CQUFtQixVQUFVLGdCQUFnQixhQUFhLFVBQVUsbUJBQW1CLFVBQVUsMEtBQTBLLHVEQUF1RCwyUUFBMlEsT0FBTyx3REFBd0QseUNBQXlDLCtEQUErRCxZQUFZLEVBQUUsOEJBQThCLHVIQUF1SCxLQUFLLEdBQUcsS0FBSyxLQUFLLEdBQUcsRUFBRSxFQUFFLElBQUksU0FBUyxzQ0FBc0MsU0FBUyxlQUFlLGFBQWEsR0FBRyxhQUFhLEVBQUUsWUFBWSxhQUFhLEtBQUssRUFBRSxTQUFTLEdBQUcsRUFBRSxXQUFXLEtBQUssRUFBRSxvQ0FBb0MsR0FBRyxLQUFLLGlyRUFBaXJF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QVcsNEJBQTRCLHNCQUFzQixHQUFHLEVBQUUsWUFBWSxFQUFFLHdCQUF3QixVQUFVLFlBQVksV0FBVyxXQUFXLFlBQVksRUFBRSxXQUFXLHFCQUFxQixpSUFBaUksb0JBQW9CLCtCQUErQixlQUFlLG1EQUFtRCxXQUFXLDJCQUEyQixpQ0FBaUMsbUNBQW1DLFlBQVksa0NBQWtDLFlBQVksSUFBSSxLQUFLLEVBQUUsTUFBTSxNQUFNLGtCQUFrQixRQUFRLHFCQUFxQixhQUFhLFlBQVksRUFBRSxFQUFFLEdBQUcsRUFBRSxrQ0FBa0Msd0NBQXdDLEVBQUUsR0FBRyxFQUFFLElBQUksYUFBYSwyQ0FBMkMsNEJBQTRCLFdBQVcsd0JBQXdCLEdBQUcsR0FBRyxFQUFFLFNBQVMsSUFBSSxFQUFFLHdCQUF3QixVQUFVLE9BQU8scUJBQXFCLFdBQVcsd0JBQXdCLGVBQWUsU0FBUyxpQkFBaUIsS0FBSyw4Q0FBOEMsNkRBQTZELHlHQUF5RyxJQUFJLDRFQUE0RSxLQUFLLDZDQUE2QyxXQUFXLHdFQUF3RSw2QkFBNkIsU0FBUyxzRUFBc0UsMENBQTBDLEdBQUcsc0JBQXNCLHNJQUErTztBQUM3eWdCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac3RpdGNoZXMvY29yZS9kaXN0L2luZGV4Lm1qcz8zZTRjIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBlLHQ9XCJjb2xvcnNcIixuPVwic2l6ZXNcIixyPVwic3BhY2VcIixpPXtnYXA6cixncmlkR2FwOnIsY29sdW1uR2FwOnIsZ3JpZENvbHVtbkdhcDpyLHJvd0dhcDpyLGdyaWRSb3dHYXA6cixpbnNldDpyLGluc2V0QmxvY2s6cixpbnNldEJsb2NrRW5kOnIsaW5zZXRCbG9ja1N0YXJ0OnIsaW5zZXRJbmxpbmU6cixpbnNldElubGluZUVuZDpyLGluc2V0SW5saW5lU3RhcnQ6cixtYXJnaW46cixtYXJnaW5Ub3A6cixtYXJnaW5SaWdodDpyLG1hcmdpbkJvdHRvbTpyLG1hcmdpbkxlZnQ6cixtYXJnaW5CbG9jazpyLG1hcmdpbkJsb2NrRW5kOnIsbWFyZ2luQmxvY2tTdGFydDpyLG1hcmdpbklubGluZTpyLG1hcmdpbklubGluZUVuZDpyLG1hcmdpbklubGluZVN0YXJ0OnIscGFkZGluZzpyLHBhZGRpbmdUb3A6cixwYWRkaW5nUmlnaHQ6cixwYWRkaW5nQm90dG9tOnIscGFkZGluZ0xlZnQ6cixwYWRkaW5nQmxvY2s6cixwYWRkaW5nQmxvY2tFbmQ6cixwYWRkaW5nQmxvY2tTdGFydDpyLHBhZGRpbmdJbmxpbmU6cixwYWRkaW5nSW5saW5lRW5kOnIscGFkZGluZ0lubGluZVN0YXJ0OnIsdG9wOnIscmlnaHQ6cixib3R0b206cixsZWZ0OnIsc2Nyb2xsTWFyZ2luOnIsc2Nyb2xsTWFyZ2luVG9wOnIsc2Nyb2xsTWFyZ2luUmlnaHQ6cixzY3JvbGxNYXJnaW5Cb3R0b206cixzY3JvbGxNYXJnaW5MZWZ0OnIsc2Nyb2xsTWFyZ2luWDpyLHNjcm9sbE1hcmdpblk6cixzY3JvbGxNYXJnaW5CbG9jazpyLHNjcm9sbE1hcmdpbkJsb2NrRW5kOnIsc2Nyb2xsTWFyZ2luQmxvY2tTdGFydDpyLHNjcm9sbE1hcmdpbklubGluZTpyLHNjcm9sbE1hcmdpbklubGluZUVuZDpyLHNjcm9sbE1hcmdpbklubGluZVN0YXJ0OnIsc2Nyb2xsUGFkZGluZzpyLHNjcm9sbFBhZGRpbmdUb3A6cixzY3JvbGxQYWRkaW5nUmlnaHQ6cixzY3JvbGxQYWRkaW5nQm90dG9tOnIsc2Nyb2xsUGFkZGluZ0xlZnQ6cixzY3JvbGxQYWRkaW5nWDpyLHNjcm9sbFBhZGRpbmdZOnIsc2Nyb2xsUGFkZGluZ0Jsb2NrOnIsc2Nyb2xsUGFkZGluZ0Jsb2NrRW5kOnIsc2Nyb2xsUGFkZGluZ0Jsb2NrU3RhcnQ6cixzY3JvbGxQYWRkaW5nSW5saW5lOnIsc2Nyb2xsUGFkZGluZ0lubGluZUVuZDpyLHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydDpyLGZvbnRTaXplOlwiZm9udFNpemVzXCIsYmFja2dyb3VuZDp0LGJhY2tncm91bmRDb2xvcjp0LGJhY2tncm91bmRJbWFnZTp0LGJvcmRlckltYWdlOnQsYm9yZGVyOnQsYm9yZGVyQmxvY2s6dCxib3JkZXJCbG9ja0VuZDp0LGJvcmRlckJsb2NrU3RhcnQ6dCxib3JkZXJCb3R0b206dCxib3JkZXJCb3R0b21Db2xvcjp0LGJvcmRlckNvbG9yOnQsYm9yZGVySW5saW5lOnQsYm9yZGVySW5saW5lRW5kOnQsYm9yZGVySW5saW5lU3RhcnQ6dCxib3JkZXJMZWZ0OnQsYm9yZGVyTGVmdENvbG9yOnQsYm9yZGVyUmlnaHQ6dCxib3JkZXJSaWdodENvbG9yOnQsYm9yZGVyVG9wOnQsYm9yZGVyVG9wQ29sb3I6dCxjYXJldENvbG9yOnQsY29sb3I6dCxjb2x1bW5SdWxlQ29sb3I6dCxmaWxsOnQsb3V0bGluZTp0LG91dGxpbmVDb2xvcjp0LHN0cm9rZTp0LHRleHREZWNvcmF0aW9uQ29sb3I6dCxmb250RmFtaWx5OlwiZm9udHNcIixmb250V2VpZ2h0OlwiZm9udFdlaWdodHNcIixsaW5lSGVpZ2h0OlwibGluZUhlaWdodHNcIixsZXR0ZXJTcGFjaW5nOlwibGV0dGVyU3BhY2luZ3NcIixibG9ja1NpemU6bixtaW5CbG9ja1NpemU6bixtYXhCbG9ja1NpemU6bixpbmxpbmVTaXplOm4sbWluSW5saW5lU2l6ZTpuLG1heElubGluZVNpemU6bix3aWR0aDpuLG1pbldpZHRoOm4sbWF4V2lkdGg6bixoZWlnaHQ6bixtaW5IZWlnaHQ6bixtYXhIZWlnaHQ6bixmbGV4QmFzaXM6bixncmlkVGVtcGxhdGVDb2x1bW5zOm4sZ3JpZFRlbXBsYXRlUm93czpuLGJvcmRlcldpZHRoOlwiYm9yZGVyV2lkdGhzXCIsYm9yZGVyVG9wV2lkdGg6XCJib3JkZXJXaWR0aHNcIixib3JkZXJSaWdodFdpZHRoOlwiYm9yZGVyV2lkdGhzXCIsYm9yZGVyQm90dG9tV2lkdGg6XCJib3JkZXJXaWR0aHNcIixib3JkZXJMZWZ0V2lkdGg6XCJib3JkZXJXaWR0aHNcIixib3JkZXJTdHlsZTpcImJvcmRlclN0eWxlc1wiLGJvcmRlclRvcFN0eWxlOlwiYm9yZGVyU3R5bGVzXCIsYm9yZGVyUmlnaHRTdHlsZTpcImJvcmRlclN0eWxlc1wiLGJvcmRlckJvdHRvbVN0eWxlOlwiYm9yZGVyU3R5bGVzXCIsYm9yZGVyTGVmdFN0eWxlOlwiYm9yZGVyU3R5bGVzXCIsYm9yZGVyUmFkaXVzOlwicmFkaWlcIixib3JkZXJUb3BMZWZ0UmFkaXVzOlwicmFkaWlcIixib3JkZXJUb3BSaWdodFJhZGl1czpcInJhZGlpXCIsYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6XCJyYWRpaVwiLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6XCJyYWRpaVwiLGJveFNoYWRvdzpcInNoYWRvd3NcIix0ZXh0U2hhZG93Olwic2hhZG93c1wiLHRyYW5zaXRpb246XCJ0cmFuc2l0aW9uc1wiLHpJbmRleDpcInpJbmRpY2VzXCJ9LG89KGUsdCk9PlwiZnVuY3Rpb25cIj09dHlwZW9mIHQ/e1wiKClcIjpGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0KX06dCxsPSgpPT57Y29uc3QgZT1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybih0LG4sLi4ucik9Pntjb25zdCBpPShlPT5KU09OLnN0cmluZ2lmeShlLG8pKSh0KTtyZXR1cm4gaSBpbiBlP2VbaV06ZVtpXT1uKHQsLi4ucil9fSxzPVN5bWJvbC5mb3IoXCJzeHMuaW50ZXJuYWxcIiksYT0oZSx0KT0+T2JqZWN0LmRlZmluZVByb3BlcnRpZXMoZSxPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh0KSksYz1lPT57Zm9yKGNvbnN0IHQgaW4gZSlyZXR1cm4hMDtyZXR1cm4hMX0se2hhc093blByb3BlcnR5OmR9PU9iamVjdC5wcm90b3R5cGUsZz1lPT5lLmluY2x1ZGVzKFwiLVwiKT9lOmUucmVwbGFjZSgvW0EtWl0vZywoZT0+XCItXCIrZS50b0xvd2VyQ2FzZSgpKSkscD0vXFxzKyg/IVteKCldKlxcKSkvLHU9ZT0+dD0+ZSguLi5cInN0cmluZ1wiPT10eXBlb2YgdD9TdHJpbmcodCkuc3BsaXQocCk6W3RdKSxoPXthcHBlYXJhbmNlOmU9Pih7V2Via2l0QXBwZWFyYW5jZTplLGFwcGVhcmFuY2U6ZX0pLGJhY2tmYWNlVmlzaWJpbGl0eTplPT4oe1dlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eTplLGJhY2tmYWNlVmlzaWJpbGl0eTplfSksYmFja2Ryb3BGaWx0ZXI6ZT0+KHtXZWJraXRCYWNrZHJvcEZpbHRlcjplLGJhY2tkcm9wRmlsdGVyOmV9KSxiYWNrZ3JvdW5kQ2xpcDplPT4oe1dlYmtpdEJhY2tncm91bmRDbGlwOmUsYmFja2dyb3VuZENsaXA6ZX0pLGJveERlY29yYXRpb25CcmVhazplPT4oe1dlYmtpdEJveERlY29yYXRpb25CcmVhazplLGJveERlY29yYXRpb25CcmVhazplfSksY2xpcFBhdGg6ZT0+KHtXZWJraXRDbGlwUGF0aDplLGNsaXBQYXRoOmV9KSxjb250ZW50OmU9Pih7Y29udGVudDplLmluY2x1ZGVzKCdcIicpfHxlLmluY2x1ZGVzKFwiJ1wiKXx8L14oW0EtWmEtel0rXFwoW15dKnxbXl0qLXF1b3RlfGluaGVyaXR8aW5pdGlhbHxub25lfG5vcm1hbHxyZXZlcnR8dW5zZXQpJC8udGVzdChlKT9lOmBcIiR7ZX1cImB9KSxoeXBoZW5zOmU9Pih7V2Via2l0SHlwaGVuczplLGh5cGhlbnM6ZX0pLG1hc2tJbWFnZTplPT4oe1dlYmtpdE1hc2tJbWFnZTplLG1hc2tJbWFnZTplfSksbWFza1NpemU6ZT0+KHtXZWJraXRNYXNrU2l6ZTplLG1hc2tTaXplOmV9KSx0YWJTaXplOmU9Pih7TW96VGFiU2l6ZTplLHRhYlNpemU6ZX0pLHRleHRTaXplQWRqdXN0OmU9Pih7V2Via2l0VGV4dFNpemVBZGp1c3Q6ZSx0ZXh0U2l6ZUFkanVzdDplfSksdXNlclNlbGVjdDplPT4oe1dlYmtpdFVzZXJTZWxlY3Q6ZSx1c2VyU2VsZWN0OmV9KSxtYXJnaW5CbG9jazp1KCgoZSx0KT0+KHttYXJnaW5CbG9ja1N0YXJ0OmUsbWFyZ2luQmxvY2tFbmQ6dHx8ZX0pKSksbWFyZ2luSW5saW5lOnUoKChlLHQpPT4oe21hcmdpbklubGluZVN0YXJ0OmUsbWFyZ2luSW5saW5lRW5kOnR8fGV9KSkpLG1heFNpemU6dSgoKGUsdCk9Pih7bWF4QmxvY2tTaXplOmUsbWF4SW5saW5lU2l6ZTp0fHxlfSkpKSxtaW5TaXplOnUoKChlLHQpPT4oe21pbkJsb2NrU2l6ZTplLG1pbklubGluZVNpemU6dHx8ZX0pKSkscGFkZGluZ0Jsb2NrOnUoKChlLHQpPT4oe3BhZGRpbmdCbG9ja1N0YXJ0OmUscGFkZGluZ0Jsb2NrRW5kOnR8fGV9KSkpLHBhZGRpbmdJbmxpbmU6dSgoKGUsdCk9Pih7cGFkZGluZ0lubGluZVN0YXJ0OmUscGFkZGluZ0lubGluZUVuZDp0fHxlfSkpKX0sZj0vKFtcXGQuXSspKFteXSopLyxtPShlLHQpPT5lLmxlbmd0aD9lLnJlZHVjZSgoKGUsbik9PihlLnB1c2goLi4udC5tYXAoKGU9PmUuaW5jbHVkZXMoXCImXCIpP2UucmVwbGFjZSgvJi9nLC9bICs+fH5dLy50ZXN0KG4pJiYvJi4qJi8udGVzdChlKT9gOmlzKCR7bn0pYDpuKTpuK1wiIFwiK2UpKSksZSkpLFtdKTp0LGI9KGUsdCk9PmUgaW4gUyYmXCJzdHJpbmdcIj09dHlwZW9mIHQ/dC5yZXBsYWNlKC9eKCg/OlteXSpbXlxcdy1dKT8pKGZpdC1jb250ZW50fHN0cmV0Y2gpKCg/OlteXFx3LV1bXl0qKT8pJC8sKCh0LG4scixpKT0+bisoXCJzdHJldGNoXCI9PT1yP2AtbW96LWF2YWlsYWJsZSR7aX07JHtnKGUpfToke259LXdlYmtpdC1maWxsLWF2YWlsYWJsZWA6YC1tb3otZml0LWNvbnRlbnQke2l9OyR7ZyhlKX06JHtufWZpdC1jb250ZW50YCkraSkpOlN0cmluZyh0KSxTPXtibG9ja1NpemU6MSxoZWlnaHQ6MSxpbmxpbmVTaXplOjEsbWF4QmxvY2tTaXplOjEsbWF4SGVpZ2h0OjEsbWF4SW5saW5lU2l6ZToxLG1heFdpZHRoOjEsbWluQmxvY2tTaXplOjEsbWluSGVpZ2h0OjEsbWluSW5saW5lU2l6ZToxLG1pbldpZHRoOjEsd2lkdGg6MX0saz1lPT5lP2UrXCItXCI6XCJcIix5PShlLHQsbik9PmUucmVwbGFjZSgvKFsrLV0pPygoPzpcXGQrKD86XFwuXFxkKik/fFxcLlxcZCspKD86W0VlXVsrLV0/XFxkKyk/KT8oXFwkfC0tKShbJFxcdy1dKykvZywoKGUscixpLG8sbCk9PlwiJFwiPT1vPT0hIWk/ZToocnx8XCItLVwiPT1vP1wiY2FsYyhcIjpcIlwiKStcInZhcigtLVwiKyhcIiRcIj09PW8/ayh0KSsobC5pbmNsdWRlcyhcIiRcIik/XCJcIjprKG4pKStsLnJlcGxhY2UoL1xcJC9nLFwiLVwiKTpsKStcIilcIisocnx8XCItLVwiPT1vP1wiKlwiKyhyfHxcIlwiKSsoaXx8XCIxXCIpK1wiKVwiOlwiXCIpKSksQj0vXFxzKixcXHMqKD8hW14oKV0qXFwpKS8sJD1PYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLHg9KGUsdCxuLHIsaSk9PntsZXQgbyxsLHM7Y29uc3QgYT0oZSx0LG4pPT57bGV0IGMsZDtjb25zdCBwPWU9Pntmb3IoYyBpbiBlKXtjb25zdCB4PTY0PT09Yy5jaGFyQ29kZUF0KDApLHo9eCYmQXJyYXkuaXNBcnJheShlW2NdKT9lW2NdOltlW2NdXTtmb3IoZCBvZiB6KXtjb25zdCBlPS9bQS1aXS8udGVzdChTPWMpP1M6Uy5yZXBsYWNlKC8tW15dL2csKGU9PmVbMV0udG9VcHBlckNhc2UoKSkpLHo9XCJvYmplY3RcIj09dHlwZW9mIGQmJmQmJmQudG9TdHJpbmc9PT0kJiYoIXIudXRpbHNbZV18fCF0Lmxlbmd0aCk7aWYoZSBpbiByLnV0aWxzJiYheil7Y29uc3QgdD1yLnV0aWxzW2VdO2lmKHQhPT1sKXtsPXQscCh0KGQpKSxsPW51bGw7Y29udGludWV9fWVsc2UgaWYoZSBpbiBoKXtjb25zdCB0PWhbZV07aWYodCE9PXMpe3M9dCxwKHQoZCkpLHM9bnVsbDtjb250aW51ZX19aWYoeCYmKHU9Yy5zbGljZSgxKWluIHIubWVkaWE/XCJAbWVkaWEgXCIrci5tZWRpYVtjLnNsaWNlKDEpXTpjLGM9dS5yZXBsYWNlKC9cXChcXHMqKFtcXHctXSspXFxzKig9fDx8PD18Pnw+PSlcXHMqKFtcXHctXSspXFxzKig/Oig8fDw9fD58Pj0pXFxzKihbXFx3LV0rKVxccyopP1xcKS9nLCgoZSx0LG4scixpLG8pPT57Y29uc3QgbD1mLnRlc3QodCkscz0uMDYyNSoobD8tMToxKSxbYSxjXT1sP1tyLHRdOlt0LHJdO3JldHVyblwiKFwiKyhcIj1cIj09PW5bMF0/XCJcIjpcIj5cIj09PW5bMF09PT1sP1wibWF4LVwiOlwibWluLVwiKSthK1wiOlwiKyhcIj1cIiE9PW5bMF0mJjE9PT1uLmxlbmd0aD9jLnJlcGxhY2UoZiwoKGUsdCxyKT0+TnVtYmVyKHQpK3MqKFwiPlwiPT09bj8xOi0xKStyKSk6YykrKGk/XCIpIGFuZCAoXCIrKFwiPlwiPT09aVswXT9cIm1pbi1cIjpcIm1heC1cIikrYStcIjpcIisoMT09PWkubGVuZ3RoP28ucmVwbGFjZShmLCgoZSx0LG4pPT5OdW1iZXIodCkrcyooXCI+XCI9PT1pPy0xOjEpK24pKTpvKTpcIlwiKStcIilcIn0pKSkseil7Y29uc3QgZT14P24uY29uY2F0KGMpOlsuLi5uXSxyPXg/Wy4uLnRdOm0odCxjLnNwbGl0KEIpKTt2b2lkIDAhPT1vJiZpKEkoLi4ubykpLG89dm9pZCAwLGEoZCxyLGUpfWVsc2Ugdm9pZCAwPT09byYmKG89W1tdLHQsbl0pLGM9eHx8MzYhPT1jLmNoYXJDb2RlQXQoMCk/YzpgLS0ke2soci5wcmVmaXgpfSR7Yy5zbGljZSgxKS5yZXBsYWNlKC9cXCQvZyxcIi1cIil9YCxkPXo/ZDpcIm51bWJlclwiPT10eXBlb2YgZD9kJiZlIGluIFI/U3RyaW5nKGQpK1wicHhcIjpTdHJpbmcoZCk6eShiKGUsbnVsbD09ZD9cIlwiOmQpLHIucHJlZml4LHIudGhlbWVNYXBbZV0pLG9bMF0ucHVzaChgJHt4P2Ake2N9IGA6YCR7ZyhjKX06YH0ke2R9YCl9fXZhciB1LFN9O3AoZSksdm9pZCAwIT09byYmaShJKC4uLm8pKSxvPXZvaWQgMH07YShlLHQsbil9LEk9KGUsdCxuKT0+YCR7bi5tYXAoKGU9PmAke2V9e2ApKS5qb2luKFwiXCIpfSR7dC5sZW5ndGg/YCR7dC5qb2luKFwiLFwiKX17YDpcIlwifSR7ZS5qb2luKFwiO1wiKX0ke3QubGVuZ3RoP1wifVwiOlwiXCJ9JHtBcnJheShuLmxlbmd0aD9uLmxlbmd0aCsxOjApLmpvaW4oXCJ9XCIpfWAsUj17YW5pbWF0aW9uRGVsYXk6MSxhbmltYXRpb25EdXJhdGlvbjoxLGJhY2tncm91bmRTaXplOjEsYmxvY2tTaXplOjEsYm9yZGVyOjEsYm9yZGVyQmxvY2s6MSxib3JkZXJCbG9ja0VuZDoxLGJvcmRlckJsb2NrRW5kV2lkdGg6MSxib3JkZXJCbG9ja1N0YXJ0OjEsYm9yZGVyQmxvY2tTdGFydFdpZHRoOjEsYm9yZGVyQmxvY2tXaWR0aDoxLGJvcmRlckJvdHRvbToxLGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6MSxib3JkZXJCb3R0b21SaWdodFJhZGl1czoxLGJvcmRlckJvdHRvbVdpZHRoOjEsYm9yZGVyRW5kRW5kUmFkaXVzOjEsYm9yZGVyRW5kU3RhcnRSYWRpdXM6MSxib3JkZXJJbmxpbmVFbmQ6MSxib3JkZXJJbmxpbmVFbmRXaWR0aDoxLGJvcmRlcklubGluZVN0YXJ0OjEsYm9yZGVySW5saW5lU3RhcnRXaWR0aDoxLGJvcmRlcklubGluZVdpZHRoOjEsYm9yZGVyTGVmdDoxLGJvcmRlckxlZnRXaWR0aDoxLGJvcmRlclJhZGl1czoxLGJvcmRlclJpZ2h0OjEsYm9yZGVyUmlnaHRXaWR0aDoxLGJvcmRlclNwYWNpbmc6MSxib3JkZXJTdGFydEVuZFJhZGl1czoxLGJvcmRlclN0YXJ0U3RhcnRSYWRpdXM6MSxib3JkZXJUb3A6MSxib3JkZXJUb3BMZWZ0UmFkaXVzOjEsYm9yZGVyVG9wUmlnaHRSYWRpdXM6MSxib3JkZXJUb3BXaWR0aDoxLGJvcmRlcldpZHRoOjEsYm90dG9tOjEsY29sdW1uR2FwOjEsY29sdW1uUnVsZToxLGNvbHVtblJ1bGVXaWR0aDoxLGNvbHVtbldpZHRoOjEsY29udGFpbkludHJpbnNpY1NpemU6MSxmbGV4QmFzaXM6MSxmb250U2l6ZToxLGdhcDoxLGdyaWRBdXRvQ29sdW1uczoxLGdyaWRBdXRvUm93czoxLGdyaWRUZW1wbGF0ZUNvbHVtbnM6MSxncmlkVGVtcGxhdGVSb3dzOjEsaGVpZ2h0OjEsaW5saW5lU2l6ZToxLGluc2V0OjEsaW5zZXRCbG9jazoxLGluc2V0QmxvY2tFbmQ6MSxpbnNldEJsb2NrU3RhcnQ6MSxpbnNldElubGluZToxLGluc2V0SW5saW5lRW5kOjEsaW5zZXRJbmxpbmVTdGFydDoxLGxlZnQ6MSxsZXR0ZXJTcGFjaW5nOjEsbWFyZ2luOjEsbWFyZ2luQmxvY2s6MSxtYXJnaW5CbG9ja0VuZDoxLG1hcmdpbkJsb2NrU3RhcnQ6MSxtYXJnaW5Cb3R0b206MSxtYXJnaW5JbmxpbmU6MSxtYXJnaW5JbmxpbmVFbmQ6MSxtYXJnaW5JbmxpbmVTdGFydDoxLG1hcmdpbkxlZnQ6MSxtYXJnaW5SaWdodDoxLG1hcmdpblRvcDoxLG1heEJsb2NrU2l6ZToxLG1heEhlaWdodDoxLG1heElubGluZVNpemU6MSxtYXhXaWR0aDoxLG1pbkJsb2NrU2l6ZToxLG1pbkhlaWdodDoxLG1pbklubGluZVNpemU6MSxtaW5XaWR0aDoxLG9mZnNldERpc3RhbmNlOjEsb2Zmc2V0Um90YXRlOjEsb3V0bGluZToxLG91dGxpbmVPZmZzZXQ6MSxvdXRsaW5lV2lkdGg6MSxvdmVyZmxvd0NsaXBNYXJnaW46MSxwYWRkaW5nOjEscGFkZGluZ0Jsb2NrOjEscGFkZGluZ0Jsb2NrRW5kOjEscGFkZGluZ0Jsb2NrU3RhcnQ6MSxwYWRkaW5nQm90dG9tOjEscGFkZGluZ0lubGluZToxLHBhZGRpbmdJbmxpbmVFbmQ6MSxwYWRkaW5nSW5saW5lU3RhcnQ6MSxwYWRkaW5nTGVmdDoxLHBhZGRpbmdSaWdodDoxLHBhZGRpbmdUb3A6MSxwZXJzcGVjdGl2ZToxLHJpZ2h0OjEscm93R2FwOjEsc2Nyb2xsTWFyZ2luOjEsc2Nyb2xsTWFyZ2luQmxvY2s6MSxzY3JvbGxNYXJnaW5CbG9ja0VuZDoxLHNjcm9sbE1hcmdpbkJsb2NrU3RhcnQ6MSxzY3JvbGxNYXJnaW5Cb3R0b206MSxzY3JvbGxNYXJnaW5JbmxpbmU6MSxzY3JvbGxNYXJnaW5JbmxpbmVFbmQ6MSxzY3JvbGxNYXJnaW5JbmxpbmVTdGFydDoxLHNjcm9sbE1hcmdpbkxlZnQ6MSxzY3JvbGxNYXJnaW5SaWdodDoxLHNjcm9sbE1hcmdpblRvcDoxLHNjcm9sbFBhZGRpbmc6MSxzY3JvbGxQYWRkaW5nQmxvY2s6MSxzY3JvbGxQYWRkaW5nQmxvY2tFbmQ6MSxzY3JvbGxQYWRkaW5nQmxvY2tTdGFydDoxLHNjcm9sbFBhZGRpbmdCb3R0b206MSxzY3JvbGxQYWRkaW5nSW5saW5lOjEsc2Nyb2xsUGFkZGluZ0lubGluZUVuZDoxLHNjcm9sbFBhZGRpbmdJbmxpbmVTdGFydDoxLHNjcm9sbFBhZGRpbmdMZWZ0OjEsc2Nyb2xsUGFkZGluZ1JpZ2h0OjEsc2Nyb2xsUGFkZGluZ1RvcDoxLHNoYXBlTWFyZ2luOjEsdGV4dERlY29yYXRpb246MSx0ZXh0RGVjb3JhdGlvblRoaWNrbmVzczoxLHRleHRJbmRlbnQ6MSx0ZXh0VW5kZXJsaW5lT2Zmc2V0OjEsdG9wOjEsdHJhbnNpdGlvbkRlbGF5OjEsdHJhbnNpdGlvbkR1cmF0aW9uOjEsdmVydGljYWxBbGlnbjoxLHdpZHRoOjEsd29yZFNwYWNpbmc6MX0sej1lPT5TdHJpbmcuZnJvbUNoYXJDb2RlKGUrKGU+MjU/Mzk6OTcpKSxXPWU9PihlPT57bGV0IHQsbj1cIlwiO2Zvcih0PU1hdGguYWJzKGUpO3Q+NTI7dD10LzUyfDApbj16KHQlNTIpK247cmV0dXJuIHoodCU1Mikrbn0pKCgoZSx0KT0+e2xldCBuPXQubGVuZ3RoO2Zvcig7bjspZT0zMyplXnQuY2hhckNvZGVBdCgtLW4pO3JldHVybiBlfSkoNTM4MSxKU09OLnN0cmluZ2lmeShlKSk+Pj4wKSxqPVtcInRoZW1lZFwiLFwiZ2xvYmFsXCIsXCJzdHlsZWRcIixcIm9uZXZhclwiLFwicmVzb25ldmFyXCIsXCJhbGx2YXJcIixcImlubGluZVwiXSxFPWU9PntpZihlLmhyZWYmJiFlLmhyZWYuc3RhcnRzV2l0aChsb2NhdGlvbi5vcmlnaW4pKXJldHVybiExO3RyeXtyZXR1cm4hIWUuY3NzUnVsZXN9Y2F0Y2goZSl7cmV0dXJuITF9fSxUPWU9PntsZXQgdDtjb25zdCBuPSgpPT57Y29uc3R7Y3NzUnVsZXM6ZX09dC5zaGVldDtyZXR1cm5bXS5tYXAuY2FsbChlLCgobixyKT0+e2NvbnN0e2Nzc1RleHQ6aX09bjtsZXQgbz1cIlwiO2lmKGkuc3RhcnRzV2l0aChcIi0tc3hzXCIpKXJldHVyblwiXCI7aWYoZVtyLTFdJiYobz1lW3ItMV0uY3NzVGV4dCkuc3RhcnRzV2l0aChcIi0tc3hzXCIpKXtpZighbi5jc3NSdWxlcy5sZW5ndGgpcmV0dXJuXCJcIjtmb3IoY29uc3QgZSBpbiB0LnJ1bGVzKWlmKHQucnVsZXNbZV0uZ3JvdXA9PT1uKXJldHVybmAtLXN4c3stLXN4czoke1suLi50LnJ1bGVzW2VdLmNhY2hlXS5qb2luKFwiIFwiKX19JHtpfWA7cmV0dXJuIG4uY3NzUnVsZXMubGVuZ3RoP2Ake299JHtpfWA6XCJcIn1yZXR1cm4gaX0pKS5qb2luKFwiXCIpfSxyPSgpPT57aWYodCl7Y29uc3R7cnVsZXM6ZSxzaGVldDpufT10O2lmKCFuLmRlbGV0ZVJ1bGUpe2Zvcig7Mz09PU9iamVjdChPYmplY3Qobi5jc3NSdWxlcylbMF0pLnR5cGU7KW4uY3NzUnVsZXMuc3BsaWNlKDAsMSk7bi5jc3NSdWxlcz1bXX1mb3IoY29uc3QgdCBpbiBlKWRlbGV0ZSBlW3RdfWNvbnN0IGk9T2JqZWN0KGUpLnN0eWxlU2hlZXRzfHxbXTtmb3IoY29uc3QgZSBvZiBpKWlmKEUoZSkpe2ZvcihsZXQgaT0wLG89ZS5jc3NSdWxlcztvW2ldOysraSl7Y29uc3QgbD1PYmplY3Qob1tpXSk7aWYoMSE9PWwudHlwZSljb250aW51ZTtjb25zdCBzPU9iamVjdChvW2krMV0pO2lmKDQhPT1zLnR5cGUpY29udGludWU7KytpO2NvbnN0e2Nzc1RleHQ6YX09bDtpZighYS5zdGFydHNXaXRoKFwiLS1zeHNcIikpY29udGludWU7Y29uc3QgYz1hLnNsaWNlKDE0LC0zKS50cmltKCkuc3BsaXQoL1xccysvKSxkPWpbY1swXV07ZCYmKHR8fCh0PXtzaGVldDplLHJlc2V0OnIscnVsZXM6e30sdG9TdHJpbmc6bn0pLHQucnVsZXNbZF09e2dyb3VwOnMsaW5kZXg6aSxjYWNoZTpuZXcgU2V0KGMpfSl9aWYodClicmVha31pZighdCl7Y29uc3QgaT0oZSx0KT0+KHt0eXBlOnQsY3NzUnVsZXM6W10saW5zZXJ0UnVsZShlLHQpe3RoaXMuY3NzUnVsZXMuc3BsaWNlKHQsMCxpKGUse2ltcG9ydDozLHVuZGVmaW5lZDoxfVsoZS50b0xvd2VyQ2FzZSgpLm1hdGNoKC9eQChbYS16XSspLyl8fFtdKVsxXV18fDQpKX0sZ2V0IGNzc1RleHQoKXtyZXR1cm5cIkBtZWRpYXt9XCI9PT1lP2BAbWVkaWF7JHtbXS5tYXAuY2FsbCh0aGlzLmNzc1J1bGVzLChlPT5lLmNzc1RleHQpKS5qb2luKFwiXCIpfX1gOmV9fSk7dD17c2hlZXQ6ZT8oZS5oZWFkfHxlKS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIikpLnNoZWV0OmkoXCJcIixcInRleHQvY3NzXCIpLHJ1bGVzOnt9LHJlc2V0OnIsdG9TdHJpbmc6bn19Y29uc3R7c2hlZXQ6byxydWxlczpsfT10O2ZvcihsZXQgZT1qLmxlbmd0aC0xO2U+PTA7LS1lKXtjb25zdCB0PWpbZV07aWYoIWxbdF0pe2NvbnN0IG49altlKzFdLHI9bFtuXT9sW25dLmluZGV4Om8uY3NzUnVsZXMubGVuZ3RoO28uaW5zZXJ0UnVsZShcIkBtZWRpYXt9XCIsciksby5pbnNlcnRSdWxlKGAtLXN4c3stLXN4czoke2V9fWAsciksbFt0XT17Z3JvdXA6by5jc3NSdWxlc1tyKzFdLGluZGV4OnIsY2FjaGU6bmV3IFNldChbZV0pfX12KGxbdF0pfX07cmV0dXJuIHIoKSx0fSx2PWU9Pntjb25zdCB0PWUuZ3JvdXA7bGV0IG49dC5jc3NSdWxlcy5sZW5ndGg7ZS5hcHBseT1lPT57dHJ5e3QuaW5zZXJ0UnVsZShlLG4pLCsrbn1jYXRjaChlKXt9fX0sTT1TeW1ib2woKSx3PWwoKSxDPShlLHQpPT53KGUsKCgpPT4oLi4ubik9PntsZXQgcj17dHlwZTpudWxsLGNvbXBvc2VyczpuZXcgU2V0fTtmb3IoY29uc3QgdCBvZiBuKWlmKG51bGwhPXQpaWYodFtzXSl7bnVsbD09ci50eXBlJiYoci50eXBlPXRbc10udHlwZSk7Zm9yKGNvbnN0IGUgb2YgdFtzXS5jb21wb3NlcnMpci5jb21wb3NlcnMuYWRkKGUpfWVsc2UgdC5jb25zdHJ1Y3RvciE9PU9iamVjdHx8dC4kJHR5cGVvZj9udWxsPT1yLnR5cGUmJihyLnR5cGU9dCk6ci5jb21wb3NlcnMuYWRkKFAodCxlKSk7cmV0dXJuIG51bGw9PXIudHlwZSYmKHIudHlwZT1cInNwYW5cIiksci5jb21wb3NlcnMuc2l6ZXx8ci5jb21wb3NlcnMuYWRkKFtcIlBKTFZcIix7fSxbXSxbXSx7fSxbXV0pLEwoZSxyLHQpfSkpLFA9KHt2YXJpYW50czplLGNvbXBvdW5kVmFyaWFudHM6dCxkZWZhdWx0VmFyaWFudHM6biwuLi5yfSxpKT0+e2NvbnN0IG89YCR7ayhpLnByZWZpeCl9Yy0ke1cocil9YCxsPVtdLHM9W10sYT1PYmplY3QuY3JlYXRlKG51bGwpLGc9W107Zm9yKGNvbnN0IGUgaW4gbilhW2VdPVN0cmluZyhuW2VdKTtpZihcIm9iamVjdFwiPT10eXBlb2YgZSYmZSlmb3IoY29uc3QgdCBpbiBlKXtwPWEsdT10LGQuY2FsbChwLHUpfHwoYVt0XT1cInVuZGVmaW5lZFwiKTtjb25zdCBuPWVbdF07Zm9yKGNvbnN0IGUgaW4gbil7Y29uc3Qgcj17W3RdOlN0cmluZyhlKX07XCJ1bmRlZmluZWRcIj09PVN0cmluZyhlKSYmZy5wdXNoKHQpO2NvbnN0IGk9bltlXSxvPVtyLGksIWMoaSldO2wucHVzaChvKX19dmFyIHAsdTtpZihcIm9iamVjdFwiPT10eXBlb2YgdCYmdClmb3IoY29uc3QgZSBvZiB0KXtsZXR7Y3NzOnQsLi4ubn09ZTt0PVwib2JqZWN0XCI9PXR5cGVvZiB0JiZ0fHx7fTtmb3IoY29uc3QgZSBpbiBuKW5bZV09U3RyaW5nKG5bZV0pO2NvbnN0IHI9W24sdCwhYyh0KV07cy5wdXNoKHIpfXJldHVybltvLHIsbCxzLGEsZ119LEw9KGUsdCxuKT0+e2NvbnN0W3IsaSxvLGxdPU8odC5jb21wb3NlcnMpLGM9XCJmdW5jdGlvblwiPT10eXBlb2YgdC50eXBlfHx0LnR5cGUuJCR0eXBlb2Y/KGU9PntmdW5jdGlvbiB0KCl7Zm9yKGxldCBuPTA7bjx0W01dLmxlbmd0aDtuKyspe2NvbnN0W3IsaV09dFtNXVtuXTtlLnJ1bGVzW3JdLmFwcGx5KGkpfXJldHVybiB0W01dPVtdLG51bGx9cmV0dXJuIHRbTV09W10sdC5ydWxlcz17fSxqLmZvckVhY2goKGU9PnQucnVsZXNbZV09e2FwcGx5Om49PnRbTV0ucHVzaChbZSxuXSl9KSksdH0pKG4pOm51bGwsZD0oY3x8bikucnVsZXMsZz1gLiR7cn0ke2kubGVuZ3RoPjE/YDp3aGVyZSguJHtpLnNsaWNlKDEpLmpvaW4oXCIuXCIpfSlgOlwiXCJ9YCxwPXM9PntzPVwib2JqZWN0XCI9PXR5cGVvZiBzJiZzfHxEO2NvbnN0e2NzczphLC4uLnB9PXMsdT17fTtmb3IoY29uc3QgZSBpbiBvKWlmKGRlbGV0ZSBwW2VdLGUgaW4gcyl7bGV0IHQ9c1tlXTtcIm9iamVjdFwiPT10eXBlb2YgdCYmdD91W2VdPXtcIkBpbml0aWFsXCI6b1tlXSwuLi50fToodD1TdHJpbmcodCksdVtlXT1cInVuZGVmaW5lZFwiIT09dHx8bC5oYXMoZSk/dDpvW2VdKX1lbHNlIHVbZV09b1tlXTtjb25zdCBoPW5ldyBTZXQoWy4uLmldKTtmb3IoY29uc3RbcixpLG8sbF1vZiB0LmNvbXBvc2Vycyl7bi5ydWxlcy5zdHlsZWQuY2FjaGUuaGFzKHIpfHwobi5ydWxlcy5zdHlsZWQuY2FjaGUuYWRkKHIpLHgoaSxbYC4ke3J9YF0sW10sZSwoZT0+e2Quc3R5bGVkLmFwcGx5KGUpfSkpKTtjb25zdCB0PUEobyx1LGUubWVkaWEpLHM9QShsLHUsZS5tZWRpYSwhMCk7Zm9yKGNvbnN0IGkgb2YgdClpZih2b2lkIDAhPT1pKWZvcihjb25zdFt0LG8sbF1vZiBpKXtjb25zdCBpPWAke3J9LSR7VyhvKX0tJHt0fWA7aC5hZGQoaSk7Y29uc3Qgcz0obD9uLnJ1bGVzLnJlc29uZXZhcjpuLnJ1bGVzLm9uZXZhcikuY2FjaGUsYT1sP2QucmVzb25ldmFyOmQub25ldmFyO3MuaGFzKGkpfHwocy5hZGQoaSkseChvLFtgLiR7aX1gXSxbXSxlLChlPT57YS5hcHBseShlKX0pKSl9Zm9yKGNvbnN0IHQgb2YgcylpZih2b2lkIDAhPT10KWZvcihjb25zdFtpLG9db2YgdCl7Y29uc3QgdD1gJHtyfS0ke1cobyl9LSR7aX1gO2guYWRkKHQpLG4ucnVsZXMuYWxsdmFyLmNhY2hlLmhhcyh0KXx8KG4ucnVsZXMuYWxsdmFyLmNhY2hlLmFkZCh0KSx4KG8sW2AuJHt0fWBdLFtdLGUsKGU9PntkLmFsbHZhci5hcHBseShlKX0pKSl9fWlmKFwib2JqZWN0XCI9PXR5cGVvZiBhJiZhKXtjb25zdCB0PWAke3J9LWkke1coYSl9LWNzc2A7aC5hZGQodCksbi5ydWxlcy5pbmxpbmUuY2FjaGUuaGFzKHQpfHwobi5ydWxlcy5pbmxpbmUuY2FjaGUuYWRkKHQpLHgoYSxbYC4ke3R9YF0sW10sZSwoZT0+e2QuaW5saW5lLmFwcGx5KGUpfSkpKX1mb3IoY29uc3QgZSBvZiBTdHJpbmcocy5jbGFzc05hbWV8fFwiXCIpLnRyaW0oKS5zcGxpdCgvXFxzKy8pKWUmJmguYWRkKGUpO2NvbnN0IGY9cC5jbGFzc05hbWU9Wy4uLmhdLmpvaW4oXCIgXCIpO3JldHVybnt0eXBlOnQudHlwZSxjbGFzc05hbWU6ZixzZWxlY3RvcjpnLHByb3BzOnAsdG9TdHJpbmc6KCk9PmYsZGVmZXJyZWRJbmplY3RvcjpjfX07cmV0dXJuIGEocCx7Y2xhc3NOYW1lOnIsc2VsZWN0b3I6Zyxbc106dCx0b1N0cmluZzooKT0+KG4ucnVsZXMuc3R5bGVkLmNhY2hlLmhhcyhyKXx8cCgpLHIpfSl9LE89ZT0+e2xldCB0PVwiXCI7Y29uc3Qgbj1bXSxyPXt9LGk9W107Zm9yKGNvbnN0W28sLCwsbCxzXW9mIGUpe1wiXCI9PT10JiYodD1vKSxuLnB1c2gobyksaS5wdXNoKC4uLnMpO2Zvcihjb25zdCBlIGluIGwpe2NvbnN0IHQ9bFtlXTsodm9pZCAwPT09cltlXXx8XCJ1bmRlZmluZWRcIiE9PXR8fHMuaW5jbHVkZXModCkpJiYocltlXT10KX19cmV0dXJuW3QsbixyLG5ldyBTZXQoaSldfSxBPShlLHQsbixyKT0+e2NvbnN0IGk9W107ZTpmb3IobGV0W28sbCxzXW9mIGUpe2lmKHMpY29udGludWU7bGV0IGUsYT0wLGM9ITE7Zm9yKGUgaW4gbyl7Y29uc3Qgcj1vW2VdO2xldCBpPXRbZV07aWYoaSE9PXIpe2lmKFwib2JqZWN0XCIhPXR5cGVvZiBpfHwhaSljb250aW51ZSBlO3tsZXQgZSx0LG89MDtmb3IoY29uc3QgbCBpbiBpKXtpZihyPT09U3RyaW5nKGlbbF0pKXtpZihcIkBpbml0aWFsXCIhPT1sKXtjb25zdCBlPWwuc2xpY2UoMSk7KHQ9dHx8W10pLnB1c2goZSBpbiBuP25bZV06bC5yZXBsYWNlKC9eQG1lZGlhID8vLFwiXCIpKSxjPSEwfWErPW8sZT0hMH0rK299aWYodCYmdC5sZW5ndGgmJihsPXtbXCJAbWVkaWEgXCIrdC5qb2luKFwiLCBcIildOmx9KSwhZSljb250aW51ZSBlfX19KGlbYV09aVthXXx8W10pLnB1c2goW3I/XCJjdlwiOmAke2V9LSR7b1tlXX1gLGwsY10pfXJldHVybiBpfSxEPXt9LEg9bCgpLE49KGUsdCk9PkgoZSwoKCk9PiguLi5uKT0+e2NvbnN0IHI9KCk9Pntmb3IobGV0IHIgb2Ygbil7cj1cIm9iamVjdFwiPT10eXBlb2YgciYmcnx8e307bGV0IG49VyhyKTtpZighdC5ydWxlcy5nbG9iYWwuY2FjaGUuaGFzKG4pKXtpZih0LnJ1bGVzLmdsb2JhbC5jYWNoZS5hZGQobiksXCJAaW1wb3J0XCJpbiByKXtsZXQgZT1bXS5pbmRleE9mLmNhbGwodC5zaGVldC5jc3NSdWxlcyx0LnJ1bGVzLnRoZW1lZC5ncm91cCktMTtmb3IobGV0IG4gb2ZbXS5jb25jYXQocltcIkBpbXBvcnRcIl0pKW49bi5pbmNsdWRlcygnXCInKXx8bi5pbmNsdWRlcyhcIidcIik/bjpgXCIke259XCJgLHQuc2hlZXQuaW5zZXJ0UnVsZShgQGltcG9ydCAke259O2AsZSsrKTtkZWxldGUgcltcIkBpbXBvcnRcIl19eChyLFtdLFtdLGUsKGU9Pnt0LnJ1bGVzLmdsb2JhbC5hcHBseShlKX0pKX19cmV0dXJuXCJcIn07cmV0dXJuIGEocix7dG9TdHJpbmc6cn0pfSkpLFY9bCgpLEc9KGUsdCk9PlYoZSwoKCk9Pm49Pntjb25zdCByPWAke2soZS5wcmVmaXgpfWstJHtXKG4pfWAsaT0oKT0+e2lmKCF0LnJ1bGVzLmdsb2JhbC5jYWNoZS5oYXMocikpe3QucnVsZXMuZ2xvYmFsLmNhY2hlLmFkZChyKTtjb25zdCBpPVtdO3gobixbXSxbXSxlLChlPT5pLnB1c2goZSkpKTtjb25zdCBvPWBAa2V5ZnJhbWVzICR7cn17JHtpLmpvaW4oXCJcIil9fWA7dC5ydWxlcy5nbG9iYWwuYXBwbHkobyl9cmV0dXJuIHJ9O3JldHVybiBhKGkse2dldCBuYW1lKCl7cmV0dXJuIGkoKX0sdG9TdHJpbmc6aX0pfSkpLEY9Y2xhc3N7Y29uc3RydWN0b3IoZSx0LG4scil7dGhpcy50b2tlbj1udWxsPT1lP1wiXCI6U3RyaW5nKGUpLHRoaXMudmFsdWU9bnVsbD09dD9cIlwiOlN0cmluZyh0KSx0aGlzLnNjYWxlPW51bGw9PW4/XCJcIjpTdHJpbmcobiksdGhpcy5wcmVmaXg9bnVsbD09cj9cIlwiOlN0cmluZyhyKX1nZXQgY29tcHV0ZWRWYWx1ZSgpe3JldHVyblwidmFyKFwiK3RoaXMudmFyaWFibGUrXCIpXCJ9Z2V0IHZhcmlhYmxlKCl7cmV0dXJuXCItLVwiK2sodGhpcy5wcmVmaXgpK2sodGhpcy5zY2FsZSkrdGhpcy50b2tlbn10b1N0cmluZygpe3JldHVybiB0aGlzLmNvbXB1dGVkVmFsdWV9fSxKPWwoKSxVPShlLHQpPT5KKGUsKCgpPT4obixyKT0+e3I9XCJvYmplY3RcIj09dHlwZW9mIG4mJm58fE9iamVjdChyKTtjb25zdCBpPWAuJHtuPShuPVwic3RyaW5nXCI9PXR5cGVvZiBuP246XCJcIil8fGAke2soZS5wcmVmaXgpfXQtJHtXKHIpfWB9YCxvPXt9LGw9W107Zm9yKGNvbnN0IHQgaW4gcil7b1t0XT17fTtmb3IoY29uc3QgbiBpbiByW3RdKXtjb25zdCBpPWAtLSR7ayhlLnByZWZpeCl9JHt0fS0ke259YCxzPXkoU3RyaW5nKHJbdF1bbl0pLGUucHJlZml4LHQpO29bdF1bbl09bmV3IEYobixzLHQsZS5wcmVmaXgpLGwucHVzaChgJHtpfToke3N9YCl9fWNvbnN0IHM9KCk9PntpZihsLmxlbmd0aCYmIXQucnVsZXMudGhlbWVkLmNhY2hlLmhhcyhuKSl7dC5ydWxlcy50aGVtZWQuY2FjaGUuYWRkKG4pO2NvbnN0IGk9YCR7cj09PWUudGhlbWU/XCI6cm9vdCxcIjpcIlwifS4ke259eyR7bC5qb2luKFwiO1wiKX19YDt0LnJ1bGVzLnRoZW1lZC5hcHBseShpKX1yZXR1cm4gbn07cmV0dXJuey4uLm8sZ2V0IGNsYXNzTmFtZSgpe3JldHVybiBzKCl9LHNlbGVjdG9yOmksdG9TdHJpbmc6c319KSksWj1sKCksWD1lPT57bGV0IHQ9ITE7Y29uc3Qgbj1aKGUsKGU9Pnt0PSEwO2NvbnN0IG49XCJwcmVmaXhcImluKGU9XCJvYmplY3RcIj09dHlwZW9mIGUmJmV8fHt9KT9TdHJpbmcoZS5wcmVmaXgpOlwiXCIscj1cIm9iamVjdFwiPT10eXBlb2YgZS5tZWRpYSYmZS5tZWRpYXx8e30sbz1cIm9iamVjdFwiPT10eXBlb2YgZS5yb290P2Uucm9vdHx8bnVsbDpnbG9iYWxUaGlzLmRvY3VtZW50fHxudWxsLGw9XCJvYmplY3RcIj09dHlwZW9mIGUudGhlbWUmJmUudGhlbWV8fHt9LHM9e3ByZWZpeDpuLG1lZGlhOnIsdGhlbWU6bCx0aGVtZU1hcDpcIm9iamVjdFwiPT10eXBlb2YgZS50aGVtZU1hcCYmZS50aGVtZU1hcHx8ey4uLml9LHV0aWxzOlwib2JqZWN0XCI9PXR5cGVvZiBlLnV0aWxzJiZlLnV0aWxzfHx7fX0sYT1UKG8pLGM9e2NzczpDKHMsYSksZ2xvYmFsQ3NzOk4ocyxhKSxrZXlmcmFtZXM6RyhzLGEpLGNyZWF0ZVRoZW1lOlUocyxhKSxyZXNldCgpe2EucmVzZXQoKSxjLnRoZW1lLnRvU3RyaW5nKCl9LHRoZW1lOnt9LHNoZWV0OmEsY29uZmlnOnMscHJlZml4Om4sZ2V0Q3NzVGV4dDphLnRvU3RyaW5nLHRvU3RyaW5nOmEudG9TdHJpbmd9O3JldHVybiBTdHJpbmcoYy50aGVtZT1jLmNyZWF0ZVRoZW1lKGwpKSxjfSkpO3JldHVybiB0fHxuLnJlc2V0KCksbn0sWT0oKT0+ZXx8KGU9WCgpKSxxPSguLi5lKT0+WSgpLmNyZWF0ZVRoZW1lKC4uLmUpLEs9KC4uLmUpPT5ZKCkuZ2xvYmFsQ3NzKC4uLmUpLFE9KC4uLmUpPT5ZKCkua2V5ZnJhbWVzKC4uLmUpLF89KC4uLmUpPT5ZKCkuY3NzKC4uLmUpO2V4cG9ydHtYIGFzIGNyZWF0ZVN0aXRjaGVzLHEgYXMgY3JlYXRlVGhlbWUsXyBhcyBjc3MsaSBhcyBkZWZhdWx0VGhlbWVNYXAsSyBhcyBnbG9iYWxDc3MsUSBhcyBrZXlmcmFtZXN9O1xuLy8jIHNvdXJjZU1hcHBpbmdVcmw9aW5kZXgubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@stitches/core/dist/index.mjs\n"));

/***/ }),

/***/ "./node_modules/@supabase/auth-ui-react/dist/index.es.js":
/*!***************************************************************!*\
  !*** ./node_modules/@supabase/auth-ui-react/dist/index.es.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Auth: function() { return /* binding */ k; },\n/* harmony export */   AuthCard: function() { return /* binding */ Z1; },\n/* harmony export */   ForgottenPassword: function() { return /* binding */ J1; },\n/* harmony export */   MagicLink: function() { return /* binding */ K1; },\n/* harmony export */   SignIn: function() { return /* binding */ q1; },\n/* harmony export */   SignUp: function() { return /* binding */ j1; },\n/* harmony export */   SocialAuth: function() { return /* binding */ Y1; },\n/* harmony export */   UpdatePassword: function() { return /* binding */ Q1; },\n/* harmony export */   VerifyOtp: function() { return /* binding */ X1; }\n/* harmony export */ });\n/* harmony import */ var _stitches_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stitches/core */ \"./node_modules/@stitches/core/dist/index.mjs\");\n/* harmony import */ var _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @supabase/auth-ui-shared */ \"./node_modules/@supabase/auth-ui-shared/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\n\n\nconst g1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  fontFamily: \"$bodyFontFamily\",\n  fontSize: \"$baseBodySize\",\n  marginBottom: \"$anchorBottomMargin\",\n  color: \"$anchorTextColor\",\n  display: \"block\",\n  textAlign: \"center\",\n  textDecoration: \"underline\",\n  \"&:hover\": {\n    color: \"$anchorTextHoverColor\"\n  }\n}), I = ({ children: t, appearance: l, ...n }) => {\n  var o;\n  const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"anchor\",\n    g1(),\n    l\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"a\",\n    {\n      ...n,\n      style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.anchor,\n      className: r.join(\" \")\n    },\n    t\n  );\n}, h1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  fontFamily: \"$buttonFontFamily\",\n  display: \"flex\",\n  alignItems: \"center\",\n  justifyContent: \"center\",\n  gap: \"8px\",\n  borderRadius: \"$borderRadiusButton\",\n  fontSize: \"$baseButtonSize\",\n  padding: \"$buttonPadding\",\n  cursor: \"pointer\",\n  borderWidth: \"$buttonBorderWidth\",\n  borderStyle: \"solid\",\n  width: \"100%\",\n  transitionPproperty: \"background-color\",\n  transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n  transitionDuration: \"100ms\",\n  \"&:disabled\": {\n    opacity: 0.7,\n    cursor: \"unset\"\n  },\n  variants: {\n    color: {\n      default: {\n        backgroundColor: \"$defaultButtonBackground\",\n        color: \"$defaultButtonText\",\n        borderColor: \"$defaultButtonBorder\",\n        \"&:hover:not(:disabled)\": {\n          backgroundColor: \"$defaultButtonBackgroundHover\"\n        }\n      },\n      primary: {\n        backgroundColor: \"$brand\",\n        color: \"$brandButtonText\",\n        borderColor: \"$brandAccent\",\n        \"&:hover:not(:disabled)\": {\n          backgroundColor: \"$brandAccent\"\n        }\n      }\n    }\n  }\n}), A = ({\n  children: t,\n  color: l = \"default\",\n  appearance: n,\n  icon: r,\n  loading: o = !1,\n  ...v\n}) => {\n  var C;\n  const E = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"button\",\n    h1({ color: l }),\n    n\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"button\",\n    {\n      ...v,\n      style: (C = n == null ? void 0 : n.style) == null ? void 0 : C.button,\n      className: E.join(\" \"),\n      disabled: o\n    },\n    r,\n    t\n  );\n}, f1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  display: \"flex\",\n  gap: \"4px\",\n  variants: {\n    direction: {\n      horizontal: {\n        display: \"grid\",\n        gridTemplateColumns: \"repeat(auto-fit, minmax(48px, 1fr))\"\n      },\n      vertical: {\n        flexDirection: \"column\",\n        margin: \"8px 0\"\n      }\n    },\n    gap: {\n      small: {\n        gap: \"4px\"\n      },\n      medium: {\n        gap: \"8px\"\n      },\n      large: {\n        gap: \"16px\"\n      }\n    }\n  }\n}), z = ({\n  children: t,\n  appearance: l,\n  ...n\n}) => {\n  var o;\n  const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"container\",\n    f1({\n      direction: n.direction,\n      gap: n.gap\n    }),\n    l\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"div\",\n    {\n      ...n,\n      style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.container,\n      className: r.join(\" \")\n    },\n    t\n  );\n}, E1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  background: \"$dividerBackground\",\n  display: \"block\",\n  margin: \"16px 0\",\n  height: \"1px\",\n  width: \"100%\"\n}), C1 = ({\n  children: t,\n  appearance: l,\n  ...n\n}) => {\n  var o;\n  const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"divider\",\n    E1(),\n    l\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"div\",\n    {\n      ...n,\n      style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.divider,\n      className: r.join(\" \")\n    }\n  );\n}, w1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  fontFamily: \"$inputFontFamily\",\n  background: \"$inputBackground\",\n  borderRadius: \"$inputBorderRadius\",\n  padding: \"$inputPadding\",\n  cursor: \"text\",\n  borderWidth: \"$inputBorderWidth\",\n  borderColor: \"$inputBorder\",\n  borderStyle: \"solid\",\n  fontSize: \"$baseInputSize\",\n  width: \"100%\",\n  color: \"$inputText\",\n  boxSizing: \"border-box\",\n  \"&:hover\": {\n    borderColor: \"$inputBorderHover\",\n    outline: \"none\"\n  },\n  \"&:focus\": {\n    borderColor: \"$inputBorderFocus\",\n    outline: \"none\"\n  },\n  \"&::placeholder\": {\n    color: \"$inputPlaceholder\",\n    letterSpacing: \"initial\"\n  },\n  transitionPproperty: \"background-color, border\",\n  transitionTimingFunction: \"cubic-bezier(0.4, 0, 0.2, 1)\",\n  transitionDuration: \"100ms\",\n  variants: {\n    type: {\n      default: {\n        letterSpacing: \"0px\"\n      },\n      password: {\n        letterSpacing: \"6px\"\n      }\n    }\n  }\n}), B = ({ children: t, appearance: l, ...n }) => {\n  var o;\n  const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"input\",\n    w1({\n      type: n.type === \"password\" ? \"password\" : \"default\"\n    }),\n    l\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"input\",\n    {\n      ...n,\n      style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.input,\n      className: r.join(\" \")\n    },\n    t\n  );\n}, v1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  fontFamily: \"$labelFontFamily\",\n  fontSize: \"$baseLabelSize\",\n  marginBottom: \"$labelBottomMargin\",\n  color: \"$inputLabelText\",\n  display: \"block\"\n}), H = ({ children: t, appearance: l, ...n }) => {\n  var o;\n  const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"label\",\n    v1(),\n    l\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"label\",\n    {\n      ...n,\n      style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.label,\n      className: r.join(\" \")\n    },\n    t\n  );\n}, _1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  fontFamily: \"$bodyFontFamily\",\n  fontSize: \"$baseBodySize\",\n  marginBottom: \"$labelBottomMargin\",\n  display: \"block\",\n  textAlign: \"center\",\n  variants: {\n    color: {\n      default: {\n        color: \"$messageText\"\n      },\n      danger: {\n        color: \"$messageTextDanger\"\n      }\n    }\n  }\n}), N = ({\n  children: t,\n  appearance: l,\n  ...n\n}) => {\n  var o;\n  const r = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.generateClassNames)(\n    \"message\",\n    _1({ color: n.color }),\n    l\n  );\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"span\",\n    {\n      ...n,\n      style: (o = l == null ? void 0 : l.style) == null ? void 0 : o.message,\n      className: r.join(\" \")\n    },\n    t\n  );\n};\nfunction X({\n  setAuthView: t = () => {\n  },\n  supabaseClient: l,\n  redirectTo: n,\n  i18n: r,\n  appearance: o,\n  showLinks: v = !1\n}) {\n  var x;\n  const [E, C] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [w, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [a, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), _ = async (h) => {\n    var s;\n    h.preventDefault(), d(\"\"), m(\"\"), y(!0);\n    const { error: g } = await l.auth.signInWithOtp({\n      email: E,\n      options: { emailRedirectTo: n }\n    });\n    g ? d(g.message) : m((s = r == null ? void 0 : r.magic_link) == null ? void 0 : s.confirmation_text), y(!1);\n  }, i = r == null ? void 0 : r.magic_link;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", { id: \"auth-magic-link\", onSubmit: _ }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { gap: \"large\", direction: \"vertical\", appearance: o }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"email\", appearance: o }, i == null ? void 0 : i.email_input_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    B,\n    {\n      id: \"email\",\n      name: \"email\",\n      type: \"email\",\n      autoFocus: !0,\n      placeholder: i == null ? void 0 : i.email_input_placeholder,\n      onChange: (h) => C(h.target.value),\n      appearance: o\n    }\n  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    A,\n    {\n      color: \"primary\",\n      type: \"submit\",\n      loading: c,\n      appearance: o\n    },\n    c ? i == null ? void 0 : i.loading_button_label : i == null ? void 0 : i.button_label\n  ), v && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    I,\n    {\n      href: \"#auth-sign-in\",\n      onClick: (h) => {\n        h.preventDefault(), t(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n      },\n      appearance: o\n    },\n    (x = r == null ? void 0 : r.sign_in) == null ? void 0 : x.link_text\n  ), a && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { appearance: o }, a), w && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { color: \"danger\", appearance: o }, w)));\n}\nconst L = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  width: \"21px\",\n  height: \"21px\"\n}), x1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#FFC107\",\n      d: \"M43.611,20.083H42V20H24v8h11.303c-1.649,4.657-6.08,8-11.303,8c-6.627,0-12-5.373-12-12c0-6.627,5.373-12,12-12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C12.955,4,4,12.955,4,24c0,11.045,8.955,20,20,20c11.045,0,20-8.955,20-20C44,22.659,43.862,21.35,43.611,20.083z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#FF3D00\",\n      d: \"M6.306,14.691l6.571,4.819C14.655,15.108,18.961,12,24,12c3.059,0,5.842,1.154,7.961,3.039l5.657-5.657C34.046,6.053,29.268,4,24,4C16.318,4,9.656,8.337,6.306,14.691z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#4CAF50\",\n      d: \"M24,44c5.166,0,9.86-1.977,13.409-5.192l-6.19-5.238C29.211,35.091,26.715,36,24,36c-5.202,0-9.619-3.317-11.283-7.946l-6.522,5.025C9.505,39.556,16.227,44,24,44z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#1976D2\",\n      d: \"M43.611,20.083H42V20H24v8h11.303c-0.792,2.237-2.231,4.166-4.087,5.571c0.001-0.001,0.002-0.001,0.003-0.002l6.19,5.238C36.971,39.205,44,34,44,24C44,22.659,43.862,21.35,43.611,20.083z\"\n    }\n  )\n), y1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#039be5\", d: \"M24 5A19 19 0 1 0 24 43A19 19 0 1 0 24 5Z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#fff\",\n      d: \"M26.572,29.036h4.917l0.772-4.995h-5.69v-2.73c0-2.075,0.678-3.915,2.619-3.915h3.119v-4.359c-0.548-0.074-1.707-0.236-3.897-0.236c-4.573,0-7.254,2.415-7.254,7.917v3.323h-4.701v4.995h4.701v13.729C22.089,42.905,23.032,43,24,43c0.875,0,1.729-0.08,2.572-0.194V29.036z\"\n    }\n  )\n), p1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#03A9F4\",\n      d: \"M42,12.429c-1.323,0.586-2.746,0.977-4.247,1.162c1.526-0.906,2.7-2.351,3.251-4.058c-1.428,0.837-3.01,1.452-4.693,1.776C34.967,9.884,33.05,9,30.926,9c-4.08,0-7.387,3.278-7.387,7.32c0,0.572,0.067,1.129,0.193,1.67c-6.138-0.308-11.582-3.226-15.224-7.654c-0.64,1.082-1,2.349-1,3.686c0,2.541,1.301,4.778,3.285,6.096c-1.211-0.037-2.351-0.374-3.349-0.914c0,0.022,0,0.055,0,0.086c0,3.551,2.547,6.508,5.923,7.181c-0.617,0.169-1.269,0.263-1.941,0.263c-0.477,0-0.942-0.054-1.392-0.135c0.94,2.902,3.667,5.023,6.898,5.086c-2.528,1.96-5.712,3.134-9.174,3.134c-0.598,0-1.183-0.034-1.761-0.104C9.268,36.786,13.152,38,17.321,38c13.585,0,21.017-11.156,21.017-20.834c0-0.317-0.01-0.633-0.025-0.945C39.763,15.197,41.013,13.905,42,12.429\"\n    }\n  )\n), L1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    fill: \"gray\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 24 24\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  \" \",\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { d: \"M 15.904297 1.078125 C 15.843359 1.06875 15.774219 1.0746094 15.699219 1.0996094 C 14.699219 1.2996094 13.600391 1.8996094 12.900391 2.5996094 C 12.300391 3.1996094 11.800781 4.1996094 11.800781 5.0996094 C 11.800781 5.2996094 11.999219 5.5 12.199219 5.5 C 13.299219 5.4 14.399609 4.7996094 15.099609 4.0996094 C 15.699609 3.2996094 16.199219 2.4 16.199219 1.5 C 16.199219 1.275 16.087109 1.10625 15.904297 1.078125 z M 16.199219 5.4003906 C 14.399219 5.4003906 13.600391 6.5 12.400391 6.5 C 11.100391 6.5 9.9003906 5.5 8.4003906 5.5 C 6.3003906 5.5 3.0996094 7.4996094 3.0996094 12.099609 C 2.9996094 16.299609 6.8 21 9 21 C 10.3 21 10.600391 20.199219 12.400391 20.199219 C 14.200391 20.199219 14.600391 21 15.900391 21 C 17.400391 21 18.500391 19.399609 19.400391 18.099609 C 19.800391 17.399609 20.100391 17.000391 20.400391 16.400391 C 20.600391 16.000391 20.4 15.600391 20 15.400391 C 17.4 14.100391 16.900781 9.9003906 19.800781 8.4003906 C 20.300781 8.1003906 20.4 7.4992188 20 7.1992188 C 18.9 6.1992187 17.299219 5.4003906 16.199219 5.4003906 z\" })\n), b1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    fill: \"gray\",\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 30 30\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  \" \",\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { d: \"M15,3C8.373,3,3,8.373,3,15c0,5.623,3.872,10.328,9.092,11.63C12.036,26.468,12,26.28,12,26.047v-2.051 c-0.487,0-1.303,0-1.508,0c-0.821,0-1.551-0.353-1.905-1.009c-0.393-0.729-0.461-1.844-1.435-2.526 c-0.289-0.227-0.069-0.486,0.264-0.451c0.615,0.174,1.125,0.596,1.605,1.222c0.478,0.627,0.703,0.769,1.596,0.769 c0.433,0,1.081-0.025,1.691-0.121c0.328-0.833,0.895-1.6,1.588-1.962c-3.996-0.411-5.903-2.399-5.903-5.098 c0-1.162,0.495-2.286,1.336-3.233C9.053,10.647,8.706,8.73,9.435,8c1.798,0,2.885,1.166,3.146,1.481C13.477,9.174,14.461,9,15.495,9 c1.036,0,2.024,0.174,2.922,0.483C18.675,9.17,19.763,8,21.565,8c0.732,0.731,0.381,2.656,0.102,3.594 c0.836,0.945,1.328,2.066,1.328,3.226c0,2.697-1.904,4.684-5.894,5.097C18.199,20.49,19,22.1,19,23.313v2.734 c0,0.104-0.023,0.179-0.035,0.268C23.641,24.676,27,20.236,27,15C27,8.373,21.627,3,15,3z\" })\n), S1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#e53935\", d: \"M24 43L16 20 32 20z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#ff7043\", d: \"M24 43L42 20 32 20z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#e53935\", d: \"M37 5L42 20 32 20z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#ffa726\", d: \"M24 43L42 20 45 28z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#ff7043\", d: \"M24 43L6 20 16 20z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#e53935\", d: \"M11 5L6 20 16 20z\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { fill: \"#ffa726\", d: \"M24 43L6 20 3 28z\" })\n), M1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    width: \"512\",\n    height: \"512\",\n    viewBox: \"0 0 62.42 62.42\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"defs\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"linearGradient\",\n    {\n      id: \"New_Gradient_Swatch_1\",\n      x1: \"64.01\",\n      y1: \"30.27\",\n      x2: \"32.99\",\n      y2: \"54.48\",\n      gradientUnits: \"userSpaceOnUse\"\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"0.18\", stopColor: \"#0052cc\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"1\", stopColor: \"#2684ff\" })\n  )),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"title\", null, \"Bitbucket-blue\"),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"g\", { id: \"Layer_2\", \"data-name\": \"Layer 2\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"g\", { id: \"Blue\", transform: \"translate(0 -3.13)\" }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M2,6.26A2,2,0,0,0,0,8.58L8.49,60.12a2.72,2.72,0,0,0,2.66,2.27H51.88a2,2,0,0,0,2-1.68L62.37,8.59a2,2,0,0,0-2-2.32ZM37.75,43.51h-13L21.23,25.12H40.9Z\",\n      fill: \"#2684ff\"\n    }\n  ), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M59.67,25.12H40.9L37.75,43.51h-13L9.4,61.73a2.71,2.71,0,0,0,1.75.66H51.89a2,2,0,0,0,2-1.68Z\",\n      fill: \"url(#New_Gradient_Swatch_1)\"\n    }\n  )))\n), k1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#536dfe\",\n      d: \"M39.248,10.177c-2.804-1.287-5.812-2.235-8.956-2.778c-0.057-0.01-0.114,0.016-0.144,0.068\tc-0.387,0.688-0.815,1.585-1.115,2.291c-3.382-0.506-6.747-0.506-10.059,0c-0.3-0.721-0.744-1.603-1.133-2.291\tc-0.03-0.051-0.087-0.077-0.144-0.068c-3.143,0.541-6.15,1.489-8.956,2.778c-0.024,0.01-0.045,0.028-0.059,0.051\tc-5.704,8.522-7.267,16.835-6.5,25.044c0.003,0.04,0.026,0.079,0.057,0.103c3.763,2.764,7.409,4.442,10.987,5.554\tc0.057,0.017,0.118-0.003,0.154-0.051c0.846-1.156,1.601-2.374,2.248-3.656c0.038-0.075,0.002-0.164-0.076-0.194\tc-1.197-0.454-2.336-1.007-3.432-1.636c-0.087-0.051-0.094-0.175-0.014-0.234c0.231-0.173,0.461-0.353,0.682-0.534\tc0.04-0.033,0.095-0.04,0.142-0.019c7.201,3.288,14.997,3.288,22.113,0c0.047-0.023,0.102-0.016,0.144,0.017\tc0.22,0.182,0.451,0.363,0.683,0.536c0.08,0.059,0.075,0.183-0.012,0.234c-1.096,0.641-2.236,1.182-3.434,1.634\tc-0.078,0.03-0.113,0.12-0.075,0.196c0.661,1.28,1.415,2.498,2.246,3.654c0.035,0.049,0.097,0.07,0.154,0.052\tc3.595-1.112,7.241-2.79,11.004-5.554c0.033-0.024,0.054-0.061,0.057-0.101c0.917-9.491-1.537-17.735-6.505-25.044\tC39.293,10.205,39.272,10.187,39.248,10.177z M16.703,30.273c-2.168,0-3.954-1.99-3.954-4.435s1.752-4.435,3.954-4.435\tc2.22,0,3.989,2.008,3.954,4.435C20.658,28.282,18.906,30.273,16.703,30.273z M31.324,30.273c-2.168,0-3.954-1.99-3.954-4.435\ts1.752-4.435,3.954-4.435c2.22,0,3.989,2.008,3.954,4.435C35.278,28.282,33.544,30.273,31.324,30.273z\"\n    }\n  )\n), N1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"linearGradient\",\n    {\n      id: \"k8yl7~hDat~FaoWq8WjN6a\",\n      x1: \"-1254.397\",\n      x2: \"-1261.911\",\n      y1: \"877.268\",\n      y2: \"899.466\",\n      gradientTransform: \"translate(1981.75 -1362.063) scale(1.5625)\",\n      gradientUnits: \"userSpaceOnUse\"\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"0\", stopColor: \"#114a8b\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"1\", stopColor: \"#0669bc\" })\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"url(#k8yl7~hDat~FaoWq8WjN6a)\",\n      d: \"M17.634,6h11.305L17.203,40.773c-0.247,0.733-0.934,1.226-1.708,1.226H6.697 c-0.994,0-1.8-0.806-1.8-1.8c0-0.196,0.032-0.39,0.094-0.576L15.926,7.227C16.173,6.494,16.86,6,17.634,6L17.634,6z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#0078d4\",\n      d: \"M34.062,29.324H16.135c-0.458-0.001-0.83,0.371-0.831,0.829c0,0.231,0.095,0.451,0.264,0.608 l11.52,10.752C27.423,41.826,27.865,42,28.324,42h10.151L34.062,29.324z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"linearGradient\",\n    {\n      id: \"k8yl7~hDat~FaoWq8WjN6b\",\n      x1: \"-1252.05\",\n      x2: \"-1253.788\",\n      y1: \"887.612\",\n      y2: \"888.2\",\n      gradientTransform: \"translate(1981.75 -1362.063) scale(1.5625)\",\n      gradientUnits: \"userSpaceOnUse\"\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"0\", stopOpacity: \".3\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \".071\", stopOpacity: \".2\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \".321\", stopOpacity: \".1\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \".623\", stopOpacity: \".05\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"1\", stopOpacity: \"0\" })\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"url(#k8yl7~hDat~FaoWq8WjN6b)\",\n      d: \"M17.634,6c-0.783-0.003-1.476,0.504-1.712,1.25L5.005,39.595 c-0.335,0.934,0.151,1.964,1.085,2.299C6.286,41.964,6.493,42,6.702,42h9.026c0.684-0.122,1.25-0.603,1.481-1.259l2.177-6.416 l7.776,7.253c0.326,0.27,0.735,0.419,1.158,0.422h10.114l-4.436-12.676l-12.931,0.003L28.98,6H17.634z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"linearGradient\",\n    {\n      id: \"k8yl7~hDat~FaoWq8WjN6c\",\n      x1: \"-1252.952\",\n      x2: \"-1244.704\",\n      y1: \"876.6\",\n      y2: \"898.575\",\n      gradientTransform: \"translate(1981.75 -1362.063) scale(1.5625)\",\n      gradientUnits: \"userSpaceOnUse\"\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"0\", stopColor: \"#3ccbf4\" }),\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"stop\", { offset: \"1\", stopColor: \"#2892df\" })\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"url(#k8yl7~hDat~FaoWq8WjN6c)\",\n      d: \"M32.074,7.225C31.827,6.493,31.141,6,30.368,6h-12.6c0.772,0,1.459,0.493,1.705,1.224 l10.935,32.399c0.318,0.942-0.188,1.963-1.13,2.281C29.093,41.968,28.899,42,28.703,42h12.6c0.994,0,1.8-0.806,1.8-1.801 c0-0.196-0.032-0.39-0.095-0.575L32.074,7.225z\"\n    }\n  )\n), F1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    width: \"512\",\n    height: \"512\",\n    viewBox: \"0 0 512 512\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M472.136 163.959H408.584C407.401 163.959 406.218 163.327 405.666 162.3L354.651 73.6591C354.02 72.632 352.916 72 351.654 72H143.492C142.309 72 141.126 72.632 140.574 73.6591L87.5084 165.618L36.414 254.259C35.862 255.286 35.862 256.55 36.414 257.656L87.5084 346.297L140.495 438.335C141.047 439.362 142.23 440.073 143.413 439.994H351.654C352.837 439.994 354.02 439.362 354.651 438.335L405.745 349.694C406.297 348.667 407.48 347.956 408.663 348.035H472.215C474.344 348.035 476 346.297 476 344.243V167.83C475.921 165.697 474.186 163.959 472.136 163.959ZM228.728 349.694L212.721 377.345C212.485 377.74 212.091 378.135 211.696 378.372C211.223 378.609 210.75 378.767 210.198 378.767H178.422C177.318 378.767 176.293 378.214 175.82 377.187L128.431 294.787L123.779 286.65L106.748 257.498C106.511 257.103 106.353 256.629 106.432 256.076C106.432 255.602 106.59 255.049 106.827 254.654L123.937 224.949L175.899 134.886C176.451 133.938 177.476 133.306 178.501 133.306H210.198C210.75 133.306 211.302 133.464 211.854 133.701C212.248 133.938 212.643 134.254 212.879 134.728L228.886 162.537C229.359 163.485 229.28 164.67 228.728 165.539L177.397 254.654C177.16 255.049 177.081 255.523 177.081 255.918C177.081 256.392 177.239 256.787 177.397 257.182L228.728 346.218C229.438 347.403 229.359 348.667 228.728 349.694V349.694ZM388.083 257.498L371.051 286.65L366.399 294.787L319.011 377.187C318.459 378.135 317.512 378.767 316.409 378.767H284.632C284.08 378.767 283.607 378.609 283.134 378.372C282.74 378.135 282.346 377.819 282.109 377.345L266.103 349.694C265.393 348.667 265.393 347.403 266.024 346.376L317.355 257.34C317.591 256.945 317.67 256.471 317.67 256.076C317.67 255.602 317.513 255.207 317.355 254.812L266.024 165.697C265.472 164.749 265.393 163.643 265.866 162.695L281.873 134.886C282.109 134.491 282.503 134.096 282.898 133.859C283.371 133.543 283.923 133.464 284.553 133.464H316.409C317.512 133.464 318.538 134.017 319.011 135.044L370.972 225.107L388.083 254.812C388.319 255.286 388.477 255.76 388.477 256.234C388.477 256.55 388.319 257.024 388.083 257.498V257.498Z\",\n      fill: \"#008AAA\"\n    }\n  )\n), z1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#0288D1\",\n      d: \"M42,37c0,2.762-2.238,5-5,5H11c-2.761,0-5-2.238-5-5V11c0-2.762,2.239-5,5-5h26c2.762,0,5,2.238,5,5V37z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#FFF\",\n      d: \"M12 19H17V36H12zM14.485 17h-.028C12.965 17 12 15.888 12 14.499 12 13.08 12.995 12 14.514 12c1.521 0 2.458 1.08 2.486 2.499C17 15.887 16.035 17 14.485 17zM36 36h-5v-9.099c0-2.198-1.225-3.698-3.192-3.698-1.501 0-2.313 1.012-2.707 1.99C24.957 25.543 25 26.511 25 27v9h-5V19h5v2.616C25.721 20.5 26.85 19 29.738 19c3.578 0 6.261 2.25 6.261 7.274L36 36 36 36z\"\n    }\n  )\n), D1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\",\n    fillRule: \"evenodd\",\n    clipRule: \"evenodd\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#fff\",\n      fillRule: \"evenodd\",\n      d: \"M11.553,11.099c1.232,1.001,1.694,0.925,4.008,0.77 l21.812-1.31c0.463,0,0.078-0.461-0.076-0.538l-3.622-2.619c-0.694-0.539-1.619-1.156-3.391-1.002l-21.12,1.54 c-0.77,0.076-0.924,0.461-0.617,0.77L11.553,11.099z\",\n      clipRule: \"evenodd\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#fff\",\n      fillRule: \"evenodd\",\n      d: \"M12.862,16.182v22.95c0,1.233,0.616,1.695,2.004,1.619 l23.971-1.387c1.388-0.076,1.543-0.925,1.543-1.927V14.641c0-1-0.385-1.54-1.234-1.463l-25.05,1.463 C13.171,14.718,12.862,15.181,12.862,16.182L12.862,16.182z\",\n      clipRule: \"evenodd\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#424242\",\n      fillRule: \"evenodd\",\n      d: \"M11.553,11.099c1.232,1.001,1.694,0.925,4.008,0.77 l21.812-1.31c0.463,0,0.078-0.461-0.076-0.538l-3.622-2.619c-0.694-0.539-1.619-1.156-3.391-1.002l-21.12,1.54 c-0.77,0.076-0.924,0.461-0.617,0.77L11.553,11.099z M12.862,16.182v22.95c0,1.233,0.616,1.695,2.004,1.619l23.971-1.387 c1.388-0.076,1.543-0.925,1.543-1.927V14.641c0-1-0.385-1.54-1.234-1.463l-25.05,1.463C13.171,14.718,12.862,15.181,12.862,16.182 L12.862,16.182z M36.526,17.413c0.154,0.694,0,1.387-0.695,1.465l-1.155,0.23v16.943c-1.003,0.539-1.928,0.847-2.698,0.847 c-1.234,0-1.543-0.385-2.467-1.54l-7.555-11.86v11.475l2.391,0.539c0,0,0,1.386-1.929,1.386l-5.317,0.308 c-0.154-0.308,0-1.078,0.539-1.232l1.388-0.385V20.418l-1.927-0.154c-0.155-0.694,0.23-1.694,1.31-1.772l5.704-0.385l7.862,12.015 V19.493l-2.005-0.23c-0.154-0.848,0.462-1.464,1.233-1.54L36.526,17.413z M7.389,5.862l21.968-1.618 c2.698-0.231,3.392-0.076,5.087,1.155l7.013,4.929C42.614,11.176,43,11.407,43,12.33v27.032c0,1.694-0.617,2.696-2.775,2.849 l-25.512,1.541c-1.62,0.077-2.391-0.154-3.239-1.232l-5.164-6.7C5.385,34.587,5,33.664,5,32.585V8.556 C5,7.171,5.617,6.015,7.389,5.862z\",\n      clipRule: \"evenodd\"\n    }\n  )\n), $1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    xmlns: \"http://www.w3.org/2000/svg\",\n    viewBox: \"0 0 48 48\",\n    width: \"21px\",\n    height: \"21px\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#33d375\",\n      d: \"M33,8c0-2.209-1.791-4-4-4s-4,1.791-4,4c0,1.254,0,9.741,0,11c0,2.209,1.791,4,4,4s4-1.791,4-4\tC33,17.741,33,9.254,33,8z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#33d375\",\n      d: \"M43,19c0,2.209-1.791,4-4,4c-1.195,0-4,0-4,0s0-2.986,0-4c0-2.209,1.791-4,4-4S43,16.791,43,19z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#40c4ff\",\n      d: \"M8,14c-2.209,0-4,1.791-4,4s1.791,4,4,4c1.254,0,9.741,0,11,0c2.209,0,4-1.791,4-4s-1.791-4-4-4\tC17.741,14,9.254,14,8,14z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#40c4ff\",\n      d: \"M19,4c2.209,0,4,1.791,4,4c0,1.195,0,4,0,4s-2.986,0-4,0c-2.209,0-4-1.791-4-4S16.791,4,19,4z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#e91e63\",\n      d: \"M14,39.006C14,41.212,15.791,43,18,43s4-1.788,4-3.994c0-1.252,0-9.727,0-10.984\tc0-2.206-1.791-3.994-4-3.994s-4,1.788-4,3.994C14,29.279,14,37.754,14,39.006z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#e91e63\",\n      d: \"M4,28.022c0-2.206,1.791-3.994,4-3.994c1.195,0,4,0,4,0s0,2.981,0,3.994c0,2.206-1.791,3.994-4,3.994\tS4,30.228,4,28.022z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#ffc107\",\n      d: \"M39,33c2.209,0,4-1.791,4-4s-1.791-4-4-4c-1.254,0-9.741,0-11,0c-2.209,0-4,1.791-4,4s1.791,4,4,4\tC29.258,33,37.746,33,39,33z\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      fill: \"#ffc107\",\n      d: \"M28,43c-2.209,0-4-1.791-4-4c0-1.195,0-4,0-4s2.986,0,4,0c2.209,0,4,1.791,4,4S30.209,43,28,43z\"\n    }\n  )\n), B1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    width: \"512\",\n    height: \"512\",\n    viewBox: \"0 0 512 512\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M255.498 31.0034C131.513 31.0034 31 131.515 31 255.502C31 379.492 131.513 480 255.498 480C379.497 480 480 379.495 480 255.502C480 131.522 379.497 31.0135 255.495 31.0135L255.498 31V31.0034ZM358.453 354.798C354.432 361.391 345.801 363.486 339.204 359.435C286.496 327.237 220.139 319.947 141.993 337.801C134.463 339.516 126.957 334.798 125.24 327.264C123.516 319.731 128.217 312.225 135.767 310.511C221.284 290.972 294.639 299.384 353.816 335.549C360.413 339.596 362.504 348.2 358.453 354.798ZM385.932 293.67C380.864 301.903 370.088 304.503 361.858 299.438C301.512 262.345 209.528 251.602 138.151 273.272C128.893 276.067 119.118 270.851 116.309 261.61C113.521 252.353 118.74 242.597 127.981 239.782C209.512 215.044 310.87 227.026 380.17 269.612C388.4 274.68 391 285.456 385.935 293.676V293.673L385.932 293.67ZM388.293 230.016C315.935 187.039 196.56 183.089 127.479 204.055C116.387 207.42 104.654 201.159 101.293 190.063C97.9326 178.964 104.189 167.241 115.289 163.87C194.59 139.796 326.418 144.446 409.723 193.902C419.722 199.826 422.995 212.71 417.068 222.675C411.168 232.653 398.247 235.943 388.303 230.016H388.293V230.016Z\",\n      fill: \"#1ED760\"\n    }\n  )\n), H1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    width: \"512\",\n    height: \"512\",\n    viewBox: \"0 0 512 512\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { d: \"M416 240L352 304H288L232 360V304H160V64H416V240Z\", fill: \"white\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M144 32L64 112V400H160V480L240 400H304L448 256V32H144ZM416 240L352 304H288L232 360V304H160V64H416V240Z\",\n      fill: \"#9146FF\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { d: \"M368 120H336V216H368V120Z\", fill: \"#9146FF\" }),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"path\", { d: \"M280 120H248V216H280V120Z\", fill: \"#9146FF\" })\n), P1 = () => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  \"svg\",\n  {\n    className: L(),\n    width: \"512\",\n    height: \"512\",\n    viewBox: \"0 0 512 512\",\n    fill: \"none\",\n    xmlns: \"http://www.w3.org/2000/svg\"\n  },\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M33 256.043C33 264.556 35.3159 273.069 39.4845 280.202L117.993 415.493C126.098 429.298 138.373 440.572 153.657 445.634C183.764 455.528 214.797 442.873 229.618 417.333L248.609 384.661L173.806 256.043L252.777 119.831L271.768 87.1591C277.557 77.2654 284.968 69.4424 294 63H285.894H172.185C150.878 63 131.193 74.2742 120.54 92.6812L39.7161 231.884C35.3159 239.016 33 247.53 33 256.043Z\",\n      fill: \"#6363F1\"\n    }\n  ),\n  /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"path\",\n    {\n      d: \"M480 256.058C480 247.539 477.684 239.021 473.516 231.883L393.849 94.6596C379.028 69.3331 347.995 56.4396 317.888 66.34C302.603 71.4053 290.329 82.6871 282.224 96.5015L264.391 127.354L339.194 256.058L260.223 392.131L241.232 424.825C235.443 434.495 228.032 442.553 219 449H227.106H340.815C362.122 449 381.807 437.718 392.46 419.299L473.284 280.003C477.684 272.866 480 264.577 480 256.058Z\",\n      fill: \"#6363F1\"\n    }\n  )\n), I1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({\n  __proto__: null,\n  apple: L1,\n  azure: N1,\n  bitbucket: M1,\n  discord: k1,\n  facebook: y1,\n  github: b1,\n  gitlab: S1,\n  google: x1,\n  keycloak: F1,\n  linkedin: z1,\n  notion: D1,\n  slack: $1,\n  spotify: B1,\n  twitch: H1,\n  twitter: p1,\n  workos: P1\n}, Symbol.toStringTag, { value: \"Module\" }));\nfunction V1({\n  supabaseClient: t,\n  socialLayout: l = \"vertical\",\n  providers: n = [\"github\", \"google\", \"azure\"],\n  providerScopes: r,\n  queryParams: o,\n  redirectTo: v,\n  onlyThirdPartyProviders: E = !0,\n  view: C = \"sign_in\",\n  i18n: w,\n  appearance: d\n}) {\n  const [a, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), _ = l === \"vertical\", i = C === \"magic_link\" ? \"sign_in\" : C, x = async (g) => {\n    m(!0);\n    const { error: s } = await t.auth.signInWithOAuth({\n      provider: g,\n      options: {\n        redirectTo: v,\n        scopes: r == null ? void 0 : r[g],\n        queryParams: o\n      }\n    });\n    s && y(s.message), m(!1);\n  };\n  function h(g) {\n    const s = g.toLowerCase();\n    return g.charAt(0).toUpperCase() + s.slice(1);\n  }\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, n && n.length > 0 && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { gap: \"large\", direction: \"vertical\", appearance: d }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    z,\n    {\n      direction: _ ? \"vertical\" : \"horizontal\",\n      gap: _ ? \"small\" : \"medium\",\n      appearance: d\n    },\n    n.map((g) => {\n      var M;\n      const s = I1[g];\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        A,\n        {\n          key: g,\n          color: \"default\",\n          icon: s ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(s, null) : \"\",\n          loading: a,\n          onClick: () => x(g),\n          appearance: d\n        },\n        _ && (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.template)(\n          (M = w == null ? void 0 : w[i]) == null ? void 0 : M.social_provider_text,\n          {\n            provider: h(g)\n          }\n        )\n      );\n    })\n  )), !E && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(C1, { appearance: d })));\n}\nfunction Q({\n  authView: t = \"sign_in\",\n  defaultEmail: l = \"\",\n  defaultPassword: n = \"\",\n  setAuthView: r = () => {\n  },\n  setDefaultEmail: o = (_) => {\n  },\n  setDefaultPassword: v = (_) => {\n  },\n  supabaseClient: E,\n  showLinks: C = !1,\n  redirectTo: w,\n  additionalData: d,\n  magicLink: a,\n  i18n: m,\n  appearance: c,\n  children: y\n}) {\n  var T, G, Z, j;\n  const _ = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(!0), [i, x] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(l), [h, g] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(n), [s, M] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [b, $] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), [P, U] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\");\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => (_.current = !0, x(l), g(n), () => {\n    _.current = !1;\n  }), [t]);\n  const O = async (S) => {\n    var q;\n    switch (S.preventDefault(), M(\"\"), $(!0), t) {\n      case \"sign_in\":\n        const { error: K } = await E.auth.signInWithPassword({\n          email: i,\n          password: h\n        });\n        K && M(K.message);\n        break;\n      case \"sign_up\":\n        let Y = {\n          emailRedirectTo: w\n        };\n        d && (Y.data = d);\n        const {\n          data: { user: o1, session: r1 },\n          error: J\n        } = await E.auth.signUp({\n          email: i,\n          password: h,\n          options: Y\n        });\n        J ? M(J.message) : o1 && !r1 && U((q = m == null ? void 0 : m.sign_up) == null ? void 0 : q.confirmation_text);\n        break;\n    }\n    _.current && $(!1);\n  }, F = (S) => {\n    o(i), v(h), r(S);\n  }, f = m == null ? void 0 : m[t];\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    \"form\",\n    {\n      id: t === \"sign_in\" ? \"auth-sign-in\" : \"auth-sign-up\",\n      onSubmit: O,\n      autoComplete: \"on\",\n      style: { width: \"100%\" }\n    },\n    /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { direction: \"vertical\", gap: \"large\", appearance: c }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { direction: \"vertical\", gap: \"large\", appearance: c }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"email\", appearance: c }, f == null ? void 0 : f.email_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      B,\n      {\n        id: \"email\",\n        type: \"email\",\n        name: \"email\",\n        placeholder: f == null ? void 0 : f.email_input_placeholder,\n        defaultValue: i,\n        onChange: (S) => x(S.target.value),\n        autoComplete: \"email\",\n        appearance: c\n      }\n    )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"password\", appearance: c }, f == null ? void 0 : f.password_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      B,\n      {\n        id: \"password\",\n        type: \"password\",\n        name: \"password\",\n        placeholder: f == null ? void 0 : f.password_input_placeholder,\n        defaultValue: h,\n        onChange: (S) => g(S.target.value),\n        autoComplete: t === \"sign_in\" ? \"current-password\" : \"new-password\",\n        appearance: c\n      }\n    )), y), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      A,\n      {\n        type: \"submit\",\n        color: \"primary\",\n        loading: b,\n        appearance: c\n      },\n      b ? f == null ? void 0 : f.loading_button_label : f == null ? void 0 : f.button_label\n    ), C && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { direction: \"vertical\", gap: \"small\", appearance: c }, t === _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN && a && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      I,\n      {\n        href: \"#auth-magic-link\",\n        onClick: (S) => {\n          S.preventDefault(), r(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.MAGIC_LINK);\n        },\n        appearance: c\n      },\n      (T = m == null ? void 0 : m.magic_link) == null ? void 0 : T.link_text\n    ), t === _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      I,\n      {\n        href: \"#auth-forgot-password\",\n        onClick: (S) => {\n          S.preventDefault(), r(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.FORGOTTEN_PASSWORD);\n        },\n        appearance: c\n      },\n      (G = m == null ? void 0 : m.forgotten_password) == null ? void 0 : G.link_text\n    ), t === _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      I,\n      {\n        href: \"#auth-sign-up\",\n        onClick: (S) => {\n          S.preventDefault(), F(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_UP);\n        },\n        appearance: c\n      },\n      (Z = m == null ? void 0 : m.sign_up) == null ? void 0 : Z.link_text\n    ) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n      I,\n      {\n        href: \"#auth-sign-in\",\n        onClick: (S) => {\n          S.preventDefault(), F(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n        },\n        appearance: c\n      },\n      (j = m == null ? void 0 : m.sign_in) == null ? void 0 : j.link_text\n    ))),\n    P && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { appearance: c }, P),\n    s && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { color: \"danger\", appearance: c }, s)\n  );\n}\nfunction e1({\n  setAuthView: t = () => {\n  },\n  supabaseClient: l,\n  redirectTo: n,\n  i18n: r,\n  appearance: o,\n  showLinks: v = !1\n}) {\n  var x;\n  const [E, C] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [w, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [a, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), _ = async (h) => {\n    var s;\n    h.preventDefault(), d(\"\"), m(\"\"), y(!0);\n    const { error: g } = await l.auth.resetPasswordForEmail(E, {\n      redirectTo: n\n    });\n    g ? d(g.message) : m((s = r == null ? void 0 : r.forgotten_password) == null ? void 0 : s.confirmation_text), y(!1);\n  }, i = r == null ? void 0 : r.forgotten_password;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", { id: \"auth-forgot-password\", onSubmit: _ }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { gap: \"large\", direction: \"vertical\", appearance: o }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"email\", appearance: o }, i == null ? void 0 : i.email_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    B,\n    {\n      id: \"email\",\n      name: \"email\",\n      type: \"email\",\n      autoFocus: !0,\n      placeholder: i == null ? void 0 : i.email_input_placeholder,\n      onChange: (h) => C(h.target.value),\n      appearance: o\n    }\n  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    A,\n    {\n      type: \"submit\",\n      color: \"primary\",\n      loading: c,\n      appearance: o\n    },\n    c ? i == null ? void 0 : i.loading_button_label : i == null ? void 0 : i.button_label\n  ), v && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    I,\n    {\n      href: \"#auth-sign-in\",\n      onClick: (h) => {\n        h.preventDefault(), t(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n      },\n      appearance: o\n    },\n    (x = r == null ? void 0 : r.sign_in) == null ? void 0 : x.link_text\n  ), a && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { appearance: o }, a), w && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { color: \"danger\", appearance: o }, w)));\n}\nfunction t1({\n  supabaseClient: t,\n  i18n: l,\n  appearance: n\n}) {\n  const [r, o] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [v, E] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [C, w] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [d, a] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), m = async (y) => {\n    var i;\n    y.preventDefault(), E(\"\"), w(\"\"), a(!0);\n    const { error: _ } = await t.auth.updateUser({ password: r });\n    _ ? E(_.message) : w((i = l == null ? void 0 : l.update_password) == null ? void 0 : i.confirmation_text), a(!1);\n  }, c = l == null ? void 0 : l.update_password;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", { id: \"auth-update-password\", onSubmit: m }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { gap: \"large\", direction: \"vertical\", appearance: n }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"password\", appearance: n }, c == null ? void 0 : c.password_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    B,\n    {\n      id: \"password\",\n      name: \"password\",\n      placeholder: c == null ? void 0 : c.password_label,\n      type: \"password\",\n      autoFocus: !0,\n      onChange: (y) => o(y.target.value),\n      appearance: n\n    }\n  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    A,\n    {\n      type: \"submit\",\n      color: \"primary\",\n      loading: d,\n      appearance: n\n    },\n    d ? c == null ? void 0 : c.loading_button_label : c == null ? void 0 : c.button_label\n  ), C && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { appearance: n }, C), v && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { color: \"danger\", appearance: n }, v)));\n}\nfunction A1({\n  setAuthView: t = () => {\n  },\n  supabaseClient: l,\n  otpType: n = \"email\",\n  i18n: r,\n  appearance: o,\n  showLinks: v = !1\n}) {\n  var M;\n  const [E, C] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [w, d] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [a, m] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [c, y] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [_, i] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [x, h] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(!1), g = async (b) => {\n    b.preventDefault(), y(\"\"), i(\"\"), h(!0);\n    let $ = {\n      email: E,\n      token: a,\n      type: n\n    };\n    [\"sms\", \"phone_change\"].includes(n) && ($ = {\n      phone: w,\n      token: a,\n      type: n\n    });\n    const { error: P } = await l.auth.verifyOtp($);\n    P && y(P.message), h(!1);\n  }, s = r == null ? void 0 : r.verify_otp;\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"form\", { id: \"auth-magic-link\", onSubmit: g }, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(z, { gap: \"large\", direction: \"vertical\", appearance: o }, [\"sms\", \"phone_change\"].includes(n) ? /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"phone\", appearance: o }, s == null ? void 0 : s.phone_input_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    B,\n    {\n      id: \"phone\",\n      name: \"phone\",\n      type: \"text\",\n      autoFocus: !0,\n      placeholder: s == null ? void 0 : s.phone_input_placeholder,\n      onChange: (b) => d(b.target.value),\n      appearance: o\n    }\n  )) : /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"email\", appearance: o }, s == null ? void 0 : s.email_input_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    B,\n    {\n      id: \"email\",\n      name: \"email\",\n      type: \"email\",\n      autoFocus: !0,\n      placeholder: s == null ? void 0 : s.email_input_placeholder,\n      onChange: (b) => C(b.target.value),\n      appearance: o\n    }\n  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(H, { htmlFor: \"token\", appearance: o }, s == null ? void 0 : s.token_input_label), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    B,\n    {\n      id: \"token\",\n      name: \"token\",\n      type: \"text\",\n      placeholder: s == null ? void 0 : s.token_input_placeholder,\n      onChange: (b) => m(b.target.value),\n      appearance: o\n    }\n  )), /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    A,\n    {\n      color: \"primary\",\n      type: \"submit\",\n      loading: x,\n      appearance: o\n    },\n    x ? s == null ? void 0 : s.loading_button_label : s == null ? void 0 : s.button_label\n  ), v && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n    I,\n    {\n      href: \"#auth-sign-in\",\n      onClick: (b) => {\n        b.preventDefault(), t(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN);\n      },\n      appearance: o\n    },\n    (M = r == null ? void 0 : r.sign_in) == null ? void 0 : M.link_text\n  ), _ && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { appearance: o }, _), c && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(N, { color: \"danger\", appearance: o }, c)));\n}\nconst l1 = (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)({ user: null, session: null }), U1 = (t) => {\n  const { supabaseClient: l } = t, [n, r] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null), [o, v] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)((n == null ? void 0 : n.user) ?? null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    (async () => {\n      var d;\n      const { data: w } = await l.auth.getSession();\n      r(w.session), v(((d = w.session) == null ? void 0 : d.user) ?? null);\n    })();\n    const { data: C } = l.auth.onAuthStateChange(\n      async (w, d) => {\n        r(d), v((d == null ? void 0 : d.user) ?? null);\n      }\n    );\n    return () => {\n      C == null || C.subscription.unsubscribe();\n    };\n  }, []);\n  const E = {\n    session: n,\n    user: o\n  };\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(l1.Provider, { value: E, ...t });\n}, R1 = () => {\n  const t = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(l1);\n  if (t === void 0)\n    throw new Error(\"useUser must be used within a UserContextProvider.\");\n  return t;\n};\nfunction k({\n  supabaseClient: t,\n  socialLayout: l = \"vertical\",\n  providers: n,\n  providerScopes: r,\n  queryParams: o,\n  view: v = \"sign_in\",\n  redirectTo: E,\n  onlyThirdPartyProviders: C = !1,\n  magicLink: w = !1,\n  showLinks: d = !0,\n  appearance: a,\n  theme: m = \"default\",\n  localization: c = { variables: {} },\n  otpType: y = \"email\",\n  additionalData: _,\n  children: i\n}) {\n  const x = (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.merge)(_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.en, c.variables ?? {}), [h, g] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(v), [s, M] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), [b, $] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"\"), P = h === \"sign_in\" || h === \"sign_up\" || h === \"magic_link\";\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    var F, f;\n    (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.createStitches)({\n      theme: (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.merge)(\n        ((F = a == null ? void 0 : a.theme) == null ? void 0 : F.default) ?? {},\n        ((f = a == null ? void 0 : a.variables) == null ? void 0 : f.default) ?? {}\n      )\n    });\n  }, [a]);\n  const U = ({ children: F }) => {\n    var f;\n    return (\n      // @ts-ignore\n      /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        \"div\",\n        {\n          className: m !== \"default\" ? (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.createTheme)(\n            (0,_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.merge)(\n              // @ts-ignore\n              a == null ? void 0 : a.theme[m],\n              ((f = a == null ? void 0 : a.variables) == null ? void 0 : f[m]) ?? {}\n            )\n          ) : \"\"\n        },\n        P && /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n          V1,\n          {\n            appearance: a,\n            supabaseClient: t,\n            providers: n,\n            providerScopes: r,\n            queryParams: o,\n            socialLayout: l,\n            redirectTo: E,\n            onlyThirdPartyProviders: C,\n            i18n: x,\n            view: h\n          }\n        ),\n        !C && F\n      )\n    );\n  };\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n    const { data: F } = t.auth.onAuthStateChange(\n      (f) => {\n        f === \"PASSWORD_RECOVERY\" ? g(\"update_password\") : f === \"USER_UPDATED\" && g(\"sign_in\");\n      }\n    );\n    return g(v), () => F.subscription.unsubscribe();\n  }, [v]);\n  const O = {\n    supabaseClient: t,\n    setAuthView: g,\n    defaultEmail: s,\n    defaultPassword: b,\n    setDefaultEmail: M,\n    setDefaultPassword: $,\n    redirectTo: E,\n    magicLink: w,\n    showLinks: d,\n    i18n: x,\n    appearance: a\n  };\n  switch (h) {\n    case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_IN:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Q, { ...O, authView: \"sign_in\" }));\n    case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.SIGN_UP:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        Q,\n        {\n          appearance: a,\n          supabaseClient: t,\n          authView: \"sign_up\",\n          setAuthView: g,\n          defaultEmail: s,\n          defaultPassword: b,\n          setDefaultEmail: M,\n          setDefaultPassword: $,\n          redirectTo: E,\n          magicLink: w,\n          showLinks: d,\n          i18n: x,\n          additionalData: _,\n          children: i\n        }\n      ));\n    case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.FORGOTTEN_PASSWORD:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        e1,\n        {\n          appearance: a,\n          supabaseClient: t,\n          setAuthView: g,\n          redirectTo: E,\n          showLinks: d,\n          i18n: x\n        }\n      );\n    case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.MAGIC_LINK:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(U, null, /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        X,\n        {\n          appearance: a,\n          supabaseClient: t,\n          setAuthView: g,\n          redirectTo: E,\n          showLinks: d,\n          i18n: x\n        }\n      ));\n    case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.UPDATE_PASSWORD:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        t1,\n        {\n          appearance: a,\n          supabaseClient: t,\n          i18n: x\n        }\n      );\n    case _supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.VIEWS.VERIFY_OTP:\n      return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n        A1,\n        {\n          appearance: a,\n          supabaseClient: t,\n          otpType: y,\n          i18n: x\n        }\n      );\n    default:\n      return null;\n  }\n}\nk.ForgottenPassword = e1;\nk.UpdatePassword = t1;\nk.MagicLink = X;\nk.UserContextProvider = U1;\nk.useUser = R1;\nconst O1 = (0,_stitches_core__WEBPACK_IMPORTED_MODULE_2__.css)({\n  borderRadius: \"12px\",\n  boxShadow: \"rgba(100, 100, 111, 0.2) 0px 7px 29px 0px\",\n  width: \"360px\",\n  padding: \"28px 32px\"\n}), Z1 = ({\n  children: t,\n  appearance: l\n}) => {\n  const n = [\n    `${_supabase_auth_ui_shared__WEBPACK_IMPORTED_MODULE_0__.PREPENDED_CLASS_NAMES}_ui-card`,\n    O1(),\n    l == null ? void 0 : l.className\n  ];\n  return /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"div\", { className: n.join(\" \") }, t);\n}, j1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  k,\n  {\n    showLinks: !1,\n    ...t,\n    onlyThirdPartyProviders: !1,\n    view: \"sign_up\"\n  }\n), q1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  k,\n  {\n    showLinks: !1,\n    ...t,\n    onlyThirdPartyProviders: !1,\n    view: \"sign_in\"\n  }\n), K1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(k, { ...t, view: \"magic_link\", showLinks: !1 }), Y1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\n  k,\n  {\n    ...t,\n    view: \"sign_in\",\n    showLinks: !1,\n    onlyThirdPartyProviders: !0\n  }\n), J1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(k, { showLinks: !1, ...t, view: \"forgotten_password\" }), Q1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(k, { ...t, view: \"update_password\" }), X1 = (t) => /* @__PURE__ */ react__WEBPACK_IMPORTED_MODULE_1__.createElement(k, { ...t, view: \"verify_otp\" });\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtdWktcmVhY3QvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBbUY7QUFDK0Q7QUFDcEM7QUFDOUcsV0FBVyxtREFBQztBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxVQUFVLGtDQUFrQztBQUM3QztBQUNBLFlBQVksNEVBQUM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixnREFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDLE9BQU8sbURBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLFlBQVksNEVBQUM7QUFDYjtBQUNBLFNBQVMsVUFBVTtBQUNuQjtBQUNBO0FBQ0EseUJBQXlCLGdEQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxDQUFDLE9BQU8sbURBQUM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNE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Qyw4QkFBOEIsZ0RBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZ0RBQWUsTUFBTSx5Q0FBeUMsK0JBQStCLGdEQUFlO0FBQzNJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGdEQUFlLE1BQU0saURBQWlELCtCQUErQixnREFBZSxNQUFNLCtCQUErQiwrQkFBK0IsZ0RBQWUsTUFBTSwwQkFBMEI7QUFXcFEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BzdXBhYmFzZS9hdXRoLXVpLXJlYWN0L2Rpc3QvaW5kZXguZXMuanM/MzY3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBjc3MgYXMgRCwgY3JlYXRlU3RpdGNoZXMgYXMgbjEsIGNyZWF0ZVRoZW1lIGFzIHMxIH0gZnJvbSBcIkBzdGl0Y2hlcy9jb3JlXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUNsYXNzTmFtZXMgYXMgViwgVklFV1MgYXMgcCwgdGVtcGxhdGUgYXMgYzEsIG1lcmdlIGFzIFcsIGVuIGFzIGkxLCBQUkVQRU5ERURfQ0xBU1NfTkFNRVMgYXMgYTEgfSBmcm9tIFwiQHN1cGFiYXNlL2F1dGgtdWktc2hhcmVkXCI7XG5pbXBvcnQgZSwgeyB1c2VTdGF0ZSBhcyB1LCB1c2VSZWYgYXMgbTEsIHVzZUVmZmVjdCBhcyBSLCBjcmVhdGVDb250ZXh0IGFzIGQxLCB1c2VDb250ZXh0IGFzIHUxIH0gZnJvbSBcInJlYWN0XCI7XG5jb25zdCBnMSA9IEQoe1xuICBmb250RmFtaWx5OiBcIiRib2R5Rm9udEZhbWlseVwiLFxuICBmb250U2l6ZTogXCIkYmFzZUJvZHlTaXplXCIsXG4gIG1hcmdpbkJvdHRvbTogXCIkYW5jaG9yQm90dG9tTWFyZ2luXCIsXG4gIGNvbG9yOiBcIiRhbmNob3JUZXh0Q29sb3JcIixcbiAgZGlzcGxheTogXCJibG9ja1wiLFxuICB0ZXh0QWxpZ246IFwiY2VudGVyXCIsXG4gIHRleHREZWNvcmF0aW9uOiBcInVuZGVybGluZVwiLFxuICBcIiY6aG92ZXJcIjoge1xuICAgIGNvbG9yOiBcIiRhbmNob3JUZXh0SG92ZXJDb2xvclwiXG4gIH1cbn0pLCBJID0gKHsgY2hpbGRyZW46IHQsIGFwcGVhcmFuY2U6IGwsIC4uLm4gfSkgPT4ge1xuICB2YXIgbztcbiAgY29uc3QgciA9IFYoXG4gICAgXCJhbmNob3JcIixcbiAgICBnMSgpLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJhXCIsXG4gICAge1xuICAgICAgLi4ubixcbiAgICAgIHN0eWxlOiAobyA9IGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBvLmFuY2hvcixcbiAgICAgIGNsYXNzTmFtZTogci5qb2luKFwiIFwiKVxuICAgIH0sXG4gICAgdFxuICApO1xufSwgaDEgPSBEKHtcbiAgZm9udEZhbWlseTogXCIkYnV0dG9uRm9udEZhbWlseVwiLFxuICBkaXNwbGF5OiBcImZsZXhcIixcbiAgYWxpZ25JdGVtczogXCJjZW50ZXJcIixcbiAganVzdGlmeUNvbnRlbnQ6IFwiY2VudGVyXCIsXG4gIGdhcDogXCI4cHhcIixcbiAgYm9yZGVyUmFkaXVzOiBcIiRib3JkZXJSYWRpdXNCdXR0b25cIixcbiAgZm9udFNpemU6IFwiJGJhc2VCdXR0b25TaXplXCIsXG4gIHBhZGRpbmc6IFwiJGJ1dHRvblBhZGRpbmdcIixcbiAgY3Vyc29yOiBcInBvaW50ZXJcIixcbiAgYm9yZGVyV2lkdGg6IFwiJGJ1dHRvbkJvcmRlcldpZHRoXCIsXG4gIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgdHJhbnNpdGlvblBwcm9wZXJ0eTogXCJiYWNrZ3JvdW5kLWNvbG9yXCIsXG4gIHRyYW5zaXRpb25UaW1pbmdGdW5jdGlvbjogXCJjdWJpYy1iZXppZXIoMC40LCAwLCAwLjIsIDEpXCIsXG4gIHRyYW5zaXRpb25EdXJhdGlvbjogXCIxMDBtc1wiLFxuICBcIiY6ZGlzYWJsZWRcIjoge1xuICAgIG9wYWNpdHk6IDAuNyxcbiAgICBjdXJzb3I6IFwidW5zZXRcIlxuICB9LFxuICB2YXJpYW50czoge1xuICAgIGNvbG9yOiB7XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIkZGVmYXVsdEJ1dHRvbkJhY2tncm91bmRcIixcbiAgICAgICAgY29sb3I6IFwiJGRlZmF1bHRCdXR0b25UZXh0XCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBcIiRkZWZhdWx0QnV0dG9uQm9yZGVyXCIsXG4gICAgICAgIFwiJjpob3Zlcjpub3QoOmRpc2FibGVkKVwiOiB7XG4gICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiRkZWZhdWx0QnV0dG9uQmFja2dyb3VuZEhvdmVyXCJcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHByaW1hcnk6IHtcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiBcIiRicmFuZFwiLFxuICAgICAgICBjb2xvcjogXCIkYnJhbmRCdXR0b25UZXh0XCIsXG4gICAgICAgIGJvcmRlckNvbG9yOiBcIiRicmFuZEFjY2VudFwiLFxuICAgICAgICBcIiY6aG92ZXI6bm90KDpkaXNhYmxlZClcIjoge1xuICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogXCIkYnJhbmRBY2NlbnRcIlxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KSwgQSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBjb2xvcjogbCA9IFwiZGVmYXVsdFwiLFxuICBhcHBlYXJhbmNlOiBuLFxuICBpY29uOiByLFxuICBsb2FkaW5nOiBvID0gITEsXG4gIC4uLnZcbn0pID0+IHtcbiAgdmFyIEM7XG4gIGNvbnN0IEUgPSBWKFxuICAgIFwiYnV0dG9uXCIsXG4gICAgaDEoeyBjb2xvcjogbCB9KSxcbiAgICBuXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwiYnV0dG9uXCIsXG4gICAge1xuICAgICAgLi4udixcbiAgICAgIHN0eWxlOiAoQyA9IG4gPT0gbnVsbCA/IHZvaWQgMCA6IG4uc3R5bGUpID09IG51bGwgPyB2b2lkIDAgOiBDLmJ1dHRvbixcbiAgICAgIGNsYXNzTmFtZTogRS5qb2luKFwiIFwiKSxcbiAgICAgIGRpc2FibGVkOiBvXG4gICAgfSxcbiAgICByLFxuICAgIHRcbiAgKTtcbn0sIGYxID0gRCh7XG4gIGRpc3BsYXk6IFwiZmxleFwiLFxuICBnYXA6IFwiNHB4XCIsXG4gIHZhcmlhbnRzOiB7XG4gICAgZGlyZWN0aW9uOiB7XG4gICAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGRpc3BsYXk6IFwiZ3JpZFwiLFxuICAgICAgICBncmlkVGVtcGxhdGVDb2x1bW5zOiBcInJlcGVhdChhdXRvLWZpdCwgbWlubWF4KDQ4cHgsIDFmcikpXCJcbiAgICAgIH0sXG4gICAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBmbGV4RGlyZWN0aW9uOiBcImNvbHVtblwiLFxuICAgICAgICBtYXJnaW46IFwiOHB4IDBcIlxuICAgICAgfVxuICAgIH0sXG4gICAgZ2FwOiB7XG4gICAgICBzbWFsbDoge1xuICAgICAgICBnYXA6IFwiNHB4XCJcbiAgICAgIH0sXG4gICAgICBtZWRpdW06IHtcbiAgICAgICAgZ2FwOiBcIjhweFwiXG4gICAgICB9LFxuICAgICAgbGFyZ2U6IHtcbiAgICAgICAgZ2FwOiBcIjE2cHhcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIHogPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgYXBwZWFyYW5jZTogbCxcbiAgLi4ublxufSkgPT4ge1xuICB2YXIgbztcbiAgY29uc3QgciA9IFYoXG4gICAgXCJjb250YWluZXJcIixcbiAgICBmMSh7XG4gICAgICBkaXJlY3Rpb246IG4uZGlyZWN0aW9uLFxuICAgICAgZ2FwOiBuLmdhcFxuICAgIH0pLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICAuLi5uLFxuICAgICAgc3R5bGU6IChvID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uY29udGFpbmVyLFxuICAgICAgY2xhc3NOYW1lOiByLmpvaW4oXCIgXCIpXG4gICAgfSxcbiAgICB0XG4gICk7XG59LCBFMSA9IEQoe1xuICBiYWNrZ3JvdW5kOiBcIiRkaXZpZGVyQmFja2dyb3VuZFwiLFxuICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gIG1hcmdpbjogXCIxNnB4IDBcIixcbiAgaGVpZ2h0OiBcIjFweFwiLFxuICB3aWR0aDogXCIxMDAlXCJcbn0pLCBDMSA9ICh7XG4gIGNoaWxkcmVuOiB0LFxuICBhcHBlYXJhbmNlOiBsLFxuICAuLi5uXG59KSA9PiB7XG4gIHZhciBvO1xuICBjb25zdCByID0gVihcbiAgICBcImRpdmlkZXJcIixcbiAgICBFMSgpLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJkaXZcIixcbiAgICB7XG4gICAgICAuLi5uLFxuICAgICAgc3R5bGU6IChvID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8uZGl2aWRlcixcbiAgICAgIGNsYXNzTmFtZTogci5qb2luKFwiIFwiKVxuICAgIH1cbiAgKTtcbn0sIHcxID0gRCh7XG4gIGZvbnRGYW1pbHk6IFwiJGlucHV0Rm9udEZhbWlseVwiLFxuICBiYWNrZ3JvdW5kOiBcIiRpbnB1dEJhY2tncm91bmRcIixcbiAgYm9yZGVyUmFkaXVzOiBcIiRpbnB1dEJvcmRlclJhZGl1c1wiLFxuICBwYWRkaW5nOiBcIiRpbnB1dFBhZGRpbmdcIixcbiAgY3Vyc29yOiBcInRleHRcIixcbiAgYm9yZGVyV2lkdGg6IFwiJGlucHV0Qm9yZGVyV2lkdGhcIixcbiAgYm9yZGVyQ29sb3I6IFwiJGlucHV0Qm9yZGVyXCIsXG4gIGJvcmRlclN0eWxlOiBcInNvbGlkXCIsXG4gIGZvbnRTaXplOiBcIiRiYXNlSW5wdXRTaXplXCIsXG4gIHdpZHRoOiBcIjEwMCVcIixcbiAgY29sb3I6IFwiJGlucHV0VGV4dFwiLFxuICBib3hTaXppbmc6IFwiYm9yZGVyLWJveFwiLFxuICBcIiY6aG92ZXJcIjoge1xuICAgIGJvcmRlckNvbG9yOiBcIiRpbnB1dEJvcmRlckhvdmVyXCIsXG4gICAgb3V0bGluZTogXCJub25lXCJcbiAgfSxcbiAgXCImOmZvY3VzXCI6IHtcbiAgICBib3JkZXJDb2xvcjogXCIkaW5wdXRCb3JkZXJGb2N1c1wiLFxuICAgIG91dGxpbmU6IFwibm9uZVwiXG4gIH0sXG4gIFwiJjo6cGxhY2Vob2xkZXJcIjoge1xuICAgIGNvbG9yOiBcIiRpbnB1dFBsYWNlaG9sZGVyXCIsXG4gICAgbGV0dGVyU3BhY2luZzogXCJpbml0aWFsXCJcbiAgfSxcbiAgdHJhbnNpdGlvblBwcm9wZXJ0eTogXCJiYWNrZ3JvdW5kLWNvbG9yLCBib3JkZXJcIixcbiAgdHJhbnNpdGlvblRpbWluZ0Z1bmN0aW9uOiBcImN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSlcIixcbiAgdHJhbnNpdGlvbkR1cmF0aW9uOiBcIjEwMG1zXCIsXG4gIHZhcmlhbnRzOiB7XG4gICAgdHlwZToge1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBsZXR0ZXJTcGFjaW5nOiBcIjBweFwiXG4gICAgICB9LFxuICAgICAgcGFzc3dvcmQ6IHtcbiAgICAgICAgbGV0dGVyU3BhY2luZzogXCI2cHhcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIEIgPSAoeyBjaGlsZHJlbjogdCwgYXBwZWFyYW5jZTogbCwgLi4ubiB9KSA9PiB7XG4gIHZhciBvO1xuICBjb25zdCByID0gVihcbiAgICBcImlucHV0XCIsXG4gICAgdzEoe1xuICAgICAgdHlwZTogbi50eXBlID09PSBcInBhc3N3b3JkXCIgPyBcInBhc3N3b3JkXCIgOiBcImRlZmF1bHRcIlxuICAgIH0pLFxuICAgIGxcbiAgKTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJpbnB1dFwiLFxuICAgIHtcbiAgICAgIC4uLm4sXG4gICAgICBzdHlsZTogKG8gPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogby5pbnB1dCxcbiAgICAgIGNsYXNzTmFtZTogci5qb2luKFwiIFwiKVxuICAgIH0sXG4gICAgdFxuICApO1xufSwgdjEgPSBEKHtcbiAgZm9udEZhbWlseTogXCIkbGFiZWxGb250RmFtaWx5XCIsXG4gIGZvbnRTaXplOiBcIiRiYXNlTGFiZWxTaXplXCIsXG4gIG1hcmdpbkJvdHRvbTogXCIkbGFiZWxCb3R0b21NYXJnaW5cIixcbiAgY29sb3I6IFwiJGlucHV0TGFiZWxUZXh0XCIsXG4gIGRpc3BsYXk6IFwiYmxvY2tcIlxufSksIEggPSAoeyBjaGlsZHJlbjogdCwgYXBwZWFyYW5jZTogbCwgLi4ubiB9KSA9PiB7XG4gIHZhciBvO1xuICBjb25zdCByID0gVihcbiAgICBcImxhYmVsXCIsXG4gICAgdjEoKSxcbiAgICBsXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGFiZWxcIixcbiAgICB7XG4gICAgICAuLi5uLFxuICAgICAgc3R5bGU6IChvID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC5zdHlsZSkgPT0gbnVsbCA/IHZvaWQgMCA6IG8ubGFiZWwsXG4gICAgICBjbGFzc05hbWU6IHIuam9pbihcIiBcIilcbiAgICB9LFxuICAgIHRcbiAgKTtcbn0sIF8xID0gRCh7XG4gIGZvbnRGYW1pbHk6IFwiJGJvZHlGb250RmFtaWx5XCIsXG4gIGZvbnRTaXplOiBcIiRiYXNlQm9keVNpemVcIixcbiAgbWFyZ2luQm90dG9tOiBcIiRsYWJlbEJvdHRvbU1hcmdpblwiLFxuICBkaXNwbGF5OiBcImJsb2NrXCIsXG4gIHRleHRBbGlnbjogXCJjZW50ZXJcIixcbiAgdmFyaWFudHM6IHtcbiAgICBjb2xvcjoge1xuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb2xvcjogXCIkbWVzc2FnZVRleHRcIlxuICAgICAgfSxcbiAgICAgIGRhbmdlcjoge1xuICAgICAgICBjb2xvcjogXCIkbWVzc2FnZVRleHREYW5nZXJcIlxuICAgICAgfVxuICAgIH1cbiAgfVxufSksIE4gPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgYXBwZWFyYW5jZTogbCxcbiAgLi4ublxufSkgPT4ge1xuICB2YXIgbztcbiAgY29uc3QgciA9IFYoXG4gICAgXCJtZXNzYWdlXCIsXG4gICAgXzEoeyBjb2xvcjogbi5jb2xvciB9KSxcbiAgICBsXG4gICk7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwic3BhblwiLFxuICAgIHtcbiAgICAgIC4uLm4sXG4gICAgICBzdHlsZTogKG8gPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnN0eWxlKSA9PSBudWxsID8gdm9pZCAwIDogby5tZXNzYWdlLFxuICAgICAgY2xhc3NOYW1lOiByLmpvaW4oXCIgXCIpXG4gICAgfSxcbiAgICB0XG4gICk7XG59O1xuZnVuY3Rpb24gWCh7XG4gIHNldEF1dGhWaWV3OiB0ID0gKCkgPT4ge1xuICB9LFxuICBzdXBhYmFzZUNsaWVudDogbCxcbiAgcmVkaXJlY3RUbzogbixcbiAgaTE4bjogcixcbiAgYXBwZWFyYW5jZTogbyxcbiAgc2hvd0xpbmtzOiB2ID0gITFcbn0pIHtcbiAgdmFyIHg7XG4gIGNvbnN0IFtFLCBDXSA9IHUoXCJcIiksIFt3LCBkXSA9IHUoXCJcIiksIFthLCBtXSA9IHUoXCJcIiksIFtjLCB5XSA9IHUoITEpLCBfID0gYXN5bmMgKGgpID0+IHtcbiAgICB2YXIgcztcbiAgICBoLnByZXZlbnREZWZhdWx0KCksIGQoXCJcIiksIG0oXCJcIiksIHkoITApO1xuICAgIGNvbnN0IHsgZXJyb3I6IGcgfSA9IGF3YWl0IGwuYXV0aC5zaWduSW5XaXRoT3RwKHtcbiAgICAgIGVtYWlsOiBFLFxuICAgICAgb3B0aW9uczogeyBlbWFpbFJlZGlyZWN0VG86IG4gfVxuICAgIH0pO1xuICAgIGcgPyBkKGcubWVzc2FnZSkgOiBtKChzID0gciA9PSBudWxsID8gdm9pZCAwIDogci5tYWdpY19saW5rKSA9PSBudWxsID8gdm9pZCAwIDogcy5jb25maXJtYXRpb25fdGV4dCksIHkoITEpO1xuICB9LCBpID0gciA9PSBudWxsID8gdm9pZCAwIDogci5tYWdpY19saW5rO1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImZvcm1cIiwgeyBpZDogXCJhdXRoLW1hZ2ljLWxpbmtcIiwgb25TdWJtaXQ6IF8gfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh6LCB7IGdhcDogXCJsYXJnZVwiLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgYXBwZWFyYW5jZTogbyB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSCwgeyBodG1sRm9yOiBcImVtYWlsXCIsIGFwcGVhcmFuY2U6IG8gfSwgaSA9PSBudWxsID8gdm9pZCAwIDogaS5lbWFpbF9pbnB1dF9sYWJlbCksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgQixcbiAgICB7XG4gICAgICBpZDogXCJlbWFpbFwiLFxuICAgICAgbmFtZTogXCJlbWFpbFwiLFxuICAgICAgdHlwZTogXCJlbWFpbFwiLFxuICAgICAgYXV0b0ZvY3VzOiAhMCxcbiAgICAgIHBsYWNlaG9sZGVyOiBpID09IG51bGwgPyB2b2lkIDAgOiBpLmVtYWlsX2lucHV0X3BsYWNlaG9sZGVyLFxuICAgICAgb25DaGFuZ2U6IChoKSA9PiBDKGgudGFyZ2V0LnZhbHVlKSxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9XG4gICkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEEsXG4gICAge1xuICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgdHlwZTogXCJzdWJtaXRcIixcbiAgICAgIGxvYWRpbmc6IGMsXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfSxcbiAgICBjID8gaSA9PSBudWxsID8gdm9pZCAwIDogaS5sb2FkaW5nX2J1dHRvbl9sYWJlbCA6IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuYnV0dG9uX2xhYmVsXG4gICksIHYgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBJLFxuICAgIHtcbiAgICAgIGhyZWY6IFwiI2F1dGgtc2lnbi1pblwiLFxuICAgICAgb25DbGljazogKGgpID0+IHtcbiAgICAgICAgaC5wcmV2ZW50RGVmYXVsdCgpLCB0KHAuU0lHTl9JTik7XG4gICAgICB9LFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH0sXG4gICAgKHggPSByID09IG51bGwgPyB2b2lkIDAgOiByLnNpZ25faW4pID09IG51bGwgPyB2b2lkIDAgOiB4LmxpbmtfdGV4dFxuICApLCBhICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBhcHBlYXJhbmNlOiBvIH0sIGEpLCB3ICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBjb2xvcjogXCJkYW5nZXJcIiwgYXBwZWFyYW5jZTogbyB9LCB3KSkpO1xufVxuY29uc3QgTCA9IEQoe1xuICB3aWR0aDogXCIyMXB4XCIsXG4gIGhlaWdodDogXCIyMXB4XCJcbn0pLCB4MSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDQ4IDQ4XCIsXG4gICAgd2lkdGg6IFwiMjFweFwiLFxuICAgIGhlaWdodDogXCIyMXB4XCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNGRkMxMDdcIixcbiAgICAgIGQ6IFwiTTQzLjYxMSwyMC4wODNINDJWMjBIMjR2OGgxMS4zMDNjLTEuNjQ5LDQuNjU3LTYuMDgsOC0xMS4zMDMsOGMtNi42MjcsMC0xMi01LjM3My0xMi0xMmMwLTYuNjI3LDUuMzczLTEyLDEyLTEyYzMuMDU5LDAsNS44NDIsMS4xNTQsNy45NjEsMy4wMzlsNS42NTctNS42NTdDMzQuMDQ2LDYuMDUzLDI5LjI2OCw0LDI0LDRDMTIuOTU1LDQsNCwxMi45NTUsNCwyNGMwLDExLjA0NSw4Ljk1NSwyMCwyMCwyMGMxMS4wNDUsMCwyMC04Ljk1NSwyMC0yMEM0NCwyMi42NTksNDMuODYyLDIxLjM1LDQzLjYxMSwyMC4wODN6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjRkYzRDAwXCIsXG4gICAgICBkOiBcIk02LjMwNiwxNC42OTFsNi41NzEsNC44MTlDMTQuNjU1LDE1LjEwOCwxOC45NjEsMTIsMjQsMTJjMy4wNTksMCw1Ljg0MiwxLjE1NCw3Ljk2MSwzLjAzOWw1LjY1Ny01LjY1N0MzNC4wNDYsNi4wNTMsMjkuMjY4LDQsMjQsNEMxNi4zMTgsNCw5LjY1Niw4LjMzNyw2LjMwNiwxNC42OTF6XCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjNENBRjUwXCIsXG4gICAgICBkOiBcIk0yNCw0NGM1LjE2NiwwLDkuODYtMS45NzcsMTMuNDA5LTUuMTkybC02LjE5LTUuMjM4QzI5LjIxMSwzNS4wOTEsMjYuNzE1LDM2LDI0LDM2Yy01LjIwMiwwLTkuNjE5LTMuMzE3LTExLjI4My03Ljk0NmwtNi41MjIsNS4wMjVDOS41MDUsMzkuNTU2LDE2LjIyNyw0NCwyNCw0NHpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiMxOTc2RDJcIixcbiAgICAgIGQ6IFwiTTQzLjYxMSwyMC4wODNINDJWMjBIMjR2OGgxMS4zMDNjLTAuNzkyLDIuMjM3LTIuMjMxLDQuMTY2LTQuMDg3LDUuNTcxYzAuMDAxLTAuMDAxLDAuMDAyLTAuMDAxLDAuMDAzLTAuMDAybDYuMTksNS4yMzhDMzYuOTcxLDM5LjIwNSw0NCwzNCw0NCwyNEM0NCwyMi42NTksNDMuODYyLDIxLjM1LDQzLjYxMSwyMC4wODN6XCJcbiAgICB9XG4gIClcbiksIHkxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiIzAzOWJlNVwiLCBkOiBcIk0yNCA1QTE5IDE5IDAgMSAwIDI0IDQzQTE5IDE5IDAgMSAwIDI0IDVaXCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjZmZmXCIsXG4gICAgICBkOiBcIk0yNi41NzIsMjkuMDM2aDQuOTE3bDAuNzcyLTQuOTk1aC01LjY5di0yLjczYzAtMi4wNzUsMC42NzgtMy45MTUsMi42MTktMy45MTVoMy4xMTl2LTQuMzU5Yy0wLjU0OC0wLjA3NC0xLjcwNy0wLjIzNi0zLjg5Ny0wLjIzNmMtNC41NzMsMC03LjI1NCwyLjQxNS03LjI1NCw3LjkxN3YzLjMyM2gtNC43MDF2NC45OTVoNC43MDF2MTMuNzI5QzIyLjA4OSw0Mi45MDUsMjMuMDMyLDQzLDI0LDQzYzAuODc1LDAsMS43MjktMC4wOCwyLjU3Mi0wLjE5NFYyOS4wMzZ6XCJcbiAgICB9XG4gIClcbiksIHAxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzAzQTlGNFwiLFxuICAgICAgZDogXCJNNDIsMTIuNDI5Yy0xLjMyMywwLjU4Ni0yLjc0NiwwLjk3Ny00LjI0NywxLjE2MmMxLjUyNi0wLjkwNiwyLjctMi4zNTEsMy4yNTEtNC4wNThjLTEuNDI4LDAuODM3LTMuMDEsMS40NTItNC42OTMsMS43NzZDMzQuOTY3LDkuODg0LDMzLjA1LDksMzAuOTI2LDljLTQuMDgsMC03LjM4NywzLjI3OC03LjM4Nyw3LjMyYzAsMC41NzIsMC4wNjcsMS4xMjksMC4xOTMsMS42N2MtNi4xMzgtMC4zMDgtMTEuNTgyLTMuMjI2LTE1LjIyNC03LjY1NGMtMC42NCwxLjA4Mi0xLDIuMzQ5LTEsMy42ODZjMCwyLjU0MSwxLjMwMSw0Ljc3OCwzLjI4NSw2LjA5NmMtMS4yMTEtMC4wMzctMi4zNTEtMC4zNzQtMy4zNDktMC45MTRjMCwwLjAyMiwwLDAuMDU1LDAsMC4wODZjMCwzLjU1MSwyLjU0Nyw2LjUwOCw1LjkyMyw3LjE4MWMtMC42MTcsMC4xNjktMS4yNjksMC4yNjMtMS45NDEsMC4yNjNjLTAuNDc3LDAtMC45NDItMC4wNTQtMS4zOTItMC4xMzVjMC45NCwyLjkwMiwzLjY2Nyw1LjAyMyw2Ljg5OCw1LjA4NmMtMi41MjgsMS45Ni01LjcxMiwzLjEzNC05LjE3NCwzLjEzNGMtMC41OTgsMC0xLjE4My0wLjAzNC0xLjc2MS0wLjEwNEM5LjI2OCwzNi43ODYsMTMuMTUyLDM4LDE3LjMyMSwzOGMxMy41ODUsMCwyMS4wMTctMTEuMTU2LDIxLjAxNy0yMC44MzRjMC0wLjMxNy0wLjAxLTAuNjMzLTAuMDI1LTAuOTQ1QzM5Ljc2MywxNS4xOTcsNDEuMDEzLDEzLjkwNSw0MiwxMi40MjlcIlxuICAgIH1cbiAgKVxuKSwgTDEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgZmlsbDogXCJncmF5XCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCAyNCAyNFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIFwiIFwiLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTSAxNS45MDQyOTcgMS4wNzgxMjUgQyAxNS44NDMzNTkgMS4wNjg3NSAxNS43NzQyMTkgMS4wNzQ2MDk0IDE1LjY5OTIxOSAxLjA5OTYwOTQgQyAxNC42OTkyMTkgMS4yOTk2MDk0IDEzLjYwMDM5MSAxLjg5OTYwOTQgMTIuOTAwMzkxIDIuNTk5NjA5NCBDIDEyLjMwMDM5MSAzLjE5OTYwOTQgMTEuODAwNzgxIDQuMTk5NjA5NCAxMS44MDA3ODEgNS4wOTk2MDk0IEMgMTEuODAwNzgxIDUuMjk5NjA5NCAxMS45OTkyMTkgNS41IDEyLjE5OTIxOSA1LjUgQyAxMy4yOTkyMTkgNS40IDE0LjM5OTYwOSA0Ljc5OTYwOTQgMTUuMDk5NjA5IDQuMDk5NjA5NCBDIDE1LjY5OTYwOSAzLjI5OTYwOTQgMTYuMTk5MjE5IDIuNCAxNi4xOTkyMTkgMS41IEMgMTYuMTk5MjE5IDEuMjc1IDE2LjA4NzEwOSAxLjEwNjI1IDE1LjkwNDI5NyAxLjA3ODEyNSB6IE0gMTYuMTk5MjE5IDUuNDAwMzkwNiBDIDE0LjM5OTIxOSA1LjQwMDM5MDYgMTMuNjAwMzkxIDYuNSAxMi40MDAzOTEgNi41IEMgMTEuMTAwMzkxIDYuNSA5LjkwMDM5MDYgNS41IDguNDAwMzkwNiA1LjUgQyA2LjMwMDM5MDYgNS41IDMuMDk5NjA5NCA3LjQ5OTYwOTQgMy4wOTk2MDk0IDEyLjA5OTYwOSBDIDIuOTk5NjA5NCAxNi4yOTk2MDkgNi44IDIxIDkgMjEgQyAxMC4zIDIxIDEwLjYwMDM5MSAyMC4xOTkyMTkgMTIuNDAwMzkxIDIwLjE5OTIxOSBDIDE0LjIwMDM5MSAyMC4xOTkyMTkgMTQuNjAwMzkxIDIxIDE1LjkwMDM5MSAyMSBDIDE3LjQwMDM5MSAyMSAxOC41MDAzOTEgMTkuMzk5NjA5IDE5LjQwMDM5MSAxOC4wOTk2MDkgQyAxOS44MDAzOTEgMTcuMzk5NjA5IDIwLjEwMDM5MSAxNy4wMDAzOTEgMjAuNDAwMzkxIDE2LjQwMDM5MSBDIDIwLjYwMDM5MSAxNi4wMDAzOTEgMjAuNCAxNS42MDAzOTEgMjAgMTUuNDAwMzkxIEMgMTcuNCAxNC4xMDAzOTEgMTYuOTAwNzgxIDkuOTAwMzkwNiAxOS44MDA3ODEgOC40MDAzOTA2IEMgMjAuMzAwNzgxIDguMTAwMzkwNiAyMC40IDcuNDk5MjE4OCAyMCA3LjE5OTIxODggQyAxOC45IDYuMTk5MjE4NyAxNy4yOTkyMTkgNS40MDAzOTA2IDE2LjE5OTIxOSA1LjQwMDM5MDYgelwiIH0pXG4pLCBiMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICBmaWxsOiBcImdyYXlcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDMwIDMwXCIsXG4gICAgd2lkdGg6IFwiMjFweFwiLFxuICAgIGhlaWdodDogXCIyMXB4XCJcbiAgfSxcbiAgXCIgXCIsXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTUsM0M4LjM3MywzLDMsOC4zNzMsMywxNWMwLDUuNjIzLDMuODcyLDEwLjMyOCw5LjA5MiwxMS42M0MxMi4wMzYsMjYuNDY4LDEyLDI2LjI4LDEyLDI2LjA0N3YtMi4wNTEgYy0wLjQ4NywwLTEuMzAzLDAtMS41MDgsMGMtMC44MjEsMC0xLjU1MS0wLjM1My0xLjkwNS0xLjAwOWMtMC4zOTMtMC43MjktMC40NjEtMS44NDQtMS40MzUtMi41MjYgYy0wLjI4OS0wLjIyNy0wLjA2OS0wLjQ4NiwwLjI2NC0wLjQ1MWMwLjYxNSwwLjE3NCwxLjEyNSwwLjU5NiwxLjYwNSwxLjIyMmMwLjQ3OCwwLjYyNywwLjcwMywwLjc2OSwxLjU5NiwwLjc2OSBjMC40MzMsMCwxLjA4MS0wLjAyNSwxLjY5MS0wLjEyMWMwLjMyOC0wLjgzMywwLjg5NS0xLjYsMS41ODgtMS45NjJjLTMuOTk2LTAuNDExLTUuOTAzLTIuMzk5LTUuOTAzLTUuMDk4IGMwLTEuMTYyLDAuNDk1LTIuMjg2LDEuMzM2LTMuMjMzQzkuMDUzLDEwLjY0Nyw4LjcwNiw4LjczLDkuNDM1LDhjMS43OTgsMCwyLjg4NSwxLjE2NiwzLjE0NiwxLjQ4MUMxMy40NzcsOS4xNzQsMTQuNDYxLDksMTUuNDk1LDkgYzEuMDM2LDAsMi4wMjQsMC4xNzQsMi45MjIsMC40ODNDMTguNjc1LDkuMTcsMTkuNzYzLDgsMjEuNTY1LDhjMC43MzIsMC43MzEsMC4zODEsMi42NTYsMC4xMDIsMy41OTQgYzAuODM2LDAuOTQ1LDEuMzI4LDIuMDY2LDEuMzI4LDMuMjI2YzAsMi42OTctMS45MDQsNC42ODQtNS44OTQsNS4wOTdDMTguMTk5LDIwLjQ5LDE5LDIyLjEsMTksMjMuMzEzdjIuNzM0IGMwLDAuMTA0LTAuMDIzLDAuMTc5LTAuMDM1LDAuMjY4QzIzLjY0MSwyNC42NzYsMjcsMjAuMjM2LDI3LDE1QzI3LDguMzczLDIxLjYyNywzLDE1LDN6XCIgfSlcbiksIFMxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIsXG4gICAgdmlld0JveDogXCIwIDAgNDggNDhcIixcbiAgICB3aWR0aDogXCIyMXB4XCIsXG4gICAgaGVpZ2h0OiBcIjIxcHhcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiI2U1MzkzNVwiLCBkOiBcIk0yNCA0M0wxNiAyMCAzMiAyMHpcIiB9KSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBmaWxsOiBcIiNmZjcwNDNcIiwgZDogXCJNMjQgNDNMNDIgMjAgMzIgMjB6XCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZmlsbDogXCIjZTUzOTM1XCIsIGQ6IFwiTTM3IDVMNDIgMjAgMzIgMjB6XCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZmlsbDogXCIjZmZhNzI2XCIsIGQ6IFwiTTI0IDQzTDQyIDIwIDQ1IDI4elwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiI2ZmNzA0M1wiLCBkOiBcIk0yNCA0M0w2IDIwIDE2IDIwelwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGZpbGw6IFwiI2U1MzkzNVwiLCBkOiBcIk0xMSA1TDYgMjAgMTYgMjB6XCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZmlsbDogXCIjZmZhNzI2XCIsIGQ6IFwiTTI0IDQzTDYgMjAgMyAyOHpcIiB9KVxuKSwgTTEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB3aWR0aDogXCI1MTJcIixcbiAgICBoZWlnaHQ6IFwiNTEyXCIsXG4gICAgdmlld0JveDogXCIwIDAgNjIuNDIgNjIuNDJcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGluZWFyR3JhZGllbnRcIixcbiAgICB7XG4gICAgICBpZDogXCJOZXdfR3JhZGllbnRfU3dhdGNoXzFcIixcbiAgICAgIHgxOiBcIjY0LjAxXCIsXG4gICAgICB5MTogXCIzMC4yN1wiLFxuICAgICAgeDI6IFwiMzIuOTlcIixcbiAgICAgIHkyOiBcIjU0LjQ4XCIsXG4gICAgICBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCJcbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuMThcIiwgc3RvcENvbG9yOiBcIiMwMDUyY2NcIiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BDb2xvcjogXCIjMjY4NGZmXCIgfSlcbiAgKSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJ0aXRsZVwiLCBudWxsLCBcIkJpdGJ1Y2tldC1ibHVlXCIpLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IGlkOiBcIkxheWVyXzJcIiwgXCJkYXRhLW5hbWVcIjogXCJMYXllciAyXCIgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImdcIiwgeyBpZDogXCJCbHVlXCIsIHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMCAtMy4xMylcIiB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTIsNi4yNkEyLDIsMCwwLDAsMCw4LjU4TDguNDksNjAuMTJhMi43MiwyLjcyLDAsMCwwLDIuNjYsMi4yN0g1MS44OGEyLDIsMCwwLDAsMi0xLjY4TDYyLjM3LDguNTlhMiwyLDAsMCwwLTItMi4zMlpNMzcuNzUsNDMuNTFoLTEzTDIxLjIzLDI1LjEySDQwLjlaXCIsXG4gICAgICBmaWxsOiBcIiMyNjg0ZmZcIlxuICAgIH1cbiAgKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk01OS42NywyNS4xMkg0MC45TDM3Ljc1LDQzLjUxaC0xM0w5LjQsNjEuNzNhMi43MSwyLjcxLDAsMCwwLDEuNzUuNjZINTEuODlhMiwyLDAsMCwwLDItMS42OFpcIixcbiAgICAgIGZpbGw6IFwidXJsKCNOZXdfR3JhZGllbnRfU3dhdGNoXzEpXCJcbiAgICB9XG4gICkpKVxuKSwgazEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjNTM2ZGZlXCIsXG4gICAgICBkOiBcIk0zOS4yNDgsMTAuMTc3Yy0yLjgwNC0xLjI4Ny01LjgxMi0yLjIzNS04Ljk1Ni0yLjc3OGMtMC4wNTctMC4wMS0wLjExNCwwLjAxNi0wLjE0NCwwLjA2OFx0Yy0wLjM4NywwLjY4OC0wLjgxNSwxLjU4NS0xLjExNSwyLjI5MWMtMy4zODItMC41MDYtNi43NDctMC41MDYtMTAuMDU5LDBjLTAuMy0wLjcyMS0wLjc0NC0xLjYwMy0xLjEzMy0yLjI5MVx0Yy0wLjAzLTAuMDUxLTAuMDg3LTAuMDc3LTAuMTQ0LTAuMDY4Yy0zLjE0MywwLjU0MS02LjE1LDEuNDg5LTguOTU2LDIuNzc4Yy0wLjAyNCwwLjAxLTAuMDQ1LDAuMDI4LTAuMDU5LDAuMDUxXHRjLTUuNzA0LDguNTIyLTcuMjY3LDE2LjgzNS02LjUsMjUuMDQ0YzAuMDAzLDAuMDQsMC4wMjYsMC4wNzksMC4wNTcsMC4xMDNjMy43NjMsMi43NjQsNy40MDksNC40NDIsMTAuOTg3LDUuNTU0XHRjMC4wNTcsMC4wMTcsMC4xMTgtMC4wMDMsMC4xNTQtMC4wNTFjMC44NDYtMS4xNTYsMS42MDEtMi4zNzQsMi4yNDgtMy42NTZjMC4wMzgtMC4wNzUsMC4wMDItMC4xNjQtMC4wNzYtMC4xOTRcdGMtMS4xOTctMC40NTQtMi4zMzYtMS4wMDctMy40MzItMS42MzZjLTAuMDg3LTAuMDUxLTAuMDk0LTAuMTc1LTAuMDE0LTAuMjM0YzAuMjMxLTAuMTczLDAuNDYxLTAuMzUzLDAuNjgyLTAuNTM0XHRjMC4wNC0wLjAzMywwLjA5NS0wLjA0LDAuMTQyLTAuMDE5YzcuMjAxLDMuMjg4LDE0Ljk5NywzLjI4OCwyMi4xMTMsMGMwLjA0Ny0wLjAyMywwLjEwMi0wLjAxNiwwLjE0NCwwLjAxN1x0YzAuMjIsMC4xODIsMC40NTEsMC4zNjMsMC42ODMsMC41MzZjMC4wOCwwLjA1OSwwLjA3NSwwLjE4My0wLjAxMiwwLjIzNGMtMS4wOTYsMC42NDEtMi4yMzYsMS4xODItMy40MzQsMS42MzRcdGMtMC4wNzgsMC4wMy0wLjExMywwLjEyLTAuMDc1LDAuMTk2YzAuNjYxLDEuMjgsMS40MTUsMi40OTgsMi4yNDYsMy42NTRjMC4wMzUsMC4wNDksMC4wOTcsMC4wNywwLjE1NCwwLjA1Mlx0YzMuNTk1LTEuMTEyLDcuMjQxLTIuNzksMTEuMDA0LTUuNTU0YzAuMDMzLTAuMDI0LDAuMDU0LTAuMDYxLDAuMDU3LTAuMTAxYzAuOTE3LTkuNDkxLTEuNTM3LTE3LjczNS02LjUwNS0yNS4wNDRcdEMzOS4yOTMsMTAuMjA1LDM5LjI3MiwxMC4xODcsMzkuMjQ4LDEwLjE3N3ogTTE2LjcwMywzMC4yNzNjLTIuMTY4LDAtMy45NTQtMS45OS0zLjk1NC00LjQzNXMxLjc1Mi00LjQzNSwzLjk1NC00LjQzNVx0YzIuMjIsMCwzLjk4OSwyLjAwOCwzLjk1NCw0LjQzNUMyMC42NTgsMjguMjgyLDE4LjkwNiwzMC4yNzMsMTYuNzAzLDMwLjI3M3ogTTMxLjMyNCwzMC4yNzNjLTIuMTY4LDAtMy45NTQtMS45OS0zLjk1NC00LjQzNVx0czEuNzUyLTQuNDM1LDMuOTU0LTQuNDM1YzIuMjIsMCwzLjk4OSwyLjAwOCwzLjk1NCw0LjQzNUMzNS4yNzgsMjguMjgyLDMzLjU0NCwzMC4yNzMsMzEuMzI0LDMwLjI3M3pcIlxuICAgIH1cbiAgKVxuKSwgTjEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJsaW5lYXJHcmFkaWVudFwiLFxuICAgIHtcbiAgICAgIGlkOiBcIms4eWw3fmhEYXR+RmFvV3E4V2pONmFcIixcbiAgICAgIHgxOiBcIi0xMjU0LjM5N1wiLFxuICAgICAgeDI6IFwiLTEyNjEuOTExXCIsXG4gICAgICB5MTogXCI4NzcuMjY4XCIsXG4gICAgICB5MjogXCI4OTkuNDY2XCIsXG4gICAgICBncmFkaWVudFRyYW5zZm9ybTogXCJ0cmFuc2xhdGUoMTk4MS43NSAtMTM2Mi4wNjMpIHNjYWxlKDEuNTYyNSlcIixcbiAgICAgIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIlxuICAgIH0sXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMFwiLCBzdG9wQ29sb3I6IFwiIzExNGE4YlwiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMwNjY5YmNcIiB9KVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwidXJsKCNrOHlsN35oRGF0fkZhb1dxOFdqTjZhKVwiLFxuICAgICAgZDogXCJNMTcuNjM0LDZoMTEuMzA1TDE3LjIwMyw0MC43NzNjLTAuMjQ3LDAuNzMzLTAuOTM0LDEuMjI2LTEuNzA4LDEuMjI2SDYuNjk3IGMtMC45OTQsMC0xLjgtMC44MDYtMS44LTEuOGMwLTAuMTk2LDAuMDMyLTAuMzksMC4wOTQtMC41NzZMMTUuOTI2LDcuMjI3QzE2LjE3Myw2LjQ5NCwxNi44Niw2LDE3LjYzNCw2TDE3LjYzNCw2elwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzAwNzhkNFwiLFxuICAgICAgZDogXCJNMzQuMDYyLDI5LjMyNEgxNi4xMzVjLTAuNDU4LTAuMDAxLTAuODMsMC4zNzEtMC44MzEsMC44MjljMCwwLjIzMSwwLjA5NSwwLjQ1MSwwLjI2NCwwLjYwOCBsMTEuNTIsMTAuNzUyQzI3LjQyMyw0MS44MjYsMjcuODY1LDQyLDI4LjMyNCw0MmgxMC4xNTFMMzQuMDYyLDI5LjMyNHpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcImxpbmVhckdyYWRpZW50XCIsXG4gICAge1xuICAgICAgaWQ6IFwiazh5bDd+aERhdH5GYW9XcThXak42YlwiLFxuICAgICAgeDE6IFwiLTEyNTIuMDVcIixcbiAgICAgIHgyOiBcIi0xMjUzLjc4OFwiLFxuICAgICAgeTE6IFwiODg3LjYxMlwiLFxuICAgICAgeTI6IFwiODg4LjJcIixcbiAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgxOTgxLjc1IC0xMzYyLjA2Mykgc2NhbGUoMS41NjI1KVwiLFxuICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwXCIsIHN0b3BPcGFjaXR5OiBcIi4zXCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiLjA3MVwiLCBzdG9wT3BhY2l0eTogXCIuMlwiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIi4zMjFcIiwgc3RvcE9wYWNpdHk6IFwiLjFcIiB9KSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIuNjIzXCIsIHN0b3BPcGFjaXR5OiBcIi4wNVwiIH0pLFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcE9wYWNpdHk6IFwiMFwiIH0pXG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCJ1cmwoI2s4eWw3fmhEYXR+RmFvV3E4V2pONmIpXCIsXG4gICAgICBkOiBcIk0xNy42MzQsNmMtMC43ODMtMC4wMDMtMS40NzYsMC41MDQtMS43MTIsMS4yNUw1LjAwNSwzOS41OTUgYy0wLjMzNSwwLjkzNCwwLjE1MSwxLjk2NCwxLjA4NSwyLjI5OUM2LjI4Niw0MS45NjQsNi40OTMsNDIsNi43MDIsNDJoOS4wMjZjMC42ODQtMC4xMjIsMS4yNS0wLjYwMywxLjQ4MS0xLjI1OWwyLjE3Ny02LjQxNiBsNy43NzYsNy4yNTNjMC4zMjYsMC4yNywwLjczNSwwLjQxOSwxLjE1OCwwLjQyMmgxMC4xMTRsLTQuNDM2LTEyLjY3NmwtMTIuOTMxLDAuMDAzTDI4Ljk4LDZIMTcuNjM0elwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwibGluZWFyR3JhZGllbnRcIixcbiAgICB7XG4gICAgICBpZDogXCJrOHlsN35oRGF0fkZhb1dxOFdqTjZjXCIsXG4gICAgICB4MTogXCItMTI1Mi45NTJcIixcbiAgICAgIHgyOiBcIi0xMjQ0LjcwNFwiLFxuICAgICAgeTE6IFwiODc2LjZcIixcbiAgICAgIHkyOiBcIjg5OC41NzVcIixcbiAgICAgIGdyYWRpZW50VHJhbnNmb3JtOiBcInRyYW5zbGF0ZSgxOTgxLjc1IC0xMzYyLjA2Mykgc2NhbGUoMS41NjI1KVwiLFxuICAgICAgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiXG4gICAgfSxcbiAgICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwXCIsIHN0b3BDb2xvcjogXCIjM2NjYmY0XCIgfSksXG4gICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMVwiLCBzdG9wQ29sb3I6IFwiIzI4OTJkZlwiIH0pXG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCJ1cmwoI2s4eWw3fmhEYXR+RmFvV3E4V2pONmMpXCIsXG4gICAgICBkOiBcIk0zMi4wNzQsNy4yMjVDMzEuODI3LDYuNDkzLDMxLjE0MSw2LDMwLjM2OCw2aC0xMi42YzAuNzcyLDAsMS40NTksMC40OTMsMS43MDUsMS4yMjQgbDEwLjkzNSwzMi4zOTljMC4zMTgsMC45NDItMC4xODgsMS45NjMtMS4xMywyLjI4MUMyOS4wOTMsNDEuOTY4LDI4Ljg5OSw0MiwyOC43MDMsNDJoMTIuNmMwLjk5NCwwLDEuOC0wLjgwNiwxLjgtMS44MDEgYzAtMC4xOTYtMC4wMzItMC4zOS0wLjA5NS0wLjU3NUwzMi4wNzQsNy4yMjV6XCJcbiAgICB9XG4gIClcbiksIEYxID0gKCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgXCJzdmdcIixcbiAge1xuICAgIGNsYXNzTmFtZTogTCgpLFxuICAgIHdpZHRoOiBcIjUxMlwiLFxuICAgIGhlaWdodDogXCI1MTJcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA1MTIgNTEyXCIsXG4gICAgZmlsbDogXCJub25lXCIsXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICB9LFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTQ3Mi4xMzYgMTYzLjk1OUg0MDguNTg0QzQwNy40MDEgMTYzLjk1OSA0MDYuMjE4IDE2My4zMjcgNDA1LjY2NiAxNjIuM0wzNTQuNjUxIDczLjY1OTFDMzU0LjAyIDcyLjYzMiAzNTIuOTE2IDcyIDM1MS42NTQgNzJIMTQzLjQ5MkMxNDIuMzA5IDcyIDE0MS4xMjYgNzIuNjMyIDE0MC41NzQgNzMuNjU5MUw4Ny41MDg0IDE2NS42MThMMzYuNDE0IDI1NC4yNTlDMzUuODYyIDI1NS4yODYgMzUuODYyIDI1Ni41NSAzNi40MTQgMjU3LjY1Nkw4Ny41MDg0IDM0Ni4yOTdMMTQwLjQ5NSA0MzguMzM1QzE0MS4wNDcgNDM5LjM2MiAxNDIuMjMgNDQwLjA3MyAxNDMuNDEzIDQzOS45OTRIMzUxLjY1NEMzNTIuODM3IDQzOS45OTQgMzU0LjAyIDQzOS4zNjIgMzU0LjY1MSA0MzguMzM1TDQwNS43NDUgMzQ5LjY5NEM0MDYuMjk3IDM0OC42NjcgNDA3LjQ4IDM0Ny45NTYgNDA4LjY2MyAzNDguMDM1SDQ3Mi4yMTVDNDc0LjM0NCAzNDguMDM1IDQ3NiAzNDYuMjk3IDQ3NiAzNDQuMjQzVjE2Ny44M0M0NzUuOTIxIDE2NS42OTcgNDc0LjE4NiAxNjMuOTU5IDQ3Mi4xMzYgMTYzLjk1OVpNMjI4LjcyOCAzNDkuNjk0TDIxMi43MjEgMzc3LjM0NUMyMTIuNDg1IDM3Ny43NCAyMTIuMDkxIDM3OC4xMzUgMjExLjY5NiAzNzguMzcyQzIxMS4yMjMgMzc4LjYwOSAyMTAuNzUgMzc4Ljc2NyAyMTAuMTk4IDM3OC43NjdIMTc4LjQyMkMxNzcuMzE4IDM3OC43NjcgMTc2LjI5MyAzNzguMjE0IDE3NS44MiAzNzcuMTg3TDEyOC40MzEgMjk0Ljc4N0wxMjMuNzc5IDI4Ni42NUwxMDYuNzQ4IDI1Ny40OThDMTA2LjUxMSAyNTcuMTAzIDEwNi4zNTMgMjU2LjYyOSAxMDYuNDMyIDI1Ni4wNzZDMTA2LjQzMiAyNTUuNjAyIDEwNi41OSAyNTUuMDQ5IDEwNi44MjcgMjU0LjY1NEwxMjMuOTM3IDIyNC45NDlMMTc1Ljg5OSAxMzQuODg2QzE3Ni40NTEgMTMzLjkzOCAxNzcuNDc2IDEzMy4zMDYgMTc4LjUwMSAxMzMuMzA2SDIxMC4xOThDMjEwLjc1IDEzMy4zMDYgMjExLjMwMiAxMzMuNDY0IDIxMS44NTQgMTMzLjcwMUMyMTIuMjQ4IDEzMy45MzggMjEyLjY0MyAxMzQuMjU0IDIxMi44NzkgMTM0LjcyOEwyMjguODg2IDE2Mi41MzdDMjI5LjM1OSAxNjMuNDg1IDIyOS4yOCAxNjQuNjcgMjI4LjcyOCAxNjUuNTM5TDE3Ny4zOTcgMjU0LjY1NEMxNzcuMTYgMjU1LjA0OSAxNzcuMDgxIDI1NS41MjMgMTc3LjA4MSAyNTUuOTE4QzE3Ny4wODEgMjU2LjM5MiAxNzcuMjM5IDI1Ni43ODcgMTc3LjM5NyAyNTcuMTgyTDIyOC43MjggMzQ2LjIxOEMyMjkuNDM4IDM0Ny40MDMgMjI5LjM1OSAzNDguNjY3IDIyOC43MjggMzQ5LjY5NFYzNDkuNjk0Wk0zODguMDgzIDI1Ny40OThMMzcxLjA1MSAyODYuNjVMMzY2LjM5OSAyOTQuNzg3TDMxOS4wMTEgMzc3LjE4N0MzMTguNDU5IDM3OC4xMzUgMzE3LjUxMiAzNzguNzY3IDMxNi40MDkgMzc4Ljc2N0gyODQuNjMyQzI4NC4wOCAzNzguNzY3IDI4My42MDcgMzc4LjYwOSAyODMuMTM0IDM3OC4zNzJDMjgyLjc0IDM3OC4xMzUgMjgyLjM0NiAzNzcuODE5IDI4Mi4xMDkgMzc3LjM0NUwyNjYuMTAzIDM0OS42OTRDMjY1LjM5MyAzNDguNjY3IDI2NS4zOTMgMzQ3LjQwMyAyNjYuMDI0IDM0Ni4zNzZMMzE3LjM1NSAyNTcuMzRDMzE3LjU5MSAyNTYuOTQ1IDMxNy42NyAyNTYuNDcxIDMxNy42NyAyNTYuMDc2QzMxNy42NyAyNTUuNjAyIDMxNy41MTMgMjU1LjIwNyAzMTcuMzU1IDI1NC44MTJMMjY2LjAyNCAxNjUuNjk3QzI2NS40NzIgMTY0Ljc0OSAyNjUuMzkzIDE2My42NDMgMjY1Ljg2NiAxNjIuNjk1TDI4MS44NzMgMTM0Ljg4NkMyODIuMTA5IDEzNC40OTEgMjgyLjUwMyAxMzQuMDk2IDI4Mi44OTggMTMzLjg1OUMyODMuMzcxIDEzMy41NDMgMjgzLjkyMyAxMzMuNDY0IDI4NC41NTMgMTMzLjQ2NEgzMTYuNDA5QzMxNy41MTIgMTMzLjQ2NCAzMTguNTM4IDEzNC4wMTcgMzE5LjAxMSAxMzUuMDQ0TDM3MC45NzIgMjI1LjEwN0wzODguMDgzIDI1NC44MTJDMzg4LjMxOSAyNTUuMjg2IDM4OC40NzcgMjU1Ljc2IDM4OC40NzcgMjU2LjIzNEMzODguNDc3IDI1Ni41NSAzODguMzE5IDI1Ny4wMjQgMzg4LjA4MyAyNTcuNDk4VjI1Ny40OThaXCIsXG4gICAgICBmaWxsOiBcIiMwMDhBQUFcIlxuICAgIH1cbiAgKVxuKSwgejEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjMDI4OEQxXCIsXG4gICAgICBkOiBcIk00MiwzN2MwLDIuNzYyLTIuMjM4LDUtNSw1SDExYy0yLjc2MSwwLTUtMi4yMzgtNS01VjExYzAtMi43NjIsMi4yMzktNSw1LTVoMjZjMi43NjIsMCw1LDIuMjM4LDUsNVYzN3pcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNGRkZcIixcbiAgICAgIGQ6IFwiTTEyIDE5SDE3VjM2SDEyek0xNC40ODUgMTdoLS4wMjhDMTIuOTY1IDE3IDEyIDE1Ljg4OCAxMiAxNC40OTkgMTIgMTMuMDggMTIuOTk1IDEyIDE0LjUxNCAxMmMxLjUyMSAwIDIuNDU4IDEuMDggMi40ODYgMi40OTlDMTcgMTUuODg3IDE2LjAzNSAxNyAxNC40ODUgMTd6TTM2IDM2aC01di05LjA5OWMwLTIuMTk4LTEuMjI1LTMuNjk4LTMuMTkyLTMuNjk4LTEuNTAxIDAtMi4zMTMgMS4wMTItMi43MDcgMS45OUMyNC45NTcgMjUuNTQzIDI1IDI2LjUxMSAyNSAyN3Y5aC01VjE5aDV2Mi42MTZDMjUuNzIxIDIwLjUgMjYuODUgMTkgMjkuNzM4IDE5YzMuNTc4IDAgNi4yNjEgMi4yNSA2LjI2MSA3LjI3NEwzNiAzNiAzNiAzNnpcIlxuICAgIH1cbiAgKVxuKSwgRDEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIixcbiAgICB2aWV3Qm94OiBcIjAgMCA0OCA0OFwiLFxuICAgIHdpZHRoOiBcIjIxcHhcIixcbiAgICBoZWlnaHQ6IFwiMjFweFwiLFxuICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNmZmZcIixcbiAgICAgIGZpbGxSdWxlOiBcImV2ZW5vZGRcIixcbiAgICAgIGQ6IFwiTTExLjU1MywxMS4wOTljMS4yMzIsMS4wMDEsMS42OTQsMC45MjUsNC4wMDgsMC43NyBsMjEuODEyLTEuMzFjMC40NjMsMCwwLjA3OC0wLjQ2MS0wLjA3Ni0wLjUzOGwtMy42MjItMi42MTljLTAuNjk0LTAuNTM5LTEuNjE5LTEuMTU2LTMuMzkxLTEuMDAybC0yMS4xMiwxLjU0IGMtMC43NywwLjA3Ni0wLjkyNCwwLjQ2MS0wLjYxNywwLjc3TDExLjU1MywxMS4wOTl6XCIsXG4gICAgICBjbGlwUnVsZTogXCJldmVub2RkXCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZmlsbDogXCIjZmZmXCIsXG4gICAgICBmaWxsUnVsZTogXCJldmVub2RkXCIsXG4gICAgICBkOiBcIk0xMi44NjIsMTYuMTgydjIyLjk1YzAsMS4yMzMsMC42MTYsMS42OTUsMi4wMDQsMS42MTkgbDIzLjk3MS0xLjM4N2MxLjM4OC0wLjA3NiwxLjU0My0wLjkyNSwxLjU0My0xLjkyN1YxNC42NDFjMC0xLTAuMzg1LTEuNTQtMS4yMzQtMS40NjNsLTI1LjA1LDEuNDYzIEMxMy4xNzEsMTQuNzE4LDEyLjg2MiwxNS4xODEsMTIuODYyLDE2LjE4MkwxMi44NjIsMTYuMTgyelwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzQyNDI0MlwiLFxuICAgICAgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLFxuICAgICAgZDogXCJNMTEuNTUzLDExLjA5OWMxLjIzMiwxLjAwMSwxLjY5NCwwLjkyNSw0LjAwOCwwLjc3IGwyMS44MTItMS4zMWMwLjQ2MywwLDAuMDc4LTAuNDYxLTAuMDc2LTAuNTM4bC0zLjYyMi0yLjYxOWMtMC42OTQtMC41MzktMS42MTktMS4xNTYtMy4zOTEtMS4wMDJsLTIxLjEyLDEuNTQgYy0wLjc3LDAuMDc2LTAuOTI0LDAuNDYxLTAuNjE3LDAuNzdMMTEuNTUzLDExLjA5OXogTTEyLjg2MiwxNi4xODJ2MjIuOTVjMCwxLjIzMywwLjYxNiwxLjY5NSwyLjAwNCwxLjYxOWwyMy45NzEtMS4zODcgYzEuMzg4LTAuMDc2LDEuNTQzLTAuOTI1LDEuNTQzLTEuOTI3VjE0LjY0MWMwLTEtMC4zODUtMS41NC0xLjIzNC0xLjQ2M2wtMjUuMDUsMS40NjNDMTMuMTcxLDE0LjcxOCwxMi44NjIsMTUuMTgxLDEyLjg2MiwxNi4xODIgTDEyLjg2MiwxNi4xODJ6IE0zNi41MjYsMTcuNDEzYzAuMTU0LDAuNjk0LDAsMS4zODctMC42OTUsMS40NjVsLTEuMTU1LDAuMjN2MTYuOTQzYy0xLjAwMywwLjUzOS0xLjkyOCwwLjg0Ny0yLjY5OCwwLjg0NyBjLTEuMjM0LDAtMS41NDMtMC4zODUtMi40NjctMS41NGwtNy41NTUtMTEuODZ2MTEuNDc1bDIuMzkxLDAuNTM5YzAsMCwwLDEuMzg2LTEuOTI5LDEuMzg2bC01LjMxNywwLjMwOCBjLTAuMTU0LTAuMzA4LDAtMS4wNzgsMC41MzktMS4yMzJsMS4zODgtMC4zODVWMjAuNDE4bC0xLjkyNy0wLjE1NGMtMC4xNTUtMC42OTQsMC4yMy0xLjY5NCwxLjMxLTEuNzcybDUuNzA0LTAuMzg1bDcuODYyLDEyLjAxNSBWMTkuNDkzbC0yLjAwNS0wLjIzYy0wLjE1NC0wLjg0OCwwLjQ2Mi0xLjQ2NCwxLjIzMy0xLjU0TDM2LjUyNiwxNy40MTN6IE03LjM4OSw1Ljg2MmwyMS45NjgtMS42MTggYzIuNjk4LTAuMjMxLDMuMzkyLTAuMDc2LDUuMDg3LDEuMTU1bDcuMDEzLDQuOTI5QzQyLjYxNCwxMS4xNzYsNDMsMTEuNDA3LDQzLDEyLjMzdjI3LjAzMmMwLDEuNjk0LTAuNjE3LDIuNjk2LTIuNzc1LDIuODQ5IGwtMjUuNTEyLDEuNTQxYy0xLjYyLDAuMDc3LTIuMzkxLTAuMTU0LTMuMjM5LTEuMjMybC01LjE2NC02LjdDNS4zODUsMzQuNTg3LDUsMzMuNjY0LDUsMzIuNTg1VjguNTU2IEM1LDcuMTcxLDUuNjE3LDYuMDE1LDcuMzg5LDUuODYyelwiLFxuICAgICAgY2xpcFJ1bGU6IFwiZXZlbm9kZFwiXG4gICAgfVxuICApXG4pLCAkMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDQ4IDQ4XCIsXG4gICAgd2lkdGg6IFwiMjFweFwiLFxuICAgIGhlaWdodDogXCIyMXB4XCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiMzM2QzNzVcIixcbiAgICAgIGQ6IFwiTTMzLDhjMC0yLjIwOS0xLjc5MS00LTQtNHMtNCwxLjc5MS00LDRjMCwxLjI1NCwwLDkuNzQxLDAsMTFjMCwyLjIwOSwxLjc5MSw0LDQsNHM0LTEuNzkxLDQtNFx0QzMzLDE3Ljc0MSwzMyw5LjI1NCwzMyw4elwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzMzZDM3NVwiLFxuICAgICAgZDogXCJNNDMsMTljMCwyLjIwOS0xLjc5MSw0LTQsNGMtMS4xOTUsMC00LDAtNCwwczAtMi45ODYsMC00YzAtMi4yMDksMS43OTEtNCw0LTRTNDMsMTYuNzkxLDQzLDE5elwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzQwYzRmZlwiLFxuICAgICAgZDogXCJNOCwxNGMtMi4yMDksMC00LDEuNzkxLTQsNHMxLjc5MSw0LDQsNGMxLjI1NCwwLDkuNzQxLDAsMTEsMGMyLjIwOSwwLDQtMS43OTEsNC00cy0xLjc5MS00LTQtNFx0QzE3Ljc0MSwxNCw5LjI1NCwxNCw4LDE0elwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiIzQwYzRmZlwiLFxuICAgICAgZDogXCJNMTksNGMyLjIwOSwwLDQsMS43OTEsNCw0YzAsMS4xOTUsMCw0LDAsNHMtMi45ODYsMC00LDBjLTIuMjA5LDAtNC0xLjc5MS00LTRTMTYuNzkxLDQsMTksNHpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNlOTFlNjNcIixcbiAgICAgIGQ6IFwiTTE0LDM5LjAwNkMxNCw0MS4yMTIsMTUuNzkxLDQzLDE4LDQzczQtMS43ODgsNC0zLjk5NGMwLTEuMjUyLDAtOS43MjcsMC0xMC45ODRcdGMwLTIuMjA2LTEuNzkxLTMuOTk0LTQtMy45OTRzLTQsMS43ODgtNCwzLjk5NEMxNCwyOS4yNzksMTQsMzcuNzU0LDE0LDM5LjAwNnpcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNlOTFlNjNcIixcbiAgICAgIGQ6IFwiTTQsMjguMDIyYzAtMi4yMDYsMS43OTEtMy45OTQsNC0zLjk5NGMxLjE5NSwwLDQsMCw0LDBzMCwyLjk4MSwwLDMuOTk0YzAsMi4yMDYtMS43OTEsMy45OTQtNCwzLjk5NFx0UzQsMzAuMjI4LDQsMjguMDIyelwiXG4gICAgfVxuICApLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGZpbGw6IFwiI2ZmYzEwN1wiLFxuICAgICAgZDogXCJNMzksMzNjMi4yMDksMCw0LTEuNzkxLDQtNHMtMS43OTEtNC00LTRjLTEuMjU0LDAtOS43NDEsMC0xMSwwYy0yLjIwOSwwLTQsMS43OTEtNCw0czEuNzkxLDQsNCw0XHRDMjkuMjU4LDMzLDM3Ljc0NiwzMywzOSwzM3pcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBmaWxsOiBcIiNmZmMxMDdcIixcbiAgICAgIGQ6IFwiTTI4LDQzYy0yLjIwOSwwLTQtMS43OTEtNC00YzAtMS4xOTUsMC00LDAtNHMyLjk4NiwwLDQsMGMyLjIwOSwwLDQsMS43OTEsNCw0UzMwLjIwOSw0MywyOCw0M3pcIlxuICAgIH1cbiAgKVxuKSwgQjEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgd2lkdGg6IFwiNTEyXCIsXG4gICAgaGVpZ2h0OiBcIjUxMlwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDUxMiA1MTJcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNMjU1LjQ5OCAzMS4wMDM0QzEzMS41MTMgMzEuMDAzNCAzMSAxMzEuNTE1IDMxIDI1NS41MDJDMzEgMzc5LjQ5MiAxMzEuNTEzIDQ4MCAyNTUuNDk4IDQ4MEMzNzkuNDk3IDQ4MCA0ODAgMzc5LjQ5NSA0ODAgMjU1LjUwMkM0ODAgMTMxLjUyMiAzNzkuNDk3IDMxLjAxMzUgMjU1LjQ5NSAzMS4wMTM1TDI1NS40OTggMzFWMzEuMDAzNFpNMzU4LjQ1MyAzNTQuNzk4QzM1NC40MzIgMzYxLjM5MSAzNDUuODAxIDM2My40ODYgMzM5LjIwNCAzNTkuNDM1QzI4Ni40OTYgMzI3LjIzNyAyMjAuMTM5IDMxOS45NDcgMTQxLjk5MyAzMzcuODAxQzEzNC40NjMgMzM5LjUxNiAxMjYuOTU3IDMzNC43OTggMTI1LjI0IDMyNy4yNjRDMTIzLjUxNiAzMTkuNzMxIDEyOC4yMTcgMzEyLjIyNSAxMzUuNzY3IDMxMC41MTFDMjIxLjI4NCAyOTAuOTcyIDI5NC42MzkgMjk5LjM4NCAzNTMuODE2IDMzNS41NDlDMzYwLjQxMyAzMzkuNTk2IDM2Mi41MDQgMzQ4LjIgMzU4LjQ1MyAzNTQuNzk4Wk0zODUuOTMyIDI5My42N0MzODAuODY0IDMwMS45MDMgMzcwLjA4OCAzMDQuNTAzIDM2MS44NTggMjk5LjQzOEMzMDEuNTEyIDI2Mi4zNDUgMjA5LjUyOCAyNTEuNjAyIDEzOC4xNTEgMjczLjI3MkMxMjguODkzIDI3Ni4wNjcgMTE5LjExOCAyNzAuODUxIDExNi4zMDkgMjYxLjYxQzExMy41MjEgMjUyLjM1MyAxMTguNzQgMjQyLjU5NyAxMjcuOTgxIDIzOS43ODJDMjA5LjUxMiAyMTUuMDQ0IDMxMC44NyAyMjcuMDI2IDM4MC4xNyAyNjkuNjEyQzM4OC40IDI3NC42OCAzOTEgMjg1LjQ1NiAzODUuOTM1IDI5My42NzZWMjkzLjY3M0wzODUuOTMyIDI5My42N1pNMzg4LjI5MyAyMzAuMDE2QzMxNS45MzUgMTg3LjAzOSAxOTYuNTYgMTgzLjA4OSAxMjcuNDc5IDIwNC4wNTVDMTE2LjM4NyAyMDcuNDIgMTA0LjY1NCAyMDEuMTU5IDEwMS4yOTMgMTkwLjA2M0M5Ny45MzI2IDE3OC45NjQgMTA0LjE4OSAxNjcuMjQxIDExNS4yODkgMTYzLjg3QzE5NC41OSAxMzkuNzk2IDMyNi40MTggMTQ0LjQ0NiA0MDkuNzIzIDE5My45MDJDNDE5LjcyMiAxOTkuODI2IDQyMi45OTUgMjEyLjcxIDQxNy4wNjggMjIyLjY3NUM0MTEuMTY4IDIzMi42NTMgMzk4LjI0NyAyMzUuOTQzIDM4OC4zMDMgMjMwLjAxNkgzODguMjkzVjIzMC4wMTZaXCIsXG4gICAgICBmaWxsOiBcIiMxRUQ3NjBcIlxuICAgIH1cbiAgKVxuKSwgSDEgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBcInN2Z1wiLFxuICB7XG4gICAgY2xhc3NOYW1lOiBMKCksXG4gICAgd2lkdGg6IFwiNTEyXCIsXG4gICAgaGVpZ2h0OiBcIjUxMlwiLFxuICAgIHZpZXdCb3g6IFwiMCAwIDUxMiA1MTJcIixcbiAgICBmaWxsOiBcIm5vbmVcIixcbiAgICB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiXG4gIH0sXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNDE2IDI0MEwzNTIgMzA0SDI4OEwyMzIgMzYwVjMwNEgxNjBWNjRINDE2VjI0MFpcIiwgZmlsbDogXCJ3aGl0ZVwiIH0pLFxuICAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIFwicGF0aFwiLFxuICAgIHtcbiAgICAgIGQ6IFwiTTE0NCAzMkw2NCAxMTJWNDAwSDE2MFY0ODBMMjQwIDQwMEgzMDRMNDQ4IDI1NlYzMkgxNDRaTTQxNiAyNDBMMzUyIDMwNEgyODhMMjMyIDM2MFYzMDRIMTYwVjY0SDQxNlYyNDBaXCIsXG4gICAgICBmaWxsOiBcIiM5MTQ2RkZcIlxuICAgIH1cbiAgKSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk0zNjggMTIwSDMzNlYyMTZIMzY4VjEyMFpcIiwgZmlsbDogXCIjOTE0NkZGXCIgfSksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMjgwIDEyMEgyNDhWMjE2SDI4MFYxMjBaXCIsIGZpbGw6IFwiIzkxNDZGRlwiIH0pXG4pLCBQMSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gIFwic3ZnXCIsXG4gIHtcbiAgICBjbGFzc05hbWU6IEwoKSxcbiAgICB3aWR0aDogXCI1MTJcIixcbiAgICBoZWlnaHQ6IFwiNTEyXCIsXG4gICAgdmlld0JveDogXCIwIDAgNTEyIDUxMlwiLFxuICAgIGZpbGw6IFwibm9uZVwiLFxuICAgIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJcbiAgfSxcbiAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBcInBhdGhcIixcbiAgICB7XG4gICAgICBkOiBcIk0zMyAyNTYuMDQzQzMzIDI2NC41NTYgMzUuMzE1OSAyNzMuMDY5IDM5LjQ4NDUgMjgwLjIwMkwxMTcuOTkzIDQxNS40OTNDMTI2LjA5OCA0MjkuMjk4IDEzOC4zNzMgNDQwLjU3MiAxNTMuNjU3IDQ0NS42MzRDMTgzLjc2NCA0NTUuNTI4IDIxNC43OTcgNDQyLjg3MyAyMjkuNjE4IDQxNy4zMzNMMjQ4LjYwOSAzODQuNjYxTDE3My44MDYgMjU2LjA0M0wyNTIuNzc3IDExOS44MzFMMjcxLjc2OCA4Ny4xNTkxQzI3Ny41NTcgNzcuMjY1NCAyODQuOTY4IDY5LjQ0MjQgMjk0IDYzSDI4NS44OTRIMTcyLjE4NUMxNTAuODc4IDYzIDEzMS4xOTMgNzQuMjc0MiAxMjAuNTQgOTIuNjgxMkwzOS43MTYxIDIzMS44ODRDMzUuMzE1OSAyMzkuMDE2IDMzIDI0Ny41MyAzMyAyNTYuMDQzWlwiLFxuICAgICAgZmlsbDogXCIjNjM2M0YxXCJcbiAgICB9XG4gICksXG4gIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJwYXRoXCIsXG4gICAge1xuICAgICAgZDogXCJNNDgwIDI1Ni4wNThDNDgwIDI0Ny41MzkgNDc3LjY4NCAyMzkuMDIxIDQ3My41MTYgMjMxLjg4M0wzOTMuODQ5IDk0LjY1OTZDMzc5LjAyOCA2OS4zMzMxIDM0Ny45OTUgNTYuNDM5NiAzMTcuODg4IDY2LjM0QzMwMi42MDMgNzEuNDA1MyAyOTAuMzI5IDgyLjY4NzEgMjgyLjIyNCA5Ni41MDE1TDI2NC4zOTEgMTI3LjM1NEwzMzkuMTk0IDI1Ni4wNThMMjYwLjIyMyAzOTIuMTMxTDI0MS4yMzIgNDI0LjgyNUMyMzUuNDQzIDQzNC40OTUgMjI4LjAzMiA0NDIuNTUzIDIxOSA0NDlIMjI3LjEwNkgzNDAuODE1QzM2Mi4xMjIgNDQ5IDM4MS44MDcgNDM3LjcxOCAzOTIuNDYgNDE5LjI5OUw0NzMuMjg0IDI4MC4wMDNDNDc3LjY4NCAyNzIuODY2IDQ4MCAyNjQuNTc3IDQ4MCAyNTYuMDU4WlwiLFxuICAgICAgZmlsbDogXCIjNjM2M0YxXCJcbiAgICB9XG4gIClcbiksIEkxID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5mcmVlemUoLyogQF9fUFVSRV9fICovIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgYXBwbGU6IEwxLFxuICBhenVyZTogTjEsXG4gIGJpdGJ1Y2tldDogTTEsXG4gIGRpc2NvcmQ6IGsxLFxuICBmYWNlYm9vazogeTEsXG4gIGdpdGh1YjogYjEsXG4gIGdpdGxhYjogUzEsXG4gIGdvb2dsZTogeDEsXG4gIGtleWNsb2FrOiBGMSxcbiAgbGlua2VkaW46IHoxLFxuICBub3Rpb246IEQxLFxuICBzbGFjazogJDEsXG4gIHNwb3RpZnk6IEIxLFxuICB0d2l0Y2g6IEgxLFxuICB0d2l0dGVyOiBwMSxcbiAgd29ya29zOiBQMVxufSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiBcIk1vZHVsZVwiIH0pKTtcbmZ1bmN0aW9uIFYxKHtcbiAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gIHNvY2lhbExheW91dDogbCA9IFwidmVydGljYWxcIixcbiAgcHJvdmlkZXJzOiBuID0gW1wiZ2l0aHViXCIsIFwiZ29vZ2xlXCIsIFwiYXp1cmVcIl0sXG4gIHByb3ZpZGVyU2NvcGVzOiByLFxuICBxdWVyeVBhcmFtczogbyxcbiAgcmVkaXJlY3RUbzogdixcbiAgb25seVRoaXJkUGFydHlQcm92aWRlcnM6IEUgPSAhMCxcbiAgdmlldzogQyA9IFwic2lnbl9pblwiLFxuICBpMThuOiB3LFxuICBhcHBlYXJhbmNlOiBkXG59KSB7XG4gIGNvbnN0IFthLCBtXSA9IHUoITEpLCBbYywgeV0gPSB1KFwiXCIpLCBfID0gbCA9PT0gXCJ2ZXJ0aWNhbFwiLCBpID0gQyA9PT0gXCJtYWdpY19saW5rXCIgPyBcInNpZ25faW5cIiA6IEMsIHggPSBhc3luYyAoZykgPT4ge1xuICAgIG0oITApO1xuICAgIGNvbnN0IHsgZXJyb3I6IHMgfSA9IGF3YWl0IHQuYXV0aC5zaWduSW5XaXRoT0F1dGgoe1xuICAgICAgcHJvdmlkZXI6IGcsXG4gICAgICBvcHRpb25zOiB7XG4gICAgICAgIHJlZGlyZWN0VG86IHYsXG4gICAgICAgIHNjb3BlczogciA9PSBudWxsID8gdm9pZCAwIDogcltnXSxcbiAgICAgICAgcXVlcnlQYXJhbXM6IG9cbiAgICAgIH1cbiAgICB9KTtcbiAgICBzICYmIHkocy5tZXNzYWdlKSwgbSghMSk7XG4gIH07XG4gIGZ1bmN0aW9uIGgoZykge1xuICAgIGNvbnN0IHMgPSBnLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIGcuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpO1xuICB9XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGUuRnJhZ21lbnQsIG51bGwsIG4gJiYgbi5sZW5ndGggPiAwICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoZS5GcmFnbWVudCwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh6LCB7IGdhcDogXCJsYXJnZVwiLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgYXBwZWFyYW5jZTogZCB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIHosXG4gICAge1xuICAgICAgZGlyZWN0aW9uOiBfID8gXCJ2ZXJ0aWNhbFwiIDogXCJob3Jpem9udGFsXCIsXG4gICAgICBnYXA6IF8gPyBcInNtYWxsXCIgOiBcIm1lZGl1bVwiLFxuICAgICAgYXBwZWFyYW5jZTogZFxuICAgIH0sXG4gICAgbi5tYXAoKGcpID0+IHtcbiAgICAgIHZhciBNO1xuICAgICAgY29uc3QgcyA9IEkxW2ddO1xuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIEEsXG4gICAgICAgIHtcbiAgICAgICAgICBrZXk6IGcsXG4gICAgICAgICAgY29sb3I6IFwiZGVmYXVsdFwiLFxuICAgICAgICAgIGljb246IHMgPyAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHMsIG51bGwpIDogXCJcIixcbiAgICAgICAgICBsb2FkaW5nOiBhLFxuICAgICAgICAgIG9uQ2xpY2s6ICgpID0+IHgoZyksXG4gICAgICAgICAgYXBwZWFyYW5jZTogZFxuICAgICAgICB9LFxuICAgICAgICBfICYmIGMxKFxuICAgICAgICAgIChNID0gdyA9PSBudWxsID8gdm9pZCAwIDogd1tpXSkgPT0gbnVsbCA/IHZvaWQgMCA6IE0uc29jaWFsX3Byb3ZpZGVyX3RleHQsXG4gICAgICAgICAge1xuICAgICAgICAgICAgcHJvdmlkZXI6IGgoZylcbiAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfSlcbiAgKSksICFFICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoQzEsIHsgYXBwZWFyYW5jZTogZCB9KSkpO1xufVxuZnVuY3Rpb24gUSh7XG4gIGF1dGhWaWV3OiB0ID0gXCJzaWduX2luXCIsXG4gIGRlZmF1bHRFbWFpbDogbCA9IFwiXCIsXG4gIGRlZmF1bHRQYXNzd29yZDogbiA9IFwiXCIsXG4gIHNldEF1dGhWaWV3OiByID0gKCkgPT4ge1xuICB9LFxuICBzZXREZWZhdWx0RW1haWw6IG8gPSAoXykgPT4ge1xuICB9LFxuICBzZXREZWZhdWx0UGFzc3dvcmQ6IHYgPSAoXykgPT4ge1xuICB9LFxuICBzdXBhYmFzZUNsaWVudDogRSxcbiAgc2hvd0xpbmtzOiBDID0gITEsXG4gIHJlZGlyZWN0VG86IHcsXG4gIGFkZGl0aW9uYWxEYXRhOiBkLFxuICBtYWdpY0xpbms6IGEsXG4gIGkxOG46IG0sXG4gIGFwcGVhcmFuY2U6IGMsXG4gIGNoaWxkcmVuOiB5XG59KSB7XG4gIHZhciBULCBHLCBaLCBqO1xuICBjb25zdCBfID0gbTEoITApLCBbaSwgeF0gPSB1KGwpLCBbaCwgZ10gPSB1KG4pLCBbcywgTV0gPSB1KFwiXCIpLCBbYiwgJF0gPSB1KCExKSwgW1AsIFVdID0gdShcIlwiKTtcbiAgUigoKSA9PiAoXy5jdXJyZW50ID0gITAsIHgobCksIGcobiksICgpID0+IHtcbiAgICBfLmN1cnJlbnQgPSAhMTtcbiAgfSksIFt0XSk7XG4gIGNvbnN0IE8gPSBhc3luYyAoUykgPT4ge1xuICAgIHZhciBxO1xuICAgIHN3aXRjaCAoUy5wcmV2ZW50RGVmYXVsdCgpLCBNKFwiXCIpLCAkKCEwKSwgdCkge1xuICAgICAgY2FzZSBcInNpZ25faW5cIjpcbiAgICAgICAgY29uc3QgeyBlcnJvcjogSyB9ID0gYXdhaXQgRS5hdXRoLnNpZ25JbldpdGhQYXNzd29yZCh7XG4gICAgICAgICAgZW1haWw6IGksXG4gICAgICAgICAgcGFzc3dvcmQ6IGhcbiAgICAgICAgfSk7XG4gICAgICAgIEsgJiYgTShLLm1lc3NhZ2UpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzaWduX3VwXCI6XG4gICAgICAgIGxldCBZID0ge1xuICAgICAgICAgIGVtYWlsUmVkaXJlY3RUbzogd1xuICAgICAgICB9O1xuICAgICAgICBkICYmIChZLmRhdGEgPSBkKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRhdGE6IHsgdXNlcjogbzEsIHNlc3Npb246IHIxIH0sXG4gICAgICAgICAgZXJyb3I6IEpcbiAgICAgICAgfSA9IGF3YWl0IEUuYXV0aC5zaWduVXAoe1xuICAgICAgICAgIGVtYWlsOiBpLFxuICAgICAgICAgIHBhc3N3b3JkOiBoLFxuICAgICAgICAgIG9wdGlvbnM6IFlcbiAgICAgICAgfSk7XG4gICAgICAgIEogPyBNKEoubWVzc2FnZSkgOiBvMSAmJiAhcjEgJiYgVSgocSA9IG0gPT0gbnVsbCA/IHZvaWQgMCA6IG0uc2lnbl91cCkgPT0gbnVsbCA/IHZvaWQgMCA6IHEuY29uZmlybWF0aW9uX3RleHQpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgXy5jdXJyZW50ICYmICQoITEpO1xuICB9LCBGID0gKFMpID0+IHtcbiAgICBvKGkpLCB2KGgpLCByKFMpO1xuICB9LCBmID0gbSA9PSBudWxsID8gdm9pZCAwIDogbVt0XTtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgXCJmb3JtXCIsXG4gICAge1xuICAgICAgaWQ6IHQgPT09IFwic2lnbl9pblwiID8gXCJhdXRoLXNpZ24taW5cIiA6IFwiYXV0aC1zaWduLXVwXCIsXG4gICAgICBvblN1Ym1pdDogTyxcbiAgICAgIGF1dG9Db21wbGV0ZTogXCJvblwiLFxuICAgICAgc3R5bGU6IHsgd2lkdGg6IFwiMTAwJVwiIH1cbiAgICB9LFxuICAgIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoeiwgeyBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgZ2FwOiBcImxhcmdlXCIsIGFwcGVhcmFuY2U6IGMgfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh6LCB7IGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLCBnYXA6IFwibGFyZ2VcIiwgYXBwZWFyYW5jZTogYyB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSCwgeyBodG1sRm9yOiBcImVtYWlsXCIsIGFwcGVhcmFuY2U6IGMgfSwgZiA9PSBudWxsID8gdm9pZCAwIDogZi5lbWFpbF9sYWJlbCksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBCLFxuICAgICAge1xuICAgICAgICBpZDogXCJlbWFpbFwiLFxuICAgICAgICB0eXBlOiBcImVtYWlsXCIsXG4gICAgICAgIG5hbWU6IFwiZW1haWxcIixcbiAgICAgICAgcGxhY2Vob2xkZXI6IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZW1haWxfaW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogaSxcbiAgICAgICAgb25DaGFuZ2U6IChTKSA9PiB4KFMudGFyZ2V0LnZhbHVlKSxcbiAgICAgICAgYXV0b0NvbXBsZXRlOiBcImVtYWlsXCIsXG4gICAgICAgIGFwcGVhcmFuY2U6IGNcbiAgICAgIH1cbiAgICApKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KEgsIHsgaHRtbEZvcjogXCJwYXNzd29yZFwiLCBhcHBlYXJhbmNlOiBjIH0sIGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYucGFzc3dvcmRfbGFiZWwpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgQixcbiAgICAgIHtcbiAgICAgICAgaWQ6IFwicGFzc3dvcmRcIixcbiAgICAgICAgdHlwZTogXCJwYXNzd29yZFwiLFxuICAgICAgICBuYW1lOiBcInBhc3N3b3JkXCIsXG4gICAgICAgIHBsYWNlaG9sZGVyOiBmID09IG51bGwgPyB2b2lkIDAgOiBmLnBhc3N3b3JkX2lucHV0X3BsYWNlaG9sZGVyLFxuICAgICAgICBkZWZhdWx0VmFsdWU6IGgsXG4gICAgICAgIG9uQ2hhbmdlOiAoUykgPT4gZyhTLnRhcmdldC52YWx1ZSksXG4gICAgICAgIGF1dG9Db21wbGV0ZTogdCA9PT0gXCJzaWduX2luXCIgPyBcImN1cnJlbnQtcGFzc3dvcmRcIiA6IFwibmV3LXBhc3N3b3JkXCIsXG4gICAgICAgIGFwcGVhcmFuY2U6IGNcbiAgICAgIH1cbiAgICApKSwgeSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBBLFxuICAgICAge1xuICAgICAgICB0eXBlOiBcInN1Ym1pdFwiLFxuICAgICAgICBjb2xvcjogXCJwcmltYXJ5XCIsXG4gICAgICAgIGxvYWRpbmc6IGIsXG4gICAgICAgIGFwcGVhcmFuY2U6IGNcbiAgICAgIH0sXG4gICAgICBiID8gZiA9PSBudWxsID8gdm9pZCAwIDogZi5sb2FkaW5nX2J1dHRvbl9sYWJlbCA6IGYgPT0gbnVsbCA/IHZvaWQgMCA6IGYuYnV0dG9uX2xhYmVsXG4gICAgKSwgQyAmJiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHosIHsgZGlyZWN0aW9uOiBcInZlcnRpY2FsXCIsIGdhcDogXCJzbWFsbFwiLCBhcHBlYXJhbmNlOiBjIH0sIHQgPT09IHAuU0lHTl9JTiAmJiBhICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBJLFxuICAgICAge1xuICAgICAgICBocmVmOiBcIiNhdXRoLW1hZ2ljLWxpbmtcIixcbiAgICAgICAgb25DbGljazogKFMpID0+IHtcbiAgICAgICAgICBTLnByZXZlbnREZWZhdWx0KCksIHIocC5NQUdJQ19MSU5LKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZWFyYW5jZTogY1xuICAgICAgfSxcbiAgICAgIChUID0gbSA9PSBudWxsID8gdm9pZCAwIDogbS5tYWdpY19saW5rKSA9PSBudWxsID8gdm9pZCAwIDogVC5saW5rX3RleHRcbiAgICApLCB0ID09PSBwLlNJR05fSU4gJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIEksXG4gICAgICB7XG4gICAgICAgIGhyZWY6IFwiI2F1dGgtZm9yZ290LXBhc3N3b3JkXCIsXG4gICAgICAgIG9uQ2xpY2s6IChTKSA9PiB7XG4gICAgICAgICAgUy5wcmV2ZW50RGVmYXVsdCgpLCByKHAuRk9SR09UVEVOX1BBU1NXT1JEKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZWFyYW5jZTogY1xuICAgICAgfSxcbiAgICAgIChHID0gbSA9PSBudWxsID8gdm9pZCAwIDogbS5mb3Jnb3R0ZW5fcGFzc3dvcmQpID09IG51bGwgPyB2b2lkIDAgOiBHLmxpbmtfdGV4dFxuICAgICksIHQgPT09IHAuU0lHTl9JTiA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICBJLFxuICAgICAge1xuICAgICAgICBocmVmOiBcIiNhdXRoLXNpZ24tdXBcIixcbiAgICAgICAgb25DbGljazogKFMpID0+IHtcbiAgICAgICAgICBTLnByZXZlbnREZWZhdWx0KCksIEYocC5TSUdOX1VQKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXBwZWFyYW5jZTogY1xuICAgICAgfSxcbiAgICAgIChaID0gbSA9PSBudWxsID8gdm9pZCAwIDogbS5zaWduX3VwKSA9PSBudWxsID8gdm9pZCAwIDogWi5saW5rX3RleHRcbiAgICApIDogLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgIEksXG4gICAgICB7XG4gICAgICAgIGhyZWY6IFwiI2F1dGgtc2lnbi1pblwiLFxuICAgICAgICBvbkNsaWNrOiAoUykgPT4ge1xuICAgICAgICAgIFMucHJldmVudERlZmF1bHQoKSwgRihwLlNJR05fSU4pO1xuICAgICAgICB9LFxuICAgICAgICBhcHBlYXJhbmNlOiBjXG4gICAgICB9LFxuICAgICAgKGogPSBtID09IG51bGwgPyB2b2lkIDAgOiBtLnNpZ25faW4pID09IG51bGwgPyB2b2lkIDAgOiBqLmxpbmtfdGV4dFxuICAgICkpKSxcbiAgICBQICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBhcHBlYXJhbmNlOiBjIH0sIFApLFxuICAgIHMgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChOLCB7IGNvbG9yOiBcImRhbmdlclwiLCBhcHBlYXJhbmNlOiBjIH0sIHMpXG4gICk7XG59XG5mdW5jdGlvbiBlMSh7XG4gIHNldEF1dGhWaWV3OiB0ID0gKCkgPT4ge1xuICB9LFxuICBzdXBhYmFzZUNsaWVudDogbCxcbiAgcmVkaXJlY3RUbzogbixcbiAgaTE4bjogcixcbiAgYXBwZWFyYW5jZTogbyxcbiAgc2hvd0xpbmtzOiB2ID0gITFcbn0pIHtcbiAgdmFyIHg7XG4gIGNvbnN0IFtFLCBDXSA9IHUoXCJcIiksIFt3LCBkXSA9IHUoXCJcIiksIFthLCBtXSA9IHUoXCJcIiksIFtjLCB5XSA9IHUoITEpLCBfID0gYXN5bmMgKGgpID0+IHtcbiAgICB2YXIgcztcbiAgICBoLnByZXZlbnREZWZhdWx0KCksIGQoXCJcIiksIG0oXCJcIiksIHkoITApO1xuICAgIGNvbnN0IHsgZXJyb3I6IGcgfSA9IGF3YWl0IGwuYXV0aC5yZXNldFBhc3N3b3JkRm9yRW1haWwoRSwge1xuICAgICAgcmVkaXJlY3RUbzogblxuICAgIH0pO1xuICAgIGcgPyBkKGcubWVzc2FnZSkgOiBtKChzID0gciA9PSBudWxsID8gdm9pZCAwIDogci5mb3Jnb3R0ZW5fcGFzc3dvcmQpID09IG51bGwgPyB2b2lkIDAgOiBzLmNvbmZpcm1hdGlvbl90ZXh0KSwgeSghMSk7XG4gIH0sIGkgPSByID09IG51bGwgPyB2b2lkIDAgOiByLmZvcmdvdHRlbl9wYXNzd29yZDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIHsgaWQ6IFwiYXV0aC1mb3Jnb3QtcGFzc3dvcmRcIiwgb25TdWJtaXQ6IF8gfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh6LCB7IGdhcDogXCJsYXJnZVwiLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgYXBwZWFyYW5jZTogbyB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSCwgeyBodG1sRm9yOiBcImVtYWlsXCIsIGFwcGVhcmFuY2U6IG8gfSwgaSA9PSBudWxsID8gdm9pZCAwIDogaS5lbWFpbF9sYWJlbCksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgQixcbiAgICB7XG4gICAgICBpZDogXCJlbWFpbFwiLFxuICAgICAgbmFtZTogXCJlbWFpbFwiLFxuICAgICAgdHlwZTogXCJlbWFpbFwiLFxuICAgICAgYXV0b0ZvY3VzOiAhMCxcbiAgICAgIHBsYWNlaG9sZGVyOiBpID09IG51bGwgPyB2b2lkIDAgOiBpLmVtYWlsX2lucHV0X3BsYWNlaG9sZGVyLFxuICAgICAgb25DaGFuZ2U6IChoKSA9PiBDKGgudGFyZ2V0LnZhbHVlKSxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9XG4gICkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEEsXG4gICAge1xuICAgICAgdHlwZTogXCJzdWJtaXRcIixcbiAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgIGxvYWRpbmc6IGMsXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfSxcbiAgICBjID8gaSA9PSBudWxsID8gdm9pZCAwIDogaS5sb2FkaW5nX2J1dHRvbl9sYWJlbCA6IGkgPT0gbnVsbCA/IHZvaWQgMCA6IGkuYnV0dG9uX2xhYmVsXG4gICksIHYgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBJLFxuICAgIHtcbiAgICAgIGhyZWY6IFwiI2F1dGgtc2lnbi1pblwiLFxuICAgICAgb25DbGljazogKGgpID0+IHtcbiAgICAgICAgaC5wcmV2ZW50RGVmYXVsdCgpLCB0KHAuU0lHTl9JTik7XG4gICAgICB9LFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH0sXG4gICAgKHggPSByID09IG51bGwgPyB2b2lkIDAgOiByLnNpZ25faW4pID09IG51bGwgPyB2b2lkIDAgOiB4LmxpbmtfdGV4dFxuICApLCBhICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBhcHBlYXJhbmNlOiBvIH0sIGEpLCB3ICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBjb2xvcjogXCJkYW5nZXJcIiwgYXBwZWFyYW5jZTogbyB9LCB3KSkpO1xufVxuZnVuY3Rpb24gdDEoe1xuICBzdXBhYmFzZUNsaWVudDogdCxcbiAgaTE4bjogbCxcbiAgYXBwZWFyYW5jZTogblxufSkge1xuICBjb25zdCBbciwgb10gPSB1KFwiXCIpLCBbdiwgRV0gPSB1KFwiXCIpLCBbQywgd10gPSB1KFwiXCIpLCBbZCwgYV0gPSB1KCExKSwgbSA9IGFzeW5jICh5KSA9PiB7XG4gICAgdmFyIGk7XG4gICAgeS5wcmV2ZW50RGVmYXVsdCgpLCBFKFwiXCIpLCB3KFwiXCIpLCBhKCEwKTtcbiAgICBjb25zdCB7IGVycm9yOiBfIH0gPSBhd2FpdCB0LmF1dGgudXBkYXRlVXNlcih7IHBhc3N3b3JkOiByIH0pO1xuICAgIF8gPyBFKF8ubWVzc2FnZSkgOiB3KChpID0gbCA9PSBudWxsID8gdm9pZCAwIDogbC51cGRhdGVfcGFzc3dvcmQpID09IG51bGwgPyB2b2lkIDAgOiBpLmNvbmZpcm1hdGlvbl90ZXh0KSwgYSghMSk7XG4gIH0sIGMgPSBsID09IG51bGwgPyB2b2lkIDAgOiBsLnVwZGF0ZV9wYXNzd29yZDtcbiAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIHsgaWQ6IFwiYXV0aC11cGRhdGUtcGFzc3dvcmRcIiwgb25TdWJtaXQ6IG0gfSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudCh6LCB7IGdhcDogXCJsYXJnZVwiLCBkaXJlY3Rpb246IFwidmVydGljYWxcIiwgYXBwZWFyYW5jZTogbiB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoSCwgeyBodG1sRm9yOiBcInBhc3N3b3JkXCIsIGFwcGVhcmFuY2U6IG4gfSwgYyA9PSBudWxsID8gdm9pZCAwIDogYy5wYXNzd29yZF9sYWJlbCksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgQixcbiAgICB7XG4gICAgICBpZDogXCJwYXNzd29yZFwiLFxuICAgICAgbmFtZTogXCJwYXNzd29yZFwiLFxuICAgICAgcGxhY2Vob2xkZXI6IGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMucGFzc3dvcmRfbGFiZWwsXG4gICAgICB0eXBlOiBcInBhc3N3b3JkXCIsXG4gICAgICBhdXRvRm9jdXM6ICEwLFxuICAgICAgb25DaGFuZ2U6ICh5KSA9PiBvKHkudGFyZ2V0LnZhbHVlKSxcbiAgICAgIGFwcGVhcmFuY2U6IG5cbiAgICB9XG4gICkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEEsXG4gICAge1xuICAgICAgdHlwZTogXCJzdWJtaXRcIixcbiAgICAgIGNvbG9yOiBcInByaW1hcnlcIixcbiAgICAgIGxvYWRpbmc6IGQsXG4gICAgICBhcHBlYXJhbmNlOiBuXG4gICAgfSxcbiAgICBkID8gYyA9PSBudWxsID8gdm9pZCAwIDogYy5sb2FkaW5nX2J1dHRvbl9sYWJlbCA6IGMgPT0gbnVsbCA/IHZvaWQgMCA6IGMuYnV0dG9uX2xhYmVsXG4gICksIEMgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChOLCB7IGFwcGVhcmFuY2U6IG4gfSwgQyksIHYgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChOLCB7IGNvbG9yOiBcImRhbmdlclwiLCBhcHBlYXJhbmNlOiBuIH0sIHYpKSk7XG59XG5mdW5jdGlvbiBBMSh7XG4gIHNldEF1dGhWaWV3OiB0ID0gKCkgPT4ge1xuICB9LFxuICBzdXBhYmFzZUNsaWVudDogbCxcbiAgb3RwVHlwZTogbiA9IFwiZW1haWxcIixcbiAgaTE4bjogcixcbiAgYXBwZWFyYW5jZTogbyxcbiAgc2hvd0xpbmtzOiB2ID0gITFcbn0pIHtcbiAgdmFyIE07XG4gIGNvbnN0IFtFLCBDXSA9IHUoXCJcIiksIFt3LCBkXSA9IHUoXCJcIiksIFthLCBtXSA9IHUoXCJcIiksIFtjLCB5XSA9IHUoXCJcIiksIFtfLCBpXSA9IHUoXCJcIiksIFt4LCBoXSA9IHUoITEpLCBnID0gYXN5bmMgKGIpID0+IHtcbiAgICBiLnByZXZlbnREZWZhdWx0KCksIHkoXCJcIiksIGkoXCJcIiksIGgoITApO1xuICAgIGxldCAkID0ge1xuICAgICAgZW1haWw6IEUsXG4gICAgICB0b2tlbjogYSxcbiAgICAgIHR5cGU6IG5cbiAgICB9O1xuICAgIFtcInNtc1wiLCBcInBob25lX2NoYW5nZVwiXS5pbmNsdWRlcyhuKSAmJiAoJCA9IHtcbiAgICAgIHBob25lOiB3LFxuICAgICAgdG9rZW46IGEsXG4gICAgICB0eXBlOiBuXG4gICAgfSk7XG4gICAgY29uc3QgeyBlcnJvcjogUCB9ID0gYXdhaXQgbC5hdXRoLnZlcmlmeU90cCgkKTtcbiAgICBQICYmIHkoUC5tZXNzYWdlKSwgaCghMSk7XG4gIH0sIHMgPSByID09IG51bGwgPyB2b2lkIDAgOiByLnZlcmlmeV9vdHA7XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCB7IGlkOiBcImF1dGgtbWFnaWMtbGlua1wiLCBvblN1Ym1pdDogZyB9LCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KHosIHsgZ2FwOiBcImxhcmdlXCIsIGRpcmVjdGlvbjogXCJ2ZXJ0aWNhbFwiLCBhcHBlYXJhbmNlOiBvIH0sIFtcInNtc1wiLCBcInBob25lX2NoYW5nZVwiXS5pbmNsdWRlcyhuKSA/IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChILCB7IGh0bWxGb3I6IFwicGhvbmVcIiwgYXBwZWFyYW5jZTogbyB9LCBzID09IG51bGwgPyB2b2lkIDAgOiBzLnBob25lX2lucHV0X2xhYmVsKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBCLFxuICAgIHtcbiAgICAgIGlkOiBcInBob25lXCIsXG4gICAgICBuYW1lOiBcInBob25lXCIsXG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIGF1dG9Gb2N1czogITAsXG4gICAgICBwbGFjZWhvbGRlcjogcyA9PSBudWxsID8gdm9pZCAwIDogcy5waG9uZV9pbnB1dF9wbGFjZWhvbGRlcixcbiAgICAgIG9uQ2hhbmdlOiAoYikgPT4gZChiLnRhcmdldC52YWx1ZSksXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfVxuICApKSA6IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChILCB7IGh0bWxGb3I6IFwiZW1haWxcIiwgYXBwZWFyYW5jZTogbyB9LCBzID09IG51bGwgPyB2b2lkIDAgOiBzLmVtYWlsX2lucHV0X2xhYmVsKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBCLFxuICAgIHtcbiAgICAgIGlkOiBcImVtYWlsXCIsXG4gICAgICBuYW1lOiBcImVtYWlsXCIsXG4gICAgICB0eXBlOiBcImVtYWlsXCIsXG4gICAgICBhdXRvRm9jdXM6ICEwLFxuICAgICAgcGxhY2Vob2xkZXI6IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuZW1haWxfaW5wdXRfcGxhY2Vob2xkZXIsXG4gICAgICBvbkNoYW5nZTogKGIpID0+IEMoYi50YXJnZXQudmFsdWUpLFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH1cbiAgKSksIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChILCB7IGh0bWxGb3I6IFwidG9rZW5cIiwgYXBwZWFyYW5jZTogbyB9LCBzID09IG51bGwgPyB2b2lkIDAgOiBzLnRva2VuX2lucHV0X2xhYmVsKSwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBCLFxuICAgIHtcbiAgICAgIGlkOiBcInRva2VuXCIsXG4gICAgICBuYW1lOiBcInRva2VuXCIsXG4gICAgICB0eXBlOiBcInRleHRcIixcbiAgICAgIHBsYWNlaG9sZGVyOiBzID09IG51bGwgPyB2b2lkIDAgOiBzLnRva2VuX2lucHV0X3BsYWNlaG9sZGVyLFxuICAgICAgb25DaGFuZ2U6IChiKSA9PiBtKGIudGFyZ2V0LnZhbHVlKSxcbiAgICAgIGFwcGVhcmFuY2U6IG9cbiAgICB9XG4gICkpLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgIEEsXG4gICAge1xuICAgICAgY29sb3I6IFwicHJpbWFyeVwiLFxuICAgICAgdHlwZTogXCJzdWJtaXRcIixcbiAgICAgIGxvYWRpbmc6IHgsXG4gICAgICBhcHBlYXJhbmNlOiBvXG4gICAgfSxcbiAgICB4ID8gcyA9PSBudWxsID8gdm9pZCAwIDogcy5sb2FkaW5nX2J1dHRvbl9sYWJlbCA6IHMgPT0gbnVsbCA/IHZvaWQgMCA6IHMuYnV0dG9uX2xhYmVsXG4gICksIHYgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICBJLFxuICAgIHtcbiAgICAgIGhyZWY6IFwiI2F1dGgtc2lnbi1pblwiLFxuICAgICAgb25DbGljazogKGIpID0+IHtcbiAgICAgICAgYi5wcmV2ZW50RGVmYXVsdCgpLCB0KHAuU0lHTl9JTik7XG4gICAgICB9LFxuICAgICAgYXBwZWFyYW5jZTogb1xuICAgIH0sXG4gICAgKE0gPSByID09IG51bGwgPyB2b2lkIDAgOiByLnNpZ25faW4pID09IG51bGwgPyB2b2lkIDAgOiBNLmxpbmtfdGV4dFxuICApLCBfICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBhcHBlYXJhbmNlOiBvIH0sIF8pLCBjICYmIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoTiwgeyBjb2xvcjogXCJkYW5nZXJcIiwgYXBwZWFyYW5jZTogbyB9LCBjKSkpO1xufVxuY29uc3QgbDEgPSBkMSh7IHVzZXI6IG51bGwsIHNlc3Npb246IG51bGwgfSksIFUxID0gKHQpID0+IHtcbiAgY29uc3QgeyBzdXBhYmFzZUNsaWVudDogbCB9ID0gdCwgW24sIHJdID0gdShudWxsKSwgW28sIHZdID0gdSgobiA9PSBudWxsID8gdm9pZCAwIDogbi51c2VyKSA/PyBudWxsKTtcbiAgUigoKSA9PiB7XG4gICAgKGFzeW5jICgpID0+IHtcbiAgICAgIHZhciBkO1xuICAgICAgY29uc3QgeyBkYXRhOiB3IH0gPSBhd2FpdCBsLmF1dGguZ2V0U2Vzc2lvbigpO1xuICAgICAgcih3LnNlc3Npb24pLCB2KCgoZCA9IHcuc2Vzc2lvbikgPT0gbnVsbCA/IHZvaWQgMCA6IGQudXNlcikgPz8gbnVsbCk7XG4gICAgfSkoKTtcbiAgICBjb25zdCB7IGRhdGE6IEMgfSA9IGwuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShcbiAgICAgIGFzeW5jICh3LCBkKSA9PiB7XG4gICAgICAgIHIoZCksIHYoKGQgPT0gbnVsbCA/IHZvaWQgMCA6IGQudXNlcikgPz8gbnVsbCk7XG4gICAgICB9XG4gICAgKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgQyA9PSBudWxsIHx8IEMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfTtcbiAgfSwgW10pO1xuICBjb25zdCBFID0ge1xuICAgIHNlc3Npb246IG4sXG4gICAgdXNlcjogb1xuICB9O1xuICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChsMS5Qcm92aWRlciwgeyB2YWx1ZTogRSwgLi4udCB9KTtcbn0sIFIxID0gKCkgPT4ge1xuICBjb25zdCB0ID0gdTEobDEpO1xuICBpZiAodCA9PT0gdm9pZCAwKVxuICAgIHRocm93IG5ldyBFcnJvcihcInVzZVVzZXIgbXVzdCBiZSB1c2VkIHdpdGhpbiBhIFVzZXJDb250ZXh0UHJvdmlkZXIuXCIpO1xuICByZXR1cm4gdDtcbn07XG5mdW5jdGlvbiBrKHtcbiAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gIHNvY2lhbExheW91dDogbCA9IFwidmVydGljYWxcIixcbiAgcHJvdmlkZXJzOiBuLFxuICBwcm92aWRlclNjb3BlczogcixcbiAgcXVlcnlQYXJhbXM6IG8sXG4gIHZpZXc6IHYgPSBcInNpZ25faW5cIixcbiAgcmVkaXJlY3RUbzogRSxcbiAgb25seVRoaXJkUGFydHlQcm92aWRlcnM6IEMgPSAhMSxcbiAgbWFnaWNMaW5rOiB3ID0gITEsXG4gIHNob3dMaW5rczogZCA9ICEwLFxuICBhcHBlYXJhbmNlOiBhLFxuICB0aGVtZTogbSA9IFwiZGVmYXVsdFwiLFxuICBsb2NhbGl6YXRpb246IGMgPSB7IHZhcmlhYmxlczoge30gfSxcbiAgb3RwVHlwZTogeSA9IFwiZW1haWxcIixcbiAgYWRkaXRpb25hbERhdGE6IF8sXG4gIGNoaWxkcmVuOiBpXG59KSB7XG4gIGNvbnN0IHggPSBXKGkxLCBjLnZhcmlhYmxlcyA/PyB7fSksIFtoLCBnXSA9IHUodiksIFtzLCBNXSA9IHUoXCJcIiksIFtiLCAkXSA9IHUoXCJcIiksIFAgPSBoID09PSBcInNpZ25faW5cIiB8fCBoID09PSBcInNpZ25fdXBcIiB8fCBoID09PSBcIm1hZ2ljX2xpbmtcIjtcbiAgUigoKSA9PiB7XG4gICAgdmFyIEYsIGY7XG4gICAgbjEoe1xuICAgICAgdGhlbWU6IFcoXG4gICAgICAgICgoRiA9IGEgPT0gbnVsbCA/IHZvaWQgMCA6IGEudGhlbWUpID09IG51bGwgPyB2b2lkIDAgOiBGLmRlZmF1bHQpID8/IHt9LFxuICAgICAgICAoKGYgPSBhID09IG51bGwgPyB2b2lkIDAgOiBhLnZhcmlhYmxlcykgPT0gbnVsbCA/IHZvaWQgMCA6IGYuZGVmYXVsdCkgPz8ge31cbiAgICAgIClcbiAgICB9KTtcbiAgfSwgW2FdKTtcbiAgY29uc3QgVSA9ICh7IGNoaWxkcmVuOiBGIH0pID0+IHtcbiAgICB2YXIgZjtcbiAgICByZXR1cm4gKFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgXCJkaXZcIixcbiAgICAgICAge1xuICAgICAgICAgIGNsYXNzTmFtZTogbSAhPT0gXCJkZWZhdWx0XCIgPyBzMShcbiAgICAgICAgICAgIFcoXG4gICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgYSA9PSBudWxsID8gdm9pZCAwIDogYS50aGVtZVttXSxcbiAgICAgICAgICAgICAgKChmID0gYSA9PSBudWxsID8gdm9pZCAwIDogYS52YXJpYWJsZXMpID09IG51bGwgPyB2b2lkIDAgOiBmW21dKSA/PyB7fVxuICAgICAgICAgICAgKVxuICAgICAgICAgICkgOiBcIlwiXG4gICAgICAgIH0sXG4gICAgICAgIFAgJiYgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgICBWMSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBhcHBlYXJhbmNlOiBhLFxuICAgICAgICAgICAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gICAgICAgICAgICBwcm92aWRlcnM6IG4sXG4gICAgICAgICAgICBwcm92aWRlclNjb3BlczogcixcbiAgICAgICAgICAgIHF1ZXJ5UGFyYW1zOiBvLFxuICAgICAgICAgICAgc29jaWFsTGF5b3V0OiBsLFxuICAgICAgICAgICAgcmVkaXJlY3RUbzogRSxcbiAgICAgICAgICAgIG9ubHlUaGlyZFBhcnR5UHJvdmlkZXJzOiBDLFxuICAgICAgICAgICAgaTE4bjogeCxcbiAgICAgICAgICAgIHZpZXc6IGhcbiAgICAgICAgICB9XG4gICAgICAgICksXG4gICAgICAgICFDICYmIEZcbiAgICAgIClcbiAgICApO1xuICB9O1xuICBSKCgpID0+IHtcbiAgICBjb25zdCB7IGRhdGE6IEYgfSA9IHQuYXV0aC5vbkF1dGhTdGF0ZUNoYW5nZShcbiAgICAgIChmKSA9PiB7XG4gICAgICAgIGYgPT09IFwiUEFTU1dPUkRfUkVDT1ZFUllcIiA/IGcoXCJ1cGRhdGVfcGFzc3dvcmRcIikgOiBmID09PSBcIlVTRVJfVVBEQVRFRFwiICYmIGcoXCJzaWduX2luXCIpO1xuICAgICAgfVxuICAgICk7XG4gICAgcmV0dXJuIGcodiksICgpID0+IEYuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gIH0sIFt2XSk7XG4gIGNvbnN0IE8gPSB7XG4gICAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gICAgc2V0QXV0aFZpZXc6IGcsXG4gICAgZGVmYXVsdEVtYWlsOiBzLFxuICAgIGRlZmF1bHRQYXNzd29yZDogYixcbiAgICBzZXREZWZhdWx0RW1haWw6IE0sXG4gICAgc2V0RGVmYXVsdFBhc3N3b3JkOiAkLFxuICAgIHJlZGlyZWN0VG86IEUsXG4gICAgbWFnaWNMaW5rOiB3LFxuICAgIHNob3dMaW5rczogZCxcbiAgICBpMThuOiB4LFxuICAgIGFwcGVhcmFuY2U6IGFcbiAgfTtcbiAgc3dpdGNoIChoKSB7XG4gICAgY2FzZSBwLlNJR05fSU46XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChVLCBudWxsLCAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFEsIHsgLi4uTywgYXV0aFZpZXc6IFwic2lnbl9pblwiIH0pKTtcbiAgICBjYXNlIHAuU0lHTl9VUDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFUsIG51bGwsIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIFEsXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlYXJhbmNlOiBhLFxuICAgICAgICAgIHN1cGFiYXNlQ2xpZW50OiB0LFxuICAgICAgICAgIGF1dGhWaWV3OiBcInNpZ25fdXBcIixcbiAgICAgICAgICBzZXRBdXRoVmlldzogZyxcbiAgICAgICAgICBkZWZhdWx0RW1haWw6IHMsXG4gICAgICAgICAgZGVmYXVsdFBhc3N3b3JkOiBiLFxuICAgICAgICAgIHNldERlZmF1bHRFbWFpbDogTSxcbiAgICAgICAgICBzZXREZWZhdWx0UGFzc3dvcmQ6ICQsXG4gICAgICAgICAgcmVkaXJlY3RUbzogRSxcbiAgICAgICAgICBtYWdpY0xpbms6IHcsXG4gICAgICAgICAgc2hvd0xpbmtzOiBkLFxuICAgICAgICAgIGkxOG46IHgsXG4gICAgICAgICAgYWRkaXRpb25hbERhdGE6IF8sXG4gICAgICAgICAgY2hpbGRyZW46IGlcbiAgICAgICAgfVxuICAgICAgKSk7XG4gICAgY2FzZSBwLkZPUkdPVFRFTl9QQVNTV09SRDpcbiAgICAgIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICAgICAgICBlMSxcbiAgICAgICAge1xuICAgICAgICAgIGFwcGVhcmFuY2U6IGEsXG4gICAgICAgICAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gICAgICAgICAgc2V0QXV0aFZpZXc6IGcsXG4gICAgICAgICAgcmVkaXJlY3RUbzogRSxcbiAgICAgICAgICBzaG93TGlua3M6IGQsXG4gICAgICAgICAgaTE4bjogeFxuICAgICAgICB9XG4gICAgICApO1xuICAgIGNhc2UgcC5NQUdJQ19MSU5LOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoVSwgbnVsbCwgLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgWCxcbiAgICAgICAge1xuICAgICAgICAgIGFwcGVhcmFuY2U6IGEsXG4gICAgICAgICAgc3VwYWJhc2VDbGllbnQ6IHQsXG4gICAgICAgICAgc2V0QXV0aFZpZXc6IGcsXG4gICAgICAgICAgcmVkaXJlY3RUbzogRSxcbiAgICAgICAgICBzaG93TGlua3M6IGQsXG4gICAgICAgICAgaTE4bjogeFxuICAgICAgICB9XG4gICAgICApKTtcbiAgICBjYXNlIHAuVVBEQVRFX1BBU1NXT1JEOlxuICAgICAgcmV0dXJuIC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoXG4gICAgICAgIHQxLFxuICAgICAgICB7XG4gICAgICAgICAgYXBwZWFyYW5jZTogYSxcbiAgICAgICAgICBzdXBhYmFzZUNsaWVudDogdCxcbiAgICAgICAgICBpMThuOiB4XG4gICAgICAgIH1cbiAgICAgICk7XG4gICAgY2FzZSBwLlZFUklGWV9PVFA6XG4gICAgICByZXR1cm4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgICAgICAgQTEsXG4gICAgICAgIHtcbiAgICAgICAgICBhcHBlYXJhbmNlOiBhLFxuICAgICAgICAgIHN1cGFiYXNlQ2xpZW50OiB0LFxuICAgICAgICAgIG90cFR5cGU6IHksXG4gICAgICAgICAgaTE4bjogeFxuICAgICAgICB9XG4gICAgICApO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuay5Gb3Jnb3R0ZW5QYXNzd29yZCA9IGUxO1xuay5VcGRhdGVQYXNzd29yZCA9IHQxO1xuay5NYWdpY0xpbmsgPSBYO1xuay5Vc2VyQ29udGV4dFByb3ZpZGVyID0gVTE7XG5rLnVzZVVzZXIgPSBSMTtcbmNvbnN0IE8xID0gRCh7XG4gIGJvcmRlclJhZGl1czogXCIxMnB4XCIsXG4gIGJveFNoYWRvdzogXCJyZ2JhKDEwMCwgMTAwLCAxMTEsIDAuMikgMHB4IDdweCAyOXB4IDBweFwiLFxuICB3aWR0aDogXCIzNjBweFwiLFxuICBwYWRkaW5nOiBcIjI4cHggMzJweFwiXG59KSwgWjEgPSAoe1xuICBjaGlsZHJlbjogdCxcbiAgYXBwZWFyYW5jZTogbFxufSkgPT4ge1xuICBjb25zdCBuID0gW1xuICAgIGAke2ExfV91aS1jYXJkYCxcbiAgICBPMSgpLFxuICAgIGwgPT0gbnVsbCA/IHZvaWQgMCA6IGwuY2xhc3NOYW1lXG4gIF07XG4gIHJldHVybiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBuLmpvaW4oXCIgXCIpIH0sIHQpO1xufSwgajEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgayxcbiAge1xuICAgIHNob3dMaW5rczogITEsXG4gICAgLi4udCxcbiAgICBvbmx5VGhpcmRQYXJ0eVByb3ZpZGVyczogITEsXG4gICAgdmlldzogXCJzaWduX3VwXCJcbiAgfVxuKSwgcTEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChcbiAgayxcbiAge1xuICAgIHNob3dMaW5rczogITEsXG4gICAgLi4udCxcbiAgICBvbmx5VGhpcmRQYXJ0eVByb3ZpZGVyczogITEsXG4gICAgdmlldzogXCJzaWduX2luXCJcbiAgfVxuKSwgSzEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChrLCB7IC4uLnQsIHZpZXc6IFwibWFnaWNfbGlua1wiLCBzaG93TGlua3M6ICExIH0pLCBZMSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KFxuICBrLFxuICB7XG4gICAgLi4udCxcbiAgICB2aWV3OiBcInNpZ25faW5cIixcbiAgICBzaG93TGlua3M6ICExLFxuICAgIG9ubHlUaGlyZFBhcnR5UHJvdmlkZXJzOiAhMFxuICB9XG4pLCBKMSA9ICh0KSA9PiAvKiBAX19QVVJFX18gKi8gZS5jcmVhdGVFbGVtZW50KGssIHsgc2hvd0xpbmtzOiAhMSwgLi4udCwgdmlldzogXCJmb3Jnb3R0ZW5fcGFzc3dvcmRcIiB9KSwgUTEgPSAodCkgPT4gLyogQF9fUFVSRV9fICovIGUuY3JlYXRlRWxlbWVudChrLCB7IC4uLnQsIHZpZXc6IFwidXBkYXRlX3Bhc3N3b3JkXCIgfSksIFgxID0gKHQpID0+IC8qIEBfX1BVUkVfXyAqLyBlLmNyZWF0ZUVsZW1lbnQoaywgeyAuLi50LCB2aWV3OiBcInZlcmlmeV9vdHBcIiB9KTtcbmV4cG9ydCB7XG4gIGsgYXMgQXV0aCxcbiAgWjEgYXMgQXV0aENhcmQsXG4gIEoxIGFzIEZvcmdvdHRlblBhc3N3b3JkLFxuICBLMSBhcyBNYWdpY0xpbmssXG4gIHExIGFzIFNpZ25JbixcbiAgajEgYXMgU2lnblVwLFxuICBZMSBhcyBTb2NpYWxBdXRoLFxuICBRMSBhcyBVcGRhdGVQYXNzd29yZCxcbiAgWDEgYXMgVmVyaWZ5T3RwXG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@supabase/auth-ui-react/dist/index.es.js\n"));

/***/ }),

/***/ "./node_modules/@supabase/auth-ui-shared/dist/index.mjs":
/*!**************************************************************!*\
  !*** ./node_modules/@supabase/auth-ui-shared/dist/index.mjs ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CLASS_NAMES: function() { return /* binding */ CLASS_NAMES; },\n/* harmony export */   PREPENDED_CLASS_NAMES: function() { return /* binding */ PREPENDED_CLASS_NAMES; },\n/* harmony export */   SocialLayouts: function() { return /* binding */ SocialLayouts; },\n/* harmony export */   ThemeMinimal: function() { return /* binding */ ThemeMinimal; },\n/* harmony export */   ThemeSupa: function() { return /* binding */ ThemeSupa; },\n/* harmony export */   VIEWS: function() { return /* binding */ VIEWS; },\n/* harmony export */   darkThemes: function() { return /* binding */ darkThemes; },\n/* harmony export */   en: function() { return /* binding */ en_default; },\n/* harmony export */   generateClassNames: function() { return /* binding */ generateClassNames; },\n/* harmony export */   merge: function() { return /* binding */ merge; },\n/* harmony export */   minimal: function() { return /* binding */ minimal; },\n/* harmony export */   supabase: function() { return /* binding */ supabase; },\n/* harmony export */   template: function() { return /* binding */ template; }\n/* harmony export */ });\n// src/theming/defaultThemes.ts\nvar ThemeSupa = {\n  default: {\n    colors: {\n      brand: \"hsl(153 60.0% 53.0%)\",\n      brandAccent: \"hsl(154 54.8% 45.1%)\",\n      brandButtonText: \"white\",\n      defaultButtonBackground: \"white\",\n      defaultButtonBackgroundHover: \"#eaeaea\",\n      defaultButtonBorder: \"lightgray\",\n      defaultButtonText: \"gray\",\n      dividerBackground: \"#eaeaea\",\n      inputBackground: \"transparent\",\n      inputBorder: \"lightgray\",\n      inputBorderHover: \"gray\",\n      inputBorderFocus: \"gray\",\n      inputText: \"black\",\n      inputLabelText: \"gray\",\n      inputPlaceholder: \"darkgray\",\n      messageText: \"gray\",\n      messageTextDanger: \"red\",\n      anchorTextColor: \"gray\",\n      anchorTextHoverColor: \"darkgray\"\n    },\n    space: {\n      spaceSmall: \"4px\",\n      spaceMedium: \"8px\",\n      spaceLarge: \"16px\",\n      labelBottomMargin: \"8px\",\n      anchorBottomMargin: \"4px\",\n      emailInputSpacing: \"4px\",\n      socialAuthSpacing: \"4px\",\n      buttonPadding: \"10px 15px\",\n      inputPadding: \"10px 15px\"\n    },\n    fontSizes: {\n      baseBodySize: \"13px\",\n      baseInputSize: \"14px\",\n      baseLabelSize: \"14px\",\n      baseButtonSize: \"14px\"\n    },\n    fonts: {\n      bodyFontFamily: `ui-sans-serif, sans-serif`,\n      buttonFontFamily: `ui-sans-serif, sans-serif`,\n      inputFontFamily: `ui-sans-serif, sans-serif`,\n      labelFontFamily: `ui-sans-serif, sans-serif`\n    },\n    // fontWeights: {},\n    // lineHeights: {},\n    // letterSpacings: {},\n    // sizes: {},\n    borderWidths: {\n      buttonBorderWidth: \"1px\",\n      inputBorderWidth: \"1px\"\n    },\n    // borderStyles: {},\n    radii: {\n      borderRadiusButton: \"4px\",\n      buttonBorderRadius: \"4px\",\n      inputBorderRadius: \"4px\"\n    }\n    // shadows: {},\n    // zIndices: {},\n    // transitions: {},\n  },\n  dark: {\n    colors: {\n      brandButtonText: \"white\",\n      defaultButtonBackground: \"#2e2e2e\",\n      defaultButtonBackgroundHover: \"#3e3e3e\",\n      defaultButtonBorder: \"#3e3e3e\",\n      defaultButtonText: \"white\",\n      dividerBackground: \"#2e2e2e\",\n      inputBackground: \"#1e1e1e\",\n      inputBorder: \"#3e3e3e\",\n      inputBorderHover: \"gray\",\n      inputBorderFocus: \"gray\",\n      inputText: \"white\",\n      inputPlaceholder: \"darkgray\"\n    }\n  }\n};\nvar ThemeMinimal = {\n  default: {\n    colors: {\n      brand: \"black\",\n      brandAccent: \"#333333\",\n      brandButtonText: \"white\",\n      defaultButtonBackground: \"white\",\n      defaultButtonBorder: \"lightgray\",\n      defaultButtonText: \"gray\",\n      dividerBackground: \"#eaeaea\",\n      inputBackground: \"transparent\",\n      inputBorder: \"lightgray\",\n      inputText: \"black\",\n      inputPlaceholder: \"darkgray\"\n    },\n    space: {\n      spaceSmall: \"4px\",\n      spaceMedium: \"8px\",\n      spaceLarge: \"16px\"\n    },\n    fontSizes: {\n      baseInputSize: \"14px\",\n      baseLabelSize: \"12px\"\n    },\n    fonts: {\n      bodyFontFamily: \"\",\n      inputFontFamily: \"\",\n      buttonFontFamily: \"\",\n      labelFontFamily: \"\"\n      // linkFontFamily: '',\n    },\n    // fontWeights: {},\n    // lineHeights: {},\n    // letterSpacings: {},\n    // sizes: {},\n    borderWidths: {},\n    // borderStyles: {},\n    radii: {}\n    // shadows: {},\n    // zIndices: {},\n    // transitions: {},\n  },\n  dark: {\n    colors: {\n      brand: \"white\",\n      brandAccent: \"#afafaf\",\n      brandButtonText: \"black\",\n      defaultButtonBackground: \"#080808\",\n      defaultButtonBorder: \"black\",\n      defaultButtonText: \"white\",\n      dividerBackground: \"black\",\n      inputBackground: \"transparent\",\n      inputBorder: \"gray\",\n      inputText: \"black\",\n      inputPlaceholder: \"darkgray\"\n    }\n  }\n};\n\n// src/theming/Themes.ts\nvar supabase = {\n  colors: {\n    brand: \"hsl(153 60.0% 53.0%)\",\n    brandAccent: \"hsl(154 54.8% 45.1%)\",\n    brandButtonText: \"white\",\n    defaultButtonBackground: \"white\",\n    defaultButtonBackgroundHover: \"#eaeaea\",\n    defaultButtonBorder: \"lightgray\",\n    defaultButtonText: \"gray\",\n    dividerBackground: \"#eaeaea\",\n    inputBackground: \"transparent\",\n    inputBorder: \"lightgray\",\n    inputBorderHover: \"gray\",\n    inputBorderFocus: \"gray\",\n    inputText: \"black\",\n    inputLabelText: \"gray\",\n    inputPlaceholder: \"darkgray\",\n    messageText: \"gray\",\n    messageTextDanger: \"red\",\n    anchorTextColor: \"gray\",\n    anchorTextHoverColor: \"darkgray\"\n  },\n  space: {\n    spaceSmall: \"4px\",\n    spaceMedium: \"8px\",\n    spaceLarge: \"16px\",\n    labelBottomMargin: \"8px\",\n    anchorBottomMargin: \"4px\",\n    emailInputSpacing: \"4px\",\n    socialAuthSpacing: \"4px\",\n    buttonPadding: \"10px 15px\",\n    inputPadding: \"10px 15px\"\n  },\n  fontSizes: {\n    baseBodySize: \"13px\",\n    baseInputSize: \"14px\",\n    baseLabelSize: \"14px\",\n    baseButtonSize: \"14px\"\n  },\n  fonts: {\n    bodyFontFamily: `ui-sans-serif, sans-serif`,\n    buttonFontFamily: `ui-sans-serif, sans-serif`,\n    inputFontFamily: `ui-sans-serif, sans-serif`,\n    labelFontFamily: `ui-sans-serif, sans-serif`\n  },\n  // fontWeights: {},\n  // lineHeights: {},\n  // letterSpacings: {},\n  // sizes: {},\n  borderWidths: {\n    buttonBorderWidth: \"1px\",\n    inputBorderWidth: \"1px\"\n  },\n  // borderStyles: {},\n  radii: {\n    borderRadiusButton: \"4px\",\n    buttonBorderRadius: \"4px\",\n    inputBorderRadius: \"4px\"\n  }\n  // shadows: {},\n  // zIndices: {},\n  // transitions: {},\n};\nvar defaultDarkTheme = {\n  colors: {\n    brandButtonText: \"white\",\n    defaultButtonBackground: \"#2e2e2e\",\n    defaultButtonBackgroundHover: \"#3e3e3e\",\n    defaultButtonBorder: \"#3e3e3e\",\n    defaultButtonText: \"white\",\n    dividerBackground: \"#2e2e2e\",\n    inputBackground: \"#1e1e1e\",\n    inputBorder: \"#3e3e3e\",\n    inputBorderHover: \"gray\",\n    inputBorderFocus: \"gray\",\n    inputText: \"white\",\n    inputPlaceholder: \"darkgray\"\n  }\n};\nvar minimal = {\n  colors: {\n    brand: \"black\",\n    brandAccent: \"#333333\",\n    brandButtonText: \"white\",\n    defaultButtonBackground: \"white\",\n    defaultButtonBorder: \"lightgray\",\n    defaultButtonText: \"gray\",\n    dividerBackground: \"#eaeaea\",\n    inputBackground: \"transparent\",\n    inputBorder: \"lightgray\",\n    inputText: \"black\",\n    inputPlaceholder: \"darkgray\"\n  },\n  space: {\n    spaceSmall: \"4px\",\n    spaceMedium: \"8px\",\n    spaceLarge: \"16px\"\n  },\n  fontSizes: {\n    baseInputSize: \"14px\",\n    baseLabelSize: \"12px\"\n  },\n  fonts: {\n    bodyFontFamily: \"\",\n    inputFontFamily: \"\",\n    buttonFontFamily: \"\",\n    labelFontFamily: \"\"\n    // linkFontFamily: '',\n  },\n  // fontWeights: {},\n  // lineHeights: {},\n  // letterSpacings: {},\n  // sizes: {},\n  borderWidths: {},\n  // borderStyles: {},\n  radii: {}\n  // shadows: {},\n  // zIndices: {},\n  // transitions: {},\n};\nvar minimalDark = {\n  colors: {\n    brand: \"white\",\n    brandAccent: \"#afafaf\",\n    brandButtonText: \"black\",\n    defaultButtonBackground: \"#080808\",\n    defaultButtonBorder: \"black\",\n    defaultButtonText: \"white\",\n    dividerBackground: \"black\",\n    inputBackground: \"transparent\",\n    inputBorder: \"gray\",\n    inputText: \"black\",\n    inputPlaceholder: \"darkgray\"\n  }\n};\nvar darkThemes = {\n  supabase: defaultDarkTheme,\n  minimal: minimalDark\n};\n\n// src/constants.ts\nvar VIEWS = {\n  SIGN_IN: \"sign_in\",\n  SIGN_UP: \"sign_up\",\n  FORGOTTEN_PASSWORD: \"forgotten_password\",\n  MAGIC_LINK: \"magic_link\",\n  UPDATE_PASSWORD: \"update_password\",\n  VERIFY_OTP: \"verify_otp\"\n};\nvar PREPENDED_CLASS_NAMES = \"supabase-auth-ui\";\nvar CLASS_NAMES = {\n  // interfaces\n  ROOT: \"root\",\n  SIGN_IN: VIEWS.SIGN_IN,\n  SIGN_UP: VIEWS.SIGN_UP,\n  FORGOTTEN_PASSWORD: VIEWS.FORGOTTEN_PASSWORD,\n  MAGIC_LINK: VIEWS.MAGIC_LINK,\n  UPDATE_PASSWORD: VIEWS.UPDATE_PASSWORD,\n  // ui\n  anchor: \"ui-anchor\",\n  button: \"ui-button\",\n  container: \"ui-container\",\n  divider: \"ui-divider\",\n  input: \"ui-input\",\n  label: \"ui-label\",\n  loader: \"ui-loader\",\n  message: \"ui-message\"\n};\n\n// src/theming/utils.ts\nfunction generateClassNames(classNameKey, defaultStyles, appearance) {\n  var _a, _b;\n  const classNames = [];\n  const className = CLASS_NAMES[classNameKey];\n  classNames.push(\n    (appearance == null ? void 0 : appearance.prependedClassName) ? (appearance == null ? void 0 : appearance.prependedClassName) + \"_\" + className : PREPENDED_CLASS_NAMES + \"_\" + className\n  );\n  if ((_a = appearance == null ? void 0 : appearance.className) == null ? void 0 : _a[classNameKey]) {\n    classNames.push((_b = appearance == null ? void 0 : appearance.className) == null ? void 0 : _b[classNameKey]);\n  }\n  if ((appearance == null ? void 0 : appearance.extend) === void 0 || (appearance == null ? void 0 : appearance.extend) === true) {\n    classNames.push(defaultStyles);\n  }\n  return classNames;\n}\n\n// src/types.ts\nvar SocialLayouts = /* @__PURE__ */ ((SocialLayouts2) => {\n  SocialLayouts2[SocialLayouts2[\"horizontal\"] = 0] = \"horizontal\";\n  SocialLayouts2[SocialLayouts2[\"vertical\"] = 1] = \"vertical\";\n  return SocialLayouts2;\n})(SocialLayouts || {});\n\n// src/utils.ts\nfunction value(src, next) {\n  let k;\n  if (src && next && typeof src === \"object\" && typeof next === \"object\") {\n    if (Array.isArray(next)) {\n      for (k = 0; k < next.length; k++) {\n        src[k] = value(src[k], next[k]);\n      }\n    } else {\n      for (k in next) {\n        src[k] = value(src[k], next[k]);\n      }\n    }\n    return src;\n  }\n  return next;\n}\nfunction merge(target, ...args) {\n  let len = args.length;\n  for (let i = 0; i < len; i++) {\n    target = value(target, args[i]);\n  }\n  return target;\n}\nfunction template(string, data) {\n  return string.replace(\n    /{{(\\w+)}}/g,\n    (placeholderWithDelimiters, placeholderWithoutDelimiters) => data.hasOwnProperty(placeholderWithoutDelimiters) ? data[placeholderWithoutDelimiters] : placeholderWithDelimiters\n  );\n}\n\n// src/localization/en.json\nvar en_default = {\n  sign_up: {\n    email_label: \"Email address\",\n    password_label: \"Create a Password\",\n    email_input_placeholder: \"Your email address\",\n    password_input_placeholder: \"Your password\",\n    button_label: \"Sign up\",\n    loading_button_label: \"Signing up ...\",\n    social_provider_text: \"Sign in with {{provider}}\",\n    link_text: \"Don't have an account? Sign up\",\n    confirmation_text: \"Check your email for the confirmation link\"\n  },\n  sign_in: {\n    email_label: \"Email address\",\n    password_label: \"Your Password\",\n    email_input_placeholder: \"Your email address\",\n    password_input_placeholder: \"Your password\",\n    button_label: \"Sign in\",\n    loading_button_label: \"Signing in ...\",\n    social_provider_text: \"Sign in with {{provider}}\",\n    link_text: \"Already have an account? Sign in\"\n  },\n  magic_link: {\n    email_input_label: \"Email address\",\n    email_input_placeholder: \"Your email address\",\n    button_label: \"Send Magic Link\",\n    loading_button_label: \"Sending Magic Link ...\",\n    link_text: \"Send a magic link email\",\n    confirmation_text: \"Check your email for the magic link\"\n  },\n  forgotten_password: {\n    email_label: \"Email address\",\n    password_label: \"Your Password\",\n    email_input_placeholder: \"Your email address\",\n    button_label: \"Send reset password instructions\",\n    loading_button_label: \"Sending reset instructions ...\",\n    link_text: \"Forgot your password?\",\n    confirmation_text: \"Check your email for the password reset link\"\n  },\n  update_password: {\n    password_label: \"New password\",\n    password_input_placeholder: \"Your new password\",\n    button_label: \"Update password\",\n    loading_button_label: \"Updating password ...\",\n    confirmation_text: \"Your password has been updated\"\n  },\n  verify_otp: {\n    email_input_label: \"Email address\",\n    email_input_placeholder: \"Your email address\",\n    phone_input_label: \"Phone number\",\n    phone_input_placeholder: \"Your phone number\",\n    token_input_label: \"Token\",\n    token_input_placeholder: \"Your Otp token\",\n    button_label: \"Verify token\",\n    loading_button_label: \"Signing in ...\"\n  }\n};\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtdWktc2hhcmVkL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxzQkFBc0I7QUFDdEIsc0JBQXNCO0FBQ3RCLHlCQUF5QjtBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0Qix5QkFBeUI7QUFDekIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQix1QkFBdUI7QUFDdkI7QUFDQSxrQkFBa0I7QUFDbEIsbUJBQW1CO0FBQ25CLHNC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cGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHN1cGFiYXNlL2F1dGgtdWktc2hhcmVkL2Rpc3QvaW5kZXgubWpzPzY3OGEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL3RoZW1pbmcvZGVmYXVsdFRoZW1lcy50c1xudmFyIFRoZW1lU3VwYSA9IHtcbiAgZGVmYXVsdDoge1xuICAgIGNvbG9yczoge1xuICAgICAgYnJhbmQ6IFwiaHNsKDE1MyA2MC4wJSA1My4wJSlcIixcbiAgICAgIGJyYW5kQWNjZW50OiBcImhzbCgxNTQgNTQuOCUgNDUuMSUpXCIsXG4gICAgICBicmFuZEJ1dHRvblRleHQ6IFwid2hpdGVcIixcbiAgICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIndoaXRlXCIsXG4gICAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZEhvdmVyOiBcIiNlYWVhZWFcIixcbiAgICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwibGlnaHRncmF5XCIsXG4gICAgICBkZWZhdWx0QnV0dG9uVGV4dDogXCJncmF5XCIsXG4gICAgICBkaXZpZGVyQmFja2dyb3VuZDogXCIjZWFlYWVhXCIsXG4gICAgICBpbnB1dEJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIGlucHV0Qm9yZGVyOiBcImxpZ2h0Z3JheVwiLFxuICAgICAgaW5wdXRCb3JkZXJIb3ZlcjogXCJncmF5XCIsXG4gICAgICBpbnB1dEJvcmRlckZvY3VzOiBcImdyYXlcIixcbiAgICAgIGlucHV0VGV4dDogXCJibGFja1wiLFxuICAgICAgaW5wdXRMYWJlbFRleHQ6IFwiZ3JheVwiLFxuICAgICAgaW5wdXRQbGFjZWhvbGRlcjogXCJkYXJrZ3JheVwiLFxuICAgICAgbWVzc2FnZVRleHQ6IFwiZ3JheVwiLFxuICAgICAgbWVzc2FnZVRleHREYW5nZXI6IFwicmVkXCIsXG4gICAgICBhbmNob3JUZXh0Q29sb3I6IFwiZ3JheVwiLFxuICAgICAgYW5jaG9yVGV4dEhvdmVyQ29sb3I6IFwiZGFya2dyYXlcIlxuICAgIH0sXG4gICAgc3BhY2U6IHtcbiAgICAgIHNwYWNlU21hbGw6IFwiNHB4XCIsXG4gICAgICBzcGFjZU1lZGl1bTogXCI4cHhcIixcbiAgICAgIHNwYWNlTGFyZ2U6IFwiMTZweFwiLFxuICAgICAgbGFiZWxCb3R0b21NYXJnaW46IFwiOHB4XCIsXG4gICAgICBhbmNob3JCb3R0b21NYXJnaW46IFwiNHB4XCIsXG4gICAgICBlbWFpbElucHV0U3BhY2luZzogXCI0cHhcIixcbiAgICAgIHNvY2lhbEF1dGhTcGFjaW5nOiBcIjRweFwiLFxuICAgICAgYnV0dG9uUGFkZGluZzogXCIxMHB4IDE1cHhcIixcbiAgICAgIGlucHV0UGFkZGluZzogXCIxMHB4IDE1cHhcIlxuICAgIH0sXG4gICAgZm9udFNpemVzOiB7XG4gICAgICBiYXNlQm9keVNpemU6IFwiMTNweFwiLFxuICAgICAgYmFzZUlucHV0U2l6ZTogXCIxNHB4XCIsXG4gICAgICBiYXNlTGFiZWxTaXplOiBcIjE0cHhcIixcbiAgICAgIGJhc2VCdXR0b25TaXplOiBcIjE0cHhcIlxuICAgIH0sXG4gICAgZm9udHM6IHtcbiAgICAgIGJvZHlGb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgICBidXR0b25Gb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgICBpbnB1dEZvbnRGYW1pbHk6IGB1aS1zYW5zLXNlcmlmLCBzYW5zLXNlcmlmYCxcbiAgICAgIGxhYmVsRm9udEZhbWlseTogYHVpLXNhbnMtc2VyaWYsIHNhbnMtc2VyaWZgXG4gICAgfSxcbiAgICAvLyBmb250V2VpZ2h0czoge30sXG4gICAgLy8gbGluZUhlaWdodHM6IHt9LFxuICAgIC8vIGxldHRlclNwYWNpbmdzOiB7fSxcbiAgICAvLyBzaXplczoge30sXG4gICAgYm9yZGVyV2lkdGhzOiB7XG4gICAgICBidXR0b25Cb3JkZXJXaWR0aDogXCIxcHhcIixcbiAgICAgIGlucHV0Qm9yZGVyV2lkdGg6IFwiMXB4XCJcbiAgICB9LFxuICAgIC8vIGJvcmRlclN0eWxlczoge30sXG4gICAgcmFkaWk6IHtcbiAgICAgIGJvcmRlclJhZGl1c0J1dHRvbjogXCI0cHhcIixcbiAgICAgIGJ1dHRvbkJvcmRlclJhZGl1czogXCI0cHhcIixcbiAgICAgIGlucHV0Qm9yZGVyUmFkaXVzOiBcIjRweFwiXG4gICAgfVxuICAgIC8vIHNoYWRvd3M6IHt9LFxuICAgIC8vIHpJbmRpY2VzOiB7fSxcbiAgICAvLyB0cmFuc2l0aW9uczoge30sXG4gIH0sXG4gIGRhcms6IHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIGJyYW5kQnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmQ6IFwiIzJlMmUyZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmRIb3ZlcjogXCIjM2UzZTNlXCIsXG4gICAgICBkZWZhdWx0QnV0dG9uQm9yZGVyOiBcIiMzZTNlM2VcIixcbiAgICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgICBkaXZpZGVyQmFja2dyb3VuZDogXCIjMmUyZTJlXCIsXG4gICAgICBpbnB1dEJhY2tncm91bmQ6IFwiIzFlMWUxZVwiLFxuICAgICAgaW5wdXRCb3JkZXI6IFwiIzNlM2UzZVwiLFxuICAgICAgaW5wdXRCb3JkZXJIb3ZlcjogXCJncmF5XCIsXG4gICAgICBpbnB1dEJvcmRlckZvY3VzOiBcImdyYXlcIixcbiAgICAgIGlucHV0VGV4dDogXCJ3aGl0ZVwiLFxuICAgICAgaW5wdXRQbGFjZWhvbGRlcjogXCJkYXJrZ3JheVwiXG4gICAgfVxuICB9XG59O1xudmFyIFRoZW1lTWluaW1hbCA9IHtcbiAgZGVmYXVsdDoge1xuICAgIGNvbG9yczoge1xuICAgICAgYnJhbmQ6IFwiYmxhY2tcIixcbiAgICAgIGJyYW5kQWNjZW50OiBcIiMzMzMzMzNcIixcbiAgICAgIGJyYW5kQnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgICAgZGVmYXVsdEJ1dHRvbkJhY2tncm91bmQ6IFwid2hpdGVcIixcbiAgICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwibGlnaHRncmF5XCIsXG4gICAgICBkZWZhdWx0QnV0dG9uVGV4dDogXCJncmF5XCIsXG4gICAgICBkaXZpZGVyQmFja2dyb3VuZDogXCIjZWFlYWVhXCIsXG4gICAgICBpbnB1dEJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICAgIGlucHV0Qm9yZGVyOiBcImxpZ2h0Z3JheVwiLFxuICAgICAgaW5wdXRUZXh0OiBcImJsYWNrXCIsXG4gICAgICBpbnB1dFBsYWNlaG9sZGVyOiBcImRhcmtncmF5XCJcbiAgICB9LFxuICAgIHNwYWNlOiB7XG4gICAgICBzcGFjZVNtYWxsOiBcIjRweFwiLFxuICAgICAgc3BhY2VNZWRpdW06IFwiOHB4XCIsXG4gICAgICBzcGFjZUxhcmdlOiBcIjE2cHhcIlxuICAgIH0sXG4gICAgZm9udFNpemVzOiB7XG4gICAgICBiYXNlSW5wdXRTaXplOiBcIjE0cHhcIixcbiAgICAgIGJhc2VMYWJlbFNpemU6IFwiMTJweFwiXG4gICAgfSxcbiAgICBmb250czoge1xuICAgICAgYm9keUZvbnRGYW1pbHk6IFwiXCIsXG4gICAgICBpbnB1dEZvbnRGYW1pbHk6IFwiXCIsXG4gICAgICBidXR0b25Gb250RmFtaWx5OiBcIlwiLFxuICAgICAgbGFiZWxGb250RmFtaWx5OiBcIlwiXG4gICAgICAvLyBsaW5rRm9udEZhbWlseTogJycsXG4gICAgfSxcbiAgICAvLyBmb250V2VpZ2h0czoge30sXG4gICAgLy8gbGluZUhlaWdodHM6IHt9LFxuICAgIC8vIGxldHRlclNwYWNpbmdzOiB7fSxcbiAgICAvLyBzaXplczoge30sXG4gICAgYm9yZGVyV2lkdGhzOiB7fSxcbiAgICAvLyBib3JkZXJTdHlsZXM6IHt9LFxuICAgIHJhZGlpOiB7fVxuICAgIC8vIHNoYWRvd3M6IHt9LFxuICAgIC8vIHpJbmRpY2VzOiB7fSxcbiAgICAvLyB0cmFuc2l0aW9uczoge30sXG4gIH0sXG4gIGRhcms6IHtcbiAgICBjb2xvcnM6IHtcbiAgICAgIGJyYW5kOiBcIndoaXRlXCIsXG4gICAgICBicmFuZEFjY2VudDogXCIjYWZhZmFmXCIsXG4gICAgICBicmFuZEJ1dHRvblRleHQ6IFwiYmxhY2tcIixcbiAgICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIiMwODA4MDhcIixcbiAgICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwiYmxhY2tcIixcbiAgICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgICBkaXZpZGVyQmFja2dyb3VuZDogXCJibGFja1wiLFxuICAgICAgaW5wdXRCYWNrZ3JvdW5kOiBcInRyYW5zcGFyZW50XCIsXG4gICAgICBpbnB1dEJvcmRlcjogXCJncmF5XCIsXG4gICAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICAgIGlucHV0UGxhY2Vob2xkZXI6IFwiZGFya2dyYXlcIlxuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL3RoZW1pbmcvVGhlbWVzLnRzXG52YXIgc3VwYWJhc2UgPSB7XG4gIGNvbG9yczoge1xuICAgIGJyYW5kOiBcImhzbCgxNTMgNjAuMCUgNTMuMCUpXCIsXG4gICAgYnJhbmRBY2NlbnQ6IFwiaHNsKDE1NCA1NC44JSA0NS4xJSlcIixcbiAgICBicmFuZEJ1dHRvblRleHQ6IFwid2hpdGVcIixcbiAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kSG92ZXI6IFwiI2VhZWFlYVwiLFxuICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwibGlnaHRncmF5XCIsXG4gICAgZGVmYXVsdEJ1dHRvblRleHQ6IFwiZ3JheVwiLFxuICAgIGRpdmlkZXJCYWNrZ3JvdW5kOiBcIiNlYWVhZWFcIixcbiAgICBpbnB1dEJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICBpbnB1dEJvcmRlcjogXCJsaWdodGdyYXlcIixcbiAgICBpbnB1dEJvcmRlckhvdmVyOiBcImdyYXlcIixcbiAgICBpbnB1dEJvcmRlckZvY3VzOiBcImdyYXlcIixcbiAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICBpbnB1dExhYmVsVGV4dDogXCJncmF5XCIsXG4gICAgaW5wdXRQbGFjZWhvbGRlcjogXCJkYXJrZ3JheVwiLFxuICAgIG1lc3NhZ2VUZXh0OiBcImdyYXlcIixcbiAgICBtZXNzYWdlVGV4dERhbmdlcjogXCJyZWRcIixcbiAgICBhbmNob3JUZXh0Q29sb3I6IFwiZ3JheVwiLFxuICAgIGFuY2hvclRleHRIb3ZlckNvbG9yOiBcImRhcmtncmF5XCJcbiAgfSxcbiAgc3BhY2U6IHtcbiAgICBzcGFjZVNtYWxsOiBcIjRweFwiLFxuICAgIHNwYWNlTWVkaXVtOiBcIjhweFwiLFxuICAgIHNwYWNlTGFyZ2U6IFwiMTZweFwiLFxuICAgIGxhYmVsQm90dG9tTWFyZ2luOiBcIjhweFwiLFxuICAgIGFuY2hvckJvdHRvbU1hcmdpbjogXCI0cHhcIixcbiAgICBlbWFpbElucHV0U3BhY2luZzogXCI0cHhcIixcbiAgICBzb2NpYWxBdXRoU3BhY2luZzogXCI0cHhcIixcbiAgICBidXR0b25QYWRkaW5nOiBcIjEwcHggMTVweFwiLFxuICAgIGlucHV0UGFkZGluZzogXCIxMHB4IDE1cHhcIlxuICB9LFxuICBmb250U2l6ZXM6IHtcbiAgICBiYXNlQm9keVNpemU6IFwiMTNweFwiLFxuICAgIGJhc2VJbnB1dFNpemU6IFwiMTRweFwiLFxuICAgIGJhc2VMYWJlbFNpemU6IFwiMTRweFwiLFxuICAgIGJhc2VCdXR0b25TaXplOiBcIjE0cHhcIlxuICB9LFxuICBmb250czoge1xuICAgIGJvZHlGb250RmFtaWx5OiBgdWktc2Fucy1zZXJpZiwgc2Fucy1zZXJpZmAsXG4gICAgYnV0dG9uRm9udEZhbWlseTogYHVpLXNhbnMtc2VyaWYsIHNhbnMtc2VyaWZgLFxuICAgIGlucHV0Rm9udEZhbWlseTogYHVpLXNhbnMtc2VyaWYsIHNhbnMtc2VyaWZgLFxuICAgIGxhYmVsRm9udEZhbWlseTogYHVpLXNhbnMtc2VyaWYsIHNhbnMtc2VyaWZgXG4gIH0sXG4gIC8vIGZvbnRXZWlnaHRzOiB7fSxcbiAgLy8gbGluZUhlaWdodHM6IHt9LFxuICAvLyBsZXR0ZXJTcGFjaW5nczoge30sXG4gIC8vIHNpemVzOiB7fSxcbiAgYm9yZGVyV2lkdGhzOiB7XG4gICAgYnV0dG9uQm9yZGVyV2lkdGg6IFwiMXB4XCIsXG4gICAgaW5wdXRCb3JkZXJXaWR0aDogXCIxcHhcIlxuICB9LFxuICAvLyBib3JkZXJTdHlsZXM6IHt9LFxuICByYWRpaToge1xuICAgIGJvcmRlclJhZGl1c0J1dHRvbjogXCI0cHhcIixcbiAgICBidXR0b25Cb3JkZXJSYWRpdXM6IFwiNHB4XCIsXG4gICAgaW5wdXRCb3JkZXJSYWRpdXM6IFwiNHB4XCJcbiAgfVxuICAvLyBzaGFkb3dzOiB7fSxcbiAgLy8gekluZGljZXM6IHt9LFxuICAvLyB0cmFuc2l0aW9uczoge30sXG59O1xudmFyIGRlZmF1bHREYXJrVGhlbWUgPSB7XG4gIGNvbG9yczoge1xuICAgIGJyYW5kQnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgIGRlZmF1bHRCdXR0b25CYWNrZ3JvdW5kOiBcIiMyZTJlMmVcIixcbiAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZEhvdmVyOiBcIiMzZTNlM2VcIixcbiAgICBkZWZhdWx0QnV0dG9uQm9yZGVyOiBcIiMzZTNlM2VcIixcbiAgICBkZWZhdWx0QnV0dG9uVGV4dDogXCJ3aGl0ZVwiLFxuICAgIGRpdmlkZXJCYWNrZ3JvdW5kOiBcIiMyZTJlMmVcIixcbiAgICBpbnB1dEJhY2tncm91bmQ6IFwiIzFlMWUxZVwiLFxuICAgIGlucHV0Qm9yZGVyOiBcIiMzZTNlM2VcIixcbiAgICBpbnB1dEJvcmRlckhvdmVyOiBcImdyYXlcIixcbiAgICBpbnB1dEJvcmRlckZvY3VzOiBcImdyYXlcIixcbiAgICBpbnB1dFRleHQ6IFwid2hpdGVcIixcbiAgICBpbnB1dFBsYWNlaG9sZGVyOiBcImRhcmtncmF5XCJcbiAgfVxufTtcbnZhciBtaW5pbWFsID0ge1xuICBjb2xvcnM6IHtcbiAgICBicmFuZDogXCJibGFja1wiLFxuICAgIGJyYW5kQWNjZW50OiBcIiMzMzMzMzNcIixcbiAgICBicmFuZEJ1dHRvblRleHQ6IFwid2hpdGVcIixcbiAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZDogXCJ3aGl0ZVwiLFxuICAgIGRlZmF1bHRCdXR0b25Cb3JkZXI6IFwibGlnaHRncmF5XCIsXG4gICAgZGVmYXVsdEJ1dHRvblRleHQ6IFwiZ3JheVwiLFxuICAgIGRpdmlkZXJCYWNrZ3JvdW5kOiBcIiNlYWVhZWFcIixcbiAgICBpbnB1dEJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICBpbnB1dEJvcmRlcjogXCJsaWdodGdyYXlcIixcbiAgICBpbnB1dFRleHQ6IFwiYmxhY2tcIixcbiAgICBpbnB1dFBsYWNlaG9sZGVyOiBcImRhcmtncmF5XCJcbiAgfSxcbiAgc3BhY2U6IHtcbiAgICBzcGFjZVNtYWxsOiBcIjRweFwiLFxuICAgIHNwYWNlTWVkaXVtOiBcIjhweFwiLFxuICAgIHNwYWNlTGFyZ2U6IFwiMTZweFwiXG4gIH0sXG4gIGZvbnRTaXplczoge1xuICAgIGJhc2VJbnB1dFNpemU6IFwiMTRweFwiLFxuICAgIGJhc2VMYWJlbFNpemU6IFwiMTJweFwiXG4gIH0sXG4gIGZvbnRzOiB7XG4gICAgYm9keUZvbnRGYW1pbHk6IFwiXCIsXG4gICAgaW5wdXRGb250RmFtaWx5OiBcIlwiLFxuICAgIGJ1dHRvbkZvbnRGYW1pbHk6IFwiXCIsXG4gICAgbGFiZWxGb250RmFtaWx5OiBcIlwiXG4gICAgLy8gbGlua0ZvbnRGYW1pbHk6ICcnLFxuICB9LFxuICAvLyBmb250V2VpZ2h0czoge30sXG4gIC8vIGxpbmVIZWlnaHRzOiB7fSxcbiAgLy8gbGV0dGVyU3BhY2luZ3M6IHt9LFxuICAvLyBzaXplczoge30sXG4gIGJvcmRlcldpZHRoczoge30sXG4gIC8vIGJvcmRlclN0eWxlczoge30sXG4gIHJhZGlpOiB7fVxuICAvLyBzaGFkb3dzOiB7fSxcbiAgLy8gekluZGljZXM6IHt9LFxuICAvLyB0cmFuc2l0aW9uczoge30sXG59O1xudmFyIG1pbmltYWxEYXJrID0ge1xuICBjb2xvcnM6IHtcbiAgICBicmFuZDogXCJ3aGl0ZVwiLFxuICAgIGJyYW5kQWNjZW50OiBcIiNhZmFmYWZcIixcbiAgICBicmFuZEJ1dHRvblRleHQ6IFwiYmxhY2tcIixcbiAgICBkZWZhdWx0QnV0dG9uQmFja2dyb3VuZDogXCIjMDgwODA4XCIsXG4gICAgZGVmYXVsdEJ1dHRvbkJvcmRlcjogXCJibGFja1wiLFxuICAgIGRlZmF1bHRCdXR0b25UZXh0OiBcIndoaXRlXCIsXG4gICAgZGl2aWRlckJhY2tncm91bmQ6IFwiYmxhY2tcIixcbiAgICBpbnB1dEJhY2tncm91bmQ6IFwidHJhbnNwYXJlbnRcIixcbiAgICBpbnB1dEJvcmRlcjogXCJncmF5XCIsXG4gICAgaW5wdXRUZXh0OiBcImJsYWNrXCIsXG4gICAgaW5wdXRQbGFjZWhvbGRlcjogXCJkYXJrZ3JheVwiXG4gIH1cbn07XG52YXIgZGFya1RoZW1lcyA9IHtcbiAgc3VwYWJhc2U6IGRlZmF1bHREYXJrVGhlbWUsXG4gIG1pbmltYWw6IG1pbmltYWxEYXJrXG59O1xuXG4vLyBzcmMvY29uc3RhbnRzLnRzXG52YXIgVklFV1MgPSB7XG4gIFNJR05fSU46IFwic2lnbl9pblwiLFxuICBTSUdOX1VQOiBcInNpZ25fdXBcIixcbiAgRk9SR09UVEVOX1BBU1NXT1JEOiBcImZvcmdvdHRlbl9wYXNzd29yZFwiLFxuICBNQUdJQ19MSU5LOiBcIm1hZ2ljX2xpbmtcIixcbiAgVVBEQVRFX1BBU1NXT1JEOiBcInVwZGF0ZV9wYXNzd29yZFwiLFxuICBWRVJJRllfT1RQOiBcInZlcmlmeV9vdHBcIlxufTtcbnZhciBQUkVQRU5ERURfQ0xBU1NfTkFNRVMgPSBcInN1cGFiYXNlLWF1dGgtdWlcIjtcbnZhciBDTEFTU19OQU1FUyA9IHtcbiAgLy8gaW50ZXJmYWNlc1xuICBST09UOiBcInJvb3RcIixcbiAgU0lHTl9JTjogVklFV1MuU0lHTl9JTixcbiAgU0lHTl9VUDogVklFV1MuU0lHTl9VUCxcbiAgRk9SR09UVEVOX1BBU1NXT1JEOiBWSUVXUy5GT1JHT1RURU5fUEFTU1dPUkQsXG4gIE1BR0lDX0xJTks6IFZJRVdTLk1BR0lDX0xJTkssXG4gIFVQREFURV9QQVNTV09SRDogVklFV1MuVVBEQVRFX1BBU1NXT1JELFxuICAvLyB1aVxuICBhbmNob3I6IFwidWktYW5jaG9yXCIsXG4gIGJ1dHRvbjogXCJ1aS1idXR0b25cIixcbiAgY29udGFpbmVyOiBcInVpLWNvbnRhaW5lclwiLFxuICBkaXZpZGVyOiBcInVpLWRpdmlkZXJcIixcbiAgaW5wdXQ6IFwidWktaW5wdXRcIixcbiAgbGFiZWw6IFwidWktbGFiZWxcIixcbiAgbG9hZGVyOiBcInVpLWxvYWRlclwiLFxuICBtZXNzYWdlOiBcInVpLW1lc3NhZ2VcIlxufTtcblxuLy8gc3JjL3RoZW1pbmcvdXRpbHMudHNcbmZ1bmN0aW9uIGdlbmVyYXRlQ2xhc3NOYW1lcyhjbGFzc05hbWVLZXksIGRlZmF1bHRTdHlsZXMsIGFwcGVhcmFuY2UpIHtcbiAgdmFyIF9hLCBfYjtcbiAgY29uc3QgY2xhc3NOYW1lcyA9IFtdO1xuICBjb25zdCBjbGFzc05hbWUgPSBDTEFTU19OQU1FU1tjbGFzc05hbWVLZXldO1xuICBjbGFzc05hbWVzLnB1c2goXG4gICAgKGFwcGVhcmFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVhcmFuY2UucHJlcGVuZGVkQ2xhc3NOYW1lKSA/IChhcHBlYXJhbmNlID09IG51bGwgPyB2b2lkIDAgOiBhcHBlYXJhbmNlLnByZXBlbmRlZENsYXNzTmFtZSkgKyBcIl9cIiArIGNsYXNzTmFtZSA6IFBSRVBFTkRFRF9DTEFTU19OQU1FUyArIFwiX1wiICsgY2xhc3NOYW1lXG4gICk7XG4gIGlmICgoX2EgPSBhcHBlYXJhbmNlID09IG51bGwgPyB2b2lkIDAgOiBhcHBlYXJhbmNlLmNsYXNzTmFtZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hW2NsYXNzTmFtZUtleV0pIHtcbiAgICBjbGFzc05hbWVzLnB1c2goKF9iID0gYXBwZWFyYW5jZSA9PSBudWxsID8gdm9pZCAwIDogYXBwZWFyYW5jZS5jbGFzc05hbWUpID09IG51bGwgPyB2b2lkIDAgOiBfYltjbGFzc05hbWVLZXldKTtcbiAgfVxuICBpZiAoKGFwcGVhcmFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGFwcGVhcmFuY2UuZXh0ZW5kKSA9PT0gdm9pZCAwIHx8IChhcHBlYXJhbmNlID09IG51bGwgPyB2b2lkIDAgOiBhcHBlYXJhbmNlLmV4dGVuZCkgPT09IHRydWUpIHtcbiAgICBjbGFzc05hbWVzLnB1c2goZGVmYXVsdFN0eWxlcyk7XG4gIH1cbiAgcmV0dXJuIGNsYXNzTmFtZXM7XG59XG5cbi8vIHNyYy90eXBlcy50c1xudmFyIFNvY2lhbExheW91dHMgPSAvKiBAX19QVVJFX18gKi8gKChTb2NpYWxMYXlvdXRzMikgPT4ge1xuICBTb2NpYWxMYXlvdXRzMltTb2NpYWxMYXlvdXRzMltcImhvcml6b250YWxcIl0gPSAwXSA9IFwiaG9yaXpvbnRhbFwiO1xuICBTb2NpYWxMYXlvdXRzMltTb2NpYWxMYXlvdXRzMltcInZlcnRpY2FsXCJdID0gMV0gPSBcInZlcnRpY2FsXCI7XG4gIHJldHVybiBTb2NpYWxMYXlvdXRzMjtcbn0pKFNvY2lhbExheW91dHMgfHwge30pO1xuXG4vLyBzcmMvdXRpbHMudHNcbmZ1bmN0aW9uIHZhbHVlKHNyYywgbmV4dCkge1xuICBsZXQgaztcbiAgaWYgKHNyYyAmJiBuZXh0ICYmIHR5cGVvZiBzcmMgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG5leHQgPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgZm9yIChrID0gMDsgayA8IG5leHQubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgc3JjW2tdID0gdmFsdWUoc3JjW2tdLCBuZXh0W2tdKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZm9yIChrIGluIG5leHQpIHtcbiAgICAgICAgc3JjW2tdID0gdmFsdWUoc3JjW2tdLCBuZXh0W2tdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNyYztcbiAgfVxuICByZXR1cm4gbmV4dDtcbn1cbmZ1bmN0aW9uIG1lcmdlKHRhcmdldCwgLi4uYXJncykge1xuICBsZXQgbGVuID0gYXJncy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICB0YXJnZXQgPSB2YWx1ZSh0YXJnZXQsIGFyZ3NbaV0pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHJpbmcsIGRhdGEpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKFxuICAgIC97eyhcXHcrKX19L2csXG4gICAgKHBsYWNlaG9sZGVyV2l0aERlbGltaXRlcnMsIHBsYWNlaG9sZGVyV2l0aG91dERlbGltaXRlcnMpID0+IGRhdGEuaGFzT3duUHJvcGVydHkocGxhY2Vob2xkZXJXaXRob3V0RGVsaW1pdGVycykgPyBkYXRhW3BsYWNlaG9sZGVyV2l0aG91dERlbGltaXRlcnNdIDogcGxhY2Vob2xkZXJXaXRoRGVsaW1pdGVyc1xuICApO1xufVxuXG4vLyBzcmMvbG9jYWxpemF0aW9uL2VuLmpzb25cbnZhciBlbl9kZWZhdWx0ID0ge1xuICBzaWduX3VwOiB7XG4gICAgZW1haWxfbGFiZWw6IFwiRW1haWwgYWRkcmVzc1wiLFxuICAgIHBhc3N3b3JkX2xhYmVsOiBcIkNyZWF0ZSBhIFBhc3N3b3JkXCIsXG4gICAgZW1haWxfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBlbWFpbCBhZGRyZXNzXCIsXG4gICAgcGFzc3dvcmRfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBwYXNzd29yZFwiLFxuICAgIGJ1dHRvbl9sYWJlbDogXCJTaWduIHVwXCIsXG4gICAgbG9hZGluZ19idXR0b25fbGFiZWw6IFwiU2lnbmluZyB1cCAuLi5cIixcbiAgICBzb2NpYWxfcHJvdmlkZXJfdGV4dDogXCJTaWduIGluIHdpdGgge3twcm92aWRlcn19XCIsXG4gICAgbGlua190ZXh0OiBcIkRvbid0IGhhdmUgYW4gYWNjb3VudD8gU2lnbiB1cFwiLFxuICAgIGNvbmZpcm1hdGlvbl90ZXh0OiBcIkNoZWNrIHlvdXIgZW1haWwgZm9yIHRoZSBjb25maXJtYXRpb24gbGlua1wiXG4gIH0sXG4gIHNpZ25faW46IHtcbiAgICBlbWFpbF9sYWJlbDogXCJFbWFpbCBhZGRyZXNzXCIsXG4gICAgcGFzc3dvcmRfbGFiZWw6IFwiWW91ciBQYXNzd29yZFwiLFxuICAgIGVtYWlsX2lucHV0X3BsYWNlaG9sZGVyOiBcIllvdXIgZW1haWwgYWRkcmVzc1wiLFxuICAgIHBhc3N3b3JkX2lucHV0X3BsYWNlaG9sZGVyOiBcIllvdXIgcGFzc3dvcmRcIixcbiAgICBidXR0b25fbGFiZWw6IFwiU2lnbiBpblwiLFxuICAgIGxvYWRpbmdfYnV0dG9uX2xhYmVsOiBcIlNpZ25pbmcgaW4gLi4uXCIsXG4gICAgc29jaWFsX3Byb3ZpZGVyX3RleHQ6IFwiU2lnbiBpbiB3aXRoIHt7cHJvdmlkZXJ9fVwiLFxuICAgIGxpbmtfdGV4dDogXCJBbHJlYWR5IGhhdmUgYW4gYWNjb3VudD8gU2lnbiBpblwiXG4gIH0sXG4gIG1hZ2ljX2xpbms6IHtcbiAgICBlbWFpbF9pbnB1dF9sYWJlbDogXCJFbWFpbCBhZGRyZXNzXCIsXG4gICAgZW1haWxfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBlbWFpbCBhZGRyZXNzXCIsXG4gICAgYnV0dG9uX2xhYmVsOiBcIlNlbmQgTWFnaWMgTGlua1wiLFxuICAgIGxvYWRpbmdfYnV0dG9uX2xhYmVsOiBcIlNlbmRpbmcgTWFnaWMgTGluayAuLi5cIixcbiAgICBsaW5rX3RleHQ6IFwiU2VuZCBhIG1hZ2ljIGxpbmsgZW1haWxcIixcbiAgICBjb25maXJtYXRpb25fdGV4dDogXCJDaGVjayB5b3VyIGVtYWlsIGZvciB0aGUgbWFnaWMgbGlua1wiXG4gIH0sXG4gIGZvcmdvdHRlbl9wYXNzd29yZDoge1xuICAgIGVtYWlsX2xhYmVsOiBcIkVtYWlsIGFkZHJlc3NcIixcbiAgICBwYXNzd29yZF9sYWJlbDogXCJZb3VyIFBhc3N3b3JkXCIsXG4gICAgZW1haWxfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBlbWFpbCBhZGRyZXNzXCIsXG4gICAgYnV0dG9uX2xhYmVsOiBcIlNlbmQgcmVzZXQgcGFzc3dvcmQgaW5zdHJ1Y3Rpb25zXCIsXG4gICAgbG9hZGluZ19idXR0b25fbGFiZWw6IFwiU2VuZGluZyByZXNldCBpbnN0cnVjdGlvbnMgLi4uXCIsXG4gICAgbGlua190ZXh0OiBcIkZvcmdvdCB5b3VyIHBhc3N3b3JkP1wiLFxuICAgIGNvbmZpcm1hdGlvbl90ZXh0OiBcIkNoZWNrIHlvdXIgZW1haWwgZm9yIHRoZSBwYXNzd29yZCByZXNldCBsaW5rXCJcbiAgfSxcbiAgdXBkYXRlX3Bhc3N3b3JkOiB7XG4gICAgcGFzc3dvcmRfbGFiZWw6IFwiTmV3IHBhc3N3b3JkXCIsXG4gICAgcGFzc3dvcmRfaW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBuZXcgcGFzc3dvcmRcIixcbiAgICBidXR0b25fbGFiZWw6IFwiVXBkYXRlIHBhc3N3b3JkXCIsXG4gICAgbG9hZGluZ19idXR0b25fbGFiZWw6IFwiVXBkYXRpbmcgcGFzc3dvcmQgLi4uXCIsXG4gICAgY29uZmlybWF0aW9uX3RleHQ6IFwiWW91ciBwYXNzd29yZCBoYXMgYmVlbiB1cGRhdGVkXCJcbiAgfSxcbiAgdmVyaWZ5X290cDoge1xuICAgIGVtYWlsX2lucHV0X2xhYmVsOiBcIkVtYWlsIGFkZHJlc3NcIixcbiAgICBlbWFpbF9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIGVtYWlsIGFkZHJlc3NcIixcbiAgICBwaG9uZV9pbnB1dF9sYWJlbDogXCJQaG9uZSBudW1iZXJcIixcbiAgICBwaG9uZV9pbnB1dF9wbGFjZWhvbGRlcjogXCJZb3VyIHBob25lIG51bWJlclwiLFxuICAgIHRva2VuX2lucHV0X2xhYmVsOiBcIlRva2VuXCIsXG4gICAgdG9rZW5faW5wdXRfcGxhY2Vob2xkZXI6IFwiWW91ciBPdHAgdG9rZW5cIixcbiAgICBidXR0b25fbGFiZWw6IFwiVmVyaWZ5IHRva2VuXCIsXG4gICAgbG9hZGluZ19idXR0b25fbGFiZWw6IFwiU2lnbmluZyBpbiAuLi5cIlxuICB9XG59O1xuZXhwb3J0IHtcbiAgQ0xBU1NfTkFNRVMsXG4gIFBSRVBFTkRFRF9DTEFTU19OQU1FUyxcbiAgU29jaWFsTGF5b3V0cyxcbiAgVGhlbWVNaW5pbWFsLFxuICBUaGVtZVN1cGEsXG4gIFZJRVdTLFxuICBkYXJrVGhlbWVzLFxuICBlbl9kZWZhdWx0IGFzIGVuLFxuICBnZW5lcmF0ZUNsYXNzTmFtZXMsXG4gIG1lcmdlLFxuICBtaW5pbWFsLFxuICBzdXBhYmFzZSxcbiAgdGVtcGxhdGVcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@supabase/auth-ui-shared/dist/index.mjs\n"));

/***/ }),

/***/ "./node_modules/superstruct/lib/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/superstruct/lib/index.es.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   StructError: function() { return /* binding */ StructError; },\n/* harmony export */   any: function() { return /* binding */ any; },\n/* harmony export */   array: function() { return /* binding */ array; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   boolean: function() { return /* binding */ boolean; },\n/* harmony export */   coerce: function() { return /* binding */ coerce; },\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   date: function() { return /* binding */ date; },\n/* harmony export */   defaulted: function() { return /* binding */ defaulted; },\n/* harmony export */   define: function() { return /* binding */ define; },\n/* harmony export */   deprecated: function() { return /* binding */ deprecated; },\n/* harmony export */   dynamic: function() { return /* binding */ dynamic; },\n/* harmony export */   empty: function() { return /* binding */ empty; },\n/* harmony export */   enums: function() { return /* binding */ enums; },\n/* harmony export */   func: function() { return /* binding */ func; },\n/* harmony export */   instance: function() { return /* binding */ instance; },\n/* harmony export */   integer: function() { return /* binding */ integer; },\n/* harmony export */   intersection: function() { return /* binding */ intersection; },\n/* harmony export */   is: function() { return /* binding */ is; },\n/* harmony export */   lazy: function() { return /* binding */ lazy; },\n/* harmony export */   literal: function() { return /* binding */ literal; },\n/* harmony export */   map: function() { return /* binding */ map; },\n/* harmony export */   mask: function() { return /* binding */ mask; },\n/* harmony export */   max: function() { return /* binding */ max; },\n/* harmony export */   min: function() { return /* binding */ min; },\n/* harmony export */   never: function() { return /* binding */ never; },\n/* harmony export */   nullable: function() { return /* binding */ nullable; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   object: function() { return /* binding */ object; },\n/* harmony export */   omit: function() { return /* binding */ omit; },\n/* harmony export */   optional: function() { return /* binding */ optional; },\n/* harmony export */   partial: function() { return /* binding */ partial; },\n/* harmony export */   pattern: function() { return /* binding */ pattern; },\n/* harmony export */   pick: function() { return /* binding */ pick; },\n/* harmony export */   record: function() { return /* binding */ record; },\n/* harmony export */   refine: function() { return /* binding */ refine; },\n/* harmony export */   regexp: function() { return /* binding */ regexp; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   size: function() { return /* binding */ size; },\n/* harmony export */   string: function() { return /* binding */ string; },\n/* harmony export */   struct: function() { return /* binding */ struct; },\n/* harmony export */   trimmed: function() { return /* binding */ trimmed; },\n/* harmony export */   tuple: function() { return /* binding */ tuple; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   union: function() { return /* binding */ union; },\n/* harmony export */   unknown: function() { return /* binding */ unknown; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction* run(value, struct, options = {}) {\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n\n    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction mask(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign(...Structs) {\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nfunction deprecated(struct, log) {\n  return new Struct({ ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n\n    *entries(value, ctx) {\n      var _struct;\n\n      (_struct = struct) != null ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n\n    validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n\n    coercer(value) {\n      return isObject(value) ? { ...value\n      } : value;\n    }\n\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validationfor example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(struct, fallback, options = {}) {\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  const expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', value => {\n    if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return size === 0 || expected + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min, max = min) {\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixzQkFBc0I7QUFDdEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4Q0FBOEM7QUFDOUMsSUFBSSxJQUFJO0FBQ1I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQSxpQ0FBaUM7QUFDakMsUUFBUTtBQUNSOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlEQUFpRDtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIOztBQUUyWTtBQUMzWSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvc3VwZXJzdHJ1Y3QvbGliL2luZGV4LmVzLmpzPzZkMjYiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBBIGBTdHJ1Y3RGYWlsdXJlYCByZXByZXNlbnRzIGEgc2luZ2xlIHNwZWNpZmljIGZhaWx1cmUgaW4gdmFsaWRhdGlvbi5cbiAqL1xuXG4vKipcbiAqIGBTdHJ1Y3RFcnJvcmAgb2JqZWN0cyBhcmUgdGhyb3duIChvciByZXR1cm5lZCkgd2hlbiB2YWxpZGF0aW9uIGZhaWxzLlxuICpcbiAqIFZhbGlkYXRpb24gbG9naWMgaXMgZGVzaWduIHRvIGV4aXQgZWFybHkgZm9yIG1heGltdW0gcGVyZm9ybWFuY2UuIFRoZSBlcnJvclxuICogcmVwcmVzZW50cyB0aGUgZmlyc3QgZXJyb3IgZW5jb3VudGVyZWQgZHVyaW5nIHZhbGlkYXRpb24uIEZvciBtb3JlIGRldGFpbCxcbiAqIHRoZSBgZXJyb3IuZmFpbHVyZXNgIHByb3BlcnR5IGlzIGEgZ2VuZXJhdG9yIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHJ1biB0b1xuICogY29udGludWUgdmFsaWRhdGlvbiBhbmQgcmVjZWl2ZSBhbGwgdGhlIGZhaWx1cmVzIGluIHRoZSBkYXRhLlxuICovXG5jbGFzcyBTdHJ1Y3RFcnJvciBleHRlbmRzIFR5cGVFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGZhaWx1cmUsIGZhaWx1cmVzKSB7XG4gICAgbGV0IGNhY2hlZDtcbiAgICBjb25zdCB7XG4gICAgICBtZXNzYWdlLFxuICAgICAgLi4ucmVzdFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IHtcbiAgICAgIHBhdGhcbiAgICB9ID0gZmFpbHVyZTtcbiAgICBjb25zdCBtc2cgPSBwYXRoLmxlbmd0aCA9PT0gMCA/IG1lc3NhZ2UgOiBcIkF0IHBhdGg6IFwiICsgcGF0aC5qb2luKCcuJykgKyBcIiAtLSBcIiArIG1lc3NhZ2U7XG4gICAgc3VwZXIobXNnKTtcbiAgICBPYmplY3QuYXNzaWduKHRoaXMsIHJlc3QpO1xuICAgIHRoaXMubmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcblxuICAgIHRoaXMuZmFpbHVyZXMgPSAoKSA9PiB7XG4gICAgICB2YXIgX2NhY2hlZDtcblxuICAgICAgcmV0dXJuIChfY2FjaGVkID0gY2FjaGVkKSAhPSBudWxsID8gX2NhY2hlZCA6IGNhY2hlZCA9IFtmYWlsdXJlLCAuLi5mYWlsdXJlcygpXTtcbiAgICB9O1xuICB9XG5cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGl0ZXJhdG9yLlxuICovXG5mdW5jdGlvbiBpc0l0ZXJhYmxlKHgpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHgpICYmIHR5cGVvZiB4W1N5bWJvbC5pdGVyYXRvcl0gPT09ICdmdW5jdGlvbic7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuXG5mdW5jdGlvbiBpc09iamVjdCh4KSB7XG4gIHJldHVybiB0eXBlb2YgeCA9PT0gJ29iamVjdCcgJiYgeCAhPSBudWxsO1xufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgcGxhaW4gb2JqZWN0LlxuICovXG5cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QoeCkge1xuICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHgpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih4KTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG4vKipcbiAqIFJldHVybiBhIHZhbHVlIGFzIGEgcHJpbnRhYmxlIHN0cmluZy5cbiAqL1xuXG5mdW5jdGlvbiBwcmludCh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IEpTT04uc3RyaW5naWZ5KHZhbHVlKSA6IFwiXCIgKyB2YWx1ZTtcbn1cbi8qKlxuICogU2hpZnRzIChyZW1vdmVzIGFuZCByZXR1cm5zKSB0aGUgZmlyc3QgdmFsdWUgZnJvbSB0aGUgYGlucHV0YCBpdGVyYXRvci5cbiAqIExpa2UgYEFycmF5LnByb3RvdHlwZS5zaGlmdCgpYCBidXQgZm9yIGFuIGBJdGVyYXRvcmAuXG4gKi9cblxuZnVuY3Rpb24gc2hpZnRJdGVyYXRvcihpbnB1dCkge1xuICBjb25zdCB7XG4gICAgZG9uZSxcbiAgICB2YWx1ZVxuICB9ID0gaW5wdXQubmV4dCgpO1xuICByZXR1cm4gZG9uZSA/IHVuZGVmaW5lZCA6IHZhbHVlO1xufVxuLyoqXG4gKiBDb252ZXJ0IGEgc2luZ2xlIHZhbGlkYXRpb24gcmVzdWx0IHRvIGEgZmFpbHVyZS5cbiAqL1xuXG5mdW5jdGlvbiB0b0ZhaWx1cmUocmVzdWx0LCBjb250ZXh0LCBzdHJ1Y3QsIHZhbHVlKSB7XG4gIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICByZXR1cm47XG4gIH0gZWxzZSBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgIHJlc3VsdCA9IHt9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnKSB7XG4gICAgcmVzdWx0ID0ge1xuICAgICAgbWVzc2FnZTogcmVzdWx0XG4gICAgfTtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9ID0gY29udGV4dDtcbiAgY29uc3Qge1xuICAgIHR5cGVcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qge1xuICAgIHJlZmluZW1lbnQsXG4gICAgbWVzc2FnZSA9IFwiRXhwZWN0ZWQgYSB2YWx1ZSBvZiB0eXBlIGBcIiArIHR5cGUgKyBcImBcIiArIChyZWZpbmVtZW50ID8gXCIgd2l0aCByZWZpbmVtZW50IGBcIiArIHJlZmluZW1lbnQgKyBcImBcIiA6ICcnKSArIFwiLCBidXQgcmVjZWl2ZWQ6IGBcIiArIHByaW50KHZhbHVlKSArIFwiYFwiXG4gIH0gPSByZXN1bHQ7XG4gIHJldHVybiB7XG4gICAgdmFsdWUsXG4gICAgdHlwZSxcbiAgICByZWZpbmVtZW50LFxuICAgIGtleTogcGF0aFtwYXRoLmxlbmd0aCAtIDFdLFxuICAgIHBhdGgsXG4gICAgYnJhbmNoLFxuICAgIC4uLnJlc3VsdCxcbiAgICBtZXNzYWdlXG4gIH07XG59XG4vKipcbiAqIENvbnZlcnQgYSB2YWxpZGF0aW9uIHJlc3VsdCB0byBhbiBpdGVyYWJsZSBvZiBmYWlsdXJlcy5cbiAqL1xuXG5mdW5jdGlvbiogdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKCFpc0l0ZXJhYmxlKHJlc3VsdCkpIHtcbiAgICByZXN1bHQgPSBbcmVzdWx0XTtcbiAgfVxuXG4gIGZvciAoY29uc3QgciBvZiByZXN1bHQpIHtcbiAgICBjb25zdCBmYWlsdXJlID0gdG9GYWlsdXJlKHIsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpO1xuXG4gICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgIHlpZWxkIGZhaWx1cmU7XG4gICAgfVxuICB9XG59XG4vKipcbiAqIENoZWNrIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgdHJhdmVyc2luZyBkZWVwbHkgaW50byBuZXN0ZWQgdmFsdWVzLCBhbmRcbiAqIHJldHVybmluZyBhbiBpdGVyYXRvciBvZiBmYWlsdXJlcyBvciBzdWNjZXNzLlxuICovXG5cbmZ1bmN0aW9uKiBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBwYXRoID0gW10sXG4gICAgYnJhbmNoID0gW3ZhbHVlXSxcbiAgICBjb2VyY2UgPSBmYWxzZSxcbiAgICBtYXNrID0gZmFsc2VcbiAgfSA9IG9wdGlvbnM7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICBwYXRoLFxuICAgIGJyYW5jaFxuICB9O1xuXG4gIGlmIChjb2VyY2UpIHtcbiAgICB2YWx1ZSA9IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuXG4gICAgaWYgKG1hc2sgJiYgc3RydWN0LnR5cGUgIT09ICd0eXBlJyAmJiBpc09iamVjdChzdHJ1Y3Quc2NoZW1hKSAmJiBpc09iamVjdCh2YWx1ZSkgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoc3RydWN0LnNjaGVtYVtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGxldCB2YWxpZCA9IHRydWU7XG5cbiAgZm9yIChjb25zdCBmYWlsdXJlIG9mIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCkpIHtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICB9XG5cbiAgZm9yIChsZXQgW2ssIHYsIHNdIG9mIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpKSB7XG4gICAgY29uc3QgdHMgPSBydW4odiwgcywge1xuICAgICAgcGF0aDogayA9PT0gdW5kZWZpbmVkID8gcGF0aCA6IFsuLi5wYXRoLCBrXSxcbiAgICAgIGJyYW5jaDogayA9PT0gdW5kZWZpbmVkID8gYnJhbmNoIDogWy4uLmJyYW5jaCwgdl0sXG4gICAgICBjb2VyY2UsXG4gICAgICBtYXNrXG4gICAgfSk7XG5cbiAgICBmb3IgKGNvbnN0IHQgb2YgdHMpIHtcbiAgICAgIGlmICh0WzBdKSB7XG4gICAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIFt0WzBdLCB1bmRlZmluZWRdO1xuICAgICAgfSBlbHNlIGlmIChjb2VyY2UpIHtcbiAgICAgICAgdiA9IHRbMV07XG5cbiAgICAgICAgaWYgKGsgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbHVlID0gdjtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICAgIHZhbHVlLnNldChrLCB2KTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICAgIHZhbHVlLmFkZCh2KTtcbiAgICAgICAgfSBlbHNlIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCkpIHtcbiAgICAgIHZhbGlkID0gZmFsc2U7XG4gICAgICB5aWVsZCBbZmFpbHVyZSwgdW5kZWZpbmVkXTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsaWQpIHtcbiAgICB5aWVsZCBbdW5kZWZpbmVkLCB2YWx1ZV07XG4gIH1cbn1cblxuLyoqXG4gKiBgU3RydWN0YCBvYmplY3RzIGVuY2Fwc3VsYXRlIHRoZSB2YWxpZGF0aW9uIGxvZ2ljIGZvciBhIHNwZWNpZmljIHR5cGUgb2ZcbiAqIHZhbHVlcy4gT25jZSBjb25zdHJ1Y3RlZCwgeW91IHVzZSB0aGUgYGFzc2VydGAsIGBpc2Agb3IgYHZhbGlkYXRlYCBoZWxwZXJzIHRvXG4gKiB2YWxpZGF0ZSB1bmtub3duIGlucHV0IGRhdGEgYWdhaW5zdCB0aGUgc3RydWN0LlxuICovXG5cbmNsYXNzIFN0cnVjdCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZSxcbiAgICAgIHNjaGVtYSxcbiAgICAgIHZhbGlkYXRvcixcbiAgICAgIHJlZmluZXIsXG4gICAgICBjb2VyY2VyID0gdmFsdWUgPT4gdmFsdWUsXG4gICAgICBlbnRyaWVzID0gZnVuY3Rpb24qICgpIHt9XG4gICAgfSA9IHByb3BzO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5zY2hlbWEgPSBzY2hlbWE7XG4gICAgdGhpcy5lbnRyaWVzID0gZW50cmllcztcbiAgICB0aGlzLmNvZXJjZXIgPSBjb2VyY2VyO1xuXG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdGhpcy52YWxpZGF0b3IgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICgpID0+IFtdO1xuICAgIH1cblxuICAgIGlmIChyZWZpbmVyKSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAodmFsdWUsIGNvbnRleHQpID0+IHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVmaW5lcih2YWx1ZSwgY29udGV4dCk7XG4gICAgICAgIHJldHVybiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgdGhpcywgdmFsdWUpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWZpbmVyID0gKCkgPT4gW107XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyB0aGUgc3RydWN0J3MgdmFsaWRhdGlvbiwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAgICovXG5cblxuICBhc3NlcnQodmFsdWUpIHtcbiAgICByZXR1cm4gYXNzZXJ0KHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgdmFsdWUgd2l0aCB0aGUgc3RydWN0J3MgY29lcmNpb24gbG9naWMsIHRoZW4gdmFsaWRhdGUgaXQuXG4gICAqL1xuXG5cbiAgY3JlYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZSh2YWx1ZSwgdGhpcyk7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLlxuICAgKi9cblxuXG4gIGlzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogTWFzayBhIHZhbHVlLCBjb2VyY2luZyBhbmQgdmFsaWRhdGluZyBpdCwgYnV0IHJldHVybmluZyBvbmx5IHRoZSBzdWJzZXQgb2ZcbiAgICogcHJvcGVydGllcyBkZWZpbmVkIGJ5IHRoZSBzdHJ1Y3QncyBzY2hlbWEuXG4gICAqL1xuXG5cbiAgbWFzayh2YWx1ZSkge1xuICAgIHJldHVybiBtYXNrKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogVmFsaWRhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uIGxvZ2ljLCByZXR1cm5pbmcgYSB0dXBsZVxuICAgKiByZXByZXNlbnRpbmcgdGhlIHJlc3VsdC5cbiAgICpcbiAgICogWW91IG1heSBvcHRpb25hbGx5IHBhc3MgYHRydWVgIGZvciB0aGUgYHdpdGhDb2VyY2lvbmAgYXJndW1lbnQgdG8gY29lcmNlXG4gICAqIHRoZSB2YWx1ZSBiZWZvcmUgYXR0ZW1wdGluZyB0byB2YWxpZGF0ZSBpdC4gSWYgeW91IGRvLCB0aGUgcmVzdWx0IHdpbGxcbiAgICogY29udGFpbiB0aGUgY29lcmNlZCByZXN1bHQgd2hlbiBzdWNjZXNzZnVsLlxuICAgKi9cblxuXG4gIHZhbGlkYXRlKHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gdmFsaWRhdGUodmFsdWUsIHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbn1cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QsIHRocm93aW5nIGlmIGl0IGRvZXNuJ3QuXG4gKi9cblxuZnVuY3Rpb24gYXNzZXJ0KHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfVxufVxuLyoqXG4gKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBjb2VyY2lvbiBsb2dpYyBvZiBzdHJ1Y3QgYW5kIHZhbGlkYXRlIGl0LlxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHtcbiAgICBjb2VyY2U6IHRydWVcbiAgfSk7XG5cbiAgaWYgKHJlc3VsdFswXSkge1xuICAgIHRocm93IHJlc3VsdFswXTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcmVzdWx0WzFdO1xuICB9XG59XG4vKipcbiAqIE1hc2sgYSB2YWx1ZSwgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgYSBzdHJ1Y3QuXG4gKi9cblxuZnVuY3Rpb24gbWFzayh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIHtcbiAgICBjb2VyY2U6IHRydWUsXG4gICAgbWFzazogdHJ1ZVxuICB9KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgYSBzdHJ1Y3QuXG4gKi9cblxuZnVuY3Rpb24gaXModmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcbiAgcmV0dXJuICFyZXN1bHRbMF07XG59XG4vKipcbiAqIFZhbGlkYXRlIGEgdmFsdWUgYWdhaW5zdCBhIHN0cnVjdCwgcmV0dXJuaW5nIGFuIGVycm9yIGlmIGludmFsaWQsIG9yIHRoZVxuICogdmFsdWUgKHdpdGggcG90ZW50aWFsIGNvZXJjaW9uKSBpZiB2YWxpZC5cbiAqL1xuXG5mdW5jdGlvbiB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgdHVwbGVzID0gcnVuKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMpO1xuICBjb25zdCB0dXBsZSA9IHNoaWZ0SXRlcmF0b3IodHVwbGVzKTtcblxuICBpZiAodHVwbGVbMF0pIHtcbiAgICBjb25zdCBlcnJvciA9IG5ldyBTdHJ1Y3RFcnJvcih0dXBsZVswXSwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGZvciAoY29uc3QgdCBvZiB0dXBsZXMpIHtcbiAgICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgICB5aWVsZCB0WzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFtlcnJvciwgdW5kZWZpbmVkXTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCB2ID0gdHVwbGVbMV07XG4gICAgcmV0dXJuIFt1bmRlZmluZWQsIHZdO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFzc2lnbiguLi5TdHJ1Y3RzKSB7XG4gIGNvbnN0IHNjaGVtYXMgPSBTdHJ1Y3RzLm1hcChzID0+IHMuc2NoZW1hKTtcbiAgY29uc3Qgc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgLi4uc2NoZW1hcyk7XG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqL1xuXG5mdW5jdGlvbiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiBuYW1lLFxuICAgIHNjaGVtYTogbnVsbCxcbiAgICB2YWxpZGF0b3JcbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgc3RydWN0LCBidXQgdGhlIHZhbHVlIGlzIGFsbG93ZWQgdG9cbiAqIGJlIGB1bmRlZmluZWRgLiBgbG9nYCB3aWxsIGJlIGNhbGxlZCBpZiB0aGUgdmFsdWUgaXMgbm90IGB1bmRlZmluZWRgLlxuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoc3RydWN0LCBsb2cpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgcmVmaW5lcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCksXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2codmFsdWUsIGN0eCk7XG4gICAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RydWN0IHdpdGggZHluYW1pYyB2YWxpZGF0aW9uIGxvZ2ljLlxuICpcbiAqIFRoZSBjYWxsYmFjayB3aWxsIHJlY2VpdmUgdGhlIHZhbHVlIGN1cnJlbnRseSBiZWluZyB2YWxpZGF0ZWQsIGFuZCBtdXN0XG4gKiByZXR1cm4gYSBzdHJ1Y3Qgb2JqZWN0IHRvIHZhbGlkYXRlIGl0IHdpdGguIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byBtb2RlbFxuICogdmFsaWRhdGlvbiBsb2dpYyB0aGF0IGNoYW5nZXMgYmFzZWQgb24gaXRzIGlucHV0LlxuICovXG5cbmZ1bmN0aW9uIGR5bmFtaWMoZm4pIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdkeW5hbWljJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBsYXppbHkgZXZhbHVhdGVkIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdmFsaWRhdGlvbiBpcyBydW4gd2l0aCB0aGUgc3RydWN0LCB0aGUgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWRcbiAqIGFuZCBtdXN0IHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdXNlLiBUaGlzIGlzIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgeW91XG4gKiB3YW50IHRvIGhhdmUgc2VsZi1yZWZlcmVudGlhbCBzdHJ1Y3RzIGZvciBuZXN0ZWQgZGF0YSBzdHJ1Y3R1cmVzIHRvIGF2b2lkIGFcbiAqIGNpcmN1bGFyIGRlZmluaXRpb24gcHJvYmxlbS5cbiAqL1xuXG5mdW5jdGlvbiBsYXp5KGZuKSB7XG4gIGxldCBzdHJ1Y3Q7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbGF6eScsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3Q7XG5cbiAgICAgIChfc3RydWN0ID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdCA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICB5aWVsZCogc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDI7XG5cbiAgICAgIChfc3RydWN0MiA9IHN0cnVjdCkgIT0gbnVsbCA/IF9zdHJ1Y3QyIDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHJldHVybiBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0MztcblxuICAgICAgKF9zdHJ1Y3QzID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdDMgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgcmV0dXJuIHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgZXhjbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBPbWl0YCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIG9taXQoc3RydWN0LCBrZXlzKSB7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWFcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qgc3Vic2NoZW1hID0geyAuLi5zY2hlbWFcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgZGVsZXRlIHN1YnNjaGVtYVtrZXldO1xuICB9XG5cbiAgcmV0dXJuIG9iamVjdChzdWJzY2hlbWEpO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCB3aXRoIGFsbCBvZiBpdHNcbiAqIHByb3BlcnRpZXMgYWxsb3dlZCB0byBiZSBgdW5kZWZpbmVkYC5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUGFydGlhbGAgdXRpbGl0eS5cbiAqL1xuXG5mdW5jdGlvbiBwYXJ0aWFsKHN0cnVjdCkge1xuICBjb25zdCBzY2hlbWEgPSBzdHJ1Y3QgaW5zdGFuY2VvZiBTdHJ1Y3QgPyB7IC4uLnN0cnVjdC5zY2hlbWFcbiAgfSA6IHsgLi4uc3RydWN0XG4gIH07XG5cbiAgZm9yIChjb25zdCBrZXkgaW4gc2NoZW1hKSB7XG4gICAgc2NoZW1hW2tleV0gPSBvcHRpb25hbChzY2hlbWFba2V5XSk7XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IG9ubHkgaW5jbHVkaW5nXG4gKiBzcGVjaWZpYyBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQaWNrYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBpY2soc3RydWN0LCBrZXlzKSB7XG4gIGNvbnN0IHtcbiAgICBzY2hlbWFcbiAgfSA9IHN0cnVjdDtcbiAgY29uc3Qgc3Vic2NoZW1hID0ge307XG5cbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgIHN1YnNjaGVtYVtrZXldID0gc2NoZW1hW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG59XG4vKipcbiAqIERlZmluZSBhIG5ldyBzdHJ1Y3QgdHlwZSB3aXRoIGEgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb24uXG4gKlxuICogQGRlcHJlY2F0ZWQgVGhpcyBmdW5jdGlvbiBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLlxuICovXG5cbmZ1bmN0aW9uIHN0cnVjdChuYW1lLCB2YWxpZGF0b3IpIHtcbiAgY29uc29sZS53YXJuKCdzdXBlcnN0cnVjdEAwLjExIC0gVGhlIGBzdHJ1Y3RgIGhlbHBlciBoYXMgYmVlbiByZW5hbWVkIHRvIGBkZWZpbmVgLicpO1xuICByZXR1cm4gZGVmaW5lKG5hbWUsIHZhbGlkYXRvcik7XG59XG5cbi8qKlxuICogRW5zdXJlIHRoYXQgYW55IHZhbHVlIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGFueSgpIHtcbiAgcmV0dXJuIGRlZmluZSgnYW55JywgKCkgPT4gdHJ1ZSk7XG59XG5mdW5jdGlvbiBhcnJheShFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnYXJyYXknLFxuICAgIHNjaGVtYTogRWxlbWVudCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IFtpLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdiwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUuc2xpY2UoKSA6IHZhbHVlO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIGFycmF5IHZhbHVlLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGJvb2xlYW4uXG4gKi9cblxuZnVuY3Rpb24gYm9vbGVhbigpIHtcbiAgcmV0dXJuIGRlZmluZSgnYm9vbGVhbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgdmFsaWQgYERhdGVgLlxuICpcbiAqIE5vdGU6IHRoaXMgYWxzbyBlbnN1cmVzIHRoYXQgdGhlIHZhbHVlIGlzICpub3QqIGFuIGludmFsaWQgYERhdGVgIG9iamVjdCxcbiAqIHdoaWNoIGNhbiBvY2N1ciB3aGVuIHBhcnNpbmcgYSBkYXRlIGZhaWxzIGJ1dCBzdGlsbCByZXR1cm5zIGEgYERhdGVgLlxuICovXG5cbmZ1bmN0aW9uIGRhdGUoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2RhdGUnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgRGF0ZSAmJiAhaXNOYU4odmFsdWUuZ2V0VGltZSgpKSB8fCBcIkV4cGVjdGVkIGEgdmFsaWQgYERhdGVgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBlbnVtcyh2YWx1ZXMpIHtcbiAgY29uc3Qgc2NoZW1hID0ge307XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gdmFsdWVzLm1hcCh2ID0+IHByaW50KHYpKS5qb2luKCk7XG5cbiAgZm9yIChjb25zdCBrZXkgb2YgdmFsdWVzKSB7XG4gICAgc2NoZW1hW2tleV0gPSBrZXk7XG4gIH1cblxuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2VudW1zJyxcbiAgICBzY2hlbWEsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZXMuaW5jbHVkZXModmFsdWUpIHx8IFwiRXhwZWN0ZWQgb25lIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGZ1bmMoKSB7XG4gIHJldHVybiBkZWZpbmUoJ2Z1bmMnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBcIkV4cGVjdGVkIGEgZnVuY3Rpb24sIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGluc3RhbmNlIG9mIGEgc3BlY2lmaWMgY2xhc3MuXG4gKi9cblxuZnVuY3Rpb24gaW5zdGFuY2UoQ2xhc3MpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW5zdGFuY2UnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgQ2xhc3MgfHwgXCJFeHBlY3RlZCBhIGBcIiArIENsYXNzLm5hbWUgKyBcImAgaW5zdGFuY2UsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gKi9cblxuZnVuY3Rpb24gaW50ZWdlcigpIHtcbiAgcmV0dXJuIGRlZmluZSgnaW50ZWdlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpICYmIE51bWJlci5pc0ludGVnZXIodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gaW50ZWdlciwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24oU3RydWN0cykge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2ludGVyc2VjdGlvbicsXG4gICAgc2NoZW1hOiBudWxsLFxuXG4gICAgKmVudHJpZXModmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgKnZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChjb25zdGFudCkge1xuICBjb25zdCBkZXNjcmlwdGlvbiA9IHByaW50KGNvbnN0YW50KTtcbiAgY29uc3QgdCA9IHR5cGVvZiBjb25zdGFudDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsaXRlcmFsJyxcbiAgICBzY2hlbWE6IHQgPT09ICdzdHJpbmcnIHx8IHQgPT09ICdudW1iZXInIHx8IHQgPT09ICdib29sZWFuJyA/IGNvbnN0YW50IDogbnVsbCxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID09PSBjb25zdGFudCB8fCBcIkV4cGVjdGVkIHRoZSBsaXRlcmFsIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIG1hcChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnbWFwJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEtleSAmJiBWYWx1ZSAmJiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiB2YWx1ZS5lbnRyaWVzKCkpIHtcbiAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIE1hcCA/IG5ldyBNYXAodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IFwiRXhwZWN0ZWQgYSBgTWFwYCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBubyB2YWx1ZSBldmVyIHBhc3NlcyB2YWxpZGF0aW9uLlxuICovXG5cbmZ1bmN0aW9uIG5ldmVyKCkge1xuICByZXR1cm4gZGVmaW5lKCduZXZlcicsICgpID0+IGZhbHNlKTtcbn1cbi8qKlxuICogQXVnbWVudCBhbiBleGlzdGluZyBzdHJ1Y3QgdG8gYWxsb3cgYG51bGxgIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBudWxsYWJsZShzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IG51bGwgfHwgc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eClcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBudW1iZXIuXG4gKi9cblxuZnVuY3Rpb24gbnVtYmVyKCkge1xuICByZXR1cm4gZGVmaW5lKCdudW1iZXInLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHZhbHVlKSB8fCBcIkV4cGVjdGVkIGEgbnVtYmVyLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIG9iamVjdChzY2hlbWEpIHtcbiAgY29uc3Qga25vd25zID0gc2NoZW1hID8gT2JqZWN0LmtleXMoc2NoZW1hKSA6IFtdO1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICBzY2hlbWE6IHNjaGVtYSA/IHNjaGVtYSA6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKHNjaGVtYSAmJiBpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgdW5rbm93bnMgPSBuZXcgU2V0KE9iamVjdC5rZXlzKHZhbHVlKSk7XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2Yga25vd25zKSB7XG4gICAgICAgICAgdW5rbm93bnMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgeWllbGQgW2tleSwgdmFsdWVba2V5XSwgc2NoZW1hW2tleV1dO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChjb25zdCBrZXkgb2YgdW5rbm93bnMpIHtcbiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpID8geyAuLi52YWx1ZVxuICAgICAgfSA6IHZhbHVlO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byBhbGxvdyBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gKi9cblxuZnVuY3Rpb24gb3B0aW9uYWwoc3RydWN0KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIHZhbGlkYXRvcjogKHZhbHVlLCBjdHgpID0+IHZhbHVlID09PSB1bmRlZmluZWQgfHwgc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBrZXlzIGFuZCB2YWx1ZXMgb2Ygc3BlY2lmaWMgdHlwZXMsIGJ1dFxuICogd2l0aG91dCBlbnN1cmluZyBhbnkgc3BlY2lmaWMgc2hhcGUgb2YgcHJvcGVydGllcy5cbiAqXG4gKiBMaWtlIFR5cGVTY3JpcHQncyBgUmVjb3JkYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHJlY29yZChLZXksIFZhbHVlKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAncmVjb3JkJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICBjb25zdCB2ID0gdmFsdWVba107XG4gICAgICAgICAgeWllbGQgW2ssIGssIEtleV07XG4gICAgICAgICAgeWllbGQgW2ssIHYsIFZhbHVlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYFJlZ0V4cGAuXG4gKlxuICogTm90ZTogdGhpcyBkb2VzIG5vdCB0ZXN0IHRoZSB2YWx1ZSBhZ2FpbnN0IHRoZSByZWd1bGFyIGV4cHJlc3Npb24hIEZvciB0aGF0XG4gKiB5b3UgbmVlZCB0byB1c2UgdGhlIGBwYXR0ZXJuKClgIHJlZmluZW1lbnQuXG4gKi9cblxuZnVuY3Rpb24gcmVnZXhwKCkge1xuICByZXR1cm4gZGVmaW5lKCdyZWdleHAnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUmVnRXhwO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNldChFbGVtZW50KSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnc2V0JyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEVsZW1lbnQgJiYgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgZm9yIChjb25zdCB2IG9mIHZhbHVlKSB7XG4gICAgICAgICAgeWllbGQgW3YsIHYsIEVsZW1lbnRdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFNldCA/IG5ldyBTZXQodmFsdWUpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0IHx8IFwiRXhwZWN0ZWQgYSBgU2V0YCBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHN0cmluZygpIHtcbiAgcmV0dXJuIGRlZmluZSgnc3RyaW5nJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IFwiRXhwZWN0ZWQgYSBzdHJpbmcsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gdHVwbGUoRWxlbWVudHMpIHtcbiAgY29uc3QgTmV2ZXIgPSBuZXZlcigpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R1cGxlJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IE1hdGgubWF4KEVsZW1lbnRzLmxlbmd0aCwgdmFsdWUubGVuZ3RoKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgeWllbGQgW2ksIHZhbHVlW2ldLCBFbGVtZW50c1tpXSB8fCBOZXZlcl07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBhcnJheSwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaGFzIGEgc2V0IG9mIGtub3duIHByb3BlcnRpZXMgb2Ygc3BlY2lmaWMgdHlwZXMuXG4gKlxuICogTm90ZTogVW5yZWNvZ25pemVkIHByb3BlcnRpZXMgYXJlIGFsbG93ZWQgYW5kIHVudG91Y2hlZC4gVGhpcyBpcyBzaW1pbGFyIHRvXG4gKiBob3cgVHlwZVNjcmlwdCdzIHN0cnVjdHVyYWwgdHlwaW5nIHdvcmtzLlxuICovXG5cbmZ1bmN0aW9uIHR5cGUoc2NoZW1hKSB7XG4gIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhzY2hlbWEpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3R5cGUnLFxuICAgIHNjaGVtYSxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBvZiBrZXlzKSB7XG4gICAgICAgICAgeWllbGQgW2ssIHZhbHVlW2tdLCBzY2hlbWFba11dO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiB1bmlvbihTdHJ1Y3RzKSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gU3RydWN0cy5tYXAocyA9PiBzLnR5cGUpLmpvaW4oJyB8ICcpO1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ3VuaW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3QgZmFpbHVyZXMgPSBbXTtcblxuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgY29uc3QgWy4uLnR1cGxlc10gPSBydW4odmFsdWUsIFMsIGN0eCk7XG4gICAgICAgIGNvbnN0IFtmaXJzdF0gPSB0dXBsZXM7XG5cbiAgICAgICAgaWYgKCFmaXJzdFswXSkge1xuICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IFtmYWlsdXJlXSBvZiB0dXBsZXMpIHtcbiAgICAgICAgICAgIGlmIChmYWlsdXJlKSB7XG4gICAgICAgICAgICAgIGZhaWx1cmVzLnB1c2goZmFpbHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbXCJFeHBlY3RlZCB0aGUgdmFsdWUgdG8gc2F0aXNmeSBhIHVuaW9uIG9mIGBcIiArIGRlc2NyaXB0aW9uICsgXCJgLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpLCAuLi5mYWlsdXJlc107XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24sIHdpdGhvdXQgd2lkZW5pbmcgaXRzIHR5cGUgdG8gYGFueWAuXG4gKi9cblxuZnVuY3Rpb24gdW5rbm93bigpIHtcbiAgcmV0dXJuIGRlZmluZSgndW5rbm93bicsICgpID0+IHRydWUpO1xufVxuXG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCBjb2VyY2lvbiBzdGVwIHRvIGl0cyBpbnB1dC5cbiAqXG4gKiBUaGlzIGFsbG93cyB5b3UgdG8gdHJhbnNmb3JtIGlucHV0IGRhdGEgYmVmb3JlIHZhbGlkYXRpbmcgaXQsIHRvIGluY3JlYXNlIHRoZVxuICogbGlrZWxpaG9vZCB0aGF0IGl0IHBhc3NlcyB2YWxpZGF0aW9u4oCUZm9yIGV4YW1wbGUgZm9yIGRlZmF1bHQgdmFsdWVzLCBwYXJzaW5nXG4gKiBkaWZmZXJlbnQgZm9ybWF0cywgZXRjLlxuICpcbiAqIE5vdGU6IFlvdSBtdXN0IHVzZSBgY3JlYXRlKHZhbHVlLCBTdHJ1Y3QpYCBvbiB0aGUgdmFsdWUgdG8gaGF2ZSB0aGUgY29lcmNpb25cbiAqIHRha2UgZWZmZWN0ISBVc2luZyBzaW1wbHkgYGFzc2VydCgpYCBvciBgaXMoKWAgd2lsbCBub3QgdXNlIGNvZXJjaW9uLlxuICovXG5cbmZ1bmN0aW9uIGNvZXJjZShzdHJ1Y3QsIGNvbmRpdGlvbiwgY29lcmNlcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICBjb2VyY2VyOiAodmFsdWUsIGN0eCkgPT4ge1xuICAgICAgcmV0dXJuIGlzKHZhbHVlLCBjb25kaXRpb24pID8gc3RydWN0LmNvZXJjZXIoY29lcmNlcih2YWx1ZSwgY3R4KSwgY3R4KSA6IHN0cnVjdC5jb2VyY2VyKHZhbHVlLCBjdHgpO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBzdHJ1Y3QgdG8gcmVwbGFjZSBgdW5kZWZpbmVkYCB2YWx1ZXMgd2l0aCBhIGRlZmF1bHQuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gZGVmYXVsdGVkKHN0cnVjdCwgZmFsbGJhY2ssIG9wdGlvbnMgPSB7fSkge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgdW5rbm93bigpLCB4ID0+IHtcbiAgICBjb25zdCBmID0gdHlwZW9mIGZhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gZmFsbGJhY2soKSA6IGZhbGxiYWNrO1xuXG4gICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGY7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLnN0cmljdCAmJiBpc1BsYWluT2JqZWN0KHgpICYmIGlzUGxhaW5PYmplY3QoZikpIHtcbiAgICAgIGNvbnN0IHJldCA9IHsgLi4ueFxuICAgICAgfTtcbiAgICAgIGxldCBjaGFuZ2VkID0gZmFsc2U7XG5cbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGYpIHtcbiAgICAgICAgaWYgKHJldFtrZXldID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXRba2V5XSA9IGZba2V5XTtcbiAgICAgICAgICBjaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB4O1xuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byB0cmltIHN0cmluZyBpbnB1dHMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gdHJpbW1lZChzdHJ1Y3QpIHtcbiAgcmV0dXJuIGNvZXJjZShzdHJ1Y3QsIHN0cmluZygpLCB4ID0+IHgudHJpbSgpKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG1hcCwgb3Igc2V0IGlzIGVtcHR5LlxuICovXG5cbmZ1bmN0aW9uIGVtcHR5KHN0cnVjdCkge1xuICBjb25zdCBleHBlY3RlZCA9IFwiRXhwZWN0ZWQgYW4gZW1wdHkgXCIgKyBzdHJ1Y3QudHlwZTtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdlbXB0eScsIHZhbHVlID0+IHtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgdmFsdWUgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2l6ZVxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHNpemUgPT09IDAgfHwgZXhwZWN0ZWQgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBsZW5ndGggPT09IDAgfHwgZXhwZWN0ZWQgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgYFwiICsgbGVuZ3RoICsgXCJgXCI7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBiZWxvdyBhIHRocmVzaG9sZC5cbiAqL1xuXG5mdW5jdGlvbiBtYXgoc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21heCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPCB0aHJlc2hvbGQgOiB2YWx1ZSA8PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBncmVhdGVyIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgbnVtYmVyIG9yIGRhdGUgaXMgYWJvdmUgYSB0aHJlc2hvbGQuXG4gKi9cblxuZnVuY3Rpb24gbWluKHN0cnVjdCwgdGhyZXNob2xkLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIGV4Y2x1c2l2ZVxuICB9ID0gb3B0aW9ucztcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdtaW4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIGV4Y2x1c2l2ZSA/IHZhbHVlID4gdGhyZXNob2xkIDogdmFsdWUgPj0gdGhyZXNob2xkIHx8IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlICsgXCIgZ3JlYXRlciB0aGFuIFwiICsgKGV4Y2x1c2l2ZSA/ICcnIDogJ29yIGVxdWFsIHRvICcpICsgdGhyZXNob2xkICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZyBtYXRjaGVzIGEgcmVndWxhciBleHByZXNzaW9uLlxuICovXG5cbmZ1bmN0aW9uIHBhdHRlcm4oc3RydWN0LCByZWdleHApIHtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdwYXR0ZXJuJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiByZWdleHAudGVzdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBtYXRjaGluZyBgL1wiICsgcmVnZXhwLnNvdXJjZSArIFwiL2AgYnV0IHJlY2VpdmVkIFxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCI7XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHN0cmluZywgYXJyYXksIG51bWJlciwgZGF0ZSwgbWFwLCBvciBzZXQgaGFzIGEgc2l6ZSAob3IgbGVuZ3RoLCBvciB0aW1lKSBiZXR3ZWVuIGBtaW5gIGFuZCBgbWF4YC5cbiAqL1xuXG5mdW5jdGlvbiBzaXplKHN0cnVjdCwgbWluLCBtYXggPSBtaW4pIHtcbiAgY29uc3QgZXhwZWN0ZWQgPSBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZTtcbiAgY29uc3Qgb2YgPSBtaW4gPT09IG1heCA/IFwib2YgYFwiICsgbWluICsgXCJgXCIgOiBcImJldHdlZW4gYFwiICsgbWluICsgXCJgIGFuZCBgXCIgKyBtYXggKyBcImBcIjtcbiAgcmV0dXJuIHJlZmluZShzdHJ1Y3QsICdzaXplJywgdmFsdWUgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInIHx8IHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgcmV0dXJuIG1pbiA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIGBcIiArIHZhbHVlICsgXCJgXCI7XG4gICAgfSBlbHNlIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaXplXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWluIDw9IHNpemUgJiYgc2l6ZSA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiB3aXRoIGEgc2l6ZSBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgc2l6ZSBvZiBgXCIgKyBzaXplICsgXCJgXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbGVuZ3RoXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gbWluIDw9IGxlbmd0aCAmJiBsZW5ndGggPD0gbWF4IHx8IGV4cGVjdGVkICsgXCIgd2l0aCBhIGxlbmd0aCBcIiArIG9mICsgXCIgYnV0IHJlY2VpdmVkIG9uZSB3aXRoIGEgbGVuZ3RoIG9mIGBcIiArIGxlbmd0aCArIFwiYFwiO1xuICAgIH1cbiAgfSk7XG59XG4vKipcbiAqIEF1Z21lbnQgYSBgU3RydWN0YCB0byBhZGQgYW4gYWRkaXRpb25hbCByZWZpbmVtZW50IHRvIHRoZSB2YWxpZGF0aW9uLlxuICpcbiAqIFRoZSByZWZpbmVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmVjZWl2ZSBhIHZhbHVlIG9mIHRoZSBzdHJ1Y3QncyB0eXBlLFxuICogYmVjYXVzZSB0aGUgc3RydWN0J3MgZXhpc3RpbmcgdmFsaWRhdGlvbiB3aWxsIGFscmVhZHkgaGF2ZSBwYXNzZWQuIFRoaXNcbiAqIGFsbG93cyB5b3UgdG8gbGF5ZXIgYWRkaXRpb25hbCB2YWxpZGF0aW9uIG9uIHRvcCBvZiBleGlzdGluZyBzdHJ1Y3RzLlxuICovXG5cbmZ1bmN0aW9uIHJlZmluZShzdHJ1Y3QsIG5hbWUsIHJlZmluZXIpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG5cbiAgICAqcmVmaW5lcih2YWx1ZSwgY3R4KSB7XG4gICAgICB5aWVsZCogc3RydWN0LnJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjdHgpO1xuICAgICAgY29uc3QgZmFpbHVyZXMgPSB0b0ZhaWx1cmVzKHJlc3VsdCwgY3R4LCBzdHJ1Y3QsIHZhbHVlKTtcblxuICAgICAgZm9yIChjb25zdCBmYWlsdXJlIG9mIGZhaWx1cmVzKSB7XG4gICAgICAgIHlpZWxkIHsgLi4uZmFpbHVyZSxcbiAgICAgICAgICByZWZpbmVtZW50OiBuYW1lXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuXG5leHBvcnQgeyBTdHJ1Y3QsIFN0cnVjdEVycm9yLCBhbnksIGFycmF5LCBhc3NlcnQsIGFzc2lnbiwgYm9vbGVhbiwgY29lcmNlLCBjcmVhdGUsIGRhdGUsIGRlZmF1bHRlZCwgZGVmaW5lLCBkZXByZWNhdGVkLCBkeW5hbWljLCBlbXB0eSwgZW51bXMsIGZ1bmMsIGluc3RhbmNlLCBpbnRlZ2VyLCBpbnRlcnNlY3Rpb24sIGlzLCBsYXp5LCBsaXRlcmFsLCBtYXAsIG1hc2ssIG1heCwgbWluLCBuZXZlciwgbnVsbGFibGUsIG51bWJlciwgb2JqZWN0LCBvbWl0LCBvcHRpb25hbCwgcGFydGlhbCwgcGF0dGVybiwgcGljaywgcmVjb3JkLCByZWZpbmUsIHJlZ2V4cCwgc2V0LCBzaXplLCBzdHJpbmcsIHN0cnVjdCwgdHJpbW1lZCwgdHVwbGUsIHR5cGUsIHVuaW9uLCB1bmtub3duLCB2YWxpZGF0ZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXMuanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/superstruct/lib/index.es.js\n"));

/***/ }),

/***/ "./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs":
/*!***************************************************************!*\
  !*** ./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TextDecoder: function() { return /* binding */ TextDecoder; },\n/* harmony export */   TextEncoder: function() { return /* binding */ TextEncoder; }\n/* harmony export */ });\n\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00  c  0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800  c  0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00  d  0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n/** @interface */\nfunction Decoder() {}\nDecoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point, or |finished|.\n   */\n  handler: function(stream, bite) {}\n};\n\n/** @interface */\nfunction Encoder() {}\nEncoder.prototype = {\n  /**\n   * @param {Stream} stream The stream of code points being encoded.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit, or |finished|.\n   */\n  handler: function(stream, code_point) {}\n};\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        //  0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte  0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte  0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6  utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte  0x80) << (6  (utf-8 bytes\n    // needed  utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6  count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6  (count  1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGV4dC1lbmNvZGluZy11dGYtOC9saWIvZW5jb2RpbmcubGliLm1qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4QkFBOEI7QUFDekM7QUFDQTtBQUNBO0FB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Q0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixZQUFZLGlCQUFpQjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsY0FBYywwQkFBMEI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy90ZXh0LWVuY29kaW5nLXV0Zi04L2xpYi9lbmNvZGluZy5saWIubWpzPzAyM2YiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGlzIGZyZWUgYW5kIHVuZW5jdW1iZXJlZCBzb2Z0d2FyZSByZWxlYXNlZCBpbnRvIHRoZSBwdWJsaWMgZG9tYWluLlxuLy8gU2VlIExJQ0VOU0UubWQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbi8vXG4vLyBVdGlsaXRpZXNcbi8vXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgPj0gbWluIGFuZCBhIDw9IG1heC5cbiAqL1xuZnVuY3Rpb24gaW5SYW5nZShhLCBtaW4sIG1heCkge1xuICByZXR1cm4gbWluIDw9IGEgJiYgYSA8PSBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIFRvRGljdGlvbmFyeShvKSB7XG4gIGlmIChvID09PSB1bmRlZmluZWQpIHJldHVybiB7fTtcbiAgaWYgKG8gPT09IE9iamVjdChvKSkgcmV0dXJuIG87XG4gIHRocm93IFR5cGVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgYXJndW1lbnQgdG8gZGljdGlvbmFyeScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgSW5wdXQgc3RyaW5nIG9mIFVURi0xNiBjb2RlIHVuaXRzLlxuICogQHJldHVybiB7IUFycmF5LjxudW1iZXI+fSBDb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9Db2RlUG9pbnRzKHN0cmluZykge1xuICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNkZm4tb2J0YWluLXVuaWNvZGVcblxuICAvLyAxLiBMZXQgUyBiZSB0aGUgRE9NU3RyaW5nIHZhbHVlLlxuICB2YXIgcyA9IFN0cmluZyhzdHJpbmcpO1xuXG4gIC8vIDIuIExldCBuIGJlIHRoZSBsZW5ndGggb2YgUy5cbiAgdmFyIG4gPSBzLmxlbmd0aDtcblxuICAvLyAzLiBJbml0aWFsaXplIGkgdG8gMC5cbiAgdmFyIGkgPSAwO1xuXG4gIC8vIDQuIEluaXRpYWxpemUgVSB0byBiZSBhbiBlbXB0eSBzZXF1ZW5jZSBvZiBVbmljb2RlIGNoYXJhY3RlcnMuXG4gIHZhciB1ID0gW107XG5cbiAgLy8gNS4gV2hpbGUgaSA8IG46XG4gIHdoaWxlIChpIDwgbikge1xuXG4gICAgLy8gMS4gTGV0IGMgYmUgdGhlIGNvZGUgdW5pdCBpbiBTIGF0IGluZGV4IGkuXG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyAyLiBEZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cbiAgICAvLyBjIDwgMHhEODAwIG9yIGMgPiAweERGRkZcbiAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID4gMHhERkZGKSB7XG4gICAgICAvLyBBcHBlbmQgdG8gVSB0aGUgVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBjb2RlIHBvaW50IGMuXG4gICAgICB1LnB1c2goYyk7XG4gICAgfVxuXG4gICAgLy8gMHhEQzAwIOKJpCBjIOKJpCAweERGRkZcbiAgICBlbHNlIGlmICgweERDMDAgPD0gYyAmJiBjIDw9IDB4REZGRikge1xuICAgICAgLy8gQXBwZW5kIHRvIFUgYSBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLlxuICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgfVxuXG4gICAgLy8gMHhEODAwIOKJpCBjIOKJpCAweERCRkZcbiAgICBlbHNlIGlmICgweEQ4MDAgPD0gYyAmJiBjIDw9IDB4REJGRikge1xuICAgICAgLy8gMS4gSWYgaSA9IG7iiJIxLCB0aGVuIGFwcGVuZCB0byBVIGEgVStGRkZEIFJFUExBQ0VNRU5UXG4gICAgICAvLyBDSEFSQUNURVIuXG4gICAgICBpZiAoaSA9PT0gbiAtIDEpIHtcbiAgICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgICB9XG4gICAgICAvLyAyLiBPdGhlcndpc2UsIGkgPCBu4oiSMTpcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyAxLiBMZXQgZCBiZSB0aGUgY29kZSB1bml0IGluIFMgYXQgaW5kZXggaSsxLlxuICAgICAgICB2YXIgZCA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgICAvLyAyLiBJZiAweERDMDAg4omkIGQg4omkIDB4REZGRiwgdGhlbjpcbiAgICAgICAgaWYgKDB4REMwMCA8PSBkICYmIGQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IGEgYmUgYyAmIDB4M0ZGLlxuICAgICAgICAgIHZhciBhID0gYyAmIDB4M0ZGO1xuXG4gICAgICAgICAgLy8gMi4gTGV0IGIgYmUgZCAmIDB4M0ZGLlxuICAgICAgICAgIHZhciBiID0gZCAmIDB4M0ZGO1xuXG4gICAgICAgICAgLy8gMy4gQXBwZW5kIHRvIFUgdGhlIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggY29kZSBwb2ludFxuICAgICAgICAgIC8vIDJeMTYrMl4xMCphK2IuXG4gICAgICAgICAgdS5wdXNoKDB4MTAwMDAgKyAoYSA8PCAxMCkgKyBiKTtcblxuICAgICAgICAgIC8vIDQuIFNldCBpIHRvIGkrMS5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBPdGhlcndpc2UsIGQgPCAweERDMDAgb3IgZCA+IDB4REZGRi4gQXBwZW5kIHRvIFUgYVxuICAgICAgICAvLyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLlxuICAgICAgICBlbHNlICB7XG4gICAgICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgaSB0byBpKzEuXG4gICAgaSArPSAxO1xuICB9XG5cbiAgLy8gNi4gUmV0dXJuIFUuXG4gIHJldHVybiB1O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBjb2RlX3BvaW50cyBBcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIFN0cmluZyBvZiBVVEYtMTYgY29kZSB1bml0cy5cbiAqL1xuZnVuY3Rpb24gY29kZVBvaW50c1RvU3RyaW5nKGNvZGVfcG9pbnRzKSB7XG4gIHZhciBzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZV9wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY3AgPSBjb2RlX3BvaW50c1tpXTtcbiAgICBpZiAoY3AgPD0gMHhGRkZGKSB7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcCAtPSAweDEwMDAwO1xuICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjcCA+PiAxMCkgKyAweEQ4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNwICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cblxuLy9cbi8vIEltcGxlbWVudGF0aW9uIG9mIEVuY29kaW5nIHNwZWNpZmljYXRpb25cbi8vIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnL1xuLy9cblxuLy9cbi8vIDMuIFRlcm1pbm9sb2d5XG4vL1xuXG4vKipcbiAqIEVuZC1vZi1zdHJlYW0gaXMgYSBzcGVjaWFsIHRva2VuIHRoYXQgc2lnbmlmaWVzIG5vIG1vcmUgdG9rZW5zXG4gKiBhcmUgaW4gdGhlIHN0cmVhbS5cbiAqIEBjb25zdFxuICovIHZhciBlbmRfb2Zfc3RyZWFtID0gLTE7XG5cbi8qKlxuICogQSBzdHJlYW0gcmVwcmVzZW50cyBhbiBvcmRlcmVkIHNlcXVlbmNlIG9mIHRva2Vucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gdG9rZW5zIEFycmF5IG9mIHRva2VucyB0aGF0IHByb3ZpZGUgdGhlXG4gKiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbSh0b2tlbnMpIHtcbiAgLyoqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59ICovXG4gIHRoaXMudG9rZW5zID0gW10uc2xpY2UuY2FsbCh0b2tlbnMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlbmQtb2Ytc3RyZWFtIGhhcyBiZWVuIGhpdC5cbiAgICovXG4gIGVuZE9mU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMudG9rZW5zLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBhIHRva2VuIGlzIHJlYWQgZnJvbSBhIHN0cmVhbSwgdGhlIGZpcnN0IHRva2VuIGluIHRoZVxuICAgKiBzdHJlYW0gbXVzdCBiZSByZXR1cm5lZCBhbmQgc3Vic2VxdWVudGx5IHJlbW92ZWQsIGFuZFxuICAgKiBlbmQtb2Ytc3RyZWFtIG11c3QgYmUgcmV0dXJuZWQgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEdldCB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBzdHJlYW0sIG9yXG4gICAqIGVuZF9vZl9zdHJlYW0uXG4gICAqL1xuICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnRva2Vucy5sZW5ndGgpXG4gICAgICByZXR1cm4gZW5kX29mX3N0cmVhbTtcbiAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIG9uZSBvciBtb3JlIHRva2VucyBhcmUgcHJlcGVuZGVkIHRvIGEgc3RyZWFtLCB0aG9zZSB0b2tlbnNcbiAgICogbXVzdCBiZSBpbnNlcnRlZCwgaW4gZ2l2ZW4gb3JkZXIsIGJlZm9yZSB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IHRva2VuIFRoZSB0b2tlbihzKSB0byBwcmVwZW5kIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwcmVwZW5kOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8odG9rZW4pO1xuICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpXG4gICAgICAgIHRoaXMudG9rZW5zLnVuc2hpZnQodG9rZW5zLnBvcCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2tlbnMudW5zaGlmdCh0b2tlbik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIG9uZSBvciBtb3JlIHRva2VucyBhcmUgcHVzaGVkIHRvIGEgc3RyZWFtLCB0aG9zZSB0b2tlbnNcbiAgICogbXVzdCBiZSBpbnNlcnRlZCwgaW4gZ2l2ZW4gb3JkZXIsIGFmdGVyIHRoZSBsYXN0IHRva2VuIGluIHRoZVxuICAgKiBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSB0b2tlbiBUaGUgdG9rZW5zKHMpIHRvIHByZXBlbmQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHB1c2g6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyh0b2tlbik7XG4gICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aClcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxufTtcblxuLy9cbi8vIDQuIEVuY29kaW5nc1xuLy9cblxuLy8gNC4xIEVuY29kZXJzIGFuZCBkZWNvZGVyc1xuXG4vKiogQGNvbnN0ICovXG52YXIgZmluaXNoZWQgPSAtMTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZhdGFsIElmIHRydWUsIGRlY29kaW5nIGVycm9ycyByYWlzZSBhbiBleGNlcHRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9jb2RlX3BvaW50IE92ZXJyaWRlIHRoZSBzdGFuZGFyZCBmYWxsYmFjayBjb2RlIHBvaW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29kZSBwb2ludCB0byBpbnNlcnQgb24gYSBkZWNvZGluZyBlcnJvci5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlckVycm9yKGZhdGFsLCBvcHRfY29kZV9wb2ludCkge1xuICBpZiAoZmF0YWwpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdEZWNvZGVyIGVycm9yJyk7XG4gIHJldHVybiBvcHRfY29kZV9wb2ludCB8fCAweEZGRkQ7XG59XG5cbi8qKiBAaW50ZXJmYWNlICovXG5mdW5jdGlvbiBEZWNvZGVyKCkge31cbkRlY29kZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGJ5dGVzIGJlaW5nIGRlY29kZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm4gez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9IFRoZSBuZXh0IGNvZGUgcG9pbnQocylcbiAgICogICAgIGRlY29kZWQsIG9yIG51bGwgaWYgbm90IGVub3VnaCBkYXRhIGV4aXN0cyBpbiB0aGUgaW5wdXRcbiAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LCBvciB8ZmluaXNoZWR8LlxuICAgKi9cbiAgaGFuZGxlcjogZnVuY3Rpb24oc3RyZWFtLCBiaXRlKSB7fVxufTtcblxuLyoqIEBpbnRlcmZhY2UgKi9cbmZ1bmN0aW9uIEVuY29kZXIoKSB7fVxuRW5jb2Rlci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIFRoZSBzdHJlYW0gb2YgY29kZSBwb2ludHMgYmVpbmcgZW5jb2RlZC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGNvZGVfcG9pbnQgTmV4dCBjb2RlIHBvaW50IHJlYWQgZnJvbSB0aGUgc3RyZWFtLlxuICAgKiBAcmV0dXJuIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IEJ5dGUocykgdG8gZW1pdCwgb3IgfGZpbmlzaGVkfC5cbiAgICovXG4gIGhhbmRsZXI6IGZ1bmN0aW9uKHN0cmVhbSwgY29kZV9wb2ludCkge31cbn07XG5cbi8vXG4vLyA3LiBBUElcbi8vXG5cbi8qKiBAY29uc3QgKi8gdmFyIERFRkFVTFRfRU5DT0RJTkcgPSAndXRmLTgnO1xuXG4vLyA3LjEgSW50ZXJmYWNlIFRleHREZWNvZGVyXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIFRoZSBsYWJlbCBvZiB0aGUgZW5jb2Rpbmc7XG4gKiAgICAgZGVmYXVsdHMgdG8gJ3V0Zi04Jy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBUZXh0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dERlY29kZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucyk7XG4gIH1cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpIDogREVGQVVMVF9FTkNPRElORztcbiAgaWYgKGVuY29kaW5nICE9PSBERUZBVUxUX0VOQ09ESU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBub3Qgc3VwcG9ydGVkLiBPbmx5IHV0Zi04IGlzIHN1cHBvcnRlZCcpO1xuICB9XG4gIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9zdHJlYW1pbmcgPSBmYWxzZTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9CT01zZWVuID0gZmFsc2U7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7P0RlY29kZXJ9ICovXG4gIHRoaXMuX2RlY29kZXIgPSBudWxsO1xuICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuX2ZhdGFsID0gQm9vbGVhbihvcHRpb25zWydmYXRhbCddKTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9pZ25vcmVCT00gPSBCb29sZWFuKG9wdGlvbnNbJ2lnbm9yZUJPTSddKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VuY29kaW5nJywge3ZhbHVlOiAndXRmLTgnfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZmF0YWwnLCB7dmFsdWU6IHRoaXMuX2ZhdGFsfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWdub3JlQk9NJywge3ZhbHVlOiB0aGlzLl9pZ25vcmVCT019KTtcbn1cblxuVGV4dERlY29kZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXc9fSBpbnB1dCBUaGUgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICAgKi9cbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmICdidWZmZXInIGluIGlucHV0ICYmXG4gICAgICAgICAgICAgICBpbnB1dC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpbnB1dC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgICBpZiAoIXRoaXMuX3N0cmVhbWluZykge1xuICAgICAgdGhpcy5fZGVjb2RlciA9IG5ldyBVVEY4RGVjb2Rlcih7ZmF0YWw6IHRoaXMuX2ZhdGFsfSk7XG4gICAgICB0aGlzLl9CT01zZWVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbWluZyA9IEJvb2xlYW4ob3B0aW9uc1snc3RyZWFtJ10pO1xuXG4gICAgdmFyIGlucHV0X3N0cmVhbSA9IG5ldyBTdHJlYW0oYnl0ZXMpO1xuXG4gICAgdmFyIGNvZGVfcG9pbnRzID0gW107XG5cbiAgICAvKiogQHR5cGUgez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9ICovXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHdoaWxlICghaW5wdXRfc3RyZWFtLmVuZE9mU3RyZWFtKCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmluaXNoZWQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICBjb2RlX3BvaW50cy5wdXNoLmFwcGx5KGNvZGVfcG9pbnRzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgZWxzZVxuICAgICAgICBjb2RlX3BvaW50cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICBjb2RlX3BvaW50cy5wdXNoLmFwcGx5KGNvZGVfcG9pbnRzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY29kZV9wb2ludHMucHVzaChyZXN1bHQpO1xuICAgICAgfSB3aGlsZSAoIWlucHV0X3N0cmVhbS5lbmRPZlN0cmVhbSgpKTtcbiAgICAgIHRoaXMuX2RlY29kZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb2RlX3BvaW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGVuY29kaW5nIGlzIG9uZSBvZiB1dGYtOCwgdXRmLTE2YmUsIGFuZCB1dGYtMTZsZSwgYW5kXG4gICAgICAvLyBpZ25vcmUgQk9NIGZsYWcgYW5kIEJPTSBzZWVuIGZsYWcgYXJlIHVuc2V0LCBydW4gdGhlc2VcbiAgICAgIC8vIHN1YnN1YnN0ZXBzOlxuICAgICAgaWYgKFsndXRmLTgnXS5pbmRleE9mKHRoaXMuZW5jb2RpbmcpICE9PSAtMSAmJlxuICAgICAgICAgICF0aGlzLl9pZ25vcmVCT00gJiYgIXRoaXMuX0JPTXNlZW4pIHtcbiAgICAgICAgLy8gSWYgdG9rZW4gaXMgVStGRUZGLCBzZXQgQk9NIHNlZW4gZmxhZy5cbiAgICAgICAgaWYgKGNvZGVfcG9pbnRzWzBdID09PSAweEZFRkYpIHtcbiAgICAgICAgICB0aGlzLl9CT01zZWVuID0gdHJ1ZTtcbiAgICAgICAgICBjb2RlX3BvaW50cy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdG9rZW4gaXMgbm90IGVuZC1vZi1zdHJlYW0sIHNldCBCT00gc2VlblxuICAgICAgICAgIC8vIGZsYWcgYW5kIGFwcGVuZCB0b2tlbiB0byBvdXRwdXQuXG4gICAgICAgICAgdGhpcy5fQk9Nc2VlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29kZVBvaW50c1RvU3RyaW5nKGNvZGVfcG9pbnRzKTtcbiAgfVxufTtcblxuLy8gNy4yIEludGVyZmFjZSBUZXh0RW5jb2RlclxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmc9fSBlbmNvZGluZyBUaGUgbGFiZWwgb2YgdGhlIGVuY29kaW5nO1xuICogICAgIGRlZmF1bHRzIHRvICd1dGYtOCcuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVGV4dEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHRFbmNvZGVyKSlcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKGVuY29kaW5nLCBvcHRpb25zKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpIDogREVGQVVMVF9FTkNPRElORztcbiAgaWYgKGVuY29kaW5nICE9PSBERUZBVUxUX0VOQ09ESU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBub3Qgc3VwcG9ydGVkLiBPbmx5IHV0Zi04IGlzIHN1cHBvcnRlZCcpO1xuICB9XG4gIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9zdHJlYW1pbmcgPSBmYWxzZTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHs/RW5jb2Rlcn0gKi9cbiAgdGhpcy5fZW5jb2RlciA9IG51bGw7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7e2ZhdGFsOiBib29sZWFufX0gKi9cbiAgdGhpcy5fb3B0aW9ucyA9IHtmYXRhbDogQm9vbGVhbihvcHRpb25zWydmYXRhbCddKX07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlbmNvZGluZycsIHt2YWx1ZTogJ3V0Zi04J30pO1xufVxuXG5UZXh0RW5jb2Rlci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdHJpbmcgVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSBFbmNvZGVkIGJ5dGVzLCBhcyBhIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZShvcHRfc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgb3B0X3N0cmluZyA9IG9wdF9zdHJpbmcgPyBTdHJpbmcob3B0X3N0cmluZykgOiAnJztcbiAgICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gICAgLy8gTk9URTogVGhpcyBvcHRpb24gaXMgbm9uc3RhbmRhcmQuIE5vbmUgb2YgdGhlIGVuY29kaW5nc1xuICAgIC8vIHBlcm1pdHRlZCBmb3IgZW5jb2RpbmcgKGkuZS4gVVRGLTgsIFVURi0xNikgYXJlIHN0YXRlZnVsLFxuICAgIC8vIHNvIHN0cmVhbWluZyBpcyBub3QgbmVjZXNzYXJ5LlxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKVxuICAgICAgdGhpcy5fZW5jb2RlciA9IG5ldyBVVEY4RW5jb2Rlcih0aGlzLl9vcHRpb25zKTtcbiAgICB0aGlzLl9zdHJlYW1pbmcgPSBCb29sZWFuKG9wdGlvbnNbJ3N0cmVhbSddKTtcblxuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIHZhciBpbnB1dF9zdHJlYW0gPSBuZXcgU3RyZWFtKHN0cmluZ1RvQ29kZVBvaW50cyhvcHRfc3RyaW5nKSk7XG4gICAgLyoqIEB0eXBlIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSAqL1xuICAgIHZhciByZXN1bHQ7XG4gICAgd2hpbGUgKCFpbnB1dF9zdHJlYW0uZW5kT2ZTdHJlYW0oKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZW5jb2Rlci5oYW5kbGVyKGlucHV0X3N0cmVhbSwgaW5wdXRfc3RyZWFtLnJlYWQoKSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICBieXRlcy5wdXNoLmFwcGx5KGJ5dGVzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgZWxzZVxuICAgICAgICBieXRlcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVyLmhhbmRsZXIoaW5wdXRfc3RyZWFtLCBpbnB1dF9zdHJlYW0ucmVhZCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmluaXNoZWQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgICAgYnl0ZXMucHVzaC5hcHBseShieXRlcywgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ5dGVzLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICB9XG59O1xuXG4vL1xuLy8gOC4gVGhlIGVuY29kaW5nXG4vL1xuXG4vLyA4LjEgdXRmLThcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtEZWNvZGVyfVxuICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFVURjhEZWNvZGVyKG9wdGlvbnMpIHtcbiAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcblxuICAvLyB1dGYtOCdzIGRlY29kZXIncyBoYXMgYW4gYXNzb2NpYXRlZCB1dGYtOCBjb2RlIHBvaW50LCB1dGYtOFxuICAvLyBieXRlcyBzZWVuLCBhbmQgdXRmLTggYnl0ZXMgbmVlZGVkIChhbGwgaW5pdGlhbGx5IDApLCBhIHV0Zi04XG4gIC8vIGxvd2VyIGJvdW5kYXJ5IChpbml0aWFsbHkgMHg4MCksIGFuZCBhIHV0Zi04IHVwcGVyIGJvdW5kYXJ5XG4gIC8vIChpbml0aWFsbHkgMHhCRikuXG4gIHZhciAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9jb2RlX3BvaW50ID0gMCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2J5dGVzX3NlZW4gPSAwLFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHhCRjtcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGJ5dGVzIGJlaW5nIGRlY29kZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm4gez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9IFRoZSBuZXh0IGNvZGUgcG9pbnQocylcbiAgICogICAgIGRlY29kZWQsIG9yIG51bGwgaWYgbm90IGVub3VnaCBkYXRhIGV4aXN0cyBpbiB0aGUgaW5wdXRcbiAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBiaXRlKSB7XG4gICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtIGFuZCB1dGYtOCBieXRlcyBuZWVkZWQgaXMgbm90IDAsXG4gICAgLy8gc2V0IHV0Zi04IGJ5dGVzIG5lZWRlZCB0byAwIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0gJiYgdXRmOF9ieXRlc19uZWVkZWQgIT09IDApIHtcbiAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMDtcbiAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgIH1cblxuICAgIC8vIDIuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtKVxuICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgLy8gMy4gSWYgdXRmLTggYnl0ZXMgbmVlZGVkIGlzIDAsIGJhc2VkIG9uIGJ5dGU6XG4gICAgaWYgKHV0ZjhfYnl0ZXNfbmVlZGVkID09PSAwKSB7XG5cbiAgICAgIC8vIDB4MDAgdG8gMHg3RlxuICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHgwMCwgMHg3RikpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSBpcyBieXRlLlxuICAgICAgICByZXR1cm4gYml0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gMHhDMiB0byAweERGXG4gICAgICBpZiAoaW5SYW5nZShiaXRlLCAweEMyLCAweERGKSkge1xuICAgICAgICAvLyBTZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDEgYW5kIHV0Zi04IGNvZGUgcG9pbnQgdG8gYnl0ZVxuICAgICAgICAvLyDiiJIgMHhDMC5cbiAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAxO1xuICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBiaXRlIC0gMHhDMDtcbiAgICAgIH1cblxuICAgICAgLy8gMHhFMCB0byAweEVGXG4gICAgICBlbHNlIGlmIChpblJhbmdlKGJpdGUsIDB4RTAsIDB4RUYpKSB7XG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgMHhFMCwgc2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4QTAuXG4gICAgICAgIGlmIChiaXRlID09PSAweEUwKVxuICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweEEwO1xuICAgICAgICAvLyAyLiBJZiBieXRlIGlzIDB4RUQsIHNldCB1dGYtOCB1cHBlciBib3VuZGFyeSB0byAweDlGLlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHhFRClcbiAgICAgICAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHg5RjtcbiAgICAgICAgLy8gMy4gU2V0IHV0Zi04IGJ5dGVzIG5lZWRlZCB0byAyIGFuZCB1dGYtOCBjb2RlIHBvaW50IHRvXG4gICAgICAgIC8vIGJ5dGUg4oiSIDB4RTAuXG4gICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMjtcbiAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gYml0ZSAtIDB4RTA7XG4gICAgICB9XG5cbiAgICAgIC8vIDB4RjAgdG8gMHhGNFxuICAgICAgZWxzZSBpZiAoaW5SYW5nZShiaXRlLCAweEYwLCAweEY0KSkge1xuICAgICAgICAvLyAxLiBJZiBieXRlIGlzIDB4RjAsIHNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweDkwLlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHhGMClcbiAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg5MDtcbiAgICAgICAgLy8gMi4gSWYgYnl0ZSBpcyAweEY0LCBzZXQgdXRmLTggdXBwZXIgYm91bmRhcnkgdG8gMHg4Ri5cbiAgICAgICAgaWYgKGJpdGUgPT09IDB4RjQpXG4gICAgICAgICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4OEY7XG4gICAgICAgIC8vIDMuIFNldCB1dGYtOCBieXRlcyBuZWVkZWQgdG8gMyBhbmQgdXRmLTggY29kZSBwb2ludCB0b1xuICAgICAgICAvLyBieXRlIOKIkiAweEYwLlxuICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDM7XG4gICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IGJpdGUgLSAweEYwO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2VcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZXJyb3IuXG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVuIChieXRlIGlzIGluIHRoZSByYW5nZSAweEMyIHRvIDB4RjQpIHNldCB1dGYtOCBjb2RlXG4gICAgICAvLyBwb2ludCB0byB1dGYtOCBjb2RlIHBvaW50IDw8ICg2IMOXIHV0Zi04IGJ5dGVzIG5lZWRlZCkgYW5kXG4gICAgICAvLyByZXR1cm4gY29udGludWUuXG4gICAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2NvZGVfcG9pbnQgPDwgKDYgKiB1dGY4X2J5dGVzX25lZWRlZCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyA0LiBJZiBieXRlIGlzIG5vdCBpbiB0aGUgcmFuZ2UgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gdXRmLThcbiAgICAvLyB1cHBlciBib3VuZGFyeSwgcnVuIHRoZXNlIHN1YnN0ZXBzOlxuICAgIGlmICghaW5SYW5nZShiaXRlLCB1dGY4X2xvd2VyX2JvdW5kYXJ5LCB1dGY4X3VwcGVyX2JvdW5kYXJ5KSkge1xuXG4gICAgICAvLyAxLiBTZXQgdXRmLTggY29kZSBwb2ludCwgdXRmLTggYnl0ZXMgbmVlZGVkLCBhbmQgdXRmLThcbiAgICAgIC8vIGJ5dGVzIHNlZW4gdG8gMCwgc2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4ODAsIGFuZCBzZXRcbiAgICAgIC8vIHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4QkYuXG4gICAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2J5dGVzX25lZWRlZCA9IHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG4gICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MDtcbiAgICAgIHV0ZjhfdXBwZXJfYm91bmRhcnkgPSAweEJGO1xuXG4gICAgICAvLyAyLiBQcmVwZW5kIGJ5dGUgdG8gc3RyZWFtLlxuICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgIC8vIDMuIFJldHVybiBlcnJvci5cbiAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgIH1cblxuICAgIC8vIDUuIFNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweDgwIGFuZCB1dGYtOCB1cHBlciBib3VuZGFyeVxuICAgIC8vIHRvIDB4QkYuXG4gICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4ODA7XG4gICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4QkY7XG5cbiAgICAvLyA2LiBJbmNyZWFzZSB1dGYtOCBieXRlcyBzZWVuIGJ5IG9uZSBhbmQgc2V0IHV0Zi04IGNvZGUgcG9pbnRcbiAgICAvLyB0byB1dGYtOCBjb2RlIHBvaW50ICsgKGJ5dGUg4oiSIDB4ODApIDw8ICg2IMOXICh1dGYtOCBieXRlc1xuICAgIC8vIG5lZWRlZCDiiJIgdXRmLTggYnl0ZXMgc2VlbikpLlxuICAgIHV0ZjhfYnl0ZXNfc2VlbiArPSAxO1xuICAgIHV0ZjhfY29kZV9wb2ludCArPSAoYml0ZSAtIDB4ODApIDw8ICg2ICogKHV0ZjhfYnl0ZXNfbmVlZGVkIC0gdXRmOF9ieXRlc19zZWVuKSk7XG5cbiAgICAvLyA3LiBJZiB1dGYtOCBieXRlcyBzZWVuIGlzIG5vdCBlcXVhbCB0byB1dGYtOCBieXRlcyBuZWVkZWQsXG4gICAgLy8gY29udGludWUuXG4gICAgaWYgKHV0ZjhfYnl0ZXNfc2VlbiAhPT0gdXRmOF9ieXRlc19uZWVkZWQpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIC8vIDguIExldCBjb2RlIHBvaW50IGJlIHV0Zi04IGNvZGUgcG9pbnQuXG4gICAgdmFyIGNvZGVfcG9pbnQgPSB1dGY4X2NvZGVfcG9pbnQ7XG5cbiAgICAvLyA5LiBTZXQgdXRmLTggY29kZSBwb2ludCwgdXRmLTggYnl0ZXMgbmVlZGVkLCBhbmQgdXRmLTggYnl0ZXNcbiAgICAvLyBzZWVuIHRvIDAuXG4gICAgdXRmOF9jb2RlX3BvaW50ID0gdXRmOF9ieXRlc19uZWVkZWQgPSB1dGY4X2J5dGVzX3NlZW4gPSAwO1xuXG4gICAgLy8gMTAuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICByZXR1cm4gY29kZV9wb2ludDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtFbmNvZGVyfVxuICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFVURjhFbmNvZGVyKG9wdGlvbnMpIHtcbiAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm4geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gQnl0ZShzKSB0byBlbWl0LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgLy8gMS4gSWYgY29kZSBwb2ludCBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAvLyAyLiBJZiBjb2RlIHBvaW50IGlzIGluIHRoZSByYW5nZSBVKzAwMDAgdG8gVSswMDdGLCByZXR1cm4gYVxuICAgIC8vIGJ5dGUgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDAwMDAsIDB4MDA3ZikpXG4gICAgICByZXR1cm4gY29kZV9wb2ludDtcblxuICAgIC8vIDMuIFNldCBjb3VudCBhbmQgb2Zmc2V0IGJhc2VkIG9uIHRoZSByYW5nZSBjb2RlIHBvaW50IGlzIGluOlxuICAgIHZhciBjb3VudCwgb2Zmc2V0O1xuICAgIC8vIFUrMDA4MCB0byBVKzA3RkY6ICAgIDEgYW5kIDB4QzBcbiAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDAwODAsIDB4MDdGRikpIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICAgIG9mZnNldCA9IDB4QzA7XG4gICAgfVxuICAgIC8vIFUrMDgwMCB0byBVK0ZGRkY6ICAgIDIgYW5kIDB4RTBcbiAgICBlbHNlIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4MDgwMCwgMHhGRkZGKSkge1xuICAgICAgY291bnQgPSAyO1xuICAgICAgb2Zmc2V0ID0gMHhFMDtcbiAgICB9XG4gICAgLy8gVSsxMDAwMCB0byBVKzEwRkZGRjogMyBhbmQgMHhGMFxuICAgIGVsc2UgaWYgKGluUmFuZ2UoY29kZV9wb2ludCwgMHgxMDAwMCwgMHgxMEZGRkYpKSB7XG4gICAgICBjb3VudCA9IDM7XG4gICAgICBvZmZzZXQgPSAweEYwO1xuICAgIH1cblxuICAgIC8vIDQuTGV0IGJ5dGVzIGJlIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBmaXJzdCBieXRlIGlzIChjb2RlXG4gICAgLy8gcG9pbnQgPj4gKDYgw5cgY291bnQpKSArIG9mZnNldC5cbiAgICB2YXIgYnl0ZXMgPSBbKGNvZGVfcG9pbnQgPj4gKDYgKiBjb3VudCkpICsgb2Zmc2V0XTtcblxuICAgIC8vIDUuIFJ1biB0aGVzZSBzdWJzdGVwcyB3aGlsZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMDpcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG5cbiAgICAgIC8vIDEuIFNldCB0ZW1wIHRvIGNvZGUgcG9pbnQgPj4gKDYgw5cgKGNvdW50IOKIkiAxKSkuXG4gICAgICB2YXIgdGVtcCA9IGNvZGVfcG9pbnQgPj4gKDYgKiAoY291bnQgLSAxKSk7XG5cbiAgICAgIC8vIDIuIEFwcGVuZCB0byBieXRlcyAweDgwIHwgKHRlbXAgJiAweDNGKS5cbiAgICAgIGJ5dGVzLnB1c2goMHg4MCB8ICh0ZW1wICYgMHgzRikpO1xuXG4gICAgICAvLyAzLiBEZWNyZWFzZSBjb3VudCBieSBvbmUuXG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIC8vIDYuIFJldHVybiBieXRlcyBieXRlcywgaW4gb3JkZXIuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG5leHBvcnQge1RleHRFbmNvZGVyLCBUZXh0RGVjb2Rlcn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/text-encoding-utf-8/lib/encoding.lib.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=%2FUsers%2Fhunterstein%2Fopos%2Fsrc%2Fpages%2Findex.tsx&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);